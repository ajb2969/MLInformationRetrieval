<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1997">Binary heap</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Binary heap</h1>
<hr/>

<p>  A <strong>binary heap</strong> is a <a href="heap_(data_structure)" title="wikilink">heap</a> <a href="data_structure" title="wikilink">data structure</a> created using a <a href="binary_tree" title="wikilink">binary tree</a>. It can be seen as a binary tree with two additional constraints:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<dl>
<dt>Shape property: A binary heap is a <em><a href="Complete_Binary_Tree" title="wikilink">complete binary tree</a></em>; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.<br/>
Heap property: All nodes are ''either <strong>greater than or equal to</strong> or <strong>less than or equal to</strong> each of its children, according to a comparison <a href="predicate_(mathematical_logic)" title="wikilink">predicate</a> defined for the heap.</dt>
</dl>

<p>Heaps with a mathematical "greater than or equal to" (≥) comparison predicate are called <em>max-heaps</em>; those with a mathematical "less than or equal to" (≤) comparison predicate are called <em>min-heaps</em>. Min-heaps are often used to implement <a href="priority_queue" title="wikilink">priority queues</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Since the ordering of siblings in a heap is not specified by the heap property, a single node's two children can be freely interchanged unless doing so violates the shape property (compare with <a class="uri" href="treap" title="wikilink">treap</a>). Note, however, that in the common array-based heap, simply swapping the children might also necessitate moving the children's sub-tree nodes to retain the heap property.</p>

<p>The binary heap is a special case of the <a href="d-ary_heap" title="wikilink">d-ary heap</a> in which d = 2.</p>
<h2 id="heap-operations">Heap operations</h2>

<p>Both the insert and remove operations modify the heap to conform to the shape property first, by adding or removing from the end of the heap. Then the heap property is restored by traversing up or down the heap. Both operations take O(log <em>n</em>) time.</p>
<h3 id="insert">Insert</h3>

<p>To add an element to a heap we must perform an <em>up-heap</em> operation (also known as <em>bubble-up</em>, <em>percolate-up</em>, <em>sift-up</em>, <em>trickle-up</em>, <em>heapify-up</em>, or <em>cascade-up</em>), by following this algorithm:</p>
<ol>
<li>Add the element to the bottom level of the heap.</li>
<li>Compare the added element with its parent; if they are in the correct order, stop.</li>
<li>If not, swap the element with its parent and return to the previous step.</li>
</ol>

<p>The number of operations required is dependent on the number of levels the new element must rise to satisfy the heap property, thus the insertion operation has a time complexity of O(log <em>n</em>). However, in 1974, Thomas Porter and Istvan Simon proved that the function for the average number of levels an inserted node moves up is upper bounded by the constant 1.6067.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The average number of operations required for an insertion into a binary heap is 2.6067 since one additional comparison is made that does not result in the inserted node moving up a level. Thus, on average, binary heap insertion has a constant, O(1), time complexity. Intuitively, this makes sense since approximately 50% of the elements are leaves and approximately 75% of the elements are in the bottom two levels, it is likely that the new element to be inserted will only move a few levels upwards to maintain the heap.</p>

<p>As an example of binary heap insertion, say we have a max-heap</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>and we want to add the number 15 to the heap. We first place the 15 in the position marked by the X. However, the heap property is violated since 15 &gt; 8, so we need to swap the 15 and the 8. So, we have the heap looking as follows after the first swap:</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>However the heap property is still violated since 15 &gt; 11, so we need to swap again:</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>which is a valid max-heap. There is no need to check the left child after this final step: at the start, the max-heap was valid, meaning 11 &gt; 5; if 15 &gt; 11, and 11 &gt; 5, then 15 &gt; 5, because of the <a href="transitive_relation" title="wikilink">transitive relation</a>.</p>
<h3 id="extract">Extract</h3>

<p>The procedure for deleting the root from the heap (effectively extracting the maximum element in a max-heap or the minimum element in a min-heap) and restoring the properties is called <em>down-heap</em> (also known as <em>bubble-down</em>, <em>percolate-down</em>, <em>sift-down</em>, <em>trickle down</em>, <em>heapify-down</em>, <em>cascade-down</em>, and <em>extract-min/max</em>).</p>
<ol>
<li>Replace the root of the heap with the last element on the last level.</li>
<li>Compare the new root with its children; if they are in the correct order, stop.</li>
<li>If not, swap the element with one of its children and return to the previous step. (Swap with its smaller child in a min-heap and its larger child in a max-heap.)</li>
</ol>

<p>So, if we have the same max-heap as before</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>We remove the 11 and replace it with the 4.</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>Now the heap property is violated since 8 is greater than 4. In this case, swapping the two elements, 4 and 8, is enough to restore the heap property and we need not swap elements further:</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>The downward-moving node is swapped with the <em>larger</em> of its children in a max-heap (in a min-heap it would be swapped with its smaller child), until it satisfies the heap property in its new position. This functionality is achieved by the <strong>Max-Heapify</strong> function as defined below in <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> for an <a href="Array_data_structure" title="wikilink">array</a>-backed heap <em>A</em> of length <em>heap_length</em>[<em>A</em>]. Note that "A" is indexed starting at 1, not 0 as is common in many real programming languages.</p>

<p><strong>Max-Heapify</strong> (<em>A</em>, <em>i</em>):<br/>
<em>left</em> ← 2<em>i</em><br/>
<em>right</em> ← 2<em>i</em> + 1<br/>
<em>largest</em> ← <em>i</em><br/>
<strong>if</strong> <em>left</em> ≤ <em>heap_length</em>[<em>A</em>] <strong>and</strong> <em>A</em>[<em>left</em>] &gt; A[<em>largest</em>] <strong>then</strong>:<br/>
<em>largest</em> ← <em>left</em><br/>
<strong>if</strong> <em>right</em> ≤ <em>heap_length</em>[<em>A</em>] <strong>and</strong> <em>A</em>[<em>right</em>] &gt; <em>A</em>[<em>largest</em>] <strong>then</strong>:<br/>
<em>largest</em> ← <em>right</em><br/>
<strong>if</strong> <em>largest</em> ≠ <em>i</em> <strong>then</strong>:<br/>
<strong>swap</strong> <em>A[</em>i''] ↔ <em>A</em>[<em>largest</em>]<br/>
Max-Heapify(<em>A</em>, <em>largest</em>)</p>

<p>For the above algorithm to correctly re-heapify the array, the node at index <em>i</em> and its two direct children must violate the heap property. If they do not, the algorithm will fall through with no change to the array. The down-heap operation (without the preceding swap) can also be used to modify the value of the root, even when an element is not being deleted.</p>

<p>In the worst case, the new root has to be swapped with its child on each level until it reaches the bottom level of the heap, meaning that the delete operation has a time complexity relative to the height of the tree, or O(log <em>n</em>).</p>
<h2 id="building-a-heap">Building a heap</h2>

<p>A heap could be built by successive insertions. This approach requires 

<math display="inline" id="Binary_heap:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

 time because each insertion takes 

<math display="inline" id="Binary_heap:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 time and there are 

<math display="inline" id="Binary_heap:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements. However this is not the optimal method. The optimal method starts by arbitrarily putting the elements on a binary tree, respecting the shape property (the tree could be represented by an array, see below). Then starting from the lowest level and moving upwards, shift the root of each subtree downward as in the deletion algorithm until the heap property is restored. More specifically if all the subtrees starting at some height 

<math display="inline" id="Binary_heap:3">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 (measured from the bottom) have already been "heapified", the trees at height 

<math display="inline" id="Binary_heap:4">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h+1
  </annotation>
 </semantics>
</math>

 can be heapified by sending their root down along the path of maximum valued children when building a max-heap, or minimum valued children when building a min-heap. This process takes 

<math display="inline" id="Binary_heap:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(h)
  </annotation>
 </semantics>
</math>

 operations (swaps) per node. In this method most of the heapification takes place in the lower levels. Since the height of the heap is 

<math display="inline" id="Binary_heap:6">
 <semantics>
  <mrow>
   <mo>⌊</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\lfloor\log(n)\right\rfloor
  </annotation>
 </semantics>
</math>

, the number of nodes at height 

<math display="inline" id="Binary_heap:7">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Binary_heap:8">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mo>⌈</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
        <mo>-</mo>
        <mi>h</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>⌉</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </msup>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>h</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mfrac>
    <mo>⌉</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mfrac>
     <mi>n</mi>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>h</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mfrac>
    <mo>⌉</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ceiling></ceiling>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <minus></minus>
         <apply>
          <log></log>
          <ci>n</ci>
         </apply>
         <ci>h</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ceiling></ceiling>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <log></log>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ceiling></ceiling>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq\left\lceil 2^{\left(\log n-h\right)-1}\right\rceil=\left\lceil\frac{2^{%
\log n}}{2^{h+1}}\right\rceil=\left\lceil\frac{n}{2^{h+1}}\right\rceil
  </annotation>
 </semantics>
</math>

. Therefore, the cost of heapifying all subtrees is:</p>

<p>

<math display="inline" id="Binary_heap:9">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>h</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mo stretchy="false">⌈</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">⌉</mo>
     </mrow>
    </munderover>
   </mstyle>
   <mrow>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>n</mi>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>h</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mfrac>
    </mstyle>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>h</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <ceiling></ceiling>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>O</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sum_{h=0}^{\lceil\log n\rceil}\frac{n}{2^{h+1}}O(h)
  </annotation>
 </semantics>
</math>


</p>

<p>This uses the fact that the given infinite <a href="series_(mathematics)" title="wikilink">series</a> <em>h</em> / 2<sup><em>h</em></sup> <a href="Convergent_series" title="wikilink">converges</a> to 2.</p>

<p>The exact value of the above (the worst-case number of comparisons during the heap construction) is known to be equal to:</p>

<p>

<math display="block" id="Binary_heap:10">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n-2s_{2}(n)-e_{2}(n)
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> where s<sub>2</sub>(n) is the sum of all digits of the binary representation of n and e<sub>2</sub>(n) is the exponent of 2 in the prime factorization of n.</p>

<p>The <strong>Build-Max-Heap</strong> function that follows, converts an array <em>A</em> which stores a complete binary tree with n nodes to a max-heap by repeatedly using <strong>Max-Heapify</strong> in a bottom up manner. It is based on the observation that the array elements indexed by <em><a href="floor_function" title="wikilink">floor</a></em>(n/2) + 1, <em>floor</em>(n/2) + 2, ..., n are all leaves for the tree, thus each is a one-element heap. <strong>Build-Max-Heap</strong> runs <strong>Max-Heapify</strong> on each of the remaining tree nodes.</p>

<p><strong>Build-Max-Heap</strong> (<em>A</em>):<br/>
<em>heap_length</em>[<em>A</em>] ← <em>length</em>[<em>A</em>]<br/>
<strong>for</strong> <em>i</em> ← <em>floor</em>(<em>length</em>[<em>A</em>]/2) <strong>downto</strong> 1 <strong>do</strong><br/>
<strong>Max-Heapify</strong>(<em>A</em>, <em>i</em>)</p>
<h2 id="heap-implementation">Heap implementation</h2>

<p> </p>

<p>Heaps are commonly implemented with an <a href="Array_data_structure" title="wikilink">array</a>. Any binary tree can be stored in an array, but because a binary heap is always a complete binary tree, it can be stored compactly. No space is required for <a href="pointer_(computer_programming)" title="wikilink">pointers</a>; instead, the parent and children of each node can be found by arithmetic on array indices. These properties make this heap implementation a simple example of an <a href="implicit_data_structure" title="wikilink">implicit data structure</a> or <a class="uri" href="Ahnentafel" title="wikilink">Ahnentafel</a> list. Details depend on the root position, which in turn may depend on constraints of a <a href="programming_language" title="wikilink">programming language</a> used for implementation, or programmer preference. Specifically, sometimes the root is placed at index 1, sacrificing space in order to simplify arithmetic. The <em><a href="Peek_(data_type_operation)" title="wikilink">peek</a></em> operation (<em>find-min</em> or <em>find-max</em>) simply returns the value of the root, and is thus O(1).</p>

<p>Let <em>n</em> be the number of elements in the heap and <em>i</em> be an arbitrary valid index of the array storing the heap. If the tree root is at index 0, with valid indices 0 through ''n − ''1, then each element <em>a</em> at index <em>i</em> has</p>
<ul>
<li>children at indices 2''i <em>+ 1 and 2</em>i ''+ 2</li>
<li>its parent <em><a href="floor_function" title="wikilink">floor</a></em>((''i ''− 1) ∕ 2).</li>
</ul>

<p>Alternatively, if the tree root is at index 1, with valid indices 1 through <em>n</em>, then each element <em>a</em> at index <em>i</em> has</p>
<ul>
<li>children at indices 2<em>i</em> and 2''i ''+1</li>
<li>its parent at index <em><a href="floor_function" title="wikilink">floor</a></em>(<em>i ∕</em> 2).</li>
</ul>

<p>This implementation is used in the <a class="uri" href="heapsort" title="wikilink">heapsort</a> algorithm, where it allows the space in the input array to be reused to store the heap (i.e. the algorithm is done <a href="In-place_algorithm" title="wikilink">in-place</a>). The implementation is also useful for use as a <a href="Priority_queue" title="wikilink">Priority queue</a> where use of a <a href="dynamic_array" title="wikilink">dynamic array</a> allows insertion of an unbounded number of items.</p>

<p>The upheap/downheap operations can then be stated in terms of an array as follows: suppose that the heap property holds for the indices <em>b</em>, <em>b</em>+1, ..., <em>e</em>. The sift-down function extends the heap property to <em>b</em>−1, <em>b</em>, <em>b</em>+1, ..., <em>e</em>. Only index <em>i</em> = <em>b</em>−1 can violate the heap property. Let <em>j</em> be the index of the largest child of <em>a</em>[<em>i</em>] (for a max-heap, or the smallest child for a min-heap) within the range <em>b</em>, ..., <em>e</em>. (If no such index exists because 2<em>i</em> &gt; <em>e</em> then the heap property holds for the newly extended range and nothing needs to be done.) By swapping the values <em>a</em>[<em>i</em>] and <em>a</em>[<em>j</em>] the heap property for position <em>i</em> is established. At this point, the only problem is that the heap property might not hold for index <em>j</em>. The sift-down function is applied <a href="tail_recursion" title="wikilink">tail-recursively</a> to index <em>j</em> until the heap property is established for all elements.</p>

<p>The sift-down function is fast. In each step it only needs two comparisons and one swap. The index value where it is working doubles in each iteration, so that at most log<sub>2</sub> <em>e</em> steps are required.</p>

<p>For big heaps and using <a href="virtual_memory" title="wikilink">virtual memory</a>, storing elements in an array according to the above scheme is inefficient: (almost) every level is in a different <a href="Page_(computer_memory)" title="wikilink">page</a>. <a href="B-heap" title="wikilink">B-heaps</a> are binary heaps that keep subtrees in a single page, reducing the number of pages accessed by up to a factor of ten.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The operation of merging two binary heaps takes Θ(<em>n</em>) for equal-sized heaps. The best you can do is (in case of array implementation) simply concatenating the two heap arrays and build a heap of the result.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> A heap on <em>n</em> elements can be merged with a heap on <em>k</em> elements using O(log <em>n</em> log <em>k</em>) key comparisons, or, in case of a pointer-based implementation, in O(log <em>n</em> log <em>k</em>) time.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> An algorithm for splitting a heap on <em>n</em> elements into two heaps on <em>k</em> and <em>n-k</em> elements, respectively, based on a new view of heaps as an ordered collections of subheaps was presented in.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The algorithm requires O(log <em>n</em> * log <em>n</em>) comparisons. The view also presents a new and conceptually simple algorithm for merging heaps. When merging is a common task, a different heap implementation is recommended, such as <a href="binomial_heap" title="wikilink">binomial heaps</a>, which can be merged in O(log <em>n</em>).</p>

<p>Additionally, a binary heap can be implemented with a traditional binary tree data structure, but there is an issue with finding the adjacent element on the last level on the binary heap when adding an element. This element can be determined algorithmically or by adding extra data to the nodes, called "threading" the tree—instead of merely storing references to the children, we store the <a class="uri" href="inorder" title="wikilink">inorder</a> successor of the node as well.</p>

<p>It is possible to modify the heap structure to allow extraction of both the smallest and largest element in <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Binary_heap:11">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

</a>

<math display="inline" id="Binary_heap:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>log</mi>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\log n)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> To do this, the rows alternate between min heap and max heap. The algorithms are roughly the same, but, in each step, one must consider the alternating rows with alternating comparisons. The performance is roughly the same as a normal single direction heap. This idea can be generalised to a min-max-median heap.</p>
<h2 id="derivation-of-index-equations">Derivation of index equations</h2>

<p>In an array-based heap, the children and parent of a node can be located via simple arithmetic on the node's index. This section derives the relevant equations for heaps with their root at index 0, with additional notes on heaps with their root at index 1.</p>

<p>To avoid confusion, we'll define the <strong>level</strong> of a node as its distance from the root, such that the root itself occupies level 0.</p>
<h3 id="child-nodes">Child nodes</h3>

<p>For a general node located at index 

<math display="inline" id="Binary_heap:13">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 (beginning from 0), we will first derive the index of its right child, 

<math display="inline" id="Binary_heap:14">
 <semantics>
  <mrow>
   <mtext>right</mtext>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>i</mi>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>right</mtext>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{right}=2i+2
  </annotation>
 </semantics>
</math>

.</p>

<p>Let node 

<math display="inline" id="Binary_heap:15">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 be located in level 

<math display="inline" id="Binary_heap:16">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, and note that any level 

<math display="inline" id="Binary_heap:17">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 contains exactly 

<math display="inline" id="Binary_heap:18">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>l</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{l}
  </annotation>
 </semantics>
</math>

 nodes. Furthermore, there are exactly 

<math display="inline" id="Binary_heap:19">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>l</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{l+1}-1
  </annotation>
 </semantics>
</math>

 nodes contained in the layers up to and including layer 

<math display="inline" id="Binary_heap:20">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>


 (think of binary arithmetic; 0111...111 = 1000...000 - 1). Because the root is stored at 0, the 

<math display="inline" id="Binary_heap:21">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

th node will be stored at index 

<math display="inline" id="Binary_heap:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k-1)
  </annotation>
 </semantics>
</math>

. Putting these observations together yields the following expression for the <strong>index of the last node in layer l</strong>.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Binary_heap:23">
 <semantics>
  <mrow>
   <mrow>
    <mtext>last</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>l</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>l</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>last</mtext>
      <ci>l</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>l</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{last}(l)=(2^{l+1}-1)-1=2^{l+1}-2
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Let there be 

<math display="inline" id="Binary_heap:24">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 nodes after node 

<math display="inline" id="Binary_heap:25">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 in layer L, such that</p>
<dl>
<dd><dl>
<dd><math>\begin{alignat}{2}
</math></dd>
</dl>
</dd>
</dl>

<p>i = &amp; \quad \text{last}(L) - j\\</p>

<p><code> = &amp; \quad (2^{L + 1} -2) - j\\</code></p>

<p>\end{alignat} </p>

<p>Each of these 

<math display="inline" id="Binary_heap:26">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 nodes must have exactly 2 children, so there must be 

<math display="inline" id="Binary_heap:27">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2j
  </annotation>
 </semantics>
</math>

 nodes separating 

<math display="inline" id="Binary_heap:28">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

's right child from the end of its layer (

<math display="inline" id="Binary_heap:29">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L+1
  </annotation>
 </semantics>
</math>

).</p>
<dl>
<dd><dl>
<dd><math>\begin{alignat}{2}
</math></dd>
</dl>
</dd>
</dl>

<p>\text{right} = &amp; \quad \text{last(L + 1)} -2j\\</p>

<p><code>            = &amp; \quad (2^{L + 2} -2) -2j\\</code><br/>
<code>            = &amp; \quad 2(2^{L + 1} -2 -j) + 2\\</code><br/>
<code>            = &amp; \quad 2i + 2</code></p>

<p>\end{alignat} </p>

<p>As required.</p>

<p>Noting that the left child of any node is always 1 place before its right child, we get 

<math display="inline" id="Binary_heap:30">
 <semantics>
  <mrow>
   <mtext>left</mtext>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>i</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>left</mtext>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{left}=2i+1
  </annotation>
 </semantics>
</math>


.</p>

<p>If the root is located at index 1 instead of 0, the last node in each level is instead at index 

<math display="inline" id="Binary_heap:31">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>l</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{l+1}-1
  </annotation>
 </semantics>
</math>

. Using this throughout yields 

<math display="inline" id="Binary_heap:32">
 <semantics>
  <mrow>
   <mtext>left</mtext>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>i</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>left</mtext>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{left}=2i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Binary_heap:33">
 <semantics>
  <mrow>
   <mtext>right</mtext>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>i</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>right</mtext>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{right}=2i+1
  </annotation>
 </semantics>
</math>

 for heaps with their root at 1.</p>
<h3 id="parent-node">Parent node</h3>

<p>Every node is either the left or right child of its parent, so we know that either of the following is true.</p>
<ol>
<li>

<math display="inline" id="Binary_heap:34">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>parent</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <mtext>parent</mtext>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=2\times(\text{parent})+1
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Binary_heap:35">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>parent</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <mtext>parent</mtext>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=2\times(\text{parent})+2
  </annotation>
 </semantics>
</math>


</li>
</ol>

<p>Hence,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Binary_heap:36">
 <semantics>
  <mrow>
   <mtext>parent</mtext>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
    <mtext mathvariant="bold">or</mtext>
    <mfrac>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>parent</mtext>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <mtext>or</mtext>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{parent}=\frac{i-1}{2}\textbf{ or }\frac{i-2}{2}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Now consider the expression 

<math display="inline" id="Binary_heap:37">
 <semantics>
  <mrow>
   <mo>⌊</mo>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mstyle>
   <mo>⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\lfloor\dfrac{i-1}{2}\right\rfloor
  </annotation>
 </semantics>
</math>

.</p>

<p>If node 

<math display="inline" id="Binary_heap:38">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is a left child, this gives the result immediately, however, it also gives the correct result if node 

<math display="inline" id="Binary_heap:39">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is a right child. In this case, 

<math display="inline" id="Binary_heap:40">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>i</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i-2)
  </annotation>
 </semantics>
</math>


 must be even, and hence 

<math display="inline" id="Binary_heap:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i-1)
  </annotation>
 </semantics>
</math>

 must be odd.</p>
<dl>
<dd><dl>
<dd><math>\begin{alignat}{2}
</math></dd>
</dl>
</dd>
</dl>

<p>\left\lfloor \dfrac{i - 1}{2} \right\rfloor = &amp; \quad \left\lfloor \dfrac{i - 2}{2} + \dfrac{1}{2} \right\rfloor\\</p>
<h1 id="quad-fraci---22">&amp; \quad \frac{i - 2}{2}\\</h1>

<p>&amp; \quad \text{parent} \end{alignat} </p>

<p>Therefore, irrespective of whether a node is a left or right child, its parent can be found by the expression:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Binary_heap:42">
 <semantics>
  <mrow>
   <mtext>parent</mtext>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>parent</mtext>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{parent}=\left\lfloor\dfrac{i-1}{2}\right\rfloor
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Heap_(data_structure)" title="wikilink">Heap</a></li>
<li><a class="uri" href="Heapsort" title="wikilink">Heapsort</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://people.ksp.sk/~kuko/bak/index.html">Binary Heap Applet</a> by Kubo Kovac</li>
<li><a href="http://www.policyalmanac.org/games/binaryHeaps.htm">Using Binary Heaps in A* Pathfinding</a></li>
<li><a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/10_1_BinaryHeap_Implicit_Bi.html">Open Data Structures - Section 10.1 - BinaryHeap: An Implicit Binary Tree</a></li>
<li><a href="http://robin-thomas.github.io/max-heap/">Implementation of binary max heap in C</a> by Robin Thomas</li>
<li><a href="http://robin-thomas.github.io/min-heap/">Implementation of binary min heap in C</a> by Robin Thomas</li>
</ul>

<p>"</p>

<p><a href="Category:Heaps_(data_structures)" title="wikilink">Category:Heaps (data structures)</a> <a href="Category:Binary_trees" title="wikilink">Category:Binary trees</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">Poul-Henning Kamp. <a href="http://queue.acm.org/detail.cfm?id=1814327">"You're Doing It Wrong"</a>. ACM Queue. June 11, 2010.<a href="#fnref6">↩</a></li>
<li id="fn7">Chris L. Kuszmaul. <a href="http://nist.gov/dads/HTML/binaryheap.html">"binary heap"</a>. Dictionary of Algorithms and Data Structures, Paul E. Black, ed., U.S. National Institute of Standards and Technology. 16 November 2009.<a href="#fnref7">↩</a></li>
<li id="fn8">J.-R. Sack and T. Strothotte <a href="http://www.springerlink.com/content/k24440h5076w013q/">"An Algorithm for Merging Heaps"</a>, Acta Informatica 22, 171-186 (1985).<a href="#fnref8">↩</a></li>
<li id="fn9">. J.-R. Sack and T. Strothotte <a href="http://www.sciencedirect.com/science/article/pii/089054019090026E">"A characterization of heaps and its applications"</a> Information and Computation Volume 86, Issue 1, May 1990, Pages 69–86.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
