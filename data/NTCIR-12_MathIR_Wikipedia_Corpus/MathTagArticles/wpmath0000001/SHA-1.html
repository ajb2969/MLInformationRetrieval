<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="924">SHA-1</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>SHA-1</h1>
<hr/>
<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <strong>SHA-1</strong> is a <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a> designed by the United States <a href="National_Security_Agency" title="wikilink">National Security Agency</a> and is a U.S. <a href="Federal_Information_Processing_Standard" title="wikilink">Federal Information Processing Standard</a> published by the United States <a href="National_Institute_of_Standards_and_Technology" title="wikilink">NIST</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<p>SHA-1 produces a 160-<a class="uri" href="bit" title="wikilink">bit</a> (20-<a class="uri" href="byte" title="wikilink">byte</a>) hash value known as a <a href="message_digest" title="wikilink">message digest</a>. A SHA-1 hash value is typically rendered as a <a class="uri" href="hexadecimal" title="wikilink">hexadecimal</a> number, 40 digits long.</p>
<p>SHA stands for "<a href="secure_hash_algorithm" title="wikilink">secure hash algorithm</a>". The four SHA <a href="algorithm" title="wikilink">algorithms</a> are structured differently and are named <em>SHA-0</em>, <em>SHA-1</em>, <em><a class="uri" href="SHA-2" title="wikilink">SHA-2</a></em>, and <em><a class="uri" href="SHA-3" title="wikilink">SHA-3</a></em>. SHA-0 is the original version of the 160-bit hash function published in 1993 under the name "SHA": it was not adopted by many applications. Published in 1995, SHA-1 is very similar to SHA-0, but alters the original SHA hash specification to correct alleged weaknesses. SHA-2, published in 2001, is significantly different from the SHA-1 hash function.</p>
<p>SHA-1 is the most widely used of the existing SHA hash functions, and is employed in several widely used applications and protocols.</p>
<p>In 2005, cryptanalysts found attacks on SHA-1 suggesting that the algorithm might not be secure enough for ongoing use.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> NIST required many applications in federal agencies to move to <a class="uri" href="SHA-2" title="wikilink">SHA-2</a> after 2010 because of the weakness.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Although no successful attacks have yet been reported on SHA-2, it is algorithmically similar to SHA-1. In 2012, following a long-running competition, NIST selected an additional algorithm, Keccak, for standardization under <a class="uri" href="SHA-3" title="wikilink">SHA-3</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In November 2013 <a class="uri" href="Microsoft" title="wikilink">Microsoft</a> announced their deprecation policy on SHA-1 according to which Windows will stop accepting SHA-1 certificates in SSL by 2017.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In September 2014 <a class="uri" href="Google" title="wikilink">Google</a> announced their deprecation policy on SHA-1 according to which Chrome will stop accepting SHA-1 certificates in SSL in a phased way by 2017.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a class="uri" href="Mozilla" title="wikilink">Mozilla</a> is also planning to stop accepting SHA-1-based SSL certificates by 2017.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="the-sha-1-hash-function">The SHA-1 hash function</h2>
<figure><b>(Figure)</b>
<figcaption>One iteration within the SHA-1 compression function:<br/>
A, B, C, D and E are 32-bit <a href="Word_(data_type)" title="wikilink">words</a> of the state;<br/>
<em>F</em> is a nonlinear function that varies;<br/>
<a href="File:lll.png" title="wikilink">left shift</a><sub><em>n</em></sub> denotes a left bit rotation by <em>n</em> places;<br/>
<em>n</em> varies for each operation;<br/>
W<sub>t</sub> is the expanded message word of round t;<br/>
K<sub>t</sub> is the round constant of round t;<br/>
 denotes addition modulo 2<sup>32</sup>.</figcaption>
</figure>
<p>SHA-1 produces a <a href="message_digest" title="wikilink">message digest</a> based on principles similar to those used by <a href="Ron_Rivest" title="wikilink">Ronald L. Rivest</a> of <a href="Massachusetts_Institute_of_Technology" title="wikilink">MIT</a> in the design of the <a class="uri" href="MD4" title="wikilink">MD4</a> and <a class="uri" href="MD5" title="wikilink">MD5</a> message digest algorithms, but has a more conservative design.</p>
<p>The original specification of the algorithm was published in 1993 under the title <em>Secure Hash Standard</em>, <a href="Federal_Information_Processing_Standard" title="wikilink">FIPS</a> PUB 180, by U.S. government standards agency <a class="uri" href="NIST" title="wikilink">NIST</a> (National Institute of Standards and Technology). This version is now often named <em>SHA-0</em>. It was withdrawn by the <a class="uri" href="NSA" title="wikilink">NSA</a> shortly after publication and was superseded by the revised version, published in 1995 in FIPS PUB 180-1 and commonly designated <em>SHA-1</em>. SHA-1 differs from SHA-0 only by a single bitwise rotation in the message schedule of its <a href="One-way_compression_function" title="wikilink">compression function</a>; this was done, according to the NSA, to correct a flaw in the original algorithm which reduced its cryptographic security. However, the NSA did not provide any further explanation or identify the flaw that was corrected. Weaknesses have subsequently been reported in both SHA-0 and SHA-1. SHA-1 appears to provide greater resistance to attacks , supporting the NSA’s assertion that the change increased the security.</p>
<h2 id="applications">Applications</h2>
<h3 id="cryptography">Cryptography</h3>
<p>SHA-1 forms part of several widely used security applications and protocols, including <a href="Transport_Layer_Security" title="wikilink">TLS</a> and <a href="Secure_Sockets_Layer" title="wikilink">SSL</a>, <a href="Pretty_Good_Privacy" title="wikilink">PGP</a>, <a href="Secure_Shell" title="wikilink">SSH</a>, <a class="uri" href="S/MIME" title="wikilink">S/MIME</a>, and <a class="uri" href="IPsec" title="wikilink">IPsec</a>. Those applications can also use <a class="uri" href="MD5" title="wikilink">MD5</a>; both MD5 and SHA-1 are descended from <a class="uri" href="MD4" title="wikilink">MD4</a>. SHA-1 hashing is also used in <a href="distributed_revision_control" title="wikilink">distributed revision control</a> systems like <a href="Git_(software)" title="wikilink">Git</a>, <a href="Mercurial_(software)" title="wikilink">Mercurial</a>, and <a href="Monotone_(software)" title="wikilink">Monotone</a> to identify revisions, and to detect <a href="data_corruption" title="wikilink">data corruption</a> or tampering. The algorithm has also been used on <a href="Nintendo" title="wikilink">Nintendo's</a> <a class="uri" href="Wii" title="wikilink">Wii</a> gaming console for signature verification when <a class="uri" href="booting" title="wikilink">booting</a>, but a significant flaw in the first implementations of the firmware allowed for an attacker to bypass the system's security scheme.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<p>SHA-1 and SHA-2 are the secure hash algorithms required by law for use in certain <a href="U.S._Government" title="wikilink">U.S. Government</a> applications, including use within other cryptographic algorithms and protocols, for the protection of sensitive unclassified information. FIPS PUB 180-1 also encouraged adoption and use of SHA-1 by private and commercial organizations. SHA-1 is being retired from most government uses; the U.S. National Institute of Standards and Technology said, "Federal agencies <strong><em>should</em></strong> stop using SHA-1 for...applications that require collision resistance as soon as practical, and must use the <a class="uri" href="SHA-2" title="wikilink">SHA-2</a> family of hash functions for these applications after 2010" (emphasis in original),<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> though that was later relaxed.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<p>A prime motivation for the publication of the Secure Hash Algorithm was the <a href="Digital_Signature_Algorithm" title="wikilink">Digital Signature Standard</a>, in which it is incorporated.</p>
<p>The SHA hash functions have been used for the basis of the <a class="uri" href="SHACAL" title="wikilink">SHACAL</a> <a href="block_cipher" title="wikilink">block ciphers</a>.</p>
<h3 id="data-integrity">Data integrity</h3>
<p><a href="Revision_control" title="wikilink">Revision control</a> systems such as <a href="Git_(software)" title="wikilink">Git</a> and <a class="uri" href="Mercurial" title="wikilink">Mercurial</a> use SHA-1 not for security but for ensuring that the data has not changed due to accidental corruption. <a href="Linus_Torvalds" title="wikilink">Linus Torvalds</a> has said about Git: "If you have disk corruption, if you have DRAM corruption, if you have any kind of problems at all, Git will notice them. It's not a question of if, it's a guarantee. You can have people who try to be malicious. They won't succeed. [...] Nobody has been able to break SHA-1, but the point is the SHA-1, as far as Git is concerned, isn't even a security feature. It's purely a consistency check. The security parts are elsewhere, so a lot of people assume that since Git uses SHA-1 and SHA-1 is used for cryptographically secure stuff, they think that, OK, it's a huge security feature. It has nothing at all to do with security, it's just the best hash you can get. [...] I guarantee you, if you put your data in Git, you can trust the fact that five years later, after it was converted from your hard disk to DVD to whatever new technology and you copied it along, five years later you can verify that the data you get back out is the exact same data you put in. [...] One of the reasons I care is for the kernel, we had a break in on one of the BitKeeper sites where people tried to corrupt the kernel source code repositories."<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Nonetheless, without the <a href="second_preimage_resistance" title="wikilink">second preimage resistance</a> of SHA-1, signed commits and tags would no longer secure the state of the repository as they only sign the root of a <a href="Merkle_tree" title="wikilink">Merkle tree</a>.</p>
<h2 id="cryptanalysis-and-validation">Cryptanalysis and validation</h2>
<p>For a hash function for which <em>L</em> is the number of bits in the message digest, finding a message that corresponds to a given message digest can always be done using a brute force search in approximately 2<sup><em>L</em></sup> evaluations. This is called a <a href="preimage_attack" title="wikilink">preimage attack</a> and may or may not be practical depending on <em>L</em> and the particular computing environment. The second criterion, finding two different messages that produce the same message digest, namely a <em>collision,</em> requires on average only about 1.2 * 2<sup><em>L</em> / 2</sup> evaluations using a <a href="birthday_attack" title="wikilink">birthday attack</a>. For the latter reason the strength of a hash function is usually compared to a symmetric cipher of half the message digest length. Thus SHA-1 was originally thought to have 80-bit strength.</p>
<p>Cryptographers have produced collision pairs for SHA-0 and have found algorithms that should produce SHA-1 collisions in far fewer than the originally expected 2<sup>80</sup> evaluations.</p>
<p>In terms of practical security, a major concern about these new attacks is that they might pave the way to more efficient ones. Whether this is the case is yet to be seen, but a migration to stronger hashes is believed to be prudent. Some of the applications that use cryptographic hashes, like password storage, are only minimally affected by a collision attack. Constructing a password that works for a given account requires a <a href="preimage_attack" title="wikilink">preimage attack</a>, as well as access to the hash of the original password, which may or may not be trivial. Reversing password encryption (e.g. to obtain a password to try against a user's account elsewhere) is not made possible by the attacks. (However, even a secure password hash can't prevent brute-force attacks on <a href="password_strength" title="wikilink">weak passwords</a>.)</p>
<p>In the case of document signing, an attacker could not simply fake a signature from an existing document—the attacker would have to produce a pair of documents, one innocuous and one damaging, and get the private key holder to sign the innocuous document. There are practical circumstances in which this is possible; until the end of 2008, it was possible to create forged <a href="Transport_Layer_Security" title="wikilink">SSL</a> certificates using an <a class="uri" href="MD5" title="wikilink">MD5</a> collision.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<p>Due to the block and iterative structure of the algorithms and the absence of additional final steps, all SHA functions are vulnerable to <a href="Length_extension_attack" title="wikilink">length-extension</a> and partial-message collision attacks.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> These attacks allow an attacker to forge a message signed only by a keyed hash – <span class="LaTeX">$SHA(message | | key)$</span> or <span class="LaTeX">$SHA(key | | message )$</span> – by extending the message and recalculating the hash without knowing the key. The simplest improvement to prevent these attacks is to hash twice<span class="LaTeX">$$SHA_d(message) = SHA(SHA(0^b | | message))$$</span> (the length of <span class="LaTeX">$0^b$</span>, zero block, is equal to the block size of hash function).</p>
<h3 id="attacks">Attacks</h3>
<p>In early 2005, <a href="Vincent_Rijmen" title="wikilink">Rijmen</a> and <a href="Elisabeth_Oswald" title="wikilink">Oswald</a> published an attack on a reduced version of SHA-1—53 out of 80 rounds—which finds collisions with a computational effort of fewer than 2<sup>80</sup> operations.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<p>In February 2005, an attack by <a href="Xiaoyun_Wang" title="wikilink">Xiaoyun Wang</a>, <a href="Yiqun_Lisa_Yin" title="wikilink">Yiqun Lisa Yin</a>, and <a href="Hongbo_Yu" title="wikilink">Hongbo Yu</a> was announced.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The attacks can find collisions in the full version of SHA-1, requiring fewer than 2<sup>69</sup> operations. (A <a href="brute-force_search" title="wikilink">brute-force search</a> would require 2<sup>80</sup> operations.)</p>
<p>The authors write: "In particular, our analysis is built upon the original differential attack on SHA-0 , the near collision attack on SHA-0, the multiblock collision techniques, as well as the message modification techniques used in the collision search attack on MD5. Breaking SHA-1 would not be possible without these powerful analytical techniques."<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The authors have presented a collision for 58-round SHA-1, found with 2<sup>33</sup> hash operations. The paper with the full attack description was published in August 2005 at the CRYPTO conference.</p>
<p>In an interview, Yin states that, "Roughly, we exploit the following two weaknesses: One is that the file preprocessing step is not complicated enough; another is that certain math operations in the first 20 rounds have unexpected security problems."<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<p>On 17 August 2005, an improvement on the SHA-1 attack was announced on behalf of Xiaoyun Wang, <a href="Andrew_Yao" title="wikilink">Andrew Yao</a> and <a href="Frances_Yao" title="wikilink">Frances Yao</a> at the CRYPTO 2005 rump session, lowering the complexity required for finding a collision in SHA-1 to 2<sup>63</sup>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> On 18 December 2007 the details of this result were explained and verified by Martin Cochran.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<p>Christophe De Cannière and Christian Rechberger further improved the attack on SHA-1 in "Finding SHA-1 Characteristics: General Results and Applications,"<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> receiving the Best Paper Award at <a class="uri" href="ASIACRYPT" title="wikilink">ASIACRYPT</a> 2006. A two-block collision for 64-round SHA-1 was presented, found using unoptimized methods with 2<sup>35</sup> compression function evaluations. Since this attack requires the equivalent of about 2<sup>35</sup> evaluations, it is considered to be a significant theoretical break.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Their attack was extended further to 73 rounds (of 80) in 2010 by Grechnikov.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> In order to find an actual collision in the full 80 rounds of the hash function, however, massive amounts of computer time are required. To that end, a collision search for SHA-1 using the distributed computing platform <a class="uri" href="BOINC" title="wikilink">BOINC</a> began August 8, 2007, organized by the <a href="Graz_University_of_Technology" title="wikilink">Graz University of Technology</a>. The effort was abandoned May 12, 2009 due to lack of progress.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<p>At the Rump Session of CRYPTO 2006, Christian Rechberger and Christophe De Cannière claimed to have discovered a collision attack on SHA-1 that would allow an attacker to select at least parts of the message.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<p>In 2008, an attack methodology by Stéphane Manuel reported hash collisions with an estimated theoretical complexity of 2<sup>51</sup> to 2<sup>57</sup> operations.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> However he later retracted that claim after finding that local collision paths were not actually independent, and finally quoting for the most efficient a collision vector that was already known before this work.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<p>Cameron McDonald, Philip Hawkes and Josef Pieprzyk presented a hash collision attack with claimed complexity 2<sup>52</sup> at the Rump session of Eurocrypt 2009.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> However, the accompanying paper, "Differential Path for SHA-1 with complexity <a href="Big_O_notation" title="wikilink"><em>O</em></a>(2<sup>52</sup>)" has been withdrawn due to the authors' discovery that their estimate was incorrect.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> , the most efficient attack against SHA-1 is considered to be the one by Marc Stevens<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> with an estimated cost of $2.77M to break a single hash value by renting CPU power from cloud servers.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Stevens developed this attack in a project called HashClash,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> implementing a differential path attack. On 8 November 2010, he claimed he had a fully working near-collision attack against full SHA-1 working with an estimated complexity equivalent to 2<sup>57.5</sup> SHA-1 compressions. He estimates this attack can be extended to a full collision with a complexity around 2<sup>61</sup>.</p>
<h3 id="sha-0">SHA-0</h3>
<p>At <a href="CRYPTO_(conference)" title="wikilink">CRYPTO</a> 98, two French researchers, <a href="Florent_Chabaud" title="wikilink">Florent Chabaud</a> and <a href="Antoine_Joux" title="wikilink">Antoine Joux</a>, presented an attack on SHA-0 (<a href="http://fchabaud.free.fr/English/Publications/sha.pdf">Chabaud and Joux, 1998</a>): <a href="hash_collision" title="wikilink">collisions</a> can be found with complexity 2<sup>61</sup>, fewer than the 2<sup>80</sup> for an ideal hash function of the same size.</p>
<p>In 2004, <a href="Eli_Biham" title="wikilink">Biham</a> and Chen found near-collisions for SHA-0—two messages that hash to nearly the same value; in this case, 142 out of the 160 bits are equal. They also found full collisions of SHA-0 reduced to 62 out of its 80 rounds.</p>
<p>Subsequently, on 12 August 2004, a collision for the full SHA-0 algorithm was announced by Joux, Carribault, Lemuet, and Jalby. This was done by using a generalization of the Chabaud and Joux attack. Finding the collision had complexity 2<sup>51</sup> and took about 80,000 CPU hours on a <a class="uri" href="supercomputer" title="wikilink">supercomputer</a> with 256 <a href="Itanium_2" title="wikilink">Itanium 2</a> processors. (Equivalent to 13 days of full-time use of the computer.)</p>
<p>On 17 August 2004, at the Rump Session of CRYPTO 2004, preliminary results were announced by <a href="Xiaoyun_Wang" title="wikilink">Wang</a>, Feng, Lai, and Yu, about an attack on <a class="uri" href="MD5" title="wikilink">MD5</a>, SHA-0 and other hash functions. The complexity of their attack on SHA-0 is 2<sup>40</sup>, significantly better than the attack by Joux <em>et al.</em><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>
<p>In February 2005, an attack by Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu was announced which could find collisions in SHA-0 in 2<sup>39</sup> operations.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>
<p>Another attack in 2008 applying the <a href="boomerang_attack" title="wikilink">boomerang attack</a> brought the complexity of finding collisions down to 2<sup>33.6</sup>, which is estimated to take 1 hour on an average PC.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<p>In light of the results for SHA-0, some experts suggested that plans for the use of SHA-1 in new <a href="cryptosystem" title="wikilink">cryptosystems</a> should be reconsidered. After the CRYPTO 2004 results were published, NIST announced that they planned to phase out the use of SHA-1 by 2010 in favor of the SHA-2 variants.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>
<h3 id="official-validation">Official validation</h3>
<p>Implementations of all FIPS-approved security functions can be officially validated through the <a href="Cryptographic_Module_Validation_Program" title="wikilink">CMVP program</a>, jointly run by the <a href="National_Institute_of_Standards_and_Technology" title="wikilink">National Institute of Standards and Technology</a> (NIST) and the <a href="Communications_Security_Establishment" title="wikilink">Communications Security Establishment</a> (CSE). For informal verification, a package to generate a high number of test vectors is made available for download on the NIST site; the resulting verification however does not replace, in any way, the formal CMVP validation, which is required by law for certain applications.</p>
<p>, there are over 2000 validated implementations of SHA-1, with 14 of them capable of handling messages with a length in bits not a multiple of eight (see <a href="http://csrc.nist.gov/groups/STM/cavp/documents/shs/shaval.htm">SHS Validation List</a>).</p>
<h2 id="examples-and-pseudocode">Examples and pseudocode</h2>
<h3 id="example-hashes">Example hashes</h3>
<p>These are examples of SHA-1 <a href="message_digest" title="wikilink">message digests</a> in hexadecimal and in <a class="uri" href="Base64" title="wikilink">Base64</a> binary to <a class="uri" href="ASCII" title="wikilink">ASCII</a> text encoding.</p>
<p><code>SHA1("The quick brown fox jumps over the lazy </code><code>og")</code><br/>
<code>gives hexadecimal: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12</code><br/>
<code>gives </code><a href="Base64" title="wikilink"><code>Base64</code></a><code> binary to </code><a href="ASCII" title="wikilink"><code>ASCII</code></a><code> text encoding: L9ThxnotKPzthJ7hu3bnORuT6xI=</code></p>
<p>Even a small change in the message will, with overwhelming probability, result in a completely different hash due to the <a href="avalanche_effect" title="wikilink">avalanche effect</a>. For example, changing <code>dog</code> to <code>cog</code> produces a hash with different values for 81 of the 160 bits:</p>
<p><code>SHA1("The quick brown fox jumps over the lazy </code><code>og")</code><br/>
<code>gives hexadecimal: de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3</code><br/>
<code>gives </code><a href="Base64" title="wikilink"><code>Base64</code></a><code> binary to </code><a href="ASCII" title="wikilink"><code>ASCII</code></a><code> text encoding: 3p8sf9JeGzr60+haC9F9mxANtLM=</code></p>
<p>The hash of the zero-length string is:</p>
<p><code>SHA1("")</code><br/>
<code>gives hexadecimal: da39a3ee5e6b4b0d3255bfef95601890afd80709</code><br/>
<code>gives </code><a href="Base64" title="wikilink"><code>Base64</code></a><code> binary to </code><a href="ASCII" title="wikilink"><code>ASCII</code></a><code> text encoding: 2jmj7l5rSw0yVb/vlWAYkK/YBwk=</code></p>
<h3 id="sha-1-pseudocode">SHA-1 pseudocode</h3>
<p><a class="uri" href="Pseudocode" title="wikilink">Pseudocode</a> for the SHA-1 algorithm follows:</p>
<p><span style="color: green;"><em><code>Note</code> <code>1:</code> <code>All</code> <code>variables</code> <code>are</code> <code>unsigned</code> <code>32</code> <code>bits</code> <code>and</code> <code>wrap</code> <code>modulo</code> <code>2</code><sup><code>32</code></sup> <code>when</code> <code>calculating,</code> <code>except</code></em></span></p>
<p><span style="color: green;"><em>ml the message length which is 64 bits, and</em></span> <span style="color: green;"><em>hh the message digest which is 160 bits.</em></span> <span style="color: green;"><em>Note 2: All constants in this pseudo code are in <a href="endianness" title="wikilink">big endian</a>.</em></span> <span style="color: green;"><em>Within each word, the most significant byte is stored in the leftmost byte position</em></span> <span style="color: green;"><em>Initialize variables:</em></span></p>
<p><code>h0 = 0x67452301</code><br/>
<code>h1 = 0xEFCDAB89</code><br/>
<code>h2 = 0x98BADCFE</code><br/>
<code>h3 = 0x10325476</code><br/>
<code>h4 = 0xC3D2E1F0</code><br/>
<br/>
<code>ml = message length in bits (always a multiple of the number of bits in a character).</code><br/>
<br/>
<span style="color: green;"><em><code>Pre-processing:</code></em></span><br/>
<code>append the bit '1' to the message i.e. by adding 0x80 if characters are 8 bits. </code><br/>
<code>append 0 ≤ k </code><em><code>Process</code> <code>the</code> <code>message</code> <code>in</code> <code>successive</code> <code>512-bit</code> <code>chunks:</code></em><br/>
<code>break message into 512-bit chunks</code><br/>
<strong><code>for</code></strong><code> each chunk</code><br/>
<code>    break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15</code><br/>
<br/>
<code>    </code><span style="color: green;"><em><code>Extend</code> <code>the</code> <code>sixteen</code> <code>32-bit</code> <code>words</code> <code>into</code> <code>eighty</code> <code>32-bit</code> <code>words:</code></em></span><br/>
<code>    </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 16 to 79</code><br/>
<code>        w[i] = (w[i-3] </code><strong><code>xor</code></strong><code> w[i-8] </code><strong><code>xor</code></strong><code> w[i-14] </code><strong><code>xor</code></strong><code> w[i-16]) </code><strong><a href="Circular_shift" title="wikilink"><code>leftrotate</code></a></strong><code> 1</code><br/>
<br/>
<code>    </code><span style="color: green;"><em><code>Initialize</code> <code>hash</code> <code>value</code> <code>for</code> <code>this</code> <code>chunk:</code></em></span><br/>
<code>    a = h0</code><br/>
<code>    b = h1</code><br/>
<code>    c = h2</code><br/>
<code>    d = h3</code><br/>
<code>    e = h4</code><br/>
<br/>
<code>    </code><span style="color: green;"><em><code>Main</code> <code>loop:</code></em></span><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><br/>
<code>    </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 0 </code><strong><code>to</code></strong><code> 79</code><br/>
<code>        </code><strong><code>if</code></strong><code> 0 ≤ i ≤ 19 </code><strong><code>then</code></strong><br/>
<code>            f = (b </code><strong><code>and</code></strong><code> c) </code><strong><code>or</code></strong><code> ((</code><strong><code>not</code></strong><code> b) </code><strong><code>and</code></strong><code> d)</code><br/>
<code>            k = 0x5A827999</code><br/>
<code>        </code><strong><code>else</code> <code>if</code></strong><code> 20 ≤ i ≤ 39</code><br/>
<code>            f = b </code><strong><code>xor</code></strong><code> c </code><strong><code>xor</code></strong><code> d</code><br/>
<code>            k = 0x6ED9EBA1</code><br/>
<code>        </code><strong><code>else</code> <code>if</code></strong><code> 40 ≤ i ≤ 59</code><br/>
<code>            f = (b </code><strong><code>and</code></strong><code> c) </code><strong><code>or</code></strong><code> (b </code><strong><code>and</code></strong><code> d) </code><strong><code>or</code></strong><code> (c </code><strong><code>and</code></strong><code> d) </code><br/>
<code>            k = 0x8F1BBCDC</code><br/>
<code>        </code><strong><code>else</code> <code>if</code></strong><code> 60 ≤ i ≤ 79</code><br/>
<code>            f = b </code><strong><code>xor</code></strong><code> c </code><strong><code>xor</code></strong><code> d</code><br/>
<code>            k = 0xCA62C1D6</code><br/>
<br/>
<code>        temp = (a </code><strong><code>leftrotate</code></strong><code> 5) + f + e + k + w[i]</code><br/>
<code>        e = d</code><br/>
<code>        d = c</code><br/>
<code>        c = b </code><strong><code>leftrotate</code></strong><code> 30</code><br/>
<code>        b = a</code><br/>
<code>        a = temp</code><br/>
<br/>
<code>    </code><span style="color: green;"><em><code>Add</code> <code>this</code> <code>chunk's</code> <code>hash</code> <code>to</code> <code>result</code> <code>so</code> <code>far:</code></em></span><br/>
<code>    h0 = h0 + a</code><br/>
<code>    h1 = h1 + b </code><br/>
<code>    h2 = h2 + c</code><br/>
<code>    h3 = h3 + d</code><br/>
<code>    h4 = h4 + e</code><br/>
<br/>
<span style="color:green;"><em><code>Produce</code> <code>the</code> <code>final</code> <code>hash</code> <code>value</code> <code>(big-endian)</code> <code>as</code> <code>a</code> <code>160</code> <code>bit</code> <code>number:</code></em></span><br/>
<code>hh = (h0 </code><strong><code>leftshift</code></strong><code> 128) </code><strong><code>or</code></strong><code> (h1 </code><strong><code>leftshift</code></strong><code> 96) </code><strong><code>or</code></strong><code> (h2 </code><strong><code>leftshift</code></strong><code> 64) </code><strong><code>or</code></strong><code> (h3 </code><strong><code>leftshift</code></strong><code> 32) </code><strong><code>or</code></strong><code> h4</code></p>
<p>The number hh is the message digest, which can be written in hexadecimal (base 16), but is often written using <a class="uri" href="Base64" title="wikilink">Base64</a> binary to ASCII text encoding.</p>
<p>The constant values used are chosen to be <a href="nothing_up_my_sleeve_number" title="wikilink">nothing up my sleeve numbers</a>: the four round constants <code>k</code> are 2<sup>30</sup> times the square roots of 2, 3, 5 and 10. The first four starting values for <code>h0</code> through <code>h3</code> are the same with the MD5 algorithm, and the fifth (for <code>h4</code>) is similar.</p>
<p>Instead of the formulation from the original FIPS PUB 180-1 shown, the following equivalent expressions may be used to compute <code>f</code> in the main loop above:</p>
<p><code>(0  ≤ i ≤ 19): f = d </code><strong><code>xor</code></strong><code> (b </code><strong><code>and</code></strong><code> (c </code><strong><code>xor</code></strong><code> d))                </code><span style="color: green;"><em><code>(alternative</code> <code>1)</code></em></span><br/>
<code>(0  ≤ i ≤ 19): f = (b </code><strong><code>and</code></strong><code> c) </code><strong><code>xor</code></strong><code> ((</code><strong><code>not</code></strong><code> b) </code><strong><code>and</code></strong><code> d)          </code><span style="color: green;"><em><code>(alternative</code> <code>2)</code></em></span><br/>
<code>(0  ≤ i ≤ 19): f = (b </code><strong><code>and</code></strong><code> c) + ((</code><strong><code>not</code></strong><code> b) </code><strong><code>and</code></strong><code> d)            </code><span style="color: green;"><em><code>(alternative</code> <code>3)</code></em></span><br/>
<code>(0  ≤ i ≤ 19): f = vec_sel(d, c, b)                       </code><span style="color: green;"><em><code>(alternative</code> <code>4)</code></em></span><br/>
<code> </code><br/>
<code>(40 ≤ i ≤ 59): f = (b </code><strong><code>and</code></strong><code> c) </code><strong><code>or</code></strong><code> (d </code><strong><code>and</code></strong><code> (b </code><strong><code>or</code></strong><code> c))          </code><span style="color: green;"><em><code>(alternative</code> <code>1)</code></em></span><br/>
<code>(40 ≤ i ≤ 59): f = (b </code><strong><code>and</code></strong><code> c) </code><strong><code>or</code></strong><code> (d </code><strong><code>and</code></strong><code> (b </code><strong><code>xor</code></strong><code> c))         </code><span style="color: green;"><em><code>(alternative</code> <code>2)</code></em></span><br/>
<code>(40 ≤ i ≤ 59): f = (b </code><strong><code>and</code></strong><code> c) + (d </code><strong><code>and</code></strong><code> (b </code><strong><code>xor</code></strong><code> c))          </code><span style="color: green;"><em><code>(alternative</code> <code>3)</code></em></span><br/>
<code>(40 ≤ i ≤ 59): f = (b </code><strong><code>and</code></strong><code> c) </code><strong><code>xor</code></strong><code> (b </code><strong><code>and</code></strong><code> d) </code><strong><code>xor</code></strong><code> (c </code><strong><code>and</code></strong><code> d)  </code><span style="color: green;"><em><code>(alternative</code> <code>4)</code></em></span><br/>
<code>(40 ≤ i ≤ 59): f = vec_sel(c, b, c </code><strong><code>xor</code></strong><code> d)                 </code><span style="color: green;"><em><code>(alternative</code> <code>5)</code></em></span></p>
<p>Max Locktyukhin has also shown<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> that for the rounds 32–79 the computation of:</p>
<p><code>w[i] = (w[i-3] </code><strong><code>xor</code></strong><code> w[i-8] </code><strong><code>xor</code></strong><code> w[i-14] </code><strong><code>xor</code></strong><code> w[i-16]) </code><strong><a href="Circular_shift" title="wikilink"><code>leftrotate</code></a></strong><code> 1</code></p>
<p>can be replaced with:</p>
<p><code>w[i] = (w[i-6] </code><strong><code>xor</code></strong><code> w[i-16] </code><strong><code>xor</code></strong><code> w[i-28] </code><strong><code>xor</code></strong><code> w[i-32]) </code><strong><a href="Circular_shift" title="wikilink"><code>leftrotate</code></a></strong><code> 2</code></p>
<p>This transformation keeps all operands 64-bit aligned and, by removing the dependency of <code>w[i]</code> on <code>w[i-3]</code>, allows efficient SIMD implementation with a vector length of 4 like <a class="uri" href="x86" title="wikilink">x86</a> <a href="Streaming_SIMD_Extensions" title="wikilink">SSE</a> instructions.</p>
<h2 id="comparison-of-sha-functions">Comparison of SHA functions</h2>
<p>In the table below, <em>internal state</em> means the “internal hash sum” after each compression of a data block. </p>
<p>Note that performance will vary not only between algorithms, but also with the specific implementation and hardware used. The <a class="uri" href="OpenSSL" title="wikilink">OpenSSL</a> tool has a built-in "speed" command that benchmarks the various algorithms on the user's system.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Comparison_of_cryptographic_hash_functions" title="wikilink">Comparison of cryptographic hash functions</a></li>
<li><a class="uri" href="cryptlib" title="wikilink">cryptlib</a></li>
<li><a class="uri" href="Crypto++" title="wikilink">Crypto++</a></li>
<li><a href="Digital_timestamping" title="wikilink">Digital timestamping</a></li>
<li><a class="uri" href="Hashcash" title="wikilink">Hashcash</a></li>
<li><a href="Hash_collision" title="wikilink">Hash collision</a></li>
<li><a href="International_Association_for_Cryptologic_Research" title="wikilink">International Association for Cryptologic Research</a></li>
<li><a class="uri" href="Libgcrypt" title="wikilink">Libgcrypt</a></li>
<li><a class="uri" href="md5deep" title="wikilink">md5deep</a></li>
<li><a class="uri" href="OpenSSL" title="wikilink">OpenSSL</a></li>
<li><a class="uri" href="PolarSSL" title="wikilink">PolarSSL</a></li>
<li><a class="uri" href="RIPEMD-160" title="wikilink">RIPEMD-160</a></li>
<li><a href="Secure_Hash_Standard" title="wikilink">Secure Hash Standard</a></li>
<li><a class="uri" href="sha1sum" title="wikilink">sha1sum</a></li>
<li><a href="Tiger_(cryptography)" title="wikilink">Tiger (cryptography)</a></li>
<li><a href="Whirlpool_(cryptography)" title="wikilink">Whirlpool (cryptography)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Florent Chabaud, Antoine Joux: Differential Collisions in SHA-0. <a class="uri" href="CRYPTO" title="wikilink">CRYPTO</a> 1998. pp56–71</li>
<li><a href="Eli_Biham" title="wikilink">Eli Biham</a>, Rafi Chen, Near-Collisions of SHA-0, Cryptology ePrint Archive, Report 2004/146, 2004 (appeared on CRYPTO 2004), <a href="http://eprint.iacr.org/2004/146/">IACR.org</a></li>
<li><a href="Xiaoyun_Wang" title="wikilink">Xiaoyun Wang</a>, Hongbo Yu and Yiqun Lisa Yin, Efficient Collision Search Attacks on SHA-0, CRYPTO 2005, <a href="http://www.cs.cmu.edu/~dbrumley/srg/spring06/sha-0.pdf">CMU.edu</a></li>
<li><a href="Xiaoyun_Wang" title="wikilink">Xiaoyun Wang</a>, Yiqun Lisa Yin and Hongbo Yu, Finding Collisions in the Full SHA-1, Crypto 2005 <a href="http://people.csail.mit.edu/yiqun/SHA1AttackProceedingVersion.pdf">MIT.edu</a></li>
<li><a href="Henri_Gilbert" title="wikilink">Henri Gilbert</a>, <a href="Helena_Handschuh" title="wikilink">Helena Handschuh</a>: Security Analysis of SHA-256 and Sisters. <a href="Selected_Areas_in_Cryptography" title="wikilink">Selected Areas in Cryptography</a> 2003: pp175–193</li>
<li><a class="uri" href="http://www.unixwiz.net/techtips/iguide-crypto-hashes.html">http://www.unixwiz.net/techtips/iguide-crypto-hashes.html</a></li>
<li></li>
<li>A. Cilardo, L. Esposito, A. Veniero, A. Mazzeo, V. Beltran, E. Ayugadé, A CellBE-based HPC application for the analysis of vulnerabilities in cryptographic hash functions, High Performance Computing and Communication international conference, August 2010</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://csrc.nist.gov/CryptoToolkit/tkhash.html">CSRC Cryptographic Toolkit</a> – Official <a href="National_Institute_of_Standards_and_Technology" title="wikilink">NIST</a> site for the Secure Hash Standard</li>
<li><a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">FIPS 180-4: Secure Hash Standard (SHS)</a> (<a href="Portable_Document_Format" title="wikilink">PDF</a>, 1.7 MB) – Current version of the Secure Hash Standard (SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512), March 2012</li>
<li>RFC 3174 (with sample C implementation)</li>
<li><a href="http://www.zdnet.com/news/fixing-a-hole-in-security/141588">Interview with Yiqun Lisa Yin concerning the attack on SHA-1</a></li>
<li><a href="http://www.heise-online.co.uk/security/Hash-cracked--/features/75686">Explanation of the successful attacks on SHA-1</a> (3 pages, 2006)</li>
<li><a href="http://www.cryptography.com/cnews/hash.html">Cryptography Research – Hash Collision Q&A</a></li>
<li><a href="http://www.OnlineHashcrack.com">Online SHA1 hash crack using Rainbow tables</a></li>
<li><a href="http://www.hashproject.eu">Hash Project Web Site: software- and hardware-based cryptanalysis of SHA-1</a></li>
<li></li>
<li>
<p>by <a href="http://www.emsec.rub.de/chair/_staff/christof-paar/">Christof Paar</a></p></li>
</ul>
<p><a href="es:Secure_Hash_Algorithm#SHA-1" title="wikilink">es:Secure Hash Algorithm#SHA-1</a>"</p>
<p><a href="Category:Cryptographic_hash_functions" title="wikilink">Category:Cryptographic hash functions</a> <a href="Category:Broken_hash_functions" title="wikilink">Category:Broken hash functions</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Checksum_algorithms" title="wikilink">Category:Checksum algorithms</a> <a href="Category:National_Security_Agency_cryptography" title="wikilink">Category:National Security Agency cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html">http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.schneier.com/blog/archives/2005/11/nist_hash_works_4.html">Schneier on Security: NIST Hash Workshop Liveblogging (5)</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.heise-online.co.uk/security/Hash-cracked--/features/75686/2">Hash cracked – heise Security</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><mtpl></mtpl><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">National Institute on Standards and Technology Computer Security Resource Center, <a href="http://csrc.nist.gov/groups/ST/hash/policy_2006.html">NIST's March 2006 Policy on Hash Functions</a>, accessed September 28, 2012.<a href="#fnref12">↩</a></li>
<li id="fn13">National Institute on Standards and Technology Computer Security Resource Center, <a href="http://csrc.nist.gov/groups/ST/hash/policy.html">NIST's Policy on Hash Functions</a>, accessed September 28, 2012.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">Alexander Sotirov, Marc Stevens, Jacob Appelbaum, Arjen Lenstra, David Molnar, Dag Arne Osvik, Benne de Weger, <a href="http://www.win.tue.nl/hashclash/rogue-ca/">MD5 considered harmful today: Creating a rogue CA certificate</a>, accessed March 29, 2009<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="http://www.schneier.com/book-ce.html">Niels Ferguson, Bruce Schneier, and Tadayoshi Kohno, Cryptography Engineering</a>, John Wiley & Sons, 2010. ISBN 978-0-470-47424-2<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="http://eprint.iacr.org/2005/010">Cryptology ePrint Archive</a><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="http://theory.csail.mit.edu/~yiqun/shanote.pdf">MIT.edu</a>, <a href="Massachusetts_Institute_of_Technology" title="wikilink">Massachusetts Institute of Technology</a><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="http://www.zdnet.com/news/fixing-a-hole-in-security/141588">Fixing a hole in security | Tech News on ZDNet</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="http://www.schneier.com/blog/archives/2005/08/new_cryptanalyt.html">Schneier on Security: New Cryptanalytic Results Against SHA-1</a><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="http://eprint.iacr.org/2007/474">Notes on the Wang et al. $2^{63}$ SHA-1 Differential Path</a><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="http://www.heise-online.co.uk/security/SHA-1-hash-function-under-pressure--/news/77244">SHA-1 hash function under pressure – heise Security</a><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="http://www.iacr.org/conferences/crypto2006/rumpsched.html">Crypto 2006 Rump Schedule</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"> <em>the most efficient disturbance vector is Codeword2 first reported by Jutla and Patthak</em><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="http://eurocrypt2009rump.cr.yp.to/837a0a8086fa6ca714249409ddfae43d.pdf">SHA-1 collisions now 2^52</a><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="http://eprint.iacr.org/2009/259">International Association for Cryptologic Research</a><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="http://2012.sharcs.org/slides/stevens.pdf">Cryptanalysis of MD5 & SHA-1</a><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="http://www.schneier.com/blog/archives/2012/10/when_will_we_se.html">When Will We See Collisions for SHA-1?</a><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="http://code.google.com/p/hashclash/">HashClash - Framework for MD5 & SHA-1 Differential Path Construction and Chosen-Prefix Collisions for MD5</a><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="http://www.freedom-to-tinker.com/archives/000664.html">Freedom to Tinker » Blog Archive » Report from Crypto 2004</a><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="http://www.schneier.com/blog/archives/2005/02/sha1_broken.html">Schneier on Security: SHA-1 Broken</a><a href="#fnref38">↩</a></li>
<li id="fn39"> <a href="http://www.infosec.sdu.edu.cn/paper/sha0-crypto-author-new.pdf">Sdu.edu.cn</a>, <a href="Shandong_University" title="wikilink">Shandong University</a><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="http://csrc.nist.gov/groups/ST/toolkit/documents/shs/hash_standards_comments.pdf">National Institute of Standards and Technology</a><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="http://www.faqs.org/rfcs/rfc3174.html"><code>http://www.faqs.org/rfcs/rfc3174.html</code></a><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
</ol>
</section>
</body>
</html>
