<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="66">Autocorrelation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Autocorrelation</h1>
<hr/>

<p> </p>

<p><strong>Autocorrelation</strong>, also known as <strong>serial correlation</strong> or <strong>cross-autocorrelation</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is the <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a> of a <a href="Signal_(information_theory)" title="wikilink">signal</a> with itself at different points in time (that is what the cross stands for). Informally, it is the similarity between observations as a function of the time lag between them. It is a mathematical tool for finding repeating patterns, such as the presence of a periodic signal obscured by noise, or identifying the <a href="missing_fundamental" title="wikilink">missing fundamental</a> frequency in a signal implied by its <a class="uri" href="harmonic" title="wikilink">harmonic</a> frequencies. It is often used in <a href="signal_processing" title="wikilink">signal processing</a> for analyzing functions or series of values, such as <a href="time_domain" title="wikilink">time domain</a> signals.</p>
<h2 id="definitions">Definitions</h2>

<p>Different fields of study define autocorrelation differently, and not all of these definitions are equivalent. In some fields, the term is used interchangeably with <a class="uri" href="autocovariance" title="wikilink">autocovariance</a>.</p>
<h3 id="statistics">Statistics</h3>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, the autocorrelation of a <a href="random_process" title="wikilink">random process</a> describes the <a class="uri" href="correlation" title="wikilink">correlation</a> between values of the process at different times, as a function of the two times or of the time lag. Let <em>X</em> be some repeatable process, and <em>i</em> be some point in time after the start of that process. (<em>i</em> may be an <a class="uri" href="integer" title="wikilink">integer</a> for a <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> process or a <a href="real_number" title="wikilink">real number</a> for a <a class="uri" href="continuous-time" title="wikilink">continuous-time</a> process.) Then <em>X</em><sub><em>i</em></sub> is the value (or <a href="Realization_(probability)" title="wikilink">realization</a>) produced by a given <a href="Execution_(computing)" title="wikilink">run</a> of the process at time <em>i</em>. Suppose that the process is further known to have defined values for <a class="uri" href="mean" title="wikilink">mean</a> <em>μ<sub>i</sub></em> and <a class="uri" href="variance" title="wikilink">variance</a> <em>σ<sub>i</sub><sup>2</sup></em> for all times <em>i</em>. Then the definition of the autocorrelation between times <em>s</em> and <em>t</em> is</p>

<p>

<math display="block" id="Autocorrelation:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mfrac>
      <mrow>
       <mo>E</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>X</mi>
            <mi>t</mi>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>μ</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>X</mi>
            <mi>s</mi>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>μ</mi>
            <mi>s</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mrow>
       <msub>
        <mi>σ</mi>
        <mi>t</mi>
       </msub>
       <msub>
        <mi>σ</mi>
        <mi>s</mi>
       </msub>
      </mrow>
     </mfrac>
    </mpadded>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>s</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(s,t)=\frac{\operatorname{E}[(X_{t}-\mu_{t})(X_{s}-\mu_{s})]}{\sigma_{t}%
\sigma_{s}}\,,
  </annotation>
 </semantics>
</math>

</p>

<p>where "E" is the <a href="expected_value" title="wikilink">expected value</a> operator. Note that this expression is not well-defined for all time series or processes, because the variance may be zero (for a constant process) or infinite. If the function <em>R</em> is well-defined, its value must lie in the range [−1, 1], with 1 indicating perfect correlation and −1 indicating perfect <a href="Negative_relationship" title="wikilink">anti-correlation</a>.</p>

<p>If <em>X</em><sub><em>t</em></sub> is a <a href="stationary_process#Weak_or_wide-sense_stationarity" title="wikilink">wide-sense stationary process</a> then the mean <em>μ</em> and the variance <em>σ<sup>2</sup></em> are time-independent, and further the autocorrelation depends only on the lag between <em>t</em> and <em>s</em>: the correlation depends only on the time-distance between the pair of values but not on their position in time. This further implies that the autocorrelation can be expressed as a function of the time-lag, and that this would be an <a href="Even_and_odd_functions" title="wikilink">even function</a> of the lag <em>τ</em> = <em>s</em> − <em>t</em>. This gives the more familiar form</p>

<p>

<math display="block" id="Autocorrelation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo>E</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>X</mi>
           <mi>t</mi>
          </msub>
          <mo>-</mo>
          <mi>μ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>X</mi>
           <mrow>
            <mi>t</mi>
            <mo>+</mo>
            <mi>τ</mi>
           </mrow>
          </msub>
          <mo>-</mo>
          <mi>μ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <msup>
      <mi>σ</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>t</ci>
        </apply>
        <ci>μ</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <ci>τ</ci>
         </apply>
        </apply>
        <ci>μ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\tau)=\frac{\operatorname{E}[(X_{t}-\mu)(X_{t+\tau}-\mu)]}{\sigma^{2}},\,
  </annotation>
 </semantics>
</math>

</p>

<p>and the fact that this is an <a href="Even_and_odd_functions#Even_functions" title="wikilink">even function</a> can be stated as</p>

<p>

<math display="block" id="Autocorrelation:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\tau)=R(-\tau).\,
  </annotation>
 </semantics>
</math>

</p>

<p>It is common practice in some disciplines, other than statistics and <a href="time_series_analysis" title="wikilink">time series analysis</a>, to drop the normalization by <em>σ<sup>2</sup></em> and use the term "autocorrelation" interchangeably with "autocovariance". However, the normalization is important both because the interpretation of the autocorrelation as a correlation provides a scale-free measure of the strength of <a href="statistical_dependence" title="wikilink">statistical dependence</a>, and because the normalization has an effect on the statistical properties of the estimated autocorrelations.</p>
<h3 id="signal-processing">Signal processing</h3>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, the above definition is often used without the normalization, that is, without subtracting the mean and dividing by the variance. When the autocorrelation function is normalized by mean and variance, it is sometimes referred to as the <strong>autocorrelation coefficient</strong>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Given a <a href="Signal_(electronics)" title="wikilink">signal</a> 

<math display="inline" id="Autocorrelation:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)
  </annotation>
 </semantics>
</math>

, the continuous autocorrelation 

<math display="inline" id="Autocorrelation:4">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>f</mi>
     <mi>f</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{ff}(\tau)
  </annotation>
 </semantics>
</math>

 is most often defined as the continuous cross-correlation integral of 

<math display="inline" id="Autocorrelation:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)
  </annotation>
 </semantics>
</math>

 with itself, at lag 

<math display="inline" id="Autocorrelation:6">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Autocorrelation:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>f</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <msub>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>f</mi>
        <mo>¯</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>u</mi>
       <mo>+</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo>¯</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo>¯</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>u</mi>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <ci>τ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <plus></plus>
        <ci>u</ci>
        <ci>τ</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <ci>f</ci>
       </apply>
       <ci>u</ci>
       <ci>normal-d</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>u</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>u</ci>
        <ci>τ</ci>
       </apply>
       <ci>normal-d</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{ff}(\tau)=(f*g_{-1}(\overline{f}))(\tau)=\int_{-\infty}^{\infty}f(u+\tau)%
\overline{f}(u)\,{\rm d}u=\int_{-\infty}^{\infty}f(u)\overline{f}(u-\tau)\,{%
\rm d}u
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Autocorrelation:8">
 <semantics>
  <mover accent="true">
   <mi>f</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{f}
  </annotation>
 </semantics>
</math>

 represents the <a href="complex_conjugate" title="wikilink">complex conjugate</a>, 

<math display="inline" id="Autocorrelation:9">
 <semantics>
  <msub>
   <mi>g</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{-1}
  </annotation>
 </semantics>
</math>

 is a function which manipulates the function 

<math display="inline" id="Autocorrelation:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and is defined as 

<math display="inline" id="Autocorrelation:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>f</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>u</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{-1}(f)(u)=f(-u)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Autocorrelation:12">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 represents <a class="uri" href="convolution" title="wikilink">convolution</a>.</p>

<p>For a <a href="real_function" title="wikilink">real function</a>, 

<math display="inline" id="Autocorrelation:13">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>f</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{f}=f
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that the parameter 

<math display="inline" id="Autocorrelation:14">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 in the integral is a dummy variable and is only necessary to calculate the integral. It has no specific meaning.</p>

<p>The discrete autocorrelation 

<math display="inline" id="Autocorrelation:15">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 at lag 

<math display="inline" id="Autocorrelation:16">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 for a discrete signal 

<math display="inline" id="Autocorrelation:17">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Autocorrelation:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>∈</mo>
       <mi>Z</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mover accent="true">
       <mi>y</mi>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>l</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>l</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>n</ci>
       <ci>Z</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>n</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{yy}(l)=\sum_{n\in Z}y(n)\,\overline{y}(n-l).
  </annotation>
 </semantics>
</math>

</p>

<p>The above definitions work for signals that are square integrable, or square summable, that is, of finite energy. Signals that "last forever" are treated instead as random processes, in which case different definitions are needed, based on expected values. For <a href="stationary_process" title="wikilink">wide-sense-stationary random processes</a>, the autocorrelations are defined as</p>

<p>

<math display="block" id="Autocorrelation:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>f</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>E</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mover accent="true">
       <mi>f</mi>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mi>τ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <ci>τ</ci>
    </apply>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>t</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{ff}(\tau)=\operatorname{E}\left[f(t)\overline{f}(t-\tau)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Autocorrelation:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mover accent="true">
        <mi>y</mi>
        <mo>¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>l</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>l</ci>
    </apply>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>n</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{yy}(l)=\operatorname{E}\left[y(n)\,\overline{y}(n-l)\right].
  </annotation>
 </semantics>
</math>

</p>

<p>For processes that are not <a href="Stationary_process" title="wikilink">stationary</a>, these will also be functions of 

<math display="inline" id="Autocorrelation:21">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Autocorrelation:22">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>

<p>For processes that are also <a href="Ergodic_process" title="wikilink">ergodic</a>, the expectation can be replaced by the limit of a time average. The autocorrelation of an ergodic process is sometimes defined as or equated to<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Autocorrelation:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>f</mi>
      <mi>f</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>T</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>T</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>T</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mi>τ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mover accent="true">
        <mi>f</mi>
        <mo>¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">d</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <ci>τ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>T</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>T</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <ci>τ</ci>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>f</ci>
        </apply>
        <ci>t</ci>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{ff}(\tau)=\lim_{T\rightarrow\infty}\frac{1}{T}\int_{0}^{T}f(t+\tau)%
\overline{f}(t)\,{\rm d}t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Autocorrelation:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>N</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </munder>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>N</mi>
      </mfrac>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mover accent="true">
         <mi>y</mi>
         <mo>¯</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>l</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>l</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>N</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>n</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{yy}(l)=\lim_{N\rightarrow\infty}\frac{1}{N}\sum_{n=0}^{N-1}y(n)\,\overline{%
y}(n-l).
  </annotation>
 </semantics>
</math>

</p>

<p>These definitions have the advantage that they give sensible well-defined single-parameter results for periodic functions, even when those functions are not the output of stationary ergodic processes.</p>

<p>Alternatively, signals that <em>last forever</em> can be treated by a short-time autocorrelation function analysis, using finite time integrals. (See <a href="short-time_Fourier_transform" title="wikilink">short-time Fourier transform</a> for a related process.)</p>

<p>Multi-<a href="dimension" title="wikilink">dimensional</a> autocorrelation is defined similarly. For example, in <a href="Three-dimensional_space" title="wikilink">three dimensions</a> the autocorrelation of a square-summable <a href="discrete_signal" title="wikilink">discrete signal</a> would be</p>

<p>

<math display="block" id="Autocorrelation:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi mathvariant="normal">ℓ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>,</mo>
       <mi>q</mi>
       <mo>,</mo>
       <mi>r</mi>
      </mrow>
     </munder>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>n</mi>
         <mo>,</mo>
         <mi>q</mi>
         <mo>,</mo>
         <mi>r</mi>
        </mrow>
       </msub>
      </mpadded>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>j</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>q</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>r</mi>
         <mo>-</mo>
         <mi mathvariant="normal">ℓ</mi>
        </mrow>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <vector>
      <ci>j</ci>
      <ci>k</ci>
      <ci>normal-ℓ</ci>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>n</ci>
       <ci>q</ci>
       <ci>r</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <ci>n</ci>
        <ci>q</ci>
        <ci>r</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>q</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>r</ci>
         <ci>normal-ℓ</ci>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(j,k,\ell)=\sum_{n,q,r}x_{n,q,r}\,x_{n-j,q-k,r-\ell}.
  </annotation>
 </semantics>
</math>

</p>

<p>When mean values are subtracted from signals before computing an autocorrelation function, the resulting function is usually called an auto-covariance function.</p>
<h2 id="properties">Properties</h2>

<p>In the following, we will describe properties of one-dimensional autocorrelations only, since most properties are easily transferred from the one-dimensional case to the multi-dimensional cases.</p>
<ul>
<li>A fundamental property of the autocorrelation is symmetry, 

<math display="inline" id="Autocorrelation:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(i)=R(-i)
  </annotation>
 </semantics>
</math>

, which is easy to prove from the definition. In the continuous case,</li>
</ul>
<dl>
<dd>the autocorrelation is an <a href="even_function" title="wikilink">even function</a>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Autocorrelation:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>f</ci>
     </apply>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{f}(-\tau)=R_{f}(\tau)\,
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Autocorrelation:28">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a real function,
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>and the autocorrelation is a <a href="Hermitian_function" title="wikilink">Hermitian function</a>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Autocorrelation:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>R</mi>
     <mi>f</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>f</ci>
      </apply>
      <times></times>
     </apply>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{f}(-\tau)=R_{f}^{*}(\tau)\,
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Autocorrelation:30">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a <a href="complex_function" title="wikilink">complex function</a>.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>The continuous autocorrelation function reaches its peak at the origin, where it takes a real value, i.e. for any delay 

<math display="inline" id="Autocorrelation:31">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Autocorrelation:32">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>f</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>f</ci>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>f</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R_{f}(\tau)|\leq R_{f}(0)
  </annotation>
 </semantics>
</math>

. This is a consequence of the <a href="rearrangement_inequality" title="wikilink">rearrangement inequality</a>. The same result holds in the discrete case.</li>
</ul>
<ul>
<li>The autocorrelation of a <a href="periodic_function" title="wikilink">periodic function</a> is, itself, periodic with the same period.</li>
</ul>
<ul>
<li>The autocorrelation of the sum of two completely uncorrelated functions (the cross-correlation is zero for all 

<math display="inline" id="Autocorrelation:33">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

) is the sum of the autocorrelations of each function separately.</li>
</ul>
<ul>
<li>Since autocorrelation is a specific type of <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a>, it maintains all the properties of cross-correlation.</li>
</ul>
<ul>
<li>The autocorrelation of a continuous-time <a href="white_noise" title="wikilink">white noise</a> signal will have a strong peak (represented by a <a href="Dirac_delta_function" title="wikilink">Dirac delta function</a>) at 

<math display="inline" id="Autocorrelation:34">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=0
  </annotation>
 </semantics>
</math>

 and will be absolutely 0 for all other 

<math display="inline" id="Autocorrelation:35">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>The <a href="Wiener–Khinchin_theorem" title="wikilink">Wiener–Khinchin theorem</a> relates the autocorrelation function to the <a href="spectral_density" title="wikilink">power spectral density</a> via the <a href="Fourier_transform" title="wikilink">Fourier transform</a>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Autocorrelation:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mn>2</mn>
        <mi>π</mi>
        <mi>f</mi>
        <mi>τ</mi>
       </mrow>
      </msup>
     </mpadded>
     <mi mathvariant="normal">d</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>f</ci>
        <ci>τ</ci>
       </apply>
      </apply>
      <ci>normal-d</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\tau)=\int_{-\infty}^{\infty}S(f)e^{j2\pi f\tau}\,{\rm d}f
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Autocorrelation:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>j</mi>
          <mn>2</mn>
          <mi>π</mi>
          <mi>f</mi>
          <mi>τ</mi>
         </mrow>
        </mrow>
       </msup>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>τ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>τ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>f</ci>
         <ci>τ</ci>
        </apply>
       </apply>
      </apply>
      <ci>normal-d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(f)=\int_{-\infty}^{\infty}R(\tau)e^{-j2\pi f\tau}\,{\rm d}\tau.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>For real-valued functions, the symmetric autocorrelation function has a real symmetric transform, so the <a href="Wiener–Khinchin_theorem" title="wikilink">Wiener–Khinchin theorem</a> can be re-expressed in terms of real cosines only:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Autocorrelation:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>f</mi>
        <mi>τ</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>f</ci>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>f</ci>
        <ci>τ</ci>
       </apply>
      </apply>
      <ci>normal-d</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\tau)=\int_{-\infty}^{\infty}S(f)\cos(2\pi f\tau)\,{\rm d}f
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Autocorrelation:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>f</mi>
         <mi>τ</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>τ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>τ</ci>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>f</ci>
        <ci>τ</ci>
       </apply>
      </apply>
      <ci>normal-d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(f)=\int_{-\infty}^{\infty}R(\tau)\cos(2\pi f\tau)\,{\rm d}\tau.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="efficient-computation">Efficient computation</h2>

<p>For data expressed as a <a href="Discrete_signal" title="wikilink">discrete</a> sequence, it is frequently necessary to compute the autocorrelation with high <a href="algorithmic_efficiency" title="wikilink">computational efficiency</a>. A brute force method based on the signal processing definition 

<math display="inline" id="Autocorrelation:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>n</mi>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mpadded>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{xx}(j)=\sum_{n}x_{n}\,\overline{x}_{n-j}
  </annotation>
 </semantics>
</math>

 can be used when the signal size is small. For example, to calculate the autocorrelation of the real signal sequence 

<math display="inline" id="Autocorrelation:41">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <vector>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(2,3,1)
  </annotation>
 </semantics>
</math>

 (i.e. 

<math display="inline" id="Autocorrelation:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>3</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(0)=2,x(1)=3,x(2)=1
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Autocorrelation:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(i)=0
  </annotation>
 </semantics>
</math>

 for all other values of 

<math display="inline" id="Autocorrelation:44">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

) by hand, we first recognize that the definition just given is nothing but the usual multiplication with right shifts, where each vertical addition gives the autocorrelation for particular lag values:</p>

<p><code>          2  3  1</code><br/>
<code>       ×  2  3  1</code><br/>
<code>       ------------------</code><br/>
<code>          2  3  1</code><br/>
<code>             6  9  3</code><br/>
<code>                4  6  2</code><br/>
<code>       ------------------</code><br/>
<code>          2  9 14  9  2</code></p>

<p>Thus the required autocorrelation sequence is 

<math display="inline" id="Autocorrelation:45">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>x</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>9</mn>
    <mo>,</mo>
    <mn>14</mn>
    <mo>,</mo>
    <mn>9</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <vector>
     <cn type="integer">2</cn>
     <cn type="integer">9</cn>
     <cn type="integer">14</cn>
     <cn type="integer">9</cn>
     <cn type="integer">2</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{xx}=(2,9,14,9,2)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Autocorrelation:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>14</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">14</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{xx}(0)=14,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Autocorrelation:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>9</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">9</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{xx}(-1)=R_{xx}(1)=9,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Autocorrelation:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{xx}(-2)=R_{xx}(2)=2,
  </annotation>
 </semantics>
</math>

 the autocorrelation for other lag values being zero. In this calculation we do not perform the carry-over operation during addition as is usual in normal multiplication. Note that we can halve the number of operations required by exploiting the inherent symmetry of the autocorrelation. If the signal happens to be periodic, i.e. 

<math display="inline" id="Autocorrelation:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <vector>
     <ci>normal-…</ci>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(...,2,3,1,2,3,1,...),
  </annotation>
 </semantics>
</math>

 then we get a circular autocorrelation (similar to <a href="circular_convolution" title="wikilink">circular convolution</a>) where the left and right tails of the previous autocorrelation sequence will overlap and give 

<math display="inline" id="Autocorrelation:50">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>x</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>14</mn>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mn>14</mn>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <vector>
     <ci>normal-…</ci>
     <cn type="integer">14</cn>
     <cn type="integer">11</cn>
     <cn type="integer">11</cn>
     <cn type="integer">14</cn>
     <cn type="integer">11</cn>
     <cn type="integer">11</cn>
     <ci>normal-…</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{xx}=(...,14,11,11,14,11,11,...)
  </annotation>
 </semantics>
</math>

 which has the same period as the signal sequence 

<math display="inline" id="Autocorrelation:51">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x.
  </annotation>
 </semantics>
</math>

</p>

<p>While the brute force algorithm is <a href="Big_O_notation" title="wikilink">order</a> <mtpl></mtpl>, several efficient algorithms exist which can compute the autocorrelation in order 

<math display="inline" id="Autocorrelation:52">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nlog(n)
  </annotation>
 </semantics>
</math>

. For example, the <a href="Wiener–Khinchin_theorem" title="wikilink">Wiener–Khinchin theorem</a> allows computing the autocorrelation from the raw data 

<math display="inline" id="Autocorrelation:53">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)
  </annotation>
 </semantics>
</math>

 with two <a href="Fast_Fourier_transform" title="wikilink">Fast Fourier transforms</a> (FFT):<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<dl>
<dd><dl>
<dd><mtpl> FFT[<em>X</em>(<em>t</em>)]}}</mtpl>
</dd>
<dd><mtpl> <em>F</em><sub><em>R</em></sub>(<em>f</em>) <em>F</em><sub><em>R</em></sub><sup>*</sup>(<em>f</em>)}}</mtpl>
</dd>
<dd>

<math display="inline" id="Autocorrelation:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mi>F</mi>
    <mi>F</mi>
    <mi>T</mi>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>F</ci>
     <ci>F</ci>
     <ci>T</ci>
     <ci>S</ci>
     <ci>S</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(τ)=IFFTSS(f)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where IFFT denotes the inverse <a href="Fast_Fourier_transform" title="wikilink">Fast Fourier transform</a>. The asterisk denotes <a href="complex_conjugate" title="wikilink">complex conjugate</a>.</p>

<p>Alternatively, a multiple 

<math display="inline" id="Autocorrelation:55">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   τ
  </annotation>
 </semantics>
</math>

 correlation can be performed by using brute force calculation for low 

<math display="inline" id="Autocorrelation:56">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   τ
  </annotation>
 </semantics>
</math>

 values, and then progressively binning the 

<math display="inline" id="Autocorrelation:57">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)
  </annotation>
 </semantics>
</math>

 data with a <a href="logarithm" title="wikilink">logarithmic</a> density to compute higher values, resulting in the same 

<math display="inline" id="Autocorrelation:58">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nlog(n)
  </annotation>
 </semantics>
</math>

 efficiency, but with lower memory requirements.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="estimation">Estimation</h2>

<p>For a <a href="Discrete_signal" title="wikilink">discrete</a> process with known mean and variance for which we observe 

<math display="inline" id="Autocorrelation:59">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 observations 

<math display="inline" id="Autocorrelation:60">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X_{1},\,X_{2},\,\ldots,\,X_{n}\}
  </annotation>
 </semantics>
</math>

, an estimate of the autocorrelation may be obtained as</p>

<p>

<math display="block" id="Autocorrelation:61">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>R</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>σ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </munderover>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
        <mo>-</mo>
        <mi>μ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>X</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mi>k</mi>
         </mrow>
        </msub>
        <mo>-</mo>
        <mi>μ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>R</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>t</ci>
        </apply>
        <ci>μ</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>μ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{R}(k)=\frac{1}{(n-k)\sigma^{2}}\sum_{t=1}^{n-k}(X_{t}-\mu)(X_{t+k}-\mu)
  </annotation>
 </semantics>
</math>

</p>

<p>for any positive integer 

<math display="inline" id="Autocorrelation:62">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 and variance 

<math display="inline" id="Autocorrelation:63">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 are known, this estimate is <strong><a href="Biased_estimator" title="wikilink">unbiased</a></strong>. If the true mean and <a class="uri" href="variance" title="wikilink">variance</a> of the process are not known there are a several possibilities:</p>
<ul>
<li>If 

<math display="inline" id="Autocorrelation:64">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Autocorrelation:65">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 are replaced by the standard formulae for sample mean and sample variance, then this is a <strong><a href="Biased_estimator" title="wikilink">biased estimate</a></strong>.</li>
<li>A <a class="uri" href="periodogram" title="wikilink">periodogram</a>-based estimate replaces 

<math display="inline" id="Autocorrelation:66">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in the above formula with 

<math display="inline" id="Autocorrelation:67">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X_{1},\,X_{2},\,\ldots,\,X_{n-k}\}
  </annotation>
 </semantics>
</math>

. This estimate is always biased; however, it usually has a smaller mean square error.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
<li>Other possibilities derive from treating the two portions of data 

<math display="inline" id="Autocorrelation:68">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X_{k+1},\,X_{k+2},\,\ldots,\,X_{n}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Autocorrelation:69">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 separately and calculating separate sample means and/or sample variances for use in defining the estimate.</li>
</ul>

<p>The advantage of estimates of the last type is that the set of estimated autocorrelations, as a function of 

<math display="inline" id="Autocorrelation:70">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, then form a function which is a valid autocorrelation in the sense that it is possible to define a theoretical process having exactly that autocorrelation. Other estimates can suffer from the problem that, if they are used to calculate the variance of a linear combination of the 

<math display="inline" id="Autocorrelation:71">
 <semantics>
  <msup>
   <mi>χ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>χ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi^{2}
  </annotation>
 </semantics>
</math>

's, the variance calculated may turn out to be negative.</p>
<h2 id="regression-analysis">Regression analysis</h2>

<p>In <a href="regression_analysis" title="wikilink">regression analysis</a> using <a href="time_series_analysis" title="wikilink">time series data</a>, autocorrelation in a variable of interest is typically modeled either with an <a href="autoregressive_model" title="wikilink">autoregressive model</a> (AR), a <a href="moving_average_model" title="wikilink">moving average model</a> (MA), their combination as an <a href="autoregressive_moving_average_model" title="wikilink">autoregressive moving average model</a> (ARMA), or an extension of the latter called an <a href="autoregressive_integrated_moving_average_model" title="wikilink">autoregressive integrated moving average model</a> (ARIMA). With multiple interrelated data series, <a href="vector_autoregression" title="wikilink">vector autoregression</a> (VAR) or its extensions are used.</p>

<p>Problematic autocorrelation of the errors, which themselves are unobserved, can generally be detected because it produces autocorrelation in the observable <a href="Errors_and_residuals_in_statistics" title="wikilink">residuals</a>. (Errors are also known as "error terms" in <a class="uri" href="econometrics" title="wikilink">econometrics</a>.) Autocorrelation of the errors violates the ordinary least squares (OLS) assumption that the error terms are uncorrelated, meaning that the <a href="Gauss–Markov_theorem" title="wikilink">Gauss Markov theorem</a> does not apply, and that OLS estimators are no longer the Best Linear Unbiased Estimators (BLUE). While it does not bias the OLS coefficient estimates, the <a href="Standard_error_(statistics)" title="wikilink">standard errors</a> tend to be underestimated (and the <a href="T-statistics" title="wikilink">t-scores</a> overestimated) when the autocorrelations of the errors at low lags are positive.</p>

<p>The traditional test for the presence of first-order autocorrelation is the <a href="Durbin–Watson_statistic" title="wikilink">Durbin–Watson statistic</a> or, if the explanatory variables include a lagged dependent variable, <a href="Durbin–Watson_statistic#Durbin_h-statistic" title="wikilink">Durbin's h statistic</a>. The Durbin-Watson can be linearly mapped however to the Pearson correlation between values and their lags.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> A more flexible test, covering autocorrelation of higher orders and applicable whether or not the regressors include lags of the dependent variable, is the <a href="Breusch–Godfrey_test" title="wikilink">Breusch–Godfrey test</a>. This involves an auxiliary regression, wherein the residuals obtained from estimating the model of interest are regressed on (a) the original regressors and (b) <em>k</em> lags of the residuals, where <em>k</em> is the order of the test. The simplest version of the test statistic from this auxiliary regression is <em>TR</em><sup>2</sup>, where <em>T</em> is the sample size and <em>R</em><sup>2</sup> is the <a href="coefficient_of_determination" title="wikilink">coefficient of determination</a>. Under the null hypothesis of no autocorrelation, this statistic is asymptotically distributed as <span class="LaTeX">$\chi^2$</span> with <em>k</em> degrees of freedom.</p>

<p>Responses to nonzero autocorrelation include <a href="generalized_least_squares" title="wikilink">generalized least squares</a> and the <a href="Newey_West" title="wikilink">Newey–West HAC estimator</a> (Heteroskedasticity and Autocorrelation Consistent).<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>In the estimation of a <a href="moving_average_model" title="wikilink">moving average model</a> (MA), the autocorrelation function is used to determine the appropriate number of lagged error terms to include in the regression.</p>
<h2 id="applications">Applications</h2>
<ul>
<li>Autcorrelation analysis is used heavily in <a href="fluorescence_correlation_spectroscopy" title="wikilink">fluorescence correlation spectroscopy</a>.</li>
</ul>
<ul>
<li>Another application of autocorrelation is the measurement of <a href="optical_spectrum" title="wikilink">optical spectra</a> and the measurement of very-short-duration <a class="uri" href="light" title="wikilink">light</a> <a href="ultrashort_pulse" title="wikilink">pulses</a> produced by <a href="laser" title="wikilink">lasers</a>, both using <a href="optical_autocorrelation" title="wikilink">optical autocorrelators</a>.</li>
</ul>
<ul>
<li>Autocorrelation is used to analyze <a href="dynamic_light_scattering" title="wikilink">dynamic light scattering</a> data, which notably enables determination of the <a href="particle_size_distribution" title="wikilink">particle size distributions</a> of nanometer-sized particles or <a href="micelle" title="wikilink">micelles</a> suspended in a fluid. A laser shining into the mixture produces a <a href="speckle_pattern" title="wikilink">speckle pattern</a> that results from the motion of the particles. Autocorrelation of the signal can be analyzed in terms of the diffusion of the particles. From this, knowing the viscosity of the fluid, the sizes of the particles can be calculated.</li>
</ul>
<ul>
<li>The <a href="small-angle_X-ray_scattering" title="wikilink">small-angle X-ray scattering</a> intensity of a nanostructured system is the Fourier transform of the spatial autocorrelation function of the electron density.</li>
</ul>
<ul>
<li>In optics, normalized autocorrelations and cross-correlations give the <a href="degree_of_coherence" title="wikilink">degree of coherence</a> of an electromagnetic field.</li>
</ul>
<ul>
<li>In <a href="signal_processing" title="wikilink">signal processing</a>, autocorrelation can give information about repeating events like <a href="music" title="wikilink">musical</a> <a href="Beat_(music)" title="wikilink">beats</a> (for example, to determine <a class="uri" href="tempo" title="wikilink">tempo</a>) or <a class="uri" href="pulsar" title="wikilink">pulsar</a> <a href="frequency" title="wikilink">frequencies</a>, though it cannot tell the position in time of the beat. It can also be used to <a href="Pitch_detection_algorithm" title="wikilink">estimate the pitch of a musical tone</a>.</li>
</ul>
<ul>
<li>In <a href="Music_Recording" title="wikilink">music recording</a>, autocorrelation is used as a <a href="pitch_detection_algorithm" title="wikilink">pitch detection algorithm</a> prior to vocal processing, as a distortion effect or to eliminate undesired mistakes and inaccuracies.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>
<ul>
<li>Autocorrelation in space rather than time, via the <a href="Patterson_function" title="wikilink">Patterson function</a>, is used by X-ray diffractionists to help recover the "Fourier phase information" on atom positions not available through diffraction alone.</li>
</ul>
<ul>
<li>In statistics, spatial autocorrelation between sample locations also helps one estimate <a href="Variance#Generalizations" title="wikilink">mean value uncertainties</a> when sampling a heterogeneous population.</li>
</ul>
<ul>
<li>The <a class="uri" href="SEQUEST" title="wikilink">SEQUEST</a> algorithm for analyzing <a href="Mass_spectrum" title="wikilink">mass spectra</a> makes use of autocorrelation in conjunction with <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a> to score the similarity of an observed spectrum to an idealized spectrum representing a <a class="uri" href="peptide" title="wikilink">peptide</a>.</li>
<li>In <a class="uri" href="astrophysics" title="wikilink">astrophysics</a>, auto-correlation is used to study and characterize the spatial distribution of <a class="uri" href="galaxies" title="wikilink">galaxies</a> in the Universe and in multi-wavelength observations of Low Mass X-ray Binaries.</li>
</ul>
<ul>
<li>In <a href="panel_data" title="wikilink">panel data</a>, spatial autocorrelation refers to correlation of a variable with itself through space.</li>
</ul>
<ul>
<li>In analysis of <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> data, autocorrelation must be taken into account for correct error determination.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Autocorrelation_matrix" title="wikilink">Autocorrelation matrix</a></li>
<li><a href="Autocorrelation_technique" title="wikilink">Autocorrelation technique</a></li>
<li><a class="uri" href="Autocorrelator" title="wikilink">Autocorrelator</a></li>
<li><a href="Correlation_function" title="wikilink">Correlation function</a></li>
<li><a class="uri" href="Correlogram" title="wikilink">Correlogram</a></li>
<li><a href="Covariance_mapping" title="wikilink">Covariance mapping</a></li>
<li><a class="uri" href="Cross-correlation" title="wikilink">Cross-correlation</a></li>
<li><a href="Galton's_problem" title="wikilink">Galton's problem</a></li>
<li><a href="Partial_autocorrelation_function" title="wikilink">Partial autocorrelation function</a></li>
<li><a href="Fluorescence_correlation_spectroscopy" title="wikilink">Fluorescence correlation spectroscopy</a></li>
<li><a href="Optical_autocorrelation" title="wikilink">Optical autocorrelation</a></li>
<li><a href="Pitch_detection_algorithm" title="wikilink">Pitch detection algorithm</a></li>
<li><a href="Triple_correlation" title="wikilink">Triple correlation</a></li>
<li><a class="uri" href="Variance" title="wikilink">Variance</a></li>
<li><a class="uri" href="CUSUM" title="wikilink">CUSUM</a></li>
<li><a href="Cochrane–Orcutt_estimation" title="wikilink">Cochrane–Orcutt estimation</a> (transformation for autocorrelated error terms)</li>
<li><a href="Prais–Winsten_transformation" title="wikilink">Prais–Winsten transformation</a></li>
<li><a href="Scaled_Correlation" title="wikilink">Scaled Correlation</a></li>
<li><a href="Unbiased_estimation_of_standard_deviation#Effect_of_autocorrelation_(serial_correlation)" title="wikilink">Unbiased estimation of standard deviation#Effect of autocorrelation (serial correlation)</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li>Mojtaba Soltanalian, and Petre Stoica. "[<a class="uri" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp">http://ieeexplore.ieee.org/xpl/login.jsp?tp</a>=&amp;arnumber;=6142119 Computational design of sequences with good correlation properties]." IEEE Transactions on Signal Processing, 60.5 (2012): 2180-2193.</li>
<li>Solomon W. Golomb, and Guang Gong. <a href="http://www.cambridge.org/us/academic/subjects/computer-science/cryptography-cryptology-and-coding/signal-design-good-correlation-wireless-communication-cryptography-and-radar">Signal design for good correlation: for wireless communication, cryptography, and radar</a>. Cambridge University Press, 2005.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.dsprelated.com/comp.dsp/keyword/Autocorrelation.php">Autocorrelation articles in Comp.DSP (DSP usenet group).</a></li>
<li><a href="http://www.iop.org/EJ/abstract/1367-2630/11/9/093024/">GPU accelerated calculation of autocorrelation function.</a></li>
<li>

<p>by <a href="Mark_Thoma" title="wikilink">Mark Thoma</a></p></li>
<li><a href="http://itfeature.com/time-series-analysis-and-forecasting/autocorrelation-time-series-data">Autocorrelation Time Series data by itfeature</a></li>
</ul>

<p>"</p>

<p><a href="Category:Covariance_and_correlation" title="wikilink">Category:Covariance and correlation</a> <a href="Category:Regression_analysis" title="wikilink">Category:Regression analysis</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Time_domain_analysis" title="wikilink">Category:Time domain analysis</a> <a href="Category:Time_series_analysis" title="wikilink">Category:Time series analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Google Books <a class="uri" href="https://books.google.de/books?id=V46p_mH99m8C&amp;lpg">https://books.google.de/books?id=V46p_mH99m8C&amp;lpg;</a>;=PA17&amp;dq;=crossautocorrelation&amp;hl;=de&amp;pg;=PA17#v=onepage&amp;q;=crossautocorrelation&amp;f;=false<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a class="uri" href="http://statisticalideas.blogspot.com/2014/05/serial-correlation-techniques.html">http://statisticalideas.blogspot.com/2014/05/serial-correlation-techniques.html</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
