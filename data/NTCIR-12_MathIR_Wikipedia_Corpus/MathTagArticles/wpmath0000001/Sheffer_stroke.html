<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1006">Sheffer stroke</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sheffer stroke</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption><a href="Venn_diagram" title="wikilink">Venn diagram</a> of 

<math display="inline" id="Sheffer_stroke:0">
 <semantics>
  <mrow>
   <mpadded lspace="3.3pt" width="+3.3pt">
    <mi>A</mi>
   </mpadded>
   <mo>↑</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}A\uparrow B
  </annotation>
 </semantics>
</math>

</figcaption>
</figure>

<p>In <a href="Boolean_function" title="wikilink">Boolean functions</a> and <a href="propositional_calculus" title="wikilink">propositional calculus</a>, the <strong>Sheffer stroke</strong>, named after <a href="Henry_M._Sheffer" title="wikilink">Henry M. Sheffer</a>, written "|" (see <a href="vertical_bar" title="wikilink">vertical bar</a>, not to be confused with "||" which is often used to represent <a href="Logical_disjunction" title="wikilink">disjunction</a>), "D<em>pq</em>", or "↑" (an upwards arrow), denotes a <a href="logical_operation" title="wikilink">logical operation</a> that is equivalent to the <a href="logical_negation" title="wikilink">negation</a> of the <a href="logical_conjunction" title="wikilink">conjunction</a> operation, expressed in ordinary language as "not both". It is also called <strong>nand</strong> ("not and") or the <strong>alternative denial</strong>, since it says in effect that at least one of its operands is false. In <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a> and <a href="digital_electronics" title="wikilink">digital electronics</a> it is known as the <strong>NAND operation</strong>.</p>

<p>Like its <a href="duality_(mathematics)" title="wikilink">dual</a>, the <a href="logical_NOR" title="wikilink">NOR operator</a> (also known as the <a href="Charles_Sanders_Peirce" title="wikilink">Peirce</a> arrow or <a href="Willard_Van_Orman_Quine" title="wikilink">Quine</a> dagger), NAND can be used by itself, without any other logical operator, to constitute a logical <a href="formal_system" title="wikilink">formal system</a> (making NAND <a href="functional_completeness" title="wikilink">functionally complete</a>). This property makes the <a href="NAND_gate" title="wikilink">NAND gate</a> crucial to modern <a href="digital_electronics" title="wikilink">digital electronics</a>, including its use in <a href="NAND_flash" title="wikilink">NAND flash</a> memory and <a href="computer_processor" title="wikilink">computer processor</a> design.</p>
<h2 id="definition">Definition</h2>

<p>The <strong>NAND operation</strong> is a <a href="logical_operation" title="wikilink">logical operation</a> on two <a href="logical_value" title="wikilink">logical values</a>. It produces a value of true, if — and only if — at least one of the <a href="proposition" title="wikilink">propositions</a> is false.</p>
<h3 id="truth-table">Truth table</h3>

<p>The <a href="truth_table" title="wikilink">truth table</a> of <strong>A NAND B</strong> (also written as <strong>A | B</strong>, <strong>Dpq</strong>, or <strong>A ↑ B</strong>) is as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>INPUT</strong></p></td>
<td style="text-align: left;">
<p><strong>OUTPUT</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>
<h2 id="history">History</h2>

<p>The stroke is named after <a href="Henry_M._Sheffer" title="wikilink">Henry M. Sheffer</a>, who in 1913 published a paper in the <em><a href="Transactions_of_the_American_Mathematical_Society" title="wikilink">Transactions of the American Mathematical Society</a></em> (Sheffer 1913) providing an axiomatization of <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebras</a> using the stroke, and proved its equivalence to a standard formulation thereof by <a href="Edward_Vermilye_Huntington" title="wikilink">Huntington</a> employing the familiar operators of <a href="propositional_logic" title="wikilink">propositional logic</a> (<a href="logical_conjunction" title="wikilink">and</a>, <a href="logical_disjunction" title="wikilink">or</a>, <a href="negation" title="wikilink">not</a>). Because of self-<a href="duality_(order_theory)" title="wikilink">duality</a> of Boolean algebras, Sheffer's axioms are equally valid for either of the NAND or NOR operations in place of the stroke. Sheffer interpreted the stroke as a sign for non-disjunction (NOR) in his paper, mentioning non-conjunction only in a footnote and without a special sign for it. It was Jean <a class="uri" href="Nicod" title="wikilink">Nicod</a> who first used the stroke as a sign for non-conjunction (NAND) in a paper of 1917 and which has since become current practice.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Russell and Whitehead used the Sheffer stroke in the 1927 second edition of <a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a> and suggested it as a replacement for the "or" and "not" operations of the first edition.</p>

<p><a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a> (1880) had discovered the <a href="functional_completeness" title="wikilink">functional completeness</a> of NAND or NOR more than 30 years earlier, using the term <em><a class="uri" href="ampheck" title="wikilink">ampheck</a></em> (for 'cutting both ways'), but he never published his finding.</p>
<h2 id="properties">Properties</h2>

<p>NAND does not possess any of the following five properties, each of which is required to be absent from, and the absence of all of which is sufficient for, at least one member of a set of <a href="functional_completeness" title="wikilink">functionally complete</a> operators: truth-preservation, falsity-preservation, <a href="affine_transformation" title="wikilink">linearity</a>, <a href="monotonic" title="wikilink">monotonicity</a>, <a href="duality_(mathematics)#Duality_in_logic_and_set_theory" title="wikilink">self-duality</a>. (An operator is truth- (falsity-) preserving if its value is truth (falsity) whenever all of its arguments are truth (falsity).) Therefore {NAND} is a functionally complete set.</p>

<p>This can also be realized as follows: All three elements of the functionally complete set {AND, OR, NOT} can be <a href="#Introduction,_elimination,_and_equivalencies" title="wikilink">constructed using only NAND</a>. Thus the set {NAND} must be functionally complete as well.</p>
<h2 id="introduction-elimination-and-equivalencies">Introduction, elimination, and equivalencies</h2>

<p>The Sheffer stroke 

<math display="inline" id="Sheffer_stroke:1">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

 is the negation of the conjunction:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>↑</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\uparrow Q
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:3">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi mathvariant="italic">and</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>italic- and</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(P\and Q)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1110.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:5">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:6">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

 </p></td>
</tr>
</tbody>
</table>

<p>Expressed in terms of NAND 

<math display="inline" id="Sheffer_stroke:7">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

, the usual operators of propositional logic are:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:9">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:10">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:11">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:12">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn10.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:13">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn01.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:14">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn01.svg</figcaption>
</figure></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>   </p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\rightarrow Q
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:16">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:17">
 <semantics>
  <mpadded lspace="3.3pt" width="+3.3pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:18">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>Q</mi>
    <mo>↑</mo>
    <mi>Q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>Q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q\uparrow Q)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:20">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:21">
 <semantics>
  <mpadded lspace="3.3pt" width="+3.3pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:22">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mo>↑</mo>
    <mi>Q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\uparrow Q)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1011.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:24">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn0101.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:25">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1100.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:26">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn0101.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:27">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1110.svg</figcaption>
</figure></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:28">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="italic">and</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>italic- and</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\and Q
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:29">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:30">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mo>↑</mo>
    <mi>Q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\uparrow Q)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:31">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mo>↑</mo>
    <mi>Q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\uparrow Q)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn0001.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:33">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1110.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:34">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1110.svg</figcaption>
</figure></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>   </p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:35">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PQ
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:36">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mo>↑</mo>
    <mi>P</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>P</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\uparrow P)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:38">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>Q</mi>
    <mo>↑</mo>
    <mi>Q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↑</ci>
    <ci>Q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q\uparrow Q)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn0111.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>    

<math display="inline" id="Sheffer_stroke:40">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

    </p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1010.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sheffer_stroke:41">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Venn1100.svg</figcaption>
</figure></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
<h2 id="formal-system-based-on-the-sheffer-stroke">Formal system based on the Sheffer stroke</h2>

<p>The following is an example of a <a href="formal_system" title="wikilink">formal system</a> based entirely on the Sheffer stroke, yet having the functional expressiveness of the <a href="propositional_logic" title="wikilink">propositional logic</a>:</p>
<h3 id="symbols">Symbols</h3>

<p><em>p<sub>n</sub></em> for natural numbers <em>n</em><br/>
( | )</p>

<p>The Sheffer stroke commutes but does not associate (e.g., (T|T)|F = T, but T|(T|F) = F). Hence any formal system including the Sheffer stroke must also include a means of indicating grouping. We shall employ '(' and ')' to this effect.</p>

<p>We also write <em>p</em>, <em>q</em>, <em>r</em>, … instead of <em>p</em><sub>0</sub>, <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>.</p>
<h3 id="syntax">Syntax</h3>

<p><strong>Construction Rule I:</strong> For each natural number <em>n</em>, the symbol <em>p<sub>n</sub></em> is a <a href="well-formed_formula" title="wikilink">well-formed formula</a> (wff), called an atom.</p>

<p><strong>Construction Rule II:</strong> If <em>X</em> and <em>Y</em> are wffs, then (<em>X</em>|<em>Y</em>) is a wff.</p>

<p><strong>Closure Rule:</strong> Any formulae which cannot be constructed by means of the first two Construction Rules are not wffs.</p>

<p>The letters <em>U</em>, <em>V</em>, <em>W</em>, <em>X</em>, and <em>Y</em> are metavariables standing for wffs.</p>

<p>A decision procedure for determining whether a formula is well-formed goes as follows: "deconstruct" the formula by applying the Construction Rules backwards, thereby breaking the formula into smaller subformulae. Then repeat this recursive deconstruction process to each of the subformulae. Eventually the formula should be reduced to its atoms, but if some subformula cannot be so reduced, then the formula is not a wff.</p>
<h3 id="calculus">Calculus</h3>

<p>All wffs of the form</p>
<dl>
<dd>((<em>U</em>|(<em>V</em>|<em>W</em>))|((<em>Y</em>|(<em>Y</em>|<em>Y</em>))|((<em>X</em>|<em>V</em>)|((<em>U</em>|<em>X</em>)|(<em>U</em>|<em>X</em>)))))
</dd>
</dl>

<p>are axioms. Instances of</p>
<dl>
<dd>(<em>U</em>|(<em>V</em>|<em>W</em>)), <em>U</em> 

<math display="inline" id="Sheffer_stroke:42">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

 <em>W</em>
</dd>
</dl>

<p>are inference rules.</p>
<h3 id="simplification">Simplification</h3>

<p>Since the only connective of this logic is |, the symbol | could be discarded altogether, leaving only the parentheses to group the letters. A pair of parentheses must always enclose a pair of <em>wff</em>s. Examples of theorems in this simplified notation are</p>
<dl>
<dd>(<em>p</em>(<em>p</em>(<em>q</em>(<em>q</em>((<em>pq</em>)(<em>pq</em>)))))),
</dd>
</dl>
<dl>
<dd>(<em>p</em>(<em>p</em>((<em>qq</em>)(<em>pp</em>)))).
</dd>
</dl>

<p>The notation can be simplified further, by letting</p>
<dl>
<dd>(<em>U</em>) := (<em>UU</em>)
</dd>
<dd>((<em>U</em>)) 

<math display="inline" id="Sheffer_stroke:43">
 <semantics>
  <mo>≡</mo>
  <annotation-xml encoding="MathML-Content">
   <equivalent></equivalent>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv
  </annotation>
 </semantics>
</math>

 <em>U</em>
</dd>
</dl>

<p>for any <em>U</em>. This simplification causes the need to change some rules:</p>
<ol>
<li>More than two letters are allowed within parentheses.</li>
<li>Letters or wffs within parentheses are allowed to commute.</li>
<li>Repeated letters or wffs within a same set of parentheses can be eliminated.</li>
</ol>

<p>The result is a parenthetical version of the Peirce <a href="existential_graph" title="wikilink">existential graphs</a>.</p>

<p>Another way to simplify the notation is to eliminate parenthesis by using <a href="Polish_Notation" title="wikilink">Polish Notation</a>. For example, the earlier examples with only parenthesis could be rewritten using only strokes as follows</p>
<dl>
<dd>(<em>p</em>(<em>p</em>(<em>q</em>(<em>q</em>((<em>pq</em>)(<em>pq</em>)))))) becomes
</dd>
<dd>|<em>p</em>|<em>p</em>|<em>q</em>|<em>q</em>||<em>pq</em>|<em>pq</em>, and
</dd>
</dl>
<dl>
<dd>(<em>p</em>(<em>p</em>((<em>qq</em>)(<em>pp</em>)))) becomes,
</dd>
<dd>|<em>p</em>|<em>p</em>||<em>qq</em>|<em>pp</em>.
</dd>
</dl>

<p>This follows the same rules as the parenthesis version, with opening parenthesis replaced with a Sheffer stroke and the (redundant) closing parenthesis removed.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_logic_symbols" title="wikilink">List of logic symbols</a></li>
</ul>
<ul>
<li><a href="AND_gate" title="wikilink">AND gate</a></li>
<li><a href="Boolean_domain" title="wikilink">Boolean domain</a></li>
<li><a class="uri" href="CMOS" title="wikilink">CMOS</a></li>
<li><a href="Gate_equivalent" title="wikilink">Gate equivalent (GE)</a></li>
<li><a href="Laws_of_Form" title="wikilink">Laws of Form</a></li>
<li><a href="Logic_gate" title="wikilink">Logic gate</a></li>
<li><a href="Logical_graph" title="wikilink">Logical graph</a></li>
<li>NAND <a href="Flash_Memory" title="wikilink">Flash Memory</a></li>
<li><a href="NAND_logic" title="wikilink">NAND logic</a></li>
<li><a href="NAND_gate" title="wikilink">NAND gate</a></li>
<li><a href="NOR_gate" title="wikilink">NOR gate</a></li>
<li><a href="NOT_gate" title="wikilink">NOT gate</a></li>
<li><a href="OR_gate" title="wikilink">OR gate</a></li>
<li><a href="Peirce's_law" title="wikilink">Peirce's law</a></li>
<li><a href="Logical_NOR" title="wikilink">Peirce arrow = NOR</a></li>
<li><a href="Propositional_logic" title="wikilink">Propositional logic</a></li>
<li><a href="Sole_sufficient_operator" title="wikilink">Sole sufficient operator</a></li>
<li><a href="XOR_gate" title="wikilink">XOR gate</a></li>
<li><a href="Peirce_arrow" title="wikilink">Peirce arrow</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Bocheński,_Józef_Maria" title="wikilink">Bocheński, Józef Maria</a> (1960), <em>Précis of Mathematical Logic</em>, translated from the French and German editions by Otto Bird, <a class="uri" href="Dordrecht" title="wikilink">Dordrecht</a>, <a href="South_Holland" title="wikilink">South Holland</a>: <a href="D._Reidel" title="wikilink">D. Reidel</a>.</li>
<li><a href="Alonzo_Church" title="wikilink">Church, Alonzo</a>, (1956) <em>Introduction to mathematical logic</em>, Vol. 1, <a href="Princeton,_New_Jersey" title="wikilink">Princeton</a>: <a href="Princeton_University_Press" title="wikilink">Princeton University Press</a>.</li>
<li><a href="Jean_Nicod" title="wikilink">Nicod, Jean G. P.</a>, (1917) "A Reduction in the Number of Primitive Propositions of Logic", <em>Proceedings of the Cambridge Philosophical Society</em>, Vol. 19, pp. 32–41.</li>
<li><a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a>, 1880, "A Boolian[sic] Algebra with One Constant", in <a href="Charles_Hartshorne" title="wikilink">Hartshorne, C.</a> and <a href="Paul_Weiss" title="wikilink">Weiss, P.</a>, eds., (1931–35) <em><a href="Charles_Sanders_Peirce_bibliography#CP" title="wikilink">Collected Papers of Charles Sanders Peirce</a>, Vol. 4</em>: 12–20, <a class="uri" href="Cambridge" title="wikilink">Cambridge</a>: <a href="Harvard_University_Press" title="wikilink">Harvard University Press</a>.</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nand.html">http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nand.html</a></li>
<li><a href="http://www.sccs.swarthmore.edu/users/06/adem/engin/e77vlsi/lab3/">implementations of 2 and 4-input NAND gates</a></li>
<li>[<a class="uri" href="http://projecteuclid.org/DPubS?verb=Display&amp;version">http://projecteuclid.org/DPubS?verb=Display&amp;version;</a>;=1.0&amp;service;=UI&amp;handle;=euclid.pja/1195520940&amp;page;=record Proofs of some axioms by Stroke function by Yasuo Setô] @ <a href="http://projecteuclid.org">Project Euclid</a></li>
</ul>

<p><a href="eu:EZ-ETA_ate_logikoa" title="wikilink">eu:EZ-ETA ate logikoa</a> <a href="he:NAND_לוגי" title="wikilink">he:NAND לוגי</a> <a href="pl:Dysjunkcja_(logika)" title="wikilink">pl:Dysjunkcja (logika)</a> <a class="uri" href="pt:NOU" title="wikilink">pt:NOU</a> <a href="ru:Штрих_Шеффера" title="wikilink">ru:Штрих Шеффера</a> <a href="simple:NAND_gate" title="wikilink">simple:NAND gate</a> <a href="sk:Hradlo_NAND" title="wikilink">sk:Hradlo NAND</a> <a href="sr:Логичко_НИ" title="wikilink">sr:Логичко НИ</a> <a href="uk:Штрих_Шефера" title="wikilink">uk:Штрих Шефера</a>"</p>

<p><a href="Category:Logic_gates" title="wikilink">NAND gate</a> <a href="Category:Logical_connectives" title="wikilink">Category:Logical connectives</a> <a href="Category:Logic_symbols" title="wikilink">Category:Logic symbols</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
