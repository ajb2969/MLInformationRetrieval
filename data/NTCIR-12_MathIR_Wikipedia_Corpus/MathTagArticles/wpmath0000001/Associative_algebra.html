<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="48">Associative algebra</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Associative algebra</h1>
<hr/>

<p>An <strong>associative algebra</strong> <em>A</em> is a <a href="ring_(mathematics)" title="wikilink">ring</a> (not necessarily unital) that has a compatible <a href="Mathematical_structure" title="wikilink">structure</a> of a <a href="vector_space" title="wikilink">vector space</a> over a certain <a href="Field_(mathematics)" title="wikilink">field</a> <em>K</em> or, more generally, of a <a href="Module_(mathematics)" title="wikilink">module</a> over a <a href="commutative_ring" title="wikilink">commutative ring</a> <em>R</em>. Thus <em>A</em> is endowed with binary operations of addition and multiplication satisfying a number of axioms, including <a class="uri" href="associativity" title="wikilink">associativity</a> of multiplication and <a class="uri" href="distributivity" title="wikilink">distributivity</a>, as well as compatible multiplication by the elements of the field <em>K</em> or the ring <em>R</em>.</p>

<p>For example, a ring of <a href="Square_matrix" title="wikilink">square matrices</a> over a field <em>K</em> is an associative <em>K</em> algebra. More generally, given a ring <em>S</em> with <a href="center_(algebra)" title="wikilink">center</a> <em>C</em>, <em>S</em> is an associative <em>C</em> algebra.</p>

<p>In some areas of mathematics, associative algebras are typically assumed to have a multiplicative unit, denoted 1. To make this extra assumption clear, these associative algebras are called <a href="unital_algebra" title="wikilink">unital algebras</a>. Additionally, some authors demand that all rings be unital; in this article, the word "ring" is intended to refer to potentially non-unital rings as well.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Let <em>R</em> be a fixed <a href="commutative_ring" title="wikilink">commutative ring</a>. An <strong>associative <em>R</em>-algebra</strong> is an additive <a href="abelian_group" title="wikilink">abelian group</a> <em>A</em> which has the structure of both a <a href="rng_(algebra)" title="wikilink">rng</a> (a <a href="ring_(mathematics)" title="wikilink">ring</a> not necessarily containing a <a href="multiplicative_identity" title="wikilink">multiplicative identity</a>) and an <a href="module_(mathematics)" title="wikilink"><em>R</em>-module</a> in such a way that ring multiplication is <a href="bilinear_map" title="wikilink"><em>R</em>-bilinear</a>:</p>

<p>

<math display="block" id="Associative_algebra:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>⋅</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>⋅</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\cdot(xy)=(r\cdot x)y=x(r\cdot y)
  </annotation>
 </semantics>
</math>

 for all <em>r</em> ∈ <em>R</em> and <em>x</em>, <em>y</em> ∈ <em>A</em>. We say <em>A</em> is <strong>unital</strong> if it contains an element 1 such that</p>

<p>

<math display="block" id="Associative_algebra:1">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1x=x=x1
  </annotation>
 </semantics>
</math>

 for all <em>x</em> ∈ <em>A</em>. Note that such an element 1 must be unique if it exists at all.</p>

<p>If <em>A</em> itself is commutative (as a ring) then it is called a <strong>commutative <em>R</em>-algebra</strong>.</p>
<h3 id="from-r-modules">From <em>R</em>-modules</h3>

<p>Starting with an <em>R</em>-module <em>A</em>, we get an associative <em>R</em>-algebra by equipping <em>A</em> with an <em>R</em>-bilinear mapping <em>A</em> × <em>A</em> → <em>A</em> such that</p>

<p>

<math display="block" id="Associative_algebra:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mpadded width="+1.7pt">
     <mi>z</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(yz)=(xy)z\,
  </annotation>
 </semantics>
</math>

 for all <em>x</em>, <em>y</em>, and <em>z</em> in <em>A</em>. This <em>R</em>-bilinear mapping then gives <em>A</em> the structure of a ring and an associative <em>R</em>-algebra. Every associative <em>R</em>-algebra arises this way.</p>

<p>Moreover, the algebra <em>A</em> built this way will be unital if and only if there exists an element 1 of <em>A</em> such that every element <em>x</em> of <em>A</em> satisfies 1<em>x</em> = <em>x</em>1 = <em>x</em>. This definition is equivalent to the statement that a unital associative <em>R</em>-algebra is a <a href="monoid_(category_theory)" title="wikilink">monoid</a> in <strong><em>R</em>-Mod</strong> (the <a href="monoidal_category" title="wikilink">monoidal category</a> of <em>R</em>-modules).</p>
<h3 id="from-rings">From rings</h3>

<p>Starting with a ring <em>A</em>, we get a unital associative <em>R</em>-algebra by providing a <a href="ring_homomorphism" title="wikilink">ring homomorphism</a> 

<math display="inline" id="Associative_algebra:3">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <mi>R</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>R</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\colon R\to A
  </annotation>
 </semantics>
</math>


 whose image lies in the <a href="center_(algebra)" title="wikilink">center</a> of <em>A</em>. The algebra <em>A</em> can then be thought of as an <em>R</em>-module by defining</p>

<p>

<math display="block" id="Associative_algebra:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>⋅</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>η</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>η</ci>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\cdot x=\eta(r)x
  </annotation>
 </semantics>
</math>

 for all <em>r</em> ∈ <em>R</em> and <em>x</em> ∈ <em>A</em>.</p>

<p>If <em>A</em> is commutative then the center of <em>A</em> is equal to <em>A</em>, so that a commutative unital <em>R</em>-algebra can be defined simply as a homomorphism 

<math display="inline" id="Associative_algebra:5">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <mi>R</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>R</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\colon R\to A
  </annotation>
 </semantics>
</math>

 of commutative rings.</p>
<h2 id="algebra-homomorphisms">Algebra homomorphisms</h2>

<p>A <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> between two associative <em>R</em>-algebras is an <em>R</em>-linear <a href="ring_homomorphism" title="wikilink">ring homomorphism</a>. Explicitly, 

<math display="inline" id="Associative_algebra:6">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi:A_{1}\to A_{2}
  </annotation>
 </semantics>
</math>

 is an <strong>associative algebra homomorphism</strong> if</p>

<p>

<math display="block" id="Associative_algebra:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>⋅</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mo>⋅</mo>
     <mi>ϕ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>r</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>r</ci>
      <ci>ϕ</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(r\cdot x)=r\cdot\phi(x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Associative_algebra:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x+y)=\phi(x)+\phi(y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Associative_algebra:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>x</ci>
     <ci>ϕ</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(xy)=\phi(x)\phi(y)\,
  </annotation>
 </semantics>
</math>

 For a homomorphism of <em>unital</em> associative <em>R</em>-algebras, we also demand that</p>

<p>

<math display="block" id="Associative_algebra:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(1)=1\,
  </annotation>
 </semantics>
</math>

</p>

<p>The class of all unital associative <em>R</em>-algebras together with algebra homomorphisms between them form a <a href="category_(mathematics)" title="wikilink">category</a>, sometimes denoted <strong><em>R</em>-Alg</strong>.</p>

<p>The <a class="uri" href="subcategory" title="wikilink">subcategory</a> of commutative <em>R</em>-algebras can be characterized as the <a href="coslice_category" title="wikilink">coslice category</a> <em>R</em>/<strong>CRing</strong> where <strong>CRing</strong> is the <a href="category_of_commutative_rings" title="wikilink">category of commutative rings</a>.</p>
<h2 id="examples">Examples</h2>

<p>The most basic example is a ring itself; it is an algebra over its center or any subring lying in the center. In particular, any commutative ring is an algebra over any of its subrings. Other examples abound both from algebra and other fields of mathematics.</p>

<p><strong>Algebra</strong></p>
<ul>
<li>Any (unital) ring <em>A</em> can be considered as a unital <strong>Z</strong>-algebra. The unique ring homomorphism from <strong>Z</strong> to <em>A</em> is determined by the fact that it must send 1 to the identity in A. Therefore, rings and unital <strong>Z</strong>-algebras are equivalent concepts, in the same way that <a href="abelian_group" title="wikilink">abelian groups</a> and <strong>Z</strong>-modules are equivalent.</li>
<li>Any ring of <a href="characteristic_(algebra)" title="wikilink">characteristic</a> <em>n</em> is a (<strong>Z</strong>/<em>n</em><strong>Z</strong>)-algebra in the same way.</li>
<li>Given an <em>R</em>-module <em>M</em>, the <a href="endomorphism_ring" title="wikilink">endomorphism ring</a> of <em>M</em>, denoted End<sub><em>R</em></sub>(<em>M</em>) is an <em>R</em>-algebra by defining (<em>r</em>·φ)(<em>x</em>) = <em>r</em>·φ(<em>x</em>).</li>
<li>Any ring of <a href="matrix_(mathematics)" title="wikilink">matrices</a> with coefficients in a commutative ring <em>R</em> forms an <em>R</em>-algebra under matrix addition and multiplication. This coincides with the previous example when <em>M</em> is a finitely-generated, <a href="free_module" title="wikilink">free</a> <em>R</em>-module.</li>
<li>The square <em>n</em>-by-<em>n</em> <a href="matrix_(mathematics)" title="wikilink">matrices</a> with entries from the field <em>K</em> form a unital associative algebra over <em>K</em>. In particular, the <a href="2_×_2_real_matrices" title="wikilink">2 × 2 real matrices</a> form an associative algebra useful in plane mapping.</li>
<li>The <a href="complex_number" title="wikilink">complex numbers</a> form a 2-dimensional unital associative algebra over the <a href="real_number" title="wikilink">real numbers</a>.</li>
<li>The <a class="uri" href="quaternions" title="wikilink">quaternions</a> form a 4-dimensional unital associative algebra over the reals (but not an algebra over the complex numbers, since if complex numbers are treated as a subset of the quaternions, complex numbers and quaternions do not commute).</li>
<li>The <a href="polynomial" title="wikilink">polynomials</a> with real coefficients form a unital associative algebra over the reals.</li>
<li>Every <a href="polynomial_ring" title="wikilink">polynomial ring</a> <em>R</em>[<em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>n</em></sub>] is a commutative <em>R</em>-algebra. In fact, this is the free commutative <em>R</em>-algebra on the set {<em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>n</em></sub>}.</li>
<li>The <a href="free_algebra" title="wikilink">free <em>R</em>-algebra</a> on a set <em>E</em> is an algebra of polynomials with coefficients in <em>R</em> and noncommuting indeterminates taken from the set <em>E</em>.</li>
<li>The <a href="tensor_algebra" title="wikilink">tensor algebra</a> of an <em>R</em>-module is naturally an <em>R</em>-algebra. The same is true for quotients such as the <a href="exterior_algebra" title="wikilink">exterior</a> and <a href="symmetric_algebra" title="wikilink">symmetric algebras</a>. Categorically speaking, the <a class="uri" href="functor" title="wikilink">functor</a> which maps an <em>R</em>-module to its tensor algebra is <a href="left_adjoint" title="wikilink">left adjoint</a> to the functor which sends an <em>R</em>-algebra to its underlying <em>R</em>-module (forgetting the ring structure).</li>
<li>Given a commutative ring <em>R</em> and any ring <em>A</em> the <a href="tensor_product_of_rings" title="wikilink">tensor product</a> <em>R</em>⊗<sub><strong>Z</strong></sub><em>A</em> can be given the structure of an <em>R</em>-algebra by defining <em>r</em>·(<em>s</em>⊗<em>a</em>) = (<em>rs</em>⊗<em>a</em>). The functor which sends <em>A</em> to <em>R</em>⊗<sub><strong>Z</strong></sub><em>A</em> is <a href="left_adjoint" title="wikilink">left adjoint</a> to the functor which sends an <em>R</em>-algebra to its underlying ring (forgetting the module structure).</li>
</ul>

<p><strong>Analysis</strong></p>
<ul>
<li>Given any <a href="Banach_space" title="wikilink">Banach space</a> <em>X</em>, the <a href="continuous_function_(topology)" title="wikilink">continuous</a> <a href="linear_operator" title="wikilink">linear operators</a> <em>A</em> : <em>X</em> → <em>X</em> form a unital associative algebra (using composition of operators as multiplication); this is a <a href="Banach_algebra" title="wikilink">Banach algebra</a>.</li>
<li>Given any <a href="topology" title="wikilink">topological space</a> <em>X</em>, the continuous real- or complex-valued functions on <em>X</em> form a real or complex unital associative algebra; here the functions are added and multiplied pointwise.</li>
<li>An example of a non-unital associative algebra is given by the set of all functions <em>f</em>: <strong>R</strong> → <strong>R</strong> whose <a href="limit_of_a_function" title="wikilink">limit</a> as <em>x</em> nears infinity is zero.</li>
<li>The set of <a href="semimartingale" title="wikilink">semimartingales</a> defined on the <a href="filtration_(mathematics)#Measure_theory" title="wikilink">filtered probability space</a> (Ω,<em>F</em>,(<em>F</em><sub><em>t</em></sub>)<sub><em>t</em> ≥ 0</sub>,P) forms a ring under <a href="stochastic_calculus" title="wikilink">stochastic integration</a>.</li>
</ul>

<p><strong>Geometry and combinatorics</strong></p>
<ul>
<li>The <a href="Clifford_algebra" title="wikilink">Clifford algebras</a>, which are useful in <a class="uri" href="geometry" title="wikilink">geometry</a> and <a class="uri" href="physics" title="wikilink">physics</a>.</li>
<li><a href="Incidence_algebra" title="wikilink">Incidence algebras</a> of locally finite <a href="partially_ordered_set" title="wikilink">partially ordered sets</a> are unital associative algebras considered in <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>.</li>
</ul>
<h2 id="constructions">Constructions</h2>
<dl>
<dt>Subalgebras: A subalgebra of an <em>R</em>-algebra <em>A</em> is a subset of <em>A</em> which is both a <a class="uri" href="subring" title="wikilink">subring</a> and a <a class="uri" href="submodule" title="wikilink">submodule</a> of <em>A</em>. That is, it must be closed under addition, ring multiplication, scalar multiplication, and it must contain the identity element of <em>A</em>.<br/>
Quotient algebras: Let <em>A</em> be an <em>R</em>-algebra. Any ring-theoretic <a href="ideal_(ring_theory)" title="wikilink">ideal</a> <em>I</em> in <em>A</em> is automatically an <em>R</em>-module since <em>r</em>·<em>x</em> = (<em>r</em>1<sub><em>A</em></sub>)<em>x</em>. This gives the <a href="quotient_ring" title="wikilink">quotient ring</a> <em>A</em>/<em>I</em> the structure of an <em>R</em>-module and, in fact, an <em>R</em>-algebra. It follows that any ring homomorphic image of <em>A</em> is also an <em>R</em>-algebra.<br/>
Direct products: The direct product of a family of <em>R</em>-algebras is the ring-theoretic direct product. This becomes an <em>R</em>-algebra with the obvious scalar multiplication.<br/>
Free products: One can form a <a href="free_product" title="wikilink">free product</a> of <em>R</em>-algebras in a manner similar to the free product of groups. The free product is the <a class="uri" href="coproduct" title="wikilink">coproduct</a> in the category of <em>R</em>-algebras.<br/>
Tensor products: The tensor product of two <em>R</em>-algebras is also an <em>R</em>-algebra in a natural way. See <a href="tensor_product_of_algebras" title="wikilink">tensor product of algebras</a> for more details.</dt>
</dl>
<h2 id="associativity-and-the-multiplication-mapping">Associativity and the multiplication mapping</h2>

<p>Associativity was defined above quantifying over all <em>elements</em> of <em>A</em>. It is possible to define associativity in a way that does not explicitly refer to elements. An algebra is defined as a vector space <em>A</em> with a bilinear map</p>

<p>

<math display="block" id="Associative_algebra:11">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>×</mo>
     <mi>A</mi>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>M</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M:A\times A\rightarrow A
  </annotation>
 </semantics>
</math>

 (the multiplication map). An associative algebra is an algebra where the map <em>M</em> has the property</p>

<p>

<math display="block" id="Associative_algebra:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mtext>Id</mtext>
      <mo>×</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mo>×</mo>
      <mtext>Id</mtext>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>M</ci>
     <apply>
      <times></times>
      <mtext>Id</mtext>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <ci>M</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <mtext>Id</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\circ(\mbox{Id}\times M)=M\circ(M\times\mbox{Id})
  </annotation>
 </semantics>
</math>

 Here, the symbol 

<math display="inline" id="Associative_algebra:13">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>


 refers to <a href="function_composition" title="wikilink">function composition</a>, and Id : <em>A</em> → <em>A</em> is the <a href="identity_function" title="wikilink">identity map</a> on <em>A</em>.</p>

<p>To see the equivalence of the definitions, we need only understand that each side of the above equation is a function that takes three arguments. For example, the left-hand side acts as</p>

<p>

<math display="block" id="Associative_algebra:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mo>∘</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mtext>Id</mtext>
        <mo>×</mo>
        <mi>M</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>M</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>M</ci>
      <apply>
       <times></times>
       <mtext>Id</mtext>
       <ci>M</ci>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <interval closure="open">
        <ci>y</ci>
        <ci>z</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M\circ(\mbox{Id}\times M))(x,y,z)=M(x,M(y,z))
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, a unital associative algebra can be defined as a vector space <em>A</em> endowed with a map <em>M</em> as above and, additionally, a linear map</p>

<p>

<math display="block" id="Associative_algebra:15">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <mi>K</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>K</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta:K\rightarrow A
  </annotation>
 </semantics>
</math>

 (the unit map) which has the properties</p>

<p>

<math display="block" id="Associative_algebra:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mtext>Id</mtext>
       <mo>×</mo>
       <mi>η</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>s</mi>
   </mrow>
   <mo rspace="7.5pt">;</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>η</mi>
       <mo>×</mo>
       <mtext>Id</mtext>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>M</ci>
      <apply>
       <times></times>
       <mtext>Id</mtext>
       <ci>η</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>η</ci>
       <mtext>Id</mtext>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\circ(\mbox{Id}\times\eta)=s;\ M\circ(\eta\times\mbox{Id})=t
  </annotation>
 </semantics>
</math>

 Here, the unit map η takes an element <em>k</em> in <em>K</em> to the element <em>k1</em> in <em>A</em>, where <em>1</em> is the unit element of <em>A</em>. The map <em>t</em> is just plain-old scalar multiplication

<math display="block" id="Associative_algebra:17">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>K</mi>
      <mo>×</mo>
      <mi>A</mi>
     </mrow>
     <mo>→</mo>
     <mi>A</mi>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo>)</mo>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mi>k</mi>
      <mi>a</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>A</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <interval closure="open">
       <ci>k</ci>
       <ci>a</ci>
      </interval>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t:K\times A\rightarrow A,\ \left(k,a\right)\mapsto ka
  </annotation>
 </semantics>
</math>

; the map <em>s</em> is similar

<math display="block" id="Associative_algebra:18">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mo>×</mo>
      <mi>K</mi>
     </mrow>
     <mo>→</mo>
     <mi>A</mi>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo>)</mo>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mi>k</mi>
      <mi>a</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>K</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <interval closure="open">
       <ci>a</ci>
       <ci>k</ci>
      </interval>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s:A\times K\rightarrow A,\ \left(a,k\right)\mapsto ka
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="coalgebras">Coalgebras</h2>

<p>An associative unital algebra over <em>K</em> is given by a <em>K</em>-vector space <em>A</em> endowed with a bilinear map <em>A</em>×<em>A</em>→<em>A</em> having 2 inputs (multiplicator and multiplicand) and one output (product), as well as a morphism <em>K</em>→<em>A</em> identifying the scalar multiples of the multiplicative identity. If the bilinear map <em>A</em>×<em>A</em>→<em>A</em> is reinterpreted as a linear map (i. e., <a class="uri" href="morphism" title="wikilink">morphism</a> in the category of <em>K</em>-vector spaces) <em>A</em>⊗<em>A</em>→<em>A</em> (by the <a href="Tensor_product#Characterization_by_a_universal_property" title="wikilink">universal property of the tensor product</a>), then we can view an associative unital algebra over <em>K</em> as a <em>K</em>-vector space <em>A</em> endowed with two morphisms (one of the form <em>A</em>⊗<em>A</em>→<em>A</em> and one of the form <em>K</em>→<em>A</em>) satisfying certain conditions which boil down to the algebra axioms. These two morphisms can be dualized using <a href="categorial_duality" title="wikilink">categorial duality</a> by reversing all arrows in the <a href="commutative_diagram" title="wikilink">commutative diagrams</a> which describe the algebra <a href="axiom" title="wikilink">axioms</a>; this defines the structure of a <a class="uri" href="coalgebra" title="wikilink">coalgebra</a>.</p>

<p>There is also an abstract notion of <a class="uri" href="F-coalgebra" title="wikilink">F-coalgebra</a>. This is vaguely related to the notion of coalgebra discussed above.</p>
<h2 id="representations">Representations</h2>

<p>A <a href="representation_theory" title="wikilink">representation</a> of a unital algebra <em>A</em> is a unital algebra homomorphism ρ: <em>A</em> → End(<em>V</em>) from <em>A</em> to the endomorphism algebra of some vector space (or module) <em>V</em>. The property of ρ being a unital algebra homomorphism means that ρ preserves the multiplicative operation (that is, ρ(<em>xy</em>)=ρ(<em>x</em>)ρ(<em>y</em>) for all <em>x</em> and <em>y</em> in <em>A</em>), and that ρ sends the unity of <em>A</em> to the unity of End(<em>V</em>) (that is, to the identity endomorphism of <em>V</em>).</p>

<p>If <em>A</em> and <em>B</em> are two algebras, and ρ: <em>A</em> → End(<em>V</em>) and τ: <em>B</em> → End(<em>W</em>) are two representations, then it is easy to define a (canonical) representation <em>A ⊗ B</em> → End(<em>V ⊗ W</em>) of the tensor product algebra <em>A ⊗ B</em> on the vector space <em>V ⊗ W</em>. Note, however, that there is no natural way of defining a <a href="tensor_product" title="wikilink">tensor product</a> of two representations of a single associative algebra in such a way that the result is still a representation of that same algebra (not of its tensor product with itself), without somehow imposing additional conditions. Here, by <em>tensor product of representations</em>, the usual meaning is intended: the result should be a linear representation of the same algebra on the product vector space. Imposing such additional structure typically leads to the idea of a <a href="Hopf_algebra" title="wikilink">Hopf algebra</a> or a <a href="Lie_algebra" title="wikilink">Lie algebra</a>, as demonstrated below.</p>
<h3 id="motivation-for-a-hopf-algebra">Motivation for a Hopf algebra</h3>

<p>Consider, for example, two representations 

<math display="inline" id="Associative_algebra:19">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mi>End</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>σ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>End</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma:A\rightarrow\mathrm{End}(V)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Associative_algebra:20">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mi>End</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>W</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>τ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>End</ci>
      <ci>W</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau:A\rightarrow\mathrm{End}(W)
  </annotation>
 </semantics>
</math>

. One might try to form a tensor product representation 

<math display="inline" id="Associative_algebra:21">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>↦</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>x</ci>
       </apply>
       <ci>τ</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:x\mapsto\sigma(x)\otimes\tau(x)
  </annotation>
 </semantics>
</math>

 according to how it acts on the product vector space, so that</p>

<p>

<math display="block" id="Associative_algebra:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>v</mi>
       <mo>⊗</mo>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>τ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>v</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <ci>σ</ci>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <ci>τ</ci>
      <ci>x</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(x)(v\otimes w)=(\sigma(x)(v))\otimes(\tau(x)(w)).
  </annotation>
 </semantics>
</math>

</p>

<p>However, such a map would not be linear, since one would have</p>

<p>

<math display="block" id="Associative_algebra:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mi>τ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>k</mi>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mi>k</mi>
    </mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>σ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊗</mo>
       <mi>τ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>σ</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>τ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>σ</ci>
        <ci>x</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>τ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>σ</ci>
         <ci>x</ci>
        </apply>
        <ci>τ</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>ρ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(kx)=\sigma(kx)\otimes\tau(kx)=k\sigma(x)\otimes k\tau(x)=k^{2}(\sigma(x)%
\otimes\tau(x))=k^{2}\rho(x)
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>k</em> ∈ <em>K</em>. One can rescue this attempt and restore linearity by imposing additional structure, by defining an algebra homomorphism Δ: <em>A</em> → <em>A</em> ⊗ <em>A</em>, and defining the tensor product representation as</p>

<p>

<math display="block" id="Associative_algebra:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>σ</mi>
       <mo>⊗</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∘</mo>
     <mi mathvariant="normal">Δ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>σ</ci>
      <ci>τ</ci>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=(\sigma\otimes\tau)\circ\Delta.
  </annotation>
 </semantics>
</math>

</p>

<p>Such a homomorphism Δ is called a <a class="uri" href="comultiplication" title="wikilink">comultiplication</a> if it satisfies certain axioms. The resulting structure is called a <a class="uri" href="bialgebra" title="wikilink">bialgebra</a>. To be consistent with the definitions of the associative algebra, the coalgebra must be co-associative, and, if the algebra is unital, then the co-algebra must be co-unital as well. A <a href="Hopf_algebra" title="wikilink">Hopf algebra</a> is a bialgebra with an additional piece of structure (the so-called antipode), which allows not only to define the tensor product of two representations, but also the Hom module of two representations (again, similarly to how it is done in the representation theory of groups).</p>
<h3 id="motivation-for-a-lie-algebra">Motivation for a Lie algebra</h3>

<p>One can try to be more clever in defining a tensor product. Consider, for example,</p>

<p>

<math display="block" id="Associative_algebra:25">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mtext>Id</mtext>
      <mi>W</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mtext>Id</mtext>
       <mi>V</mi>
      </msub>
      <mo>⊗</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>Id</mtext>
        <ci>W</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>Id</mtext>
         <ci>V</ci>
        </apply>
        <ci>τ</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto\rho(x)=\sigma(x)\otimes\mbox{Id}_{W}+\mbox{Id}_{V}\otimes\tau(x)
  </annotation>
 </semantics>
</math>

</p>

<p>so that the action on the tensor product space is given by</p>

<p>

<math display="block" id="Associative_algebra:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>v</mi>
      <mo>⊗</mo>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊗</mo>
     <mi>w</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>v</mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>τ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>v</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>x</ci>
       <ci>v</ci>
      </apply>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>v</ci>
      <apply>
       <times></times>
       <ci>τ</ci>
       <ci>x</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(x)(v\otimes w)=(\sigma(x)v)\otimes w+v\otimes(\tau(x)w)
  </annotation>
 </semantics>
</math>

.</p>

<p>This map is clearly linear in <em>x</em>, and so it does not have the problem of the earlier definition. However, it fails to preserve multiplication:</p>

<p>

<math display="block" id="Associative_algebra:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mtext>Id</mtext>
      <mi>W</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mtext>Id</mtext>
       <mi>V</mi>
      </msub>
      <mo>⊗</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>x</ci>
       <ci>σ</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>Id</mtext>
       <ci>W</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>Id</mtext>
        <ci>V</ci>
       </apply>
       <ci>τ</ci>
      </apply>
      <ci>x</ci>
      <ci>τ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(xy)=\sigma(x)\sigma(y)\otimes\mbox{Id}_{W}+\mbox{Id}_{V}\otimes\tau(x)%
\tau(y)
  </annotation>
 </semantics>
</math>

.</p>

<p>But, in general, this does not equal</p>

<p>

<math display="block" id="Associative_algebra:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mtext>Id</mtext>
      <mi>W</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mtext>Id</mtext>
       <mi>V</mi>
      </msub>
      <mo>⊗</mo>
      <mi>τ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>x</ci>
     <ci>ρ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>x</ci>
       <ci>σ</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>Id</mtext>
       <ci>W</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>x</ci>
       </apply>
       <ci>τ</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>y</ci>
       </apply>
       <ci>τ</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>Id</mtext>
        <ci>V</ci>
       </apply>
       <ci>τ</ci>
      </apply>
      <ci>x</ci>
      <ci>τ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(x)\rho(y)=\sigma(x)\sigma(y)\otimes\mbox{Id}_{W}+\sigma(x)\otimes\tau(y)+%
\sigma(y)\otimes\tau(x)+\mbox{Id}_{V}\otimes\tau(x)\tau(y)
  </annotation>
 </semantics>
</math>

.</p>

<p>This shows that this definition of a tensor product is too naive. It can be used, however, to define the tensor product of two representations of a <a href="Lie_algebra" title="wikilink">Lie algebra</a> (rather than of an associative algebra).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Abstract_algebra" title="wikilink">Abstract algebra</a></li>
<li><a href="Algebraic_structure" title="wikilink">Algebraic structure</a></li>
<li><a href="Algebra_over_a_field" title="wikilink">Algebra over a field</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>James Byrnie Shaw (1907) <a href="http://ebooks.library.cornell.edu/cgi/t/text/text-idx?c=math;cc=math;view=toc;subview=short;idno=05160001">A Synopsis of Linear Associative Algebra</a>, link from <a href="Cornell_University" title="wikilink">Cornell University</a> Historical Math Monographs.</li>
<li>Ross Street (1998) <em><a href="http://www-texdev.ics.mq.edu.au/Quantum/Quantum.ps">Quantum Groups: an entrée to modern algebra</a></em>, an overview of index-free notation.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Algebras" title="wikilink">Category:Algebras</a></p>
</body>
</html>
