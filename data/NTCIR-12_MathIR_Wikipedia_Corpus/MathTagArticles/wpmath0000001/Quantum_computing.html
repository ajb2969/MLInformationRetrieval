<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="866">Quantum computing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum computing</h1>
<hr/>

<p> <strong>Quantum computing</strong> studies theoretical <a class="uri" href="computation" title="wikilink">computation</a> systems (<strong>quantum computers</strong>) that make direct use of <a href="quantum_mechanics" title="wikilink">quantum-mechanical</a> <a class="uri" href="phenomena" title="wikilink">phenomena</a>, such as <a href="quantum_superposition" title="wikilink">superposition</a> and <a href="quantum_entanglement" title="wikilink">entanglement</a>, to perform <a href="Instruction_(computer_science)" title="wikilink">operations</a> on <a class="uri" href="data" title="wikilink">data</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Quantum computers are different from digital computers based on <a href="transistor" title="wikilink">transistors</a>. Whereas digital computers require data to be encoded into binary digits (<a href="bit" title="wikilink">bits</a>), each of which is always in one of two definite states (0 or 1), quantum computation uses quantum bits (<a class="uri" href="qubits" title="wikilink">qubits</a>), which can be in <a href="quantum_superposition" title="wikilink">superpositions</a> of states. A <a href="quantum_Turing_machine" title="wikilink">quantum Turing machine</a> is a theoretical model of such a computer, and is also known as the universal quantum computer. Quantum computers share theoretical similarities with <a href="Non-deterministic_Turing_machine" title="wikilink">non-deterministic</a> and <a href="probabilistic_automaton" title="wikilink">probabilistic computers</a>. The field of quantum computing was initiated by the work of <a href="Yuri_Manin" title="wikilink">Yuri Manin</a> in 1980,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a href="Richard_Feynman" title="wikilink">Richard Feynman</a> in 1982,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="David_Deutsch" title="wikilink">David Deutsch</a> in 1985.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A quantum computer with spins as quantum bits was also formulated for use as a quantum <a class="uri" href="space–time" title="wikilink">space–time</a> in 1968.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> , the development of actual quantum computers is still in its infancy, but experiments have been carried out in which quantum computational operations were executed on a very small number of quantum bits.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Both practical and theoretical research continues, and many national governments and military agencies are funding quantum computing research in an effort to develop quantum <a href="computer" title="wikilink">computers</a> for civilian, business, trade, and national security purposes, such as <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Large-scale quantum computers will be able to solve certain problems much more quickly than any classical computers that use even the best currently known <a href="algorithm" title="wikilink">algorithms</a>, like <a href="integer_factorization" title="wikilink">integer factorization</a> using <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> or the <a href="Quantum_algorithm#Quantum_simulation" title="wikilink">simulation of quantum many-body systems</a>. There exist <a href="quantum_algorithm" title="wikilink">quantum algorithms</a>, such as <a href="Simon's_algorithm" title="wikilink">Simon's algorithm</a>, that run faster than any possible probabilistic classical algorithm.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Given sufficient computational resources, however, a classical computer could be made to simulate any quantum algorithm, as quantum computation does not violate the <a href="Church–Turing_thesis" title="wikilink">Church–Turing thesis</a>. <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="basis">Basis</h2>

<p>A classical computer has a <a href="Computer_memory" title="wikilink">memory</a> made up of <a href="bit" title="wikilink">bits</a>, where each bit represents either a one or a zero. A quantum computer maintains a sequence of <a href="qubit" title="wikilink">qubits</a>. A single qubit can represent a one, a zero, or any <a href="quantum_superposition" title="wikilink">quantum superposition</a> of those two <a href="Pure_qubit_state" title="wikilink">qubit states</a>; a pair of qubits can be in any quantum superposition of 4 states, and three qubits in any superposition of 8 states. In general, a quantum computer with 

<math display="inline" id="Quantum_computing:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 qubits can be in an arbitrary superposition of up to 

<math display="inline" id="Quantum_computing:1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 different states simultaneously (this compares to a normal computer that can only be in <em>one</em> of these 

<math display="inline" id="Quantum_computing:2">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 states at any one time). A quantum computer operates by setting the qubits in a controlled initial state that represents the problem at hand and by manipulating those qubits with a fixed sequence of <a href="quantum_gate" title="wikilink">quantum logic gates</a>. The sequence of gates to be applied is called a <a href="quantum_algorithm" title="wikilink">quantum algorithm</a>. The calculation ends with a measurement, collapsing the system of qubits into one of the 

<math display="inline" id="Quantum_computing:3">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 pure states, where each qubit is zero or one. The outcome can therefore be at most 

<math display="inline" id="Quantum_computing:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 classical bits of information. Quantum algorithms are often non-deterministic, in that they provide the correct solution only with a certain known probability.</p>

<p>An example of an implementation of qubits for a quantum computer could start with the use of particles with two <a href="spin_(physics)" title="wikilink">spin</a> states: "down" and "up" (typically written 

<math display="inline" id="Quantum_computing:5">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>↓</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>normal-↓</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |{\downarrow}\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_computing:6">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mo>↑</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>normal-↑</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |{\uparrow}\rangle
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Quantum_computing:7">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0{\rangle}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_computing:8">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1{\rangle}
  </annotation>
 </semantics>
</math>

). But in fact any system possessing an <a class="uri" href="observable" title="wikilink">observable</a> quantity <em>A</em>, which is <em>conserved</em> under time evolution such that <em>A</em> has at least two discrete and sufficiently spaced consecutive <a href="eigenvalue" title="wikilink">eigenvalues</a>, is a suitable candidate for implementing a qubit. This is true because any such system can be mapped onto an effective <a class="uri" href="spin-1/2" title="wikilink">spin-1/2</a> system.</p>
<h2 id="mechanics">Mechanics</h2>

<p>A quantum computer with a given number of qubits is fundamentally different from a classical computer composed of the same number of classical bits. For example, to represent the state of an <em>n</em>-qubit system on a classical computer would require the storage of 2<sup><em>n</em></sup> <a href="Complex_number" title="wikilink">complex</a> coefficients. Although this fact may seem to indicate that qubits can hold exponentially more information than their classical counterparts, care must be taken not to overlook the fact that the qubits are only in a probabilistic superposition of all of their states. This means that when the final state of the qubits is measured, they will only be found in one of the possible configurations they were in before measurement. Moreover, it is incorrect to think of the qubits as only being in one particular state before measurement since the fact that they were in a superposition of states before the measurement was made directly affects the possible outcomes of the computation.</p>
<figure><b>(Figure)</b>
<figcaption>Qubits are made up of controlled particles and the means of control (e.g. devices that trap particles and switch them from one state to another).<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> </figcaption>
</figure>

<p>For example: Consider first a classical computer that operates on a three-bit <a href="Processor_register" title="wikilink">register</a>. The state of the computer at any time is a probability distribution over the 

<math display="inline" id="Quantum_computing:9">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{3}=8
  </annotation>
 </semantics>
</math>

 different three-bit strings <code>000, 001, 010, 011, 100, 101, 110, 111</code>. If it is a deterministic computer, then it is in exactly one of these states with probability 1. However, if it is a <a href="Probabilistic_automaton" title="wikilink">probabilistic computer</a>, then there is a possibility of it being in any <em>one</em> of a number of different states. We can describe this probabilistic state by eight nonnegative numbers <em>A</em>,<em>B</em>,<em>C</em>,<em>D</em>,<em>E</em>,<em>F</em>,<em>G</em>,<em>H</em> (where <em>A</em> = is the probability that the computer is in state <code>000</code>, <em>B</em> = is the probability that the computer is in state <code>001</code>, etc.). There is a restriction that these probabilities sum to 1.</p>

<p>The state of a three-qubit quantum computer is similarly described by an eight-dimensional vector (<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>,<em>e</em>,<em>f</em>,<em>g</em>,<em>h</em>), called a <a href="Bra-ket_notation" title="wikilink">ket</a>. Here, however, the coefficients can have <a href="complex_number" title="wikilink">complex values</a>, and it is the sum of the <em>squares</em> of the coefficients' <a href="Absolute_value#Complex_numbers" title="wikilink">magnitudes</a>, 

<math display="inline" id="Quantum_computing:10">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>h</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>a</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>b</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>h</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|^{2}+|b|^{2}+\cdots+|h|^{2}
  </annotation>
 </semantics>
</math>

, that must equal 1. These squared magnitudes represent the probability of each of the given states. However, because a complex number encodes not just a magnitude but also a direction in the <a href="complex_plane" title="wikilink">complex plane</a>, the phase difference between any two coefficients (states) represents a meaningful parameter. This is a fundamental difference between quantum computing and probabilistic classical computing.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>If you measure the three qubits, you will observe a three-bit string. The probability of measuring a given string is the squared magnitude of that string's coefficient (i.e., the probability of measuring <code>000</code> = 

<math display="inline" id="Quantum_computing:11">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>a</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <ci>a</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|^{2}
  </annotation>
 </semantics>
</math>

, the probability of measuring <code>001</code> = 

<math display="inline" id="Quantum_computing:12">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>b</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <ci>b</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b|^{2}
  </annotation>
 </semantics>
</math>

, etc..). Thus, measuring a quantum state described by complex coefficients (<em>a</em>,<em>b</em>,...,<em>h</em>) gives the classical probability distribution 

<math display="inline" id="Quantum_computing:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>h</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>a</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>b</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>h</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|a|^{2},|b|^{2},\ldots,|h|^{2})
  </annotation>
 </semantics>
</math>

 and we say that the quantum state "collapses" to a classical state as a result of making the measurement.</p>

<p>Note that an eight-dimensional vector can be specified in many different ways depending on what <a href="Basis_(linear_algebra)" title="wikilink">basis</a> is chosen for the space. The basis of bit strings (e.g., 000, 001, …, 111) is known as the computational basis. Other possible bases are <a href="unit_vector" title="wikilink">unit-length</a>, <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> vectors and the eigenvectors of the <a href="Pauli_matrices" title="wikilink">Pauli-x operator</a>. <a href="Bra-ket_notation" title="wikilink">Ket notation</a> is often used to make the choice of basis explicit. For example, the state (<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>,<em>e</em>,<em>f</em>,<em>g</em>,<em>h</em>) in the computational basis can be written as:</p>

<p>

<math display="block" id="Quantum_computing:14">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>a</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>000</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>b</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>001</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>c</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>010</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>d</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>011</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>e</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>100</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>101</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>g</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>110</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>111</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">000</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">001</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">010</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">011</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">100</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">101</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">110</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">111</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,|000\rangle+b\,|001\rangle+c\,|010\rangle+d\,|011\rangle+e\,|100\rangle+f\,%
|101\rangle+g\,|110\rangle+h\,|111\rangle
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where, e.g., 

<math display="inline" id="Quantum_computing:15">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>010</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">010</cn>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |010\rangle=\left(0,0,1,0,0,0,0,0\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The computational basis for a single qubit (two dimensions) is 

<math display="inline" id="Quantum_computing:16">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>0</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">0</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle=\left(1,0\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_computing:17">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>1</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1\rangle=\left(0,1\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>Using the eigenvectors of the Pauli-x operator, a single qubit is 

<math display="inline" id="Quantum_computing:18">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <interval closure="open">
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle=\tfrac{1}{\sqrt{2}}\left(1,1\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_computing:19">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>-</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <minus></minus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <interval closure="open">
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |-\rangle=\tfrac{1}{\sqrt{2}}\left(1,-1\right)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="operation">Operation</h2>

<p>While a classical three-bit state and a quantum three-qubit state are both eight-dimensional <a href="coordinate_vector" title="wikilink">vectors</a>, they are manipulated quite differently for classical or quantum computation. For computing in either case, the system must be initialized, for example into the all-zeros string, 

<math display="inline" id="Quantum_computing:20">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>000</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">000</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |000\rangle
  </annotation>
 </semantics>
</math>

, corresponding to the vector (1,0,0,0,0,0,0,0). In classical randomized computation, the system evolves according to the application of <a href="Stochastic_matrix" title="wikilink">stochastic matrices</a>, which preserve that the probabilities add up to one (i.e., preserve the <a href="Taxicab_geometry" title="wikilink">L1 norm</a>). In quantum computation, on the other hand, allowed operations are <a href="unitary_matrix" title="wikilink">unitary matrices</a>, which are effectively rotations (they preserve that the sum of the squares add up to one, the <a href="Euclidean_metric" title="wikilink">Euclidean or L2 norm</a>). (Exactly what unitaries can be applied depend on the physics of the quantum device.) Consequently, since rotations can be undone by rotating backward, quantum computations are <a href="Reversible_computing" title="wikilink">reversible</a>. (Technically, quantum operations can be probabilistic combinations of unitaries, so quantum computation really does generalize classical computation. See <a href="quantum_circuit" title="wikilink">quantum circuit</a> for a more precise formulation.)</p>

<p>Finally, upon termination of the algorithm, the result needs to be read off. In the case of a classical computer, we <em>sample</em> from the <a href="probability_distribution" title="wikilink">probability distribution</a> on the three-bit register to obtain one definite three-bit string, say 000. Quantum mechanically, we <em><a href="quantum_measurement" title="wikilink">measure</a></em> the three-qubit state, which is equivalent to collapsing the quantum state down to a classical distribution (with the coefficients in the classical state being the squared magnitudes of the coefficients for the quantum state, as described above), followed by sampling from that distribution. Note that this destroys the original quantum state. Many algorithms will only give the correct answer with a certain probability. However, by repeatedly initializing, running and measuring the quantum computer's results, the probability of getting the correct answer can be increased.</p>

<p>For more details on the sequences of operations used for various <a href="quantum_algorithm" title="wikilink">quantum algorithms</a>, see <a href="universal_quantum_computer" title="wikilink">universal quantum computer</a>, <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>, <a href="Grover's_algorithm" title="wikilink">Grover's algorithm</a>, <a href="Deutsch–Jozsa_algorithm" title="wikilink">Deutsch–Jozsa algorithm</a>, <a href="amplitude_amplification" title="wikilink">amplitude amplification</a>, <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transform</a>, <a href="quantum_gate" title="wikilink">quantum gate</a>, <a href="Adiabatic_quantum_computation" title="wikilink">quantum adiabatic algorithm</a> and <a href="quantum_error_correction" title="wikilink">quantum error correction</a>.</p>
<h2 id="potential">Potential</h2>

<p><a href="Integer_factorization" title="wikilink">Integer factorization</a> is believed to be computationally infeasible with an ordinary computer for large integers if they are the product of few <a href="prime_number" title="wikilink">prime numbers</a> (e.g., products of two 300-digit primes).<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> By comparison, a quantum computer could efficiently solve this problem using <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> to find its factors. This ability would allow a quantum computer to decrypt many of the <a href="cryptography" title="wikilink">cryptographic</a> systems in use today, in the sense that there would be a <a href="polynomial_time" title="wikilink">polynomial time</a> (in the number of digits of the integer) algorithm for solving the problem. In particular, most of the popular <a href="Asymmetric_Algorithms" title="wikilink">public key ciphers</a> are based on the difficulty of factoring integers or the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> problem, both of which can be solved by Shor's algorithm. In particular the <a href="RSA_(algorithm)" title="wikilink">RSA</a>, <a class="uri" href="Diffie-Hellman" title="wikilink">Diffie-Hellman</a>, and <a href="Elliptic_curve_Diffie-Hellman" title="wikilink">Elliptic curve Diffie-Hellman</a> algorithms could be broken. These are used to protect secure Web pages, encrypted email, and many other types of data. Breaking these would have significant ramifications for electronic privacy and security.</p>

<p>However, other cryptographic algorithms do not appear to be broken by those algorithms.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Some public-key algorithms are based on problems other than the integer factorization and discrete logarithm problems to which Shor's algorithm applies, like the <a href="McEliece_cryptosystem" title="wikilink">McEliece cryptosystem</a> based on a problem in <a href="coding_theory" title="wikilink">coding theory</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="Lattice_based_cryptography" title="wikilink">Lattice-based cryptosystems</a> are also not known to be broken by quantum computers, and finding a polynomial time algorithm for solving the <a href="dihedral_group" title="wikilink">dihedral</a> <a href="hidden_subgroup_problem" title="wikilink">hidden subgroup problem</a>, which would break many lattice based cryptosystems, is a well-studied open problem.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> It has been proven that applying Grover's algorithm to break a <a href="Symmetric_cryptography" title="wikilink">symmetric (secret key) algorithm</a> by brute force requires time equal to roughly 2<sup>n/2</sup> invocations of the underlying cryptographic algorithm, compared with roughly 2<sup>n</sup> in the classical case,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> meaning that symmetric key lengths are effectively halved: AES-256 would have the same security against an attack using Grover's algorithm that AES-128 has against classical brute-force search (see <a href="Key_size#Effect_of_quantum_computing_attacks_on_key_strength" title="wikilink">Key size</a>). <a href="Quantum_cryptography" title="wikilink">Quantum cryptography</a> could potentially fulfill some of the functions of public key cryptography.</p>

<p>Besides factorization and discrete logarithms, quantum algorithms offering a more than polynomial speedup over the best known classical algorithm have been found for several problems,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> including the simulation of quantum physical processes from chemistry and solid state physics, the approximation of <a href="Jones_polynomial" title="wikilink">Jones polynomials</a>, and solving <a href="Pell's_equation" title="wikilink">Pell's equation</a>. No mathematical proof has been found that shows that an equally fast classical algorithm cannot be discovered, although this is considered unlikely. For some problems, quantum computers offer a polynomial speedup. The most well-known example of this is <em>quantum database search</em>, which can be solved by <a href="Grover's_algorithm" title="wikilink">Grover's algorithm</a> using quadratically fewer queries to the database than are required by classical algorithms. In this case the advantage is provable. Several other examples of provable quantum speedups for query problems have subsequently been discovered, such as for finding collisions in two-to-one functions and evaluating NAND trees.</p>

<p>Consider a problem that has these four properties:</p>
<ol>
<li>The only way to solve it is to guess answers repeatedly and check them,</li>
<li>The number of possible answers to check is the same as the number of inputs,</li>
<li>Every possible answer takes the same amount of time to check, and</li>
<li>There are no clues about which answers might be better: generating possibilities randomly is just as good as checking them in some special order.</li>
</ol>

<p>An example of this is a <a href="Password_cracking" title="wikilink">password cracker</a> that attempts to guess the password for an <a href="encryption" title="wikilink">encrypted</a> file (assuming that the password has a maximum possible length).</p>

<p>For problems with all four properties, the time for a quantum computer to solve this will be proportional to the square root of the number of inputs. It can be used to attack <a href="symmetric_cipher" title="wikilink">symmetric ciphers</a> such as <a href="Triple_DES" title="wikilink">Triple DES</a> and <a href="Advanced_Encryption_Standard" title="wikilink">AES</a> by attempting to guess the secret key.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p><a href="Grover's_algorithm" title="wikilink">Grover's algorithm</a> can also be used to obtain a quadratic speed-up over a brute-force search for a class of problems known as <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>.</p>

<p>Since chemistry and nanotechnology rely on understanding quantum systems, and such systems are impossible to simulate in an efficient manner classically, many believe <a href="Universal_quantum_simulator" title="wikilink">quantum simulation</a> will be one of the most important applications of quantum computing.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Quantum simulation could also be used to simulate the behavior of atoms and particles at unusual conditions such as the reactions inside a <a class="uri" href="collider" title="wikilink">collider</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>There are a number of technical challenges in building a large-scale quantum computer, and thus far quantum computers have yet to solve a problem faster than a classical computer. David DiVincenzo, of IBM, listed the following requirements for a practical quantum computer:<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<ul>
<li>scalable physically to increase the number of qubits;</li>
<li>qubits that can be initialized to arbitrary values;</li>
<li>quantum gates that are faster than <a class="uri" href="decoherence" title="wikilink">decoherence</a> time;</li>
<li>universal gate set;</li>
<li>qubits that can be read easily.</li>
</ul>
<h3 id="quantum-decoherence">Quantum decoherence</h3>

<p>One of the greatest challenges is controlling or removing <a href="quantum_decoherence" title="wikilink">quantum decoherence</a>. This usually means isolating the system from its environment as interactions with the external world cause the system to decohere. However, other sources of decoherence also exist. Examples include the quantum gates, and the lattice vibrations and background nuclear spin of the physical system used to implement the qubits. Decoherence is irreversible, as it is non-unitary, and is usually something that should be highly controlled, if not avoided. Decoherence times for candidate systems, in particular the transverse relaxation time <em>T</em><sub>2</sub> (for <a href="Nuclear_magnetic_resonance" title="wikilink">NMR</a> and <a class="uri" href="MRI" title="wikilink">MRI</a> technology, also called the <em>dephasing time</em>), typically range between nanoseconds and seconds at low temperature.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Currently, some quantum computers require their qubits to be cooled to 20 millikelvin in order to prevent significant decoherence.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>These issues are more difficult for optical approaches as the timescales are orders of magnitude shorter and an often-cited approach to overcoming them is optical <a href="pulse_shaping" title="wikilink">pulse shaping</a>. Error rates are typically proportional to the ratio of operating time to decoherence time, hence any operation must be completed much more quickly than the decoherence time.</p>

<p>If the error rate is small enough, it is thought to be possible to use quantum error correction, which corrects errors due to decoherence, thereby allowing the total calculation time to be longer than the decoherence time. An often cited figure for required error rate in each gate is 10<sup>−4</sup>. This implies that each gate must be able to perform its task in one 10,000th of the decoherence time of the system.</p>

<p>Meeting this scalability condition is possible for a wide range of systems. However, the use of error correction brings with it the cost of a greatly increased number of required qubits. The number required to factor integers using Shor's algorithm is still polynomial, and thought to be between <em>L</em> and <em>L</em><sup>2</sup>, where <em>L</em> is the number of bits in the number to be factored; error correction algorithms would inflate this figure by an additional factor of <em>L</em>. For a 1000-bit number, this implies a need for about 10<sup>4</sup> qubits without error correction.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> With error correction, the figure would rise to about 10<sup>7</sup> qubits. Note that computation time is about <em>L</em><sup>2</sup> or about 10<sup>7</sup> steps and on 1 M<a href="Hertz" title="wikilink">Hz</a>, about 10 seconds.</p>

<p>A very different approach to the stability-decoherence problem is to create a <a href="topological_quantum_computer" title="wikilink">topological quantum computer</a> with <a href="anyon" title="wikilink">anyons</a>, quasi-particles used as threads and relying on <a href="braid_theory" title="wikilink">braid theory</a> to form stable logic gates.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="developments">Developments</h2>

<p>There are a number of quantum computing models, distinguished by the basic elements in which the computation is decomposed. The four main models of practical importance are:</p>
<ul>
<li><em><a href="quantum_circuit" title="wikilink">Quantum gate array</a></em> (computation decomposed into sequence of few-qubit <a href="quantum_gate" title="wikilink">quantum gates</a>)</li>
<li><em><a href="One-way_quantum_computer" title="wikilink">One-way quantum computer</a></em> (computation decomposed into sequence of one-qubit measurements applied to a highly entangled initial state or <a href="cluster_state" title="wikilink">cluster state</a>)</li>
<li><em><a href="Adiabatic_quantum_computation" title="wikilink">Adiabatic quantum computer</a></em>, based on <a href="Quantum_annealing" title="wikilink">Quantum annealing</a> (computation decomposed into a slow continuous transformation of an initial <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> into a final Hamiltonian, whose ground states contains the solution)<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></li>
<li><a href="Topological_quantum_computer" title="wikilink">Topological quantum computer</a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> (computation decomposed into the braiding of <a href="anyon" title="wikilink">anyons</a> in a 2D lattice)</li>
</ul>

<p>The <em><a href="Quantum_Turing_machine" title="wikilink">Quantum Turing machine</a></em> is theoretically important but direct implementation of this model is not pursued. All four models of computation have been shown to be equivalent; each can simulate the other with no more than polynomial overhead.</p>

<p>For physically implementing a quantum computer, many different candidates are being pursued, among them (distinguished by the physical system used to realize the qubits):</p>
<ul>
<li><a class="uri" href="Superconductor" title="wikilink">Superconductor</a>-based quantum computers (including <a class="uri" href="SQUID" title="wikilink">SQUID</a>-based quantum computers)<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> (qubit implemented by the state of small superconducting circuits (<a href="Josephson_junctions" title="wikilink">Josephson junctions</a>))</li>
<li><a href="Trapped_ion_quantum_computer" title="wikilink">Trapped ion quantum computer</a> (qubit implemented by the internal state of trapped ions)</li>
<li><a href="Optical_lattice" title="wikilink">Optical lattices</a> (qubit implemented by internal states of neutral atoms trapped in an optical lattice)</li>
<li><a href="Quantum_dot" title="wikilink">Quantum dot</a> computer, spin-based (e.g. the <a href="Loss-DiVincenzo_quantum_computer" title="wikilink">Loss-DiVincenzo quantum computer</a> <a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a>) (qubit given by the spin states of trapped electrons)</li>
<li><a href="Quantum_dot" title="wikilink">Quantum dot</a> computer, spatial-based (qubit given by electron position in double quantum dot)<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></li>
<li><a href="Nuclear_magnetic_resonance" title="wikilink">Nuclear magnetic resonance</a> on molecules in solution (liquid-state NMR) (qubit provided by <a href="nuclear_spin" title="wikilink">nuclear spins</a> within the dissolved molecule)</li>
<li>Solid-state NMR <a href="Kane_quantum_computer" title="wikilink">Kane quantum computers</a> (qubit realized by the nuclear spin state of <a class="uri" href="phosphorus" title="wikilink">phosphorus</a> <a href="Electron_donor" title="wikilink">donors</a> in <a class="uri" href="silicon" title="wikilink">silicon</a>)</li>
<li>Electrons-on-<a class="uri" href="helium" title="wikilink">helium</a> quantum computers (qubit is the electron spin)</li>
<li><a href="Cavity_quantum_electrodynamics" title="wikilink">Cavity quantum electrodynamics</a> (CQED) (qubit provided by the internal state of trapped atoms coupled to high-<a class="uri" href="finesse" title="wikilink">finesse</a> cavities)</li>
<li><a href="Molecular_magnet" title="wikilink">Molecular magnet</a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> (qubit given by spin states)</li>
<li><a class="uri" href="Fullerene" title="wikilink">Fullerene</a>-based <a href="Electron_paramagnetic_resonance" title="wikilink">ESR</a> quantum computer (qubit based on the electronic spin of <a href="Endohedral_fullerene" title="wikilink">atoms or molecules encased in fullerenes</a>)</li>
<li><a href="Linear_optical_quantum_computing" title="wikilink">Linear optical quantum computer</a> (qubits realized by processing states of different <a href="Normal_mode" title="wikilink">modes</a> of light through linear elements e.g. mirrors, <a href="beam_splitter" title="wikilink">beam splitters</a> and <a href="phase_shift_module" title="wikilink">phase shifters</a>)<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></li>
<li><a href="Diamond-based_quantum_computer" title="wikilink">Diamond-based quantum computer</a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> (qubit realized by electronic or nuclear spin of <a href="nitrogen-vacancy_center" title="wikilink">nitrogen-vacancy centers</a> in diamond)</li>
<li><a href="Bose–Einstein_condensate" title="wikilink">Bose–Einstein condensate</a>-based quantum computer<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></li>
<li>Transistor-based quantum computer – string quantum computers with entrainment of positive holes using an electrostatic trap</li>
<li>Rare-earth-metal-ion-doped inorganic crystal based quantum computers<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> (qubit realized by the internal electronic state of <a href="dopant" title="wikilink">dopants</a> in <a href="optical_fiber" title="wikilink">optical fibers</a>)</li>
</ul>

<p>The large number of candidates demonstrates that the topic, in spite of rapid progress, is still in its infancy, there is also a vast amount of flexibility.</p>
<h3 id="timeline">Timeline</h3>

<p>In 2001, researchers demonstrated Shor's algorithm to factor 15 using a 7-qubit NMR computer.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></p>

<p>In 2005, researchers at the <a href="University_of_Michigan" title="wikilink">University of Michigan</a> built a <a href="semiconductor_chip" title="wikilink">semiconductor chip</a> <a href="ion_trap" title="wikilink">ion trap</a>. Such devices from standard <a href="photolithography" title="wikilink">lithography</a>, may point the way to scalable quantum computing.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p>In 2009, researchers at <a href="Yale_University" title="wikilink">Yale University</a> created the first solid-state quantum processor. The two-<a class="uri" href="qubit" title="wikilink">qubit</a> superconducting chip had artificial atom qubits made of a billion <a class="uri" href="aluminum" title="wikilink">aluminum</a> <a href="atom" title="wikilink">atoms</a> that acted like a single atom that could occupy two states.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a><a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>A team at the <a href="University_of_Bristol" title="wikilink">University of Bristol</a>, also created a <a class="uri" href="silicon" title="wikilink">silicon</a> chip based on <a href="quantum_optics" title="wikilink">quantum optics</a>, able to run <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> Further developments were made in 2010.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> Springer publishes a journal (<em>Quantum Information Processing</em>) devoted to the subject.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>

<p>In April 2011, a team of scientists from Australia and Japan made a breakthrough in <a href="quantum_teleportation" title="wikilink">quantum teleportation</a>. They successfully transferred a complex set of quantum data with full transmission integrity, without affecting the qubits superpositions.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Photograph of a chip constructed by D-Wave Systems Inc., mounted and wire-bonded in a sample holder. The D-Wave processor is designed to use 128 <a href="superconductivity" title="wikilink">superconducting</a> logic elements that exhibit controllable and tunable coupling to perform operations.</figcaption>
</figure>

<p>In 2011, <a href="D-Wave_Systems" title="wikilink">D-Wave Systems</a> announced the first commercial quantum annealer, the D-Wave One, claiming a 128 qubit processor.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> On May 25, 2011 <a href="Lockheed_Martin" title="wikilink">Lockheed Martin</a> agreed to purchase a D-Wave One system.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> Lockheed and the University of Southern California (USC) will house the D-Wave One at the newly formed USC Lockheed Martin Quantum Computing Center.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> D-Wave's engineers designed the chips with an empirical approach, focusing on solving particular problems. Investors liked this more than academics, who said D-Wave had not demonstrated they really had a quantum computer. Criticism softened after a D-Wave paper in <a href="Nature_(journal)" title="wikilink">Nature</a>, that proved the chips have some quantum properties.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a><a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> Two published papers have suggested that the D-Wave machine's operation can be explained classically, rather than requiring quantum models.<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a><a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> Later work showed that classical models are insufficient when all available data is considered.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> Experts remain divided on the ultimate classification of the D-Wave systems though their quantum behavior was established concretely with a demonstration of entanglement.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a></p>

<p>During the same year, researchers at the <a href="University_of_Bristol" title="wikilink">University of Bristol</a> created an all-bulk optics system that ran a version of <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> to successfully factor 21.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>

<p>In September 2011 researchers proved quantum computers can be made with a <a href="Von_Neumann_architecture" title="wikilink">Von Neumann architecture</a> (separation of RAM).<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a></p>

<p>In November 2011 researchers factorized 143 using 4 qubits.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p>

<p>In February 2012 <a class="uri" href="IBM" title="wikilink">IBM</a> scientists said that they had made several breakthroughs in quantum computing with superconducting integrated circuits.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a></p>

<p>In April 2012 a multinational team of researchers from the <a href="University_of_Southern_California" title="wikilink">University of Southern California</a>, <a href="Delft_University_of_Technology" title="wikilink">Delft University of Technology</a>, the <a href="Iowa_State_University_of_Science_and_Technology" title="wikilink">Iowa State University of Science and Technology</a>, and the <a href="University_of_California,_Santa_Barbara" title="wikilink">University of California, Santa Barbara</a>, constructed a two-qubit quantum computer on a doped diamond crystal that can easily be scaled up and is functional at room temperature. Two logical qubit directions of electron spin and nitrogen kernels spin were used, with microwave impulses. This computer ran Grover's algorithm generating the right answer from the first try in 95% of cases.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a></p>

<p>In September 2012, Australian researchers at the University of New South Wales said the world's first quantum computer was just 5 to 10 years away, after announcing a global breakthrough enabling manufacture of its memory building blocks. A research team led by Australian engineers created the first working qubit based on a single atom in silicon, invoking the same technological platform that forms the building blocks of modern day computers.<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> <a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a></p>

<p>In October 2012, <a href="Nobel_Prize" title="wikilink">Nobel Prizes</a> were presented to <a href="David_J._Wineland" title="wikilink">David J. Wineland</a> and <a href="Serge_Haroche" title="wikilink">Serge Haroche</a> for their basic work on understanding the quantum world, which may help make quantum computing possible.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a><a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>

<p>In November 2012, the first <a href="quantum_teleportation" title="wikilink">quantum teleportation</a> from one <a href="Macroscopic_scale" title="wikilink">macroscopic</a> object to another was reported.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a><a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a></p>

<p>In December 2012, the first dedicated quantum computing software company, <a class="uri" href="1QBit" title="wikilink">1QBit</a> was founded in Vancouver, BC.<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a> 1QBit is the first company to focus exclusively on commercializing software applications for commercially available quantum computers, including the <a href="D-Wave_Two" title="wikilink">D-Wave Two</a>. 1QBit's research demonstrated the ability of <a class="uri" href="superconducting" title="wikilink">superconducting</a> <a href="quantum_annealing" title="wikilink">quantum annealing</a> processors to solve real-world problems.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p>

<p>In February 2013, a new technique, boson sampling, was reported by two groups using photons in an optical lattice that is not a universal quantum computer but may be good enough for practical problems. <em>Science</em> Feb 15, 2013</p>

<p>In May 2013, Google announced that it was launching the Quantum Artificial Intelligence Lab, hosted by <a class="uri" href="NASA" title="wikilink">NASA</a>{{'s}} Ames Research Center, with a 512-qubit D-Wave quantum computer. The USRA (Universities Space Research Association) will invite researchers to share time on it with the goal of studying quantum computing for machine learning.<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a></p>

<p>In early 2014 it was reported, based on documents provided by former NSA contractor <a href="Edward_Snowden" title="wikilink">Edward Snowden</a>, that the U.S. <a href="National_Security_Agency" title="wikilink">National Security Agency</a> (NSA) is running a $79.7 million research program (titled "Penetrating Hard Targets") to develop a quantum computer capable of breaking vulnerable <a class="uri" href="encryption" title="wikilink">encryption</a>.<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></p>

<p>In 2014, a group of researchers from <a href="ETH_Zürich" title="wikilink">ETH Zürich</a>, <a href="University_of_Southern_California" title="wikilink">USC</a>, <a class="uri" href="Google" title="wikilink">Google</a> and <a class="uri" href="Microsoft" title="wikilink">Microsoft</a> reported a definition of quantum speedup, and were not able to measure quantum speedup with the D-Wave Two device, but did not explicitly rule it out.<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a><a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a></p>

<p>In 2014, researchers at <a href="University_of_New_South_Wales" title="wikilink">University of New South Wales</a> used silicon as a protectant shell around <a href="qubit" title="wikilink">qubits</a>, making them more accurate, increasing the length of time they will hold information and possibly made quantum computers easier to build.<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a></p>

<p>In April 2015 IBM scientists claimed two critical advances towards the realization of a practical quantum computer. They claimed the ability to detect and measure both kinds of quantum errors simultaneously, as well as a new, square quantum bit circuit design that could scale to larger dimensions.<a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a></p>
<h2 id="relation-to-computational-complexity-theory">Relation to computational complexity theory</h2>

<p> The class of problems that can be efficiently solved by quantum computers is called <a class="uri" href="BQP" title="wikilink">BQP</a>, for "bounded error, quantum, polynomial time". Quantum computers only run <a href="Probabilistic_algorithm" title="wikilink">probabilistic</a> algorithms, so BQP on quantum computers is the counterpart of <a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a> ("bounded error, probabilistic, polynomial time") on classical computers. It is defined as the set of problems solvable with a polynomial-time algorithm, whose probability of error is bounded away from one half.<a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a> A quantum computer is said to "solve" a problem if, for every instance, its answer will be right with high probability. If that solution runs in polynomial time, then that problem is in BQP.</p>

<p>BQP is contained in the complexity class <em><a href="Sharp-P" title="wikilink">#P</a></em> (or more precisely in the associated class of decision problems <em>P<sup>#P</sup></em>),<a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a> which is a subclass of <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>.</p>

<p>BQP is suspected to be disjoint from <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> and a strict superset of <a href="P_(complexity)" title="wikilink">P</a>, but that is not known. Both <a href="integer_factorization" title="wikilink">integer factorization</a> and <a href="discrete_logarithm_problem" title="wikilink">discrete log</a> are in BQP. Both of these problems are NP problems suspected to be outside BPP, and hence outside P. Both are suspected to not be NP-complete. There is a common misconception that quantum computers can solve NP-complete problems in polynomial time. That is not known to be true, and is generally suspected to be false.<a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a></p>

<p>By the same token, it is often believed that quantum computers are generally superior to classical computers, that is, faster or at least as fast for any computing task. However, there is no proof of that, and it might not be true considering the next three observations:</p>
<ul>
<li>A quantum superposition of qubit states is basically a distributed representation of data to be processed. For some computing tasks, it can yield an exponential reduction from <em>O</em>(2<sup><em>N</em></sup>) to <em>O</em>(1) in the amount of work and time needed to complete a computing task for input size <em>N</em>.</li>
<li>In classical computing, various kinds of distributed representations have been devised to reduce work and time for various computing tasks. This reduction is typically from <em>O</em>(2<sup><em>N</em></sup>) to <em>O</em>(<em>N</em><sup>2</sup>), but for at least one computing task, <a href="Transparallel_processing" title="wikilink">hyperstrings</a> are distributed representations that enable an exponential reduction from <em>O</em>(2<sup><em>N</em></sup>) to <em>O</em>(1).<a class="footnoteRef" href="#fn83" id="fnref83"><sup>83</sup></a><a class="footnoteRef" href="#fn84" id="fnref84"><sup>84</sup></a></li>
<li>In the end, it always is the computing task at hand that determines if the data to be processed can be gathered in a distributed representation by which the task can be solved efficiently.</li>
</ul>

<p>Hence, the interdependence between computing tasks and distributed representations suggests not only that quantum superpositions may be more efficient than classical distributed representations for some computing tasks, but also that the inverse may hold for other computing tasks.</p>

<p>The capacity of a quantum computer to accelerate classical algorithms has rigid limits—upper bounds of quantum computation's complexity. The overwhelming part of classical calculations cannot be accelerated on a quantum computer.<a class="footnoteRef" href="#fn85" id="fnref85"><sup>85</sup></a> A similar fact takes place for particular computational tasks, like the search problem, for which Grover's algorithm is optimal.<a class="footnoteRef" href="#fn86" id="fnref86"><sup>86</sup></a></p>

<p>Although quantum computers may be faster than classical computers for some problems, those described above can't solve any problems that classical computers can't solve, given enough time and memory (however, those amounts might be practically infeasible). A <a href="Turing_machine" title="wikilink">Turing machine</a> can simulate these quantum computers, so such a quantum computer could never solve an <a href="undecidable_problem" title="wikilink">undecidable problem</a> like the <a href="halting_problem" title="wikilink">halting problem</a>. The existence of "standard" quantum computers does not disprove the <a href="Church–Turing_thesis" title="wikilink">Church–Turing thesis</a>.<a class="footnoteRef" href="#fn87" id="fnref87"><sup>87</sup></a> It has been speculated that theories of <a href="quantum_gravity" title="wikilink">quantum gravity</a>, such as <a class="uri" href="M-theory" title="wikilink">M-theory</a> or <a href="loop_quantum_gravity" title="wikilink">loop quantum gravity</a>, may allow even faster computers to be built. Currently, <em>defining</em> computation in such theories is an open problem due to the <em><a href="problem_of_time" title="wikilink">problem of time</a></em>, i.e., there currently exists no obvious way to describe what it means for an observer to submit input to a computer and later receive output.<a class="footnoteRef" href="#fn88" id="fnref88"><sup>88</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Paul_Benioff" title="wikilink">Paul Benioff</a></li>
<li><a href="Chemical_computer" title="wikilink">Chemical computer</a></li>
<li><a href="David_Deutsch" title="wikilink">David Deutsch</a></li>
<li><a href="DNA_computer" title="wikilink">DNA computer</a></li>
<li><a href="Electronic_quantum_holography" title="wikilink">Electronic quantum holography</a></li>
<li><a href="List_of_emerging_technologies" title="wikilink">Emergin tecnologies, list</a></li>
<li><a href="Richard_Feynman" title="wikilink">Richard Feynman</a></li>
<li><a class="uri" href="IARPA" title="wikilink">IARPA</a></li>
<li><a href="Kane_quantum_computer" title="wikilink">Kane quantum computer</a></li>
<li><a href="Natural_computing" title="wikilink">Natural computing</a></li>
<li><a href="Normal_mode" title="wikilink">Normal mode</a></li>
<li><a href="Photonic_computing" title="wikilink">Photonic computing</a></li>
<li><a href="Post-quantum_cryptography" title="wikilink">Post-quantum cryptography</a></li>
<li><a href="Quantum_annealing" title="wikilink">Quantum annealing</a></li>
<li><a href="Quantum_bus" title="wikilink">Quantum bus</a></li>
<li><a href="Quantum_cognition" title="wikilink">Quantum cognition</a></li>
<li><a href="Quantum_gate" title="wikilink">Quantum gate</a></li>
<li><a href="Quantum_threshold_theorem" title="wikilink">Quantum threshold theorem</a></li>
<li><a class="uri" href="Soliton" title="wikilink">Soliton</a></li>
<li><a href="Timeline_of_quantum_computing" title="wikilink">Timeline of quantum computing</a></li>
<li><a href="Topological_quantum_computer" title="wikilink">Topological quantum computer</a></li>
<li><a class="uri" href="Valleytronics" title="wikilink">Valleytronics</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
<li>DiVincenzo, David P. (2000). "The Physical Implementation of Quantum Computation". <em>Experimental Proposals for Quantum Computation</em>. </li>
<li>

<p>Table 1 lists switching and dephasing times for various systems.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Lomonaco, Sam. <a href="http://www.csee.umbc.edu/~lomonaco/Lectures.html#OxfordLectures">Four Lectures on Quantum Computing given at Oxford University in July 2006</a></li>
<li>C. Adami, N.J. Cerf. (1998). "Quantum computation with linear optics". .</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/qt-quantcomp/">Quantum Computing</a>" by Amit Hagar.</li>
<li><a href="http://www.quantiki.org/">Quantiki</a> – Wiki and portal with free-content related to quantum information science.
<ul>
<li><a href="http://www.quantiki.org/wiki/Basic_concepts_in_quantum_computation">Basic concepts</a></li>
</ul></li>
<li><a href="http://www.scottaaronson.com/blog/">Scott Aaronson's blog</a>, which features informative and critical commentary on developments in the field</li>
<li><a href="http://www.inc.com/will-bourne/d-waves-dream-machine.html">D-Wave thinks it has built the world's first commercial quantum computer. Mother Nature has other ideas</a>, in the January 2014 issue of <em><a href="Inc._(magazine)" title="wikilink">Inc. magazine</a></em></li>
<li><a href="http://arxiv.org/pdf/1310.1339.pdf">Quantum Annealing and Computation: A Brief Documentary Note</a>, A. Ghosh and S. Mukherjee</li>
<li><a href="http://www.lps.umd.edu/Quantum%20Computing%20Group/QuantumComputingIndex.html">Maryland University Laboratory for Physical Sciences</a>: conducts researches for the quantum computer-based project led by the NSA, named 'Penetrating Hard Target'.</li>
<li><a href="http://arnetminer.org/event/quantumComputingHistory">Visualized history of quantum computing</a></li>
<li><a href="http://arxiv.org/pdf/0801.2193.pdf">Quantum Annealing and Analog Quantum Computation by Arnab Das and BK Chakrabarti</a></li>
</ul>
<dl>
<dt>Lectures</dt>
</dl>
<ul>
<li><a href="https://courses.edx.org/courses/BerkeleyX/CS-191x">Quantum Mechanics and Quantum Computation</a> – <a class="uri" href="edX" title="wikilink">edX</a> course by <a href="Umesh_Vazirani" title="wikilink">Umesh Vazirani</a></li>
<li><a href="http://www.youtube.com/playlist?list=PL1826E60FD05B44E4">Quantum computing for the determined</a> – 22 video lectures by <a href="Michael_Nielsen" title="wikilink">Michael Nielsen</a></li>
<li><a href="http://www.quiprocone.org/Protected/DD_lectures.htm">Video Lectures</a> by <a href="David_Deutsch" title="wikilink">David Deutsch</a></li>
<li><a href="http://www.quantware.ups-tlse.fr/IHP2006/">Lectures at the Institut Henri Poincaré (slides and videos)</a></li>
<li><a href="http://nanohub.org/resources/4778">Online lecture on An Introduction to Quantum Computing, Edward Gerjuoy (2008)</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink"> </a> <a href="Category:Quantum_computing" title="wikilink">Category:Quantum computing</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Quantum_cryptography" title="wikilink">Category:Quantum cryptography</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Classes_of_computers" title="wikilink">Category:Classes of computers</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a href="Category:Open_problems" title="wikilink">Category:Open problems</a> <a href="Category:1980_introductions" title="wikilink">Category:1980 introductions</a> <a href="Category:Emerging_technologies" title="wikilink">Category:Emerging technologies</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://qist.lanl.gov/qcomp_map.shtml">Quantum Information Science and Technology Roadmap</a> for a sense of where the research is heading.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"> <a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">Daniel J. Bernstein, <a href="http://pqcrypto.org/www.springer.com/cda/content/document/cda_downloaddocument/9783540887010-c1.pdf"><em>Introduction to Post-Quantum Cryptography</em></a>. Introduction to Daniel J. Bernstein, Johannes Buchmann, Erik Dahmen (editors). Post-quantum cryptography. Springer, Berlin, 2009. ISBN 978-3-540-88701-0<a href="#fnref13">↩</a></li>
<li id="fn14">See also <a href="http://pqcrypto.org/">pqcrypto.org</a>, a bibliography maintained by Daniel J. Bernstein and Tanja Lange on cryptography not known to be broken by quantum computing.<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">Robert J. McEliece. "<a href="http://ipnpr.jpl.nasa.gov/progress_report2/42-44/44N.PDF">A public-key cryptosystem based on algebraic coding theory</a>." Jet Propulsion Laboratory DSN Progress Report 42–44, 114–116.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">Bennett C.H., Bernstein E., Brassard G., Vazirani U., "<a href="http://www.cs.berkeley.edu/~vazirani/pubs/bbbv.ps">The strengths and weaknesses of quantum computation</a>". <em><a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a></em> 26(5): 1510–1523 (1997).<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://math.nist.gov/quantum/zoo/">Quantum Algorithm Zoo</a> – Stephen Jordan's Homepage<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49">"<a href="http://www.springer.com/new+%26+forthcoming+titles+%28default%29/journal/11128">Quantum Information Processing</a>". Springer.com. Retrieved on 2011-05-19.<a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"><a href="#fnref51">↩</a></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"><a href="#fnref61">↩</a></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"><a href="#fnref63">↩</a></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"><a href="#fnref66">↩</a></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"><a href="#fnref68">↩</a></li>
<li id="fn69"><a href="#fnref69">↩</a></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"><a href="#fnref71">↩</a></li>
<li id="fn72"><a href="#fnref72">↩</a></li>
<li id="fn73"><a href="#fnref73">↩</a></li>
<li id="fn74"><a href="#fnref74">↩</a></li>
<li id="fn75"><a href="#fnref75">↩</a></li>
<li id="fn76"><a href="http://arxiv.org/pdf/1401.2910v1.pdf">Defining and detecting quantum speedup</a>, Troels F. Rønnow, Zhihui Wang, Joshua Job, Sergio Boixo, Sergei V. Isakov, David Wecker, John M. Martinis, Daniel A. Lidar, Matthias Troyer, 2014-01-13.<a href="#fnref76">↩</a></li>
<li id="fn77"><a href="#fnref77">↩</a></li>
<li id="fn78"><a href="#fnref78">↩</a></li>
<li id="fn79"><a href="http://www-03.ibm.com/press/us/en/pressrelease/46725.wss">IBM Scientists Achieve Critical Steps to Building First Practical Quantum Computer</a><a href="#fnref79">↩</a></li>
<li id="fn80">Nielsen, p. 41<a href="#fnref80">↩</a></li>
<li id="fn81"><a href="#fnref81">↩</a></li>
<li id="fn82"></li>
<li id="fn83">van der Helm, P. A. (2004). <a href="http://www.pnas.org/cgi/reprint/101/30/10862.pdf">Transparallel processing by hyperstrings.</a> <em>Proceedings of the National Academy of Sciences USA, 101,</em> 10862—10867. <a href="http://dx.doi.org/10.1073/pnas.0403402101"></a><a class="uri" href="doi:10.1073/pnas.0403402101">doi:10.1073/pnas.0403402101</a>.<a href="#fnref83">↩</a></li>
<li id="fn84">van der Helm, P. A. (2015). Transparallel mind: Classical computing with quantum power. <em>Artificial Intelligence Review</em> (Online First). <a href="http://dx.doi.org/10.1007/s10462-015-9429-7"></a><a class="uri" href="doi:10.1007/s10462-015-9429-7">doi:10.1007/s10462-015-9429-7</a>.<a href="#fnref84">↩</a></li>
<li id="fn85"><a href="#fnref85">↩</a></li>
<li id="fn86"><a href="#fnref86">↩</a></li>
<li id="fn87">Nielsen, p. 126<a href="#fnref87">↩</a></li>
<li id="fn88"><a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a>, <em><a href="http://arxiv.org/abs/quant-ph/0502072">NP-complete Problems and Physical Reality</a></em>, ACM <a class="uri" href="SIGACT" title="wikilink">SIGACT</a> News, Vol. 36, No. 1. (March 2005), pp. 30–52, section 7 "Quantum Gravity": "[…] to anyone who wants a test or benchmark for a favorite quantum gravity theory,[author's footnote: That is, one without all the bother of making numerical predictions and comparing them to observation] let me humbly propose the following: <em>can you define Quantum Gravity Polynomial-Time?</em> […] until we can say what it means for a 'user' to specify an 'input' and ‘later' receive an 'output'—<em>there is no such thing as computation, not even theoretically.</em>" (emphasis in original)<a href="#fnref88">↩</a></li>
</ol>
</section>
</body>
</html>
