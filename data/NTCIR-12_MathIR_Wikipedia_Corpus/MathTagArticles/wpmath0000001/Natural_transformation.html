<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1457">Natural transformation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Natural transformation</h1>
<hr/>

<p>In <a href="category_theory" title="wikilink">category theory</a>, a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>natural transformation</strong> provides a way of transforming one <a class="uri" href="functor" title="wikilink">functor</a> into another while respecting the internal structure (i.e. the composition of <a href="morphism" title="wikilink">morphisms</a>) of the <a href="Category_(mathematics)" title="wikilink">categories</a> involved. Hence, a natural transformation can be considered to be a "morphism of functors". Indeed this intuition can be formalized to define so-called <a href="functor_category" title="wikilink">functor categories</a>. Natural transformations are, after categories and functors, one of the most fundamental notions of <a href="category_theory" title="wikilink">category theory</a> and consequently appear in the majority of its applications.</p>
<h2 id="definition">Definition</h2>

<p>If <em>F</em> and <em>G</em> are <a href="functor" title="wikilink">functors</a> between the categories <em>C</em> and <em>D</em>, then a <strong>natural transformation</strong> <em>η</em> from <em>F</em> to <em>G</em> is a family of morphisms that satisfy two requirements.</p>
<ol>
<li>The natural transformation must associate to every object <em>X</em> in <em>C</em> a <a class="uri" href="morphism" title="wikilink">morphism</a> <mtpl></mtpl> between objects of <em>D</em>. The morphism <em>η</em><sub><em>X</em></sub> is called the <strong>component</strong> of <em>η</em> at <em>X</em>.</li>
<li>Components must be such that for every morphism  we have:</li>
</ol>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Natural_transformation:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>η</mi>
      <mi>Y</mi>
     </msub>
     <mo>∘</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <msub>
     <mi>η</mi>
     <mi>X</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <ci>Y</ci>
      </apply>
      <ci>F</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{Y}\circ F(f)=G(f)\circ\eta_{X}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The last equation can conveniently be expressed by the <a href="commutative_diagram" title="wikilink">commutative diagram</a></p>
<dl>
<dd>
</dd>
</dl>

<p>If both <em>F</em> and <em>G</em> are <a href="contravariant_functor" title="wikilink">contravariant</a>, the horizontal arrows in this diagram are reversed. If <em>η</em> is a natural transformation from <em>F</em> to <em>G</em>, we also write  or . This is also expressed by saying the family of morphisms <mtpl></mtpl> is <strong>natural</strong> in <em>X</em>.</p>

<p>If, for every object <em>X</em> in <em>C</em>, the morphism <em>η</em><sub><em>X</em></sub> is an <a class="uri" href="isomorphism" title="wikilink">isomorphism</a> in <em>D</em>, then <em>η</em> is said to be a <strong></strong> (or sometimes <strong>natural equivalence</strong> or <strong>isomorphism of functors</strong>). Two functors <em>F</em> and <em>G</em> are called <em>naturally isomorphic</em> or simply <em>isomorphic</em> if there exists a natural isomorphism from <em>F</em> to <em>G</em>.</p>

<p>An <strong>infranatural transformation</strong> <em>η</em> from <em>F</em> to <em>G</em> is simply a family of morphisms <mtpl></mtpl>. Thus a natural transformation is an infranatural transformation for which <mtpl></mtpl> for every morphism . The <strong>naturalizer</strong> of <em>η</em>, nat(<em>η</em>), is the largest <a class="uri" href="subcategory" title="wikilink">subcategory</a> of <em>C</em> containing all the objects of <em>C</em> on which <em>η</em> restricts to a natural transformation.</p>
<h2 id="examples">Examples</h2>
<h3 id="opposite-group">Opposite group</h3>

<p>Statements such as</p>
<dl>
<dd>"Every group is naturally isomorphic to its <a href="opposite_group" title="wikilink">opposite group</a>"
</dd>
</dl>

<p>abound in modern mathematics. We will now give the precise meaning of this statement as well as its proof. Consider the category <strong>Grp</strong> of all <a href="group_(mathematics)" title="wikilink">groups</a> with <a href="group_homomorphism" title="wikilink">group homomorphisms</a> as morphisms. If  is a group, we define its opposite group <mtpl></mtpl> as follows: <em>G</em><sup>op</sup> is the same set as <em>G</em>, and the operation ∗<sup>op</sup> is defined by <mtpl></mtpl>. All multiplications in <em>G</em><sup>op</sup> are thus "turned around". Forming the <a href="Opposite_category" title="wikilink">opposite</a> group becomes a (covariant!) functor from <strong>Grp</strong> to <strong>Grp</strong> if we define <mtpl></mtpl> for any group homomorphism . Note that <em>f</em><sup>op</sup> is indeed a group homomorphism from <em>G</em><sup>op</sup> to <em>H</em><sup>op</sup>:</p>
<dl>
<dd><em>f</em><sup>op</sup>(<em>a</em> ∗<sup>op</sup> <em>b</em>) = <em>f</em>(<em>b</em> ∗ <em>a</em>) = <em>f</em>(<em>b</em>) ∗ <em>f</em>(<em>a</em>) = <em>f</em><sup>op</sup>(<em>a</em>) ∗<sup>op</sup> <em>f</em><sup>op</sup>(<em>b</em>).
</dd>
</dl>

<p>The content of the above statement is:</p>
<dl>
<dd>"The identity functor <mtpl></mtpl> is naturally isomorphic to the opposite functor <mtpl></mtpl>."
</dd>
</dl>

<p>To prove this, we need to provide isomorphisms <mtpl></mtpl> for every group <em>G</em>, such that the above diagram commutes. Set <mtpl></mtpl>. The formulas <mtpl></mtpl> and <mtpl></mtpl> show that <em>η</em><sub><em>G</em></sub> is a group homomorphism which is its own inverse. To prove the naturality, we start with a group homomorphism  and show <mtpl></mtpl>, i.e. <mtpl></mtpl> for all <em>a</em> in <em>G</em>. This is true since <mtpl></mtpl> and every group homomorphism has the property <mtpl></mtpl>.</p>
<h3 id="double-dual-of-a-vector-space">Double dual of a vector space</h3>

<p>If <em>K</em> is a <a href="field_(mathematics)" title="wikilink">field</a>, then for every <a href="vector_space" title="wikilink">vector space</a> <em>V</em> over <em>K</em> we have a "natural" <a class="uri" href="injective" title="wikilink">injective</a> <a href="linear_map" title="wikilink">linear map</a>  from the vector space into its <a href="double_dual" title="wikilink">double dual</a>. These maps are "natural" in the following sense: the double dual operation is a functor, and the maps are the components of a natural transformation from the identity functor to the double dual functor.</p>
<h3 id="tensor-hom-adjunction">Tensor-hom adjunction</h3>

<p>Consider the <a href="category_of_abelian_groups" title="wikilink">category <strong>Ab</strong> of abelian groups and group homomorphisms</a>. For all abelian groups <em>X</em>, <em>Y</em> and <em>Z</em> we have a group isomorphism</p>
<dl>
<dd>

<p>.</p>
</dd>
</dl>

<p>These isomorphisms are "natural" in the sense that they define a natural transformation between the two involved functors <mtpl></mtpl>. (Here "op" is the <a href="opposite_category" title="wikilink">opposite category</a> of <strong>Ab</strong>, not to be confused with the trivial <a href="opposite_group" title="wikilink">opposite group</a> functor on <strong>Ab</strong>!)</p>

<p>This is formally the <a href="tensor-hom_adjunction" title="wikilink">tensor-hom adjunction</a>, and is an archetypal example of a pair of <a href="adjoint_functors" title="wikilink">adjoint functors</a>. Natural transformations arise frequently in conjunction with adjoint functors, and indeed, adjoint functors are defined by a certain natural isomorphism. Additionally, every pair of adjoint functors comes equipped with two natural transformations (generally not isomorphisms) called the <em>unit</em> and <em>counit</em>.</p>
<h2 id="unnatural-isomorphism">Unnatural isomorphism</h2>

<p>The notion of a natural transformation is categorical, and states (informally) that a particular map between functors can be done consistently over an entire category. Informally, a particular map (esp. an isomorphism) between individual objects (not entire categories) is referred to as a "natural isomorphism", meaning implicitly that it is actually defined on the entire category, and defines a natural transformation of functors; formalizing this intuition was a motivating factor in the development of category theory. Conversely, a particular map between particular objects may be called an <strong>unnatural isomorphism</strong> (or "this isomorphism is not natural") if the map cannot be extended to a natural transformation on the entire category. Given an object <em>X,</em> a functor <em>G</em> (taking for simplicity the first functor to be the identity) and an isomorphism 

<math display="inline" id="Natural_transformation:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>η</mi>
    <mo>:</mo>
    <mrow>
     <mi>X</mi>
     <mo>→</mo>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\colon X\to G(X),
  </annotation>
 </semantics>
</math>

 proof of unnaturality is most easily shown by giving an automorphism 

<math display="inline" id="Natural_transformation:2">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>A</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\colon X\to X
  </annotation>
 </semantics>
</math>

 that does not commute with this isomorphism (so 

<math display="inline" id="Natural_transformation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>η</mi>
    <mo>∘</mo>
    <mi>A</mi>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <mi>η</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <compose></compose>
     <ci>η</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>A</ci>
     </apply>
     <ci>η</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\circ A\neq G(A)\circ\eta
  </annotation>
 </semantics>
</math>


). More strongly, if one wishes to prove that <em>X</em> and <em>G</em>(<em>X</em>) are not naturally isomorphic, without reference to a particular isomorphism, this requires showing that for <em>any</em> isomorphism <em>η,</em> there is some <em>A</em> with which it does not commute; in some cases a single automorphism <em>A</em> works for all candidate isomorphisms <em>η,</em> while in other cases one must show how to construct a different <em>A</em><sub><em>η</em></sub> for each isomorphism. The maps of the category play a crucial role – any infranatural transform is natural if the only maps are the identity map, for instance.</p>

<p>This is similar (but more categorical) to concepts in group theory or module theory, where a given decomposition of an object into a direct sum is "not natural", or rather "not unique", as automorphisms exist that do not preserve the direct sum decomposition – see <a href="Structure_theorem_for_finitely_generated_modules_over_a_principal_ideal_domain#Uniqueness" title="wikilink">Structure theorem for finitely generated modules over a principal ideal domain#Uniqueness</a> for example.</p>

<p>Some authors distinguish notationally, using ≅ for a natural isomorphism and ≈ for an unnatural isomorphism, reserving = for equality (usually equality of maps).</p>
<h3 id="example-fundamental-group-of-torus">Example: fundamental group of torus</h3>

<p>As an example of the distinction between the functorial statement and individual objects, consider <a href="homotopy_group" title="wikilink">homotopy groups</a> of a product space, specifically the fundamental group of the torus.</p>

<p>The <a href="homotopy_group" title="wikilink">homotopy groups</a> of a product space are naturally the product of the homotopy groups of the components, 

<math display="inline" id="Natural_transformation:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>×</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Y</mi>
        <mo>,</mo>
        <msub>
         <mi>y</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>π</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>×</mo>
      <msub>
       <mi>π</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
      <interval closure="open">
       <ci>Y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <ci>n</ci>
       </apply>
       <interval closure="open">
        <ci>X</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>Y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{n}((X,x_{0})\times(Y,y_{0}))\cong\pi_{n}((X,x_{0}))\times\pi_{n}((Y,y_{0}%
)),
  </annotation>
 </semantics>
</math>

 with the isomorphism given by projection onto the two factors, fundamentally because maps into a product space are exactly products of maps into the components – this is a functorial statement.</p>

<p>However, given the torus, which is abstractly a product of two circles, and thus has <a href="fundamental_group" title="wikilink">fundamental group</a> isomorphic to <strong>Z</strong><sup>2</sup>, but the splitting 

<math display="inline" id="Natural_transformation:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>𝐙</mi>
    <mo>×</mo>
    <mi>𝐙</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>𝐙</ci>
     <ci>𝐙</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(T,t_{0})\approx\mathbf{Z}\times\mathbf{Z}
  </annotation>
 </semantics>
</math>

 is not natural. Note the use of 

<math display="inline" id="Natural_transformation:6">
 <semantics>
  <mo>≈</mo>
  <annotation-xml encoding="MathML-Content">
   <approx></approx>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Natural_transformation:7">
 <semantics>
  <mo>≅</mo>
  <annotation-xml encoding="MathML-Content">
   <approx></approx>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cong
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Natural_transformation:8">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>


:<mtpl></mtpl></p>

<p>

<math display="block" id="Natural_transformation:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo>,</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>π</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>S</mi>
         <mn>1</mn>
        </msup>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>×</mo>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>S</mi>
       <mn>1</mn>
      </msup>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>𝐙</mi>
     <mo>×</mo>
     <mi>𝐙</mi>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>𝐙</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>π</ci>
         <cn type="integer">1</cn>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>S</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝐙</ci>
      <ci>𝐙</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐙</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(T,t_{0})\approx\pi_{1}(S^{1},x_{0})\times\pi_{1}(S^{1},y_{0})\cong%
\mathbf{Z}\times\mathbf{Z}=\mathbf{Z}^{2}.
  </annotation>
 </semantics>
</math>

 This abstract isomorphism with a product is not natural, as some isomorphisms of <em>T</em> do not preserve the product: the self-homeomorphism of <em>T</em> (thought of as the <a href="Quotient_space_(topology)" title="wikilink">quotient space</a> <strong>R</strong><sup>2</sup>/<strong>Z</strong><sup>2</sup>) given by 

<math display="inline" id="Natural_transformation:10">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}1&1\\
0&1\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

 (geometrically a <a href="Dehn_twist" title="wikilink">Dehn twist</a> about one of the generating curves) acts as this matrix on <strong>Z</strong><sup>2</sup> (it’s in the <a href="general_linear_group" title="wikilink">general linear group</a> GL(<strong>Z</strong>, 2) of invertible integer matrices), which does not preserve the decomposition as a product because it is not diagonal. However, if one is given the torus as a product 

<math display="inline" id="Natural_transformation:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mn>1</mn>
     </msup>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mn>1</mn>
     </msup>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
    <apply>
     <times></times>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T,t_{0})=(S^{1},x_{0})\times(S^{1},y_{0})
  </annotation>
 </semantics>
</math>

 – equivalently, given a decomposition of the space – then the splitting of the group follows from the general statement earlier. In categorical terms, the relevant category (preserving the structure of a product space) is "maps of product spaces, namely a pair of maps between the respective components".</p>

<p>Naturality is a categorical notion, and requires being very precise about exactly what data is given – the torus as a space that happens to be a product (in the category of spaces and continuous maps) is different from the torus presented as a product (in the category of products of two spaces and continuous maps between the respective components).</p>
<h3 id="example-dual-of-a-finite-dimensional-vector-space">Example: dual of a finite-dimensional vector space</h3>

<p>Every finite-dimensional vector space is isomorphic to its dual space, but this isomorphism relies on an arbitrary choice of isomorphism (for example, via choosing a basis and then taking the isomorphism sending this basis to the corresponding <a href="dual_basis" title="wikilink">dual basis</a>). There is in general no natural isomorphism between a finite-dimensional vector space and its dual space.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However, related categories (with additional structure and restrictions on the maps) do have a natural isomorphism, as described below.</p>

<p>The dual space of a finite-dimensional vector space is again a finite-dimensional vector space of the same dimension, and these are thus isomorphic, since dimension is the only invariant of finite-dimensional vector spaces over a given field. However, in the absence of additional data (such as a basis), there is no given map from a space to its dual, and thus such an isomorphism requires a choice, and is "not natural". On the category of finite-dimensional vector spaces and linear maps, one can define an infranatural isomorphism from vector spaces to their dual by choosing an isomorphism for each space (say, by choosing a basis for every vector space and taking the corresponding isomorphism), but this will not define a natural transformation. Intuitively this is because it required a choice, rigorously because <em>any</em> such choice of isomorphisms will not commute with <em>all</em> linear maps; see  for detailed discussion.</p>

<p>Starting from finite-dimensional vector spaces (as objects) and the dual functor, one can define a natural isomorphism, but this requires first adding additional structure, then restricting the maps from "all linear maps" to "linear maps that respect this structure". Explicitly, for each vector space, require that it come with the data of an isomorphism to its dual, 

<math display="inline" id="Natural_transformation:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>η</mi>
     <mi>V</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>V</mi>
     <mo>→</mo>
     <msup>
      <mi>V</mi>
      <mo>*</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{V}\colon V\to V^{*}.
  </annotation>
 </semantics>
</math>

 In other words, take as objects vector spaces with a <a href="nondegenerate_bilinear_form" title="wikilink">nondegenerate bilinear form</a> 

<math display="inline" id="Natural_transformation:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>V</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mo>×</mo>
      <mi>V</mi>
     </mrow>
     <mo>→</mo>
     <mi>K</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>V</ci>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{V}\colon V\times V\to K.
  </annotation>
 </semantics>
</math>


 This defines an infranatural isomorphism (isomorphism for each object). One then restricts the maps to only those maps T that commute with the isomorphisms

<math display="block" id="Natural_transformation:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>η</mi>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>V</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>η</mi>
     <mi>V</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>V</ci>
     </apply>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{*}(\eta_{T(V)}(T(v)))=\eta_{V}(v)
  </annotation>
 </semantics>
</math>

 or in other words, preserve the bilinear form

<math display="block" id="Natural_transformation:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>V</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>V</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>w</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>V</ci>
     </apply>
     <interval closure="open">
      <ci>v</ci>
      <ci>w</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{T(V)}(T(v),T(w))=b_{V}(v,w).
  </annotation>
 </semantics>
</math>

 (These maps define the <em>naturalizer</em> of the isomorphisms.) The resulting category, with objects finite-dimensional vector spaces with a nondegenerate bilinear form, and maps linear transforms that respect the bilinear form, by construction has a natural isomorphism from the identity to the dual (each space has an isomorphism to its dual, and the maps in the category are required to commute). Viewed in this light, this construction (add transforms for each object, restrict maps to commute with these) is completely general, and does not depend on any particular properties of vector spaces.</p>

<p>In this category (finite-dimensional vector spaces with a nondegenerate bilinear form, maps linear transforms that respect the bilinear form), the dual of a map between vector spaces can be identified as a <a class="uri" href="transpose" title="wikilink">transpose</a>. Often for reasons of geometric interest this is specialized to a subcategory, by requiring that the nondegenerate bilinear forms have additional properties, such as being symmetric (<a href="orthogonal_matrices" title="wikilink">orthogonal matrices</a>), symmetric and positive definite (<a href="inner_product_space" title="wikilink">inner product space</a>), symmetric sesquilinear (<a href="Hermitian_space" title="wikilink">Hermitian spaces</a>), skew-symmetric and totally isotropic (<a href="symplectic_vector_space" title="wikilink">symplectic vector space</a>), etc. – in all these categories a vector space is naturally identified with its dual, by the nondegenerate bilinear form.</p>
<h2 id="operations-with-natural-transformations">Operations with natural transformations</h2>

<p>If  and  are natural transformations between functors , then we can compose them to get a natural transformation . This is done componentwise: <mtpl></mtpl>. This "vertical composition" of natural transformation is <a class="uri" href="associative" title="wikilink">associative</a> and has an identity, and allows one to consider the collection of all functors  itself as a category (see below under <a href="#Functor_categories" title="wikilink">Functor categories</a>).</p>

<p>Natural transformations also have a "horizontal composition". If  is a natural transformation between functors  and  is a natural transformation between functors , then the composition of functors allows a composition of natural transformations . This operation is also associative with identity, and the identity coincides with that for vertical composition. The two operations are related by an identity which exchanges vertical composition with horizontal composition.</p>

<p>If  is a natural transformation between functors , and  is another functor, then we can form the natural transformation  by defining</p>

<p>

<math display="block" id="Natural_transformation:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>H</mi>
       <mi>η</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>X</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>H</mi>
     <msub>
      <mi>η</mi>
      <mi>X</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>η</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H\eta)_{X}=H\eta_{X}.
  </annotation>
 </semantics>
</math>

</p>

<p>If on the other hand  is a functor, the natural transformation  is defined by</p>

<p>

<math display="block" id="Natural_transformation:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>η</mi>
       <mi>K</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>X</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>η</mi>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <ci>η</ci>
      <ci>K</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\eta K)_{X}=\eta_{K(X)}.\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="functor-categories">Functor categories</h2>

<p>If <em>C</em> is any category and <em>I</em> is a <a href="small_category" title="wikilink">small category</a>, we can form the <a href="functor_category" title="wikilink">functor category</a> <em>C<sup>I</sup></em> having as objects all functors from <em>I</em> to <em>C</em> and as morphisms the natural transformations between those functors. This forms a category since for any functor <em>F</em> there is an identity natural transformation <mtpl></mtpl> (which assigns to every object <em>X</em> the identity morphism on <em>F</em>(<em>X</em>)) and the composition of two natural transformations (the "vertical composition" above) is again a natural transformation.</p>

<p>The <a href="isomorphism" title="wikilink">isomorphisms</a> in <em>C<sup>I</sup></em> are precisely the natural isomorphisms. That is, a natural transformation  is a natural isomorphism if and only if there exists a natural transformation  such that <mtpl></mtpl> and <mtpl></mtpl>.</p>

<p>The functor category <em>C<sup>I</sup></em> is especially useful if <em>I</em> arises from a <a href="directed_graph" title="wikilink">directed graph</a>. For instance, if <em>I</em> is the category of the directed graph , then <em>C<sup>I</sup></em> has as objects the morphisms of <em>C</em>, and a morphism between  and  in <em>C<sup>I</sup></em> is a pair of morphisms  and  in <em>C</em> such that the "square commutes", i.e. .</p>

<p>More generally, one can build the <a class="uri" href="2-category" title="wikilink">2-category</a> <strong>Cat</strong> whose</p>
<ul>
<li>0-cells (objects) are the small categories,</li>
<li>1-cells (arrows) between two objects 

<math display="inline" id="Natural_transformation:18">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Natural_transformation:19">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 are the functors from 

<math display="inline" id="Natural_transformation:20">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Natural_transformation:21">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

,</li>
<li>2-cells between two 1-cells (functors) 

<math display="inline" id="Natural_transformation:22">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>C</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>C</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:C\to D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Natural_transformation:23">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mi>C</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>C</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:C\to D
  </annotation>
 </semantics>
</math>


 are the natural transformations from 

<math display="inline" id="Natural_transformation:24">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Natural_transformation:25">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The horizontal and vertical compositions are the compositions between natural transformations described previously. A functor category 

<math display="inline" id="Natural_transformation:26">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi>I</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{I}
  </annotation>
 </semantics>
</math>

 is then simply a hom-category in this category (smallness issues aside).</p>
<h2 id="yoneda-lemma">Yoneda lemma</h2>

<p>If <em>X</em> is an object of a <a href="locally_small_category" title="wikilink">locally small category</a> <em>C</em>, then the assignment <mtpl></mtpl> defines a covariant functor <mtpl></mtpl>. This functor is called <em><a href="representable_functor" title="wikilink">representable</a></em> (more generally, a representable functor is any functor naturally isomorphic to this functor for an appropriate choice of <em>X</em>). The natural transformations from a representable functor to an arbitrary functor  are completely known and easy to describe; this is the content of the <a href="Yoneda_lemma" title="wikilink">Yoneda lemma</a>.</p>
<h2 id="historical-notes">Historical notes</h2>

<p><a href="Saunders_Mac_Lane" title="wikilink">Saunders Mac Lane</a>, one of the founders of category theory, is said to have remarked, "I didn't invent categories to study functors; I invented them to study natural transformations."<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Just as the study of <a href="group_(mathematics)" title="wikilink">groups</a> is not complete without a study of <a href="group_homomorphism" title="wikilink">homomorphisms</a>, so the study of categories is not complete without the study of <a href="functor" title="wikilink">functors</a>. The reason for Mac Lane's comment is that the study of functors is itself not complete without the study of natural transformations.</p>

<p>The context of Mac Lane's remark was the axiomatic theory of <a href="homology_(mathematics)" title="wikilink">homology</a>. Different ways of constructing homology could be shown to coincide: for example in the case of a <a href="simplicial_complex" title="wikilink">simplicial complex</a> the groups defined directly would be isomorphic to those of the singular theory. What cannot easily be expressed without the language of natural transformations is how homology groups are compatible with morphisms between objects, and how two equivalent homology theories not only have the same homology groups, but also the same morphisms between those groups.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Extranatural_transformation" title="wikilink">Extranatural transformation</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ncatlab.org/nlab">nLab</a>, a wiki project on mathematics, physics and philosophy with emphasis on the <em>n</em>-categorical point of view</li>
<li><a href="André_Joyal" title="wikilink">André Joyal</a>, <a href="http://ncatlab.org/nlab">CatLab</a>, a wiki project dedicated to the exposition of categorical mathematics</li>
<li>

<p>formal introduction to category theory.</p></li>
<li>J. Adamek, H. Herrlich, G. Stecker, <a href="http://katmat.math.uni-bremen.de/acc/acc.pdf">Abstract and Concrete Categories-The Joy of Cats</a></li>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/category-theory/">Category Theory</a>"—by Jean-Pierre Marquis. Extensive bibliography.</li>
<li><a href="http://www.mta.ca/~cat-dist/">List of academic conferences on category theory</a></li>
<li>Baez, John, 1996,"<a href="http://math.ucr.edu/home/baez/week73.html">The Tale of <em>n</em>-categories.</a>" An informal introduction to higher order categories.</li>
<li><a href="http://wildcatsformma.wordpress.com">WildCats</a> is a category theory package for <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>. Manipulation and visualization of objects, <a href="morphism" title="wikilink">morphisms</a>, categories, <a href="functor" title="wikilink">functors</a>, natural transformations, <a href="universal_properties" title="wikilink">universal properties</a>.</li>
<li><a href="http://www.youtube.com/user/TheCatsters">The catsters</a>, a YouTube channel about category theory.</li>
<li></li>
<li><a href="http://categorieslogicphysics.wikidot.com/events">Video archive</a> of recorded talks relevant to categories, logic and the foundations of physics.</li>
<li><a href="http://www.j-paine.org/cgi-bin/webcats/webcats.php">Interactive Web page</a> which generates examples of categorical constructions in the category of finite sets.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Functors" title="wikilink">Category:Functors</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
