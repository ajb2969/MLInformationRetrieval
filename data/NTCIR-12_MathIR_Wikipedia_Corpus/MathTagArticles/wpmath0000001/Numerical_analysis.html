<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="710">Numerical analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Numerical analysis</h1>
<hr/>

<p> <strong>Numerical analysis</strong> is the study of <a href="algorithm" title="wikilink">algorithms</a> that use numerical <a class="uri" href="approximation" title="wikilink">approximation</a> (as opposed to general <a href="symbolic_computation" title="wikilink">symbolic manipulations</a>) for the problems of <a href="mathematical_analysis" title="wikilink">mathematical analysis</a> (as distinguished from <a href="discrete_mathematics" title="wikilink">discrete mathematics</a>).</p>

<p>One of the earliest mathematical writings is a Babylonian tablet from the <a href="Yale_Babylonian_Collection" title="wikilink">Yale Babylonian Collection</a> (YBC 7289), which gives a <a class="uri" href="sexagesimal" title="wikilink">sexagesimal</a> <a href="numerical_approximation" title="wikilink">numerical approximation</a> of 

<math display="inline" id="Numerical_analysis:0">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>

, the length of the <a class="uri" href="diagonal" title="wikilink">diagonal</a> in a <a href="unit_square" title="wikilink">unit square</a>. Being able to compute the sides of a triangle (and hence, being able to compute square roots) is extremely important, for instance, in <a class="uri" href="astronomy" title="wikilink">astronomy</a>, <a class="uri" href="carpentry" title="wikilink">carpentry</a> and construction.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Numerical analysis continues this long tradition of practical mathematical calculations. Much like the Babylonian approximation of 

<math display="inline" id="Numerical_analysis:1">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>

, modern numerical analysis does not seek exact answers, because exact answers are often impossible to obtain in practice. Instead, much of numerical analysis is concerned with obtaining approximate solutions while maintaining reasonable bounds on errors.</p>

<p>Numerical analysis naturally finds applications in all fields of engineering and the physical sciences, but in the 21st century also the life sciences and even the arts have adopted elements of scientific computations. <a href="Ordinary_differential_equation" title="wikilink">Ordinary differential equations</a> appear in <a href="celestial_mechanics" title="wikilink">celestial mechanics</a> (planets, stars and galaxies); <a href="numerical_linear_algebra" title="wikilink">numerical linear algebra</a> is important for data analysis; <a href="stochastic_differential_equation" title="wikilink">stochastic differential equations</a> and <a href="Markov_chain" title="wikilink">Markov chains</a> are essential in simulating living cells for medicine and biology.</p>

<p>Before the advent of modern computers numerical methods often depended on hand <a class="uri" href="interpolation" title="wikilink">interpolation</a> in large printed tables. Since the mid 20th century, computers calculate the required functions instead. These same interpolation formulas nevertheless continue to be used as part of the software <a class="uri" href="algorithms" title="wikilink">algorithms</a> for solving <a href="differential_equations" title="wikilink">differential equations</a>.</p>
<h2 id="general-introduction">General introduction</h2>

<p>The overall goal of the field of numerical analysis is the design and analysis of techniques to give approximate but accurate solutions to hard problems, the variety of which is suggested by the following:</p>
<ul>
<li>Advanced numerical methods are essential in making <a href="numerical_weather_prediction" title="wikilink">numerical weather prediction</a> feasible.</li>
<li>Computing the trajectory of a spacecraft requires the accurate numerical solution of a system of <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a>.</li>
<li>Car companies can improve the crash safety of their vehicles by using computer simulations of car crashes. Such simulations essentially consist of solving <a href="partial_differential_equation" title="wikilink">partial differential equations</a> numerically.</li>
<li><a href="Hedge_fund" title="wikilink">Hedge funds</a> (private investment funds) use tools from all fields of numerical analysis to attempt to calculate the value of stocks and derivatives more precisely than other market participants.</li>
<li>Airlines use sophisticated optimization algorithms to decide ticket prices, airplane and crew assignments and fuel needs. Historically, such algorithms were developed within the overlapping field of <a href="operations_research" title="wikilink">operations research</a>.</li>
<li>Insurance companies use numerical programs for <a href="Actuary" title="wikilink">actuarial</a> analysis.</li>
</ul>

<p>The rest of this section outlines several important themes of numerical analysis.</p>
<h3 id="history">History</h3>

<p>The field of numerical analysis predates the invention of modern computers by many centuries. <a href="Linear_interpolation" title="wikilink">Linear interpolation</a> was already in use more than 2000 years ago. Many great mathematicians of the past were preoccupied by numerical analysis, as is obvious from the names of important algorithms like <a href="Newton's_method" title="wikilink">Newton's method</a>, <a href="Lagrange_polynomial" title="wikilink">Lagrange interpolation polynomial</a>, <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, or <a href="Euler's_method" title="wikilink">Euler's method</a>.</p>

<p>To facilitate computations by hand, large books were produced with formulas and tables of data such as interpolation points and function coefficients. Using these tables, often calculated out to 16 decimal places or more for some functions, one could look up values to plug into the formulas given and achieve very good numerical estimates of some functions. The canonical work in the field is the <a class="uri" href="NIST" title="wikilink">NIST</a> publication edited by <a href="Abramowitz_and_Stegun" title="wikilink">Abramowitz and Stegun</a>, a 1000-plus page book of a very large number of commonly used formulas and functions and their values at many points. The function values are no longer very useful when a computer is available, but the large listing of formulas can still be very handy.</p>

<p>The <a href="mechanical_calculator" title="wikilink">mechanical calculator</a> was also developed as a tool for hand computation. These calculators evolved into electronic computers in the 1940s, and it was then found that these computers were also useful for administrative purposes. But the invention of the computer also influenced the field of numerical analysis, since now longer and more complicated calculations could be done.</p>
<h3 id="direct-and-iterative-methods">Direct and iterative methods</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Direct vs iterative methods</strong> Consider the problem of solving</p>
<dl>
<dd>3<em>x</em><sup>3</sup> + 4 = 28
</dd>
</dl>

<p>for the unknown quantity <em>x</em>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Direct method</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Subtract 4</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Divide by 3</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Take cube roots</em></p></td>
</tr>
</tbody>
</table>

<p>For the iterative method, apply the <a href="bisection_method" title="wikilink">bisection method</a> to <em>f</em>(<em>x</em>) = 3<em>x</em><sup>3</sup> − 24. The initial values are <em>a</em> = 0, <em>b</em> = 3, <em>f</em>(<em>a</em>) = −24, <em>f</em>(<em>b</em>) = 57.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Iterative method</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>a</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1.5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1.5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1.875</p></td>
</tr>
</tbody>
</table>

<p>We conclude from this table that the solution is between 1.875 and 2.0625. The algorithm might return any number in that range with an error less than 0.2.</p>
<h4 id="discretization-and-numerical-integration">Discretization and numerical integration</h4>

<p> In a two hour race, we have measured the speed of the car at three instants and recorded them in the following table.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Time</p></th>
<th style="text-align: left;">
<p>0:20</p></th>
<th style="text-align: left;">
<p>1:00</p></th>
<th style="text-align: left;">
<p>1:40</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>km/h</p></td>
<td style="text-align: left;">
<p>140</p></td>
<td style="text-align: left;">
<p>150</p></td>
<td style="text-align: left;">
<p>180</p></td>
</tr>
</tbody>
</table>

<p>A <strong>discretization</strong> would be to say that the speed of the car was constant from 0:00 to 0:40, then from 0:40 to 1:20 and finally from 1:20 to 2:00. For instance, the total distance traveled in the first 40 minutes is approximately (2/3h × 140 km/h) = 93.3 km. This would allow us to estimate the total distance traveled as 93.3 km + 100 km + 120 km = 313.3 km, which is an example of <strong>numerical integration</strong> (see below) using a <a href="Riemann_sum" title="wikilink">Riemann sum</a>, because displacement is the <a class="uri" href="integral" title="wikilink">integral</a> of velocity.</p>

<p><strong>Ill-conditioned problem</strong>: Take the function <em>f</em>(<em>x</em>) = 1/(<em>x</em> − 1). Note that <em>f</em>(1.1) = 10 and <em>f</em>(1.001) = 1000: a change in <em>x</em> of less than 0.1 turns into a change in <em>f</em>(<em>x</em>) of nearly 1000. Evaluating <em>f</em>(<em>x</em>) near <em>x</em> = 1 is an ill-conditioned problem.</p>

<p><strong>Well-conditioned problem</strong>: By contrast, evaluating the same function <em>f</em>(<em>x</em>) = 1/(<em>x</em> − 1) near <em>x</em> = 10 is a well-conditioned problem. For instance, <em>f</em>(10) = 1/9 ≈ 0.111 and <em>f</em>(11) = 0.1: a modest change in <em>x</em> leads to a modest change in <em>f</em>(<em>x</em>).</p></td>
</tr>
</tbody>
</table>

<p>Direct methods compute the solution to a problem in a finite number of steps. These methods would give the precise answer if they were performed in <a href="Computer_numbering_formats" title="wikilink">infinite precision arithmetic</a>. Examples include <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, the <a href="QR_algorithm" title="wikilink">QR</a> factorization method for solving <a href="system_of_linear_equations" title="wikilink">systems of linear equations</a>, and the <a href="simplex_method" title="wikilink">simplex method</a> of <a href="linear_programming" title="wikilink">linear programming</a>. In practice, <a href="Floating_point" title="wikilink">finite precision</a> is used and the result is an approximation of the true solution (assuming <a href="Numerically_stable" title="wikilink">stability</a>).</p>

<p>In contrast to direct methods, <a href="iterative_method" title="wikilink">iterative methods</a> are not expected to terminate in a finite number of steps. Starting from an initial guess, iterative methods form successive approximations that <a href="Limit_of_a_sequence" title="wikilink">converge</a> to the exact solution only in the limit. A convergence test, often involving <a href="Residual_(numerical_analysis)" title="wikilink">the residual</a>, is specified in order to decide when a sufficiently accurate solution has (hopefully) been found. Even using infinite precision arithmetic these methods would not reach the solution within a finite number of steps (in general). Examples include <a href="Newton's_method" title="wikilink">Newton's method</a>, the <a href="bisection_method" title="wikilink">bisection method</a>, and <a href="Jacobi_iteration" title="wikilink">Jacobi iteration</a>. In computational matrix algebra, iterative methods are generally needed for large problems.</p>

<p>Iterative methods are more common than direct methods in numerical analysis. Some methods are direct in principle but are usually used as though they were not, e.g. <a class="uri" href="GMRES" title="wikilink">GMRES</a> and the <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a>. For these methods the number of steps needed to obtain the exact solution is so large that an approximation is accepted in the same manner as for an iterative method.</p>
<h3 id="discretization">Discretization</h3>

<p>Furthermore, continuous problems must sometimes be replaced by a discrete problem whose solution is known to approximate that of the continuous problem; this process is called <em><a class="uri" href="discretization" title="wikilink">discretization</a></em>. For example, the solution of a <a href="differential_equation" title="wikilink">differential equation</a> is a <a href="function_(mathematics)" title="wikilink">function</a>. This function must be represented by a finite amount of data, for instance by its value at a finite number of points at its domain, even though this domain is a <a href="Continuum_(set_theory)" title="wikilink">continuum</a>.</p>
<h2 id="generation-and-propagation-of-errors">Generation and propagation of errors</h2>

<p>The study of errors forms an important part of numerical analysis. There are several ways in which error can be introduced in the solution of the problem.</p>
<h3 id="round-off">Round-off</h3>

<p><a href="Round-off_error" title="wikilink">Round-off errors</a> arise because it is impossible to represent all <a href="real_number" title="wikilink">real numbers</a> exactly on a machine with finite memory (which is what all practical <a href="digital_computer" title="wikilink">digital computers</a> are).</p>
<h3 id="truncation-and-discretization-error">Truncation and discretization error</h3>

<p><a class="uri" href="Truncation" title="wikilink">Truncation</a> errors are committed when an iterative method is terminated or a mathematical procedure is approximated, and the approximate solution differs from the exact solution. Similarly, discretization induces a <a href="discretization_error" title="wikilink">discretization error</a> because the solution of the discrete problem does not coincide with the solution of the continuous problem. For instance, in the iteration in the sidebar to compute the solution of 

<math display="inline" id="Numerical_analysis:2">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mn>3</mn>
    <mprescripts></mprescripts>
    <none></none>
    <mi>′′</mi>
   </mmultiscripts>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mn>4</mn>
   <mo>=</mo>
   <msup>
    <mn>28</mn>
    <mi>′′</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <ci>′′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <plus></plus>
    <cn type="integer">4</cn>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">28</cn>
     <ci>′′</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{\prime\prime}3x^{3}+4=28^{\prime\prime}
  </annotation>
 </semantics>
</math>

, after 10 or so iterations, we conclude that the root is roughly 1.99 (for example). We therefore have a truncation error of 0.01.</p>

<p>Once an error is generated, it will generally propagate through the calculation. For instance, we have already noted that the operation + on a calculator (or a computer) is inexact. It follows that a calculation of the type a+b+c+d+e is even more inexact.</p>

<p>What does it mean when we say that the truncation error is created when we approximate a mathematical procedure? We know that to integrate a function exactly requires one to find the sum of infinite trapezoids. But numerically one can find the sum of only finite trapezoids, and hence the approximation of the mathematical procedure. Similarly, to differentiate a function, the differential element approaches to zero but numerically we can only choose a finite value of the differential element.</p>
<h3 id="numerical-stability-and-well-posed-problems">Numerical stability and well-posed problems</h3>

<p><a href="Numerical_stability" title="wikilink">Numerical stability</a> is an important notion in numerical analysis. An algorithm is called <em>numerically stable</em> if an error, whatever its cause, does not grow to be much larger during the calculation. This happens if the problem is <em><a href="condition_number" title="wikilink">well-conditioned</a></em>, meaning that the solution changes by only a small amount if the problem data are changed by a small amount. To the contrary, if a problem is <em>ill-conditioned</em>, then any small error in the data will grow to be a large error.</p>

<p>Both the original problem and the algorithm used to solve that problem can be <em>well-conditioned</em> and/or <em>ill-conditioned</em>, and any combination is possible.</p>

<p>So an algorithm that solves a well-conditioned problem may be either numerically stable or numerically unstable. An art of numerical analysis is to find a stable algorithm for solving a well-posed mathematical problem. For instance, computing the square root of 2 (which is roughly 1.41421) is a well-posed problem. Many algorithms solve this problem by starting with an initial approximation <em>x</em><sub>1</sub> to 

<math display="inline" id="Numerical_analysis:3">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>


, for instance <em>x</em><sub>1</sub>=1.4, and then computing improved guesses <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, etc.. One such method is the famous <a href="Babylonian_method" title="wikilink">Babylonian method</a>, which is given by <em>x</em><sub><em>k</em>+1</sub> = <em>x<sub>k</sub></em>/2 + 1/<em>x<sub>k</sub></em>. Another iteration, which we will call Method X, is given by <em>x</em><sub><em>k</em> + 1</sub> = (<em>x</em><sub><em>k</em></sub><sup>2</sup>−2)<sup>2</sup> + <em>x</em><sub><em>k</em></sub>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> We have calculated a few iterations of each scheme in table form below, with initial guesses <em>x</em><sub>1</sub> = 1.4 and <em>x</em><sub>1</sub> = 1.42.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Babylonian</p></th>
<th style="text-align: left;">
<p>Babylonian</p></th>
<th style="text-align: left;">
<p>Method X</p></th>
<th style="text-align: left;">
<p>Method X</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>x</em><sub>1</sub> = 1.4</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>1</sub> = 1.42</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>1</sub> = 1.4</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>1</sub> = 1.42</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>x</em><sub>2</sub> = 1.4142857...</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>2</sub> = 1.41422535...</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>2</sub> = 1.4016</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>2</sub> = 1.42026896</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>x</em><sub>3</sub> = 1.414213564...</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>3</sub> = 1.41421356242...</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>3</sub> = 1.4028614...</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>3</sub> = 1.42056...</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>...</p></td>
<td style="text-align: left;">
<p>...</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><em>x</em><sub>1000000</sub> = 1.41421...</p></td>
<td style="text-align: left;">
<p><em>x</em><sub>28</sub> = 7280.2284...</p></td>
</tr>
</tbody>
</table>

<p>Observe that the Babylonian method converges fast regardless of the initial guess, whereas Method X converges extremely slowly with initial guess 1.4 and diverges for initial guess 1.42. Hence, the Babylonian method is numerically stable, while Method X is numerically unstable.</p>
<dl>
<dd><strong>Numerical stability</strong> is affected by the number of the significant digits the machine keeps on, if we use a machine that keeps on the first four floating-point digits, a good example on loss of significance is given by these two equivalent functions
</dd>
<dd><math>
</math></dd>
</dl>

<p>f(x)=x\left(\sqrt{x+1}-\sqrt{x}\right) \text{ and } g(x)=\frac{x}{\sqrt{x+1}+\sqrt{x}}. </p>
<dl>
<dd>If we compare the results of

<p>

<math display="block" id="Numerical_analysis:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>500</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>500</mn>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msqrt>
       <mn>501</mn>
      </msqrt>
      <mo>-</mo>
      <msqrt>
       <mn>500</mn>
      </msqrt>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>500</mn>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mn>22.3830</mn>
      <mo>-</mo>
      <mn>22.3607</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>500</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0.0223</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>11.1500</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">500</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">500</cn>
      <apply>
       <minus></minus>
       <apply>
        <root></root>
        <cn type="integer">501</cn>
       </apply>
       <apply>
        <root></root>
        <cn type="integer">500</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">500</cn>
      <apply>
       <minus></minus>
       <cn type="float">22.3830</cn>
       <cn type="float">22.3607</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">500</cn>
      <cn type="float">0.0223</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">11.1500</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(500)=500\left(\sqrt{501}-\sqrt{500}\right)=500\left(22.3830-22.3607\right)=5%
00(0.0223)=11.1500
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>and
</dd>
<dd><math>
</math></dd>
</dl>

<p>\begin{alignat}{3}g(500)&amp;=\frac{500}{\sqrt{501}+\sqrt{500}}\\</p>

<p><code>     &amp;=\frac{500}{22.3830+22.3607}\\</code><br/>
<code>     &amp;=\frac{500}{44.7437}=11.1748</code></p>

<p>\end{alignat} </p>
<dl>
<dd>by looking to the two results above, we realize that <strong><a href="loss_of_significance" title="wikilink">loss of significance</a></strong> which is also called <strong>Subtractive Cancelation</strong> has a huge effect on the results, even though both functions are equivalent; to show that they are equivalent simply we need to start by f(x) and end with g(x), and so

<p>:<math> \begin{alignat}{4}</math></p>
</dd>
</dl>

<p>f(x)&amp;=x \left(\sqrt{x+1}-\sqrt{x} \right)\\</p>

<p><code>   &amp; =x \left(\sqrt{x+1}-\sqrt{x} \right)\frac{\sqrt{x+1}+\sqrt{x}}{\sqrt{x+1}+\sqrt{x}}\\</code><br/>
<code>   &amp;=x\frac{(\sqrt{x+1})^2-(\sqrt{x})^2}{\sqrt{x+1}+\sqrt{x}}\\</code><br/>
<code>   &amp; =x\frac{x+1-x}{\sqrt{x+1}+\sqrt{x}}  \\</code><br/>
<code>   &amp; =x\frac{1}{\sqrt{x+1}+\sqrt{x}}  \\</code><br/>
<code>   &amp;=\frac {x}{\sqrt{x+1}+\sqrt{x}}</code></p>

<p>\end{alignat}</p>
<dl>
<dd>The true value for the result is 11.174755..., which is exactly <em>g</em>(500) = 11.1748 after rounding the result to 4 decimal digits.
</dd>
<dd>Now imagine that lots of terms like these functions are used in the program; the error will increase as one proceeds in the program, unless one uses the suitable formula of the two functions each time one evaluates either <em>f</em>(<em>x</em>), or <em>g</em>(<em>x</em>); the choice is dependent on the parity of <em>x</em>.
</dd>
</dl>
<ul>
<li>The example is taken from Mathew; Numerical methods using matlab, 3rd ed.</li>
</ul>
<h2 id="areas-of-study">Areas of study</h2>

<p>The field of numerical analysis includes many sub-disciplines. Some of the major ones are:</p>
<h3 id="computing-values-of-functions">Computing values of functions</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Interpolation</strong>: We have observed the temperature to vary from 20 degrees Celsius at 1:00 to 14 degrees at 3:00. A linear interpolation of this data would conclude that it was 17 degrees at 2:00 and 18.5 degrees at 1:30pm. <strong>Extrapolation</strong>: If the <a href="gross_domestic_product" title="wikilink">gross domestic product</a> of a country has been growing an average of 5% per year and was 100 billion dollars last year, we might extrapolate that it will be 105 billion dollars this year.</p></td>
<td style="text-align: left;">
<p> <strong>Regression</strong>: In linear regression, given <em>n</em> points, we compute a line that passes as close as possible to those <em>n</em> points.</p></td>
<td style="text-align: left;">
<p> <strong>Optimization</strong>: Say you sell lemonade at a <a href="lemonade_stand" title="wikilink">lemonade stand</a>, and notice that at $1, you can sell 197 glasses of lemonade per day, and that for each increase of $0.01, you will sell one glass of lemonade less per day. If you could charge $1.485, you would maximize your profit, but due to the constraint of having to charge a whole cent amount, charging $1.48 or $1.49 per glass will both yield the maximum income of $220.52 per day.</p></td>
<td style="text-align: left;">
<p> <strong>Differential equation</strong>: If you set up 100 fans to blow air from one end of the room to the other and then you drop a feather into the wind, what happens? The feather will follow the air currents, which may be very complex. One approximation is to measure the speed at which the air is blowing near the feather every second, and advance the simulated feather as if it were moving in a straight line at that same speed for one second, before measuring the wind speed again. This is called the <a href="Euler_method" title="wikilink">Euler method</a> for solving an ordinary differential equation.</p></td>
</tr>
</tbody>
</table>

<p>One of the simplest problems is the evaluation of a function at a given point. The most straightforward approach, of just plugging in the number in the formula is sometimes not very efficient. For polynomials, a better approach is using the <a href="Horner_scheme" title="wikilink">Horner scheme</a>, since it reduces the necessary number of multiplications and additions. Generally, it is important to estimate and control <a href="round-off_error" title="wikilink">round-off errors</a> arising from the use of <a href="floating_point" title="wikilink">floating point</a> arithmetic.</p>
<h3 id="interpolation-extrapolation-and-regression">Interpolation, extrapolation, and regression</h3>

<p><a class="uri" href="Interpolation" title="wikilink">Interpolation</a> solves the following problem: given the value of some unknown function at a number of points, what value does that function have at some other point between the given points?</p>

<p><a class="uri" href="Extrapolation" title="wikilink">Extrapolation</a> is very similar to interpolation, except that now we want to find the value of the unknown function at a point which is outside the given points.</p>

<p><a href="Regression_analysis" title="wikilink">Regression</a> is also similar, but it takes into account that the data is imprecise. Given some points, and a measurement of the value of some function at these points (with an error), we want to determine the unknown function. The <a href="least_squares" title="wikilink">least squares</a>-method is one popular way to achieve this.</p>
<h3 id="solving-equations-and-systems-of-equations">Solving equations and systems of equations</h3>

<p>Another fundamental problem is computing the solution of some given equation. Two cases are commonly distinguished, depending on whether the equation is linear or not. For instance, the equation 

<math display="inline" id="Numerical_analysis:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>5</mn>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2x+5=3
  </annotation>
 </semantics>
</math>

 is linear while 

<math display="inline" id="Numerical_analysis:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mn>5</mn>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2x^{2}+5=3
  </annotation>
 </semantics>
</math>

 is not.</p>

<p>Much effort has been put in the development of methods for solving <a href="systems_of_linear_equations" title="wikilink">systems of linear equations</a>. Standard direct methods, i.e., methods that use some <a href="matrix_decomposition" title="wikilink">matrix decomposition</a> are <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, <a href="LU_decomposition" title="wikilink">LU decomposition</a>, <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a> for <a href="symmetric_matrix" title="wikilink">symmetric</a> (or <a href="hermitian_matrix" title="wikilink">hermitian</a>) and <a href="positive-definite_matrix" title="wikilink">positive-definite matrix</a>, and <a href="QR_decomposition" title="wikilink">QR decomposition</a> for non-square matrices. <a href="Iterative_method" title="wikilink">Iterative methods</a> such as the <a href="Jacobi_method" title="wikilink">Jacobi method</a>, <a href="Gauss–Seidel_method" title="wikilink">Gauss–Seidel method</a>, <a href="successive_over-relaxation" title="wikilink">successive over-relaxation</a> and <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a> are usually preferred for large systems. General iterative methods can be developed using a <a href="matrix_splitting" title="wikilink">matrix splitting</a>.</p>

<p><a href="Root-finding_algorithm" title="wikilink">Root-finding algorithms</a> are used to solve nonlinear equations (they are so named since a root of a function is an argument for which the function yields zero). If the function is <a href="derivative" title="wikilink">differentiable</a> and the derivative is known, then <a href="Newton's_method" title="wikilink">Newton's method</a> is a popular choice. <a class="uri" href="Linearization" title="wikilink">Linearization</a> is another technique for solving nonlinear equations.</p>
<h3 id="solving-eigenvalue-or-singular-value-problems">Solving eigenvalue or singular value problems</h3>

<p>Several important problems can be phrased in terms of <a href="eigenvalue_decomposition" title="wikilink">eigenvalue decompositions</a> or <a href="singular_value_decomposition" title="wikilink">singular value decompositions</a>. For instance, the <a href="image_compression" title="wikilink">spectral image compression</a> algorithm<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is based on the singular value decomposition. The corresponding tool in statistics is called <a href="principal_component_analysis" title="wikilink">principal component analysis</a>.</p>
<h3 id="optimization">Optimization</h3>

<p>Optimization problems ask for the point at which a given function is maximized (or minimized). Often, the point also has to satisfy some <a href="Constraint_(mathematics)" title="wikilink">constraints</a>.</p>

<p>The field of optimization is further split in several subfields, depending on the form of the objective function and the constraint. For instance, <a href="linear_programming" title="wikilink">linear programming</a> deals with the case that both the objective function and the constraints are linear. A famous method in linear programming is the <a href="simplex_method" title="wikilink">simplex method</a>.</p>

<p>The method of <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a> can be used to reduce optimization problems with constraints to unconstrained optimization problems.</p>
<h3 id="evaluating-integrals">Evaluating integrals</h3>

<p>Numerical integration, in some instances also known as numerical <a href="quadrature_(mathematics)" title="wikilink">quadrature</a>, asks for the value of a definite <a class="uri" href="integral" title="wikilink">integral</a>. Popular methods use one of the <a href="Newton–Cotes_formulas" title="wikilink">Newton–Cotes formulas</a> (like the midpoint rule or <a href="Simpson's_rule" title="wikilink">Simpson's rule</a>) or <a href="Gaussian_quadrature" title="wikilink">Gaussian quadrature</a>. These methods rely on a "divide and conquer" strategy, whereby an integral on a relatively large set is broken down into integrals on smaller sets. In higher dimensions, where these methods become prohibitively expensive in terms of computational effort, one may use <a href="Monte_Carlo_method" title="wikilink">Monte Carlo</a> or <a href="quasi-Monte_Carlo_method" title="wikilink">quasi-Monte Carlo methods</a> (see <a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a>), or, in modestly large dimensions, the method of <a href="sparse_grid" title="wikilink">sparse grids</a>.</p>
<h3 id="differential-equations">Differential equations</h3>

<p>Numerical analysis is also concerned with computing (in an approximate way) the solution of <a href="differential_equation" title="wikilink">differential equations</a>, both ordinary differential equations and <a href="partial_differential_equation" title="wikilink">partial differential equations</a>.</p>

<p>Partial differential equations are solved by first discretizing the equation, bringing it into a finite-dimensional subspace. This can be done by a <a href="finite_element_method" title="wikilink">finite element method</a>, a <a href="finite_difference" title="wikilink">finite difference</a> method, or (particularly in engineering) a <a href="finite_volume_method" title="wikilink">finite volume method</a>. The theoretical justification of these methods often involves theorems from <a href="functional_analysis" title="wikilink">functional analysis</a>. This reduces the problem to the solution of an algebraic equation.</p>
<h2 id="software">Software</h2>

<p>Since the late twentieth century, most algorithms are implemented in a variety of programming languages. The <a class="uri" href="Netlib" title="wikilink">Netlib</a> repository contains various collections of software routines for numerical problems, mostly in <a class="uri" href="Fortran" title="wikilink">Fortran</a> and <a href="C_(programming_language)" title="wikilink">C</a>. Commercial products implementing many different numerical algorithms include the <a href="IMSL_Numerical_Libraries" title="wikilink">IMSL</a> and <a href="Numerical_Algorithms_Group" title="wikilink">NAG</a> libraries; a free alternative is the <a href="GNU_Scientific_Library" title="wikilink">GNU Scientific Library</a>.</p>

<p>There are several popular numerical computing applications such as <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, <a href="TK_Solver" title="wikilink">TK Solver</a>, <a class="uri" href="S-PLUS" title="wikilink">S-PLUS</a>, <a class="uri" href="LabVIEW" title="wikilink">LabVIEW</a>, and <a href="IDL_(programming_language)" title="wikilink">IDL</a> as well as free and open source alternatives such as <a class="uri" href="FreeMat" title="wikilink">FreeMat</a>, <a class="uri" href="Scilab" title="wikilink">Scilab</a>, <a href="GNU_Octave" title="wikilink">GNU Octave</a> (similar to Matlab), <a class="uri" href="IT++" title="wikilink">IT++</a> (a C++ library), <a href="R_(programming_language)" title="wikilink">R</a> (similar to S-PLUS) and certain variants of <a href="Python_(programming_language)" title="wikilink">Python</a>. Performance varies widely: while vector and matrix operations are usually fast, scalar loops may vary in speed by more than an order of magnitude.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Many <a href="computer_algebra_system" title="wikilink">computer algebra systems</a> such as <a class="uri" href="Mathematica" title="wikilink">Mathematica</a> also benefit from the availability of <a href="arbitrary_precision_arithmetic" title="wikilink">arbitrary precision arithmetic</a> which can provide more accurate results.</p>

<p>Also, any <a class="uri" href="spreadsheet" title="wikilink">spreadsheet</a> software can be used to solve simple problems relating to numerical analysis.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Analysis_of_algorithms" title="wikilink">Analysis of algorithms</a></li>
<li><a href="Computational_science" title="wikilink">Computational science</a></li>
<li><a href="List_of_numerical_analysis_topics" title="wikilink">List of numerical analysis topics</a></li>
<li><a href="Numerical_differentiation" title="wikilink">Numerical differentiation</a></li>
<li><em><a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a></em></li>
<li><a href="Symbolic-numeric_computation" title="wikilink">Symbolic-numeric computation</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(examples of the importance of accurate arithmetic).</p></li>
<li><a href="Lloyd_N._Trefethen" title="wikilink">Trefethen, Lloyd N.</a> (2006). <a href="http://people.maths.ox.ac.uk/trefethen/NAessay.pdf">"Numerical analysis"</a>, 20 pages. In: Timothy Gowers and June Barrow-Green (editors), <em>Princeton Companion of Mathematics</em>, Princeton University Press.</li>
</ul>
<h2 id="external-links">External links</h2>

<p><strong>Journals</strong></p>
<ul>
<li><a href="http://www-gdz.sub.uni-goettingen.de/cgi-bin/digbib.cgi?PPN362160546">Numerische Mathematik</a>, volumes 1-66, Springer, 1959-1994 (searchable; pages are images).  </li>
<li><a href="http://www.springerlink.com/content/0029-599X">Numerische Mathematik at SpringerLink</a>, volumes 1-112, Springer, 1959–2009</li>
<li><a href="http://siamdl.aip.org/dbt/dbt.jsp?KEY=SJNAAM">SIAM Journal on Numerical Analysis</a>, volumes 1-47, SIAM, 1964–2009</li>
</ul>

<p><strong>Online texts</strong></p>
<ul>
<li></li>
<li><a href="http://www.nr.com/oldverswitcher.html"><em>Numerical Recipes</em></a>, William H. Press (free, downloadable previous editions)</li>
<li><a href="https://web.archive.org/web/20120225082123/http://kr.cs.ait.ac.th/~radok/math/mat7/stepsa.htm"><em>First Steps in Numerical Analysis</em></a> (<a href="internet_archive" title="wikilink">archived</a>), R.J.Hosking, S.Joe, D.C.Joyce, and J.C.Turner</li>
<li><a href="http://www.phy.ornl.gov/csep/CSEP/TEXTOC.html"><em>CSEP</em> (Computational Science Education Project)</a>, <a href="U.S._Department_of_Energy" title="wikilink">U.S. Department of Energy</a></li>
</ul>

<p><strong>Online course material</strong></p>
<ul>
<li><a href="http://www.damtp.cam.ac.uk/user/fdl/people/sd103/lectures/nummeth98/index.htm#L_1_Title_Page">Numerical Methods</a>, Stuart Dalziel <a href="University_of_Cambridge" title="wikilink">University of Cambridge</a></li>
<li><a href="http://www.math.upenn.edu/~wilf/DeturckWilf.pdf">Lectures on Numerical Analysis</a>, Dennis Deturck and Herbert S. Wilf <a href="University_of_Pennsylvania" title="wikilink">University of Pennsylvania</a></li>
<li><a href="http://johndfenton.com/Lectures/Numerical-Methods/Numerical-Methods.pdf">Numerical methods</a>, John D. Fenton <a href="University_of_Karlsruhe" title="wikilink">University of Karlsruhe</a></li>
<li><a href="http://numericalmethods.eng.usf.edu/">Numerical Methods for Science, Technology, Engineering and Mathematics</a>, Autar Kaw <a href="University_of_South_Florida" title="wikilink">University of South Florida</a></li>
<li><a href="http://math.fullerton.edu/mathews/numerical.html">Numerical Analysis Project</a>, John H. Mathews <a href="California_State_University,_Fullerton" title="wikilink">California State University, Fullerton</a></li>
<li><a href="http://www.math.jct.ac.il/~naiman/nm/">Numerical Methods - Online Course</a>, Aaron Naiman <a href="Jerusalem_College_of_Technology" title="wikilink">Jerusalem College of Technology</a></li>
<li><a href="http://www-teaching.physics.ox.ac.uk/computing/NumericalMethods/NMfP.pdf">Numerical Methods for Physicists</a>, Anthony O’Hare <a href="Oxford_University" title="wikilink">Oxford University</a></li>
<li><a href="https://web.archive.org/web/20120225082123/http://kr.cs.ait.ac.th/~radok/math/mat7/stepsa.htm">Lectures in Numerical Analysis</a> (<a href="internet_archive" title="wikilink">archived</a>), R. Radok <a href="Mahidol_University" title="wikilink">Mahidol University</a></li>
<li><a href="http://ocw.mit.edu/courses/mechanical-engineering/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/">Introduction to Numerical Analysis for Engineering</a>, Henrik Schmidt <a href="Massachusetts_Institute_of_Technology" title="wikilink">Massachusetts Institute of Technology</a></li>
<li><a href="http://jwhaverkort.net23.net/documents/NumMethPDEs.pdf">Numerical Methods for time-dependent Partial Differential Equations</a>, J.W. Haverkort, based on a course by P.A. Zegeling <a class="uri" href="Utrecht_University" title="wikilink">Utrecht_University</a></li>
<li><a href="http://ece.uwaterloo.ca/~dwharder/NumericalAnalysis/"><em>Numerical Analysis for Engineering</em></a>, D. W. Harder <a href="University_of_Waterloo" title="wikilink">University of Waterloo</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink"> Numerical analysis</a> <a href="Category:Mathematical_physics" title="wikilink">Category:Mathematical physics</a> <a href="Category:Computational_science" title="wikilink">Category:Computational science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The New Zealand Qualification authority specifically mentions this skill in document 13004 version 2, dated 17 October 2003 titled <a href="http://www.nzqa.govt.nz/nqfdocs/units/pdf/13004.pdf">CARPENTRY THEORY: Demonstrate knowledge of setting out a building</a><a href="#fnref1">↩</a></li>
<li id="fn2">This is a <a href="fixed_point_iteration" title="wikilink">fixed point iteration</a> for the equation 

<math display="inline" id="Numerical_analysis:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x^{2}-2)^{2}+x=f(x)
  </annotation>
 </semantics>
</math>

, whose solutions include 

<math display="inline" id="Numerical_analysis:8">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>


. The iterates always move to the right since 

<math display="inline" id="Numerical_analysis:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\geq x
  </annotation>
 </semantics>
</math>

. Hence 

<math display="inline" id="Numerical_analysis:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1.4</mn>
   <mo><</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="float">1.4</cn>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=1.4<\sqrt{2}
  </annotation>
 </semantics>
</math>

 converges and 

<math display="inline" id="Numerical_analysis:11">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1.42</mn>
   <mo>></mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="float">1.42</cn>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=1.42>\sqrt{2}
  </annotation>
 </semantics>
</math>

 diverges.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://online.redwoods.cc.ca.us/instruct/darnold/maw/single.htm">The Singular Value Decomposition and Its Applications in Image Compression</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.sciviews.org/benchmark/">Speed comparison of various number crunching packages</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.scientificweb.com/ncrunch/ncrunch5.pdf">Comparison of mathematical programs for data analysis</a> Stefan Steinhaus, ScientificWeb.com<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
