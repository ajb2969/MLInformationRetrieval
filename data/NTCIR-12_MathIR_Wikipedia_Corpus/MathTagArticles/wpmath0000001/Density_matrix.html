<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1912">Density matrix</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Density matrix</h1>
<hr/>

<p>A <strong>density matrix</strong> is a <a href="matrix_(math)" title="wikilink">matrix</a> that describes a <a href="quantum_system" title="wikilink">quantum system</a> in a <em>mixed state</em>, a <a href="statistical_ensemble" title="wikilink">statistical ensemble</a> of several <a href="quantum_state" title="wikilink">quantum states</a>. This should be contrasted with a single <a href="quantum_state" title="wikilink">state vector</a> that describes a quantum system in a <em>pure state</em>. The density matrix is the quantum-mechanical analogue to a <a href="phase_space" title="wikilink">phase-space</a> <a href="probability_measure" title="wikilink">probability measure</a> (probability distribution of position and momentum) in classical <a href="statistical_mechanics" title="wikilink">statistical mechanics</a>.</p>

<p>Explicitly, suppose a quantum system may be found in state 

<math display="inline" id="Density_matrix:0">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{1}\rangle
  </annotation>
 </semantics>
</math>

 with probability <em>p</em><sub>1</sub>, or it may be found in state 

<math display="inline" id="Density_matrix:1">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{2}\rangle
  </annotation>
 </semantics>
</math>

 with probability <em>p</em><sub>2</sub>, or it may be found in state 

<math display="inline" id="Density_matrix:2">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>3</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{3}\rangle
  </annotation>
 </semantics>
</math>

 with probability <em>p</em><sub>3</sub>, and so on. The <strong>density operator</strong> for this system is<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Density_matrix:3">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>ρ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>ψ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>ψ</mi>
        <mi>i</mi>
       </msub>
       <mo fence="true" stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}=\sum_{i}p_{i}|\psi_{i}\rangle\langle\psi_{i}|,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Density_matrix:4">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|\psi_{i}\rangle\}
  </annotation>
 </semantics>
</math>

 need not be orthogonal and 

<math display="inline" id="Density_matrix:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}p_{i}=1
  </annotation>
 </semantics>
</math>

. By choosing an orthonormal basis 

<math display="inline" id="Density_matrix:6">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>u</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|u_{m}\rangle\}
  </annotation>
 </semantics>
</math>

, one may resolve the density operator into the density matrix, whose elements are<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Density_matrix:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>m</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>u</mi>
        <mi>m</mi>
       </msub>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>ψ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>ψ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>u</mi>
      <mi>m</mi>
     </msub>
     <mo fence="true" stretchy="false">|</mo>
     <mover accent="true">
      <mi>ρ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>u</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">inner-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">inner-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>ρ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{mn}=\sum_{i}p_{i}\langle u_{m}|\psi_{i}\rangle\langle\psi_{i}|u_{n}%
\rangle=\langle u_{m}|\hat{\rho}|u_{n}\rangle.
  </annotation>
 </semantics>
</math>

 The density operator can also be defined in terms of the density matrix,</p>

<p>

<math display="block" id="Density_matrix:8">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>ρ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mi>n</mi>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>u</mi>
        <mi>m</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>ρ</mi>
       <mrow>
        <mi>m</mi>
        <mi>n</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo fence="true" stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}=\sum_{mn}|u_{m}\rangle\rho_{mn}\langle u_{n}|.
  </annotation>
 </semantics>
</math>

</p>

<p>For an operator 

<math display="inline" id="Density_matrix:9">
 <semantics>
  <mover accent="true">
   <mi>A</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{A}
  </annotation>
 </semantics>
</math>

 (which describes an observable 

<math display="inline" id="Density_matrix:10">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 of the system), the <a href="expectation_value_(quantum_mechanics)" title="wikilink">expectation value</a> 

<math display="inline" id="Density_matrix:11">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>A</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle
  </annotation>
 </semantics>
</math>

 is given by<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Density_matrix:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>A</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>ψ</mi>
        <mi>i</mi>
       </msub>
       <mo fence="true" stretchy="false">|</mo>
       <mover accent="true">
        <mi>A</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>ψ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mi>n</mi>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>u</mi>
        <mi>m</mi>
       </msub>
       <mo fence="true" stretchy="false">|</mo>
       <mover accent="true">
        <mi>ρ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo fence="true" stretchy="false">|</mo>
       <mover accent="true">
        <mi>A</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>u</mi>
        <mi>m</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mi>n</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>ρ</mi>
       <mrow>
        <mi>m</mi>
        <mi>n</mi>
       </mrow>
      </msub>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>n</mi>
        <mi>m</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ρ</mi>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">quantum-operator-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">quantum-operator-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <ci>ρ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">quantum-operator-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>tr</ci>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle=\sum_{i}p_{i}\langle\psi_{i}|\hat{A}|\psi_{i}\rangle=\sum_{mn%
}\langle u_{m}|\hat{\rho}|u_{n}\rangle\langle u_{n}|\hat{A}|u_{m}\rangle=\sum_%
{mn}\rho_{mn}A_{nm}=\operatorname{tr}(\rho A).
  </annotation>
 </semantics>
</math>

 In words, the expectation value of <em>A</em> for the mixed state is the sum of the expectation values of <em>A</em> for each of the pure states 

<math display="inline" id="Density_matrix:13">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{i}\rangle
  </annotation>
 </semantics>
</math>

 weighted by the probabilities <em>p<sub>i</sub></em> and can be computed as the <a href="trace_(linear_algebra)" title="wikilink">trace</a> of the product of the density matrix with the matrix representation of 

<math display="inline" id="Density_matrix:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in the same basis.</p>

<p>Mixed states arise in situations where the experimenter does not know which particular states are being manipulated. Examples include a <a href="canonical_ensemble" title="wikilink">system in thermal equilibrium</a> (or <a href="grand_canonical_ensemble" title="wikilink">additionally chemical equilibrium</a>) or a system with an uncertain or randomly varying preparation history (so one does not know which pure state the system is in). Also, if a quantum system has two or more subsystems that are <a href="Quantum_entanglement" title="wikilink">entangled</a>, then each subsystem must be treated as a mixed state even if the complete system is in a pure state.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The density matrix is also a crucial tool in <a href="quantum_decoherence" title="wikilink">quantum decoherence</a> theory.</p>

<p>The density matrix is a representation of a <a href="linear_operator" title="wikilink">linear operator</a> called the <em>density operator</em>. The close relationship between matrices and operators is a basic concept in <a href="linear_algebra" title="wikilink">linear algebra</a>. In practice, the terms <em>density matrix</em> and <em>density operator</em> are often used interchangeably. Both matrix and operator are <a class="uri" href="self-adjoint" title="wikilink">self-adjoint</a> (or <a href="Hermitian_matrix" title="wikilink">Hermitian</a>), <a href="positive-semidefinite_matrix" title="wikilink">positive semi-definite</a>, of <a href="trace_class" title="wikilink">trace</a> one, and may be <a href="Dimension_(vector_space)" title="wikilink">infinite-dimensional</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The formalism was introduced by <a href="John_von_Neumann" title="wikilink">John von Neumann</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> in 1927 and independently, but less systematically by <a href="Lev_Landau" title="wikilink">Lev Landau</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and <a href="Felix_Bloch" title="wikilink">Felix Bloch</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> in 1927 and 1946 respectively.</p>
<h2 id="pure-and-mixed-states">Pure and mixed states</h2>

<p>In <a href="mathematical_formulation_of_quantum_mechanics#Mathematical_structure_of_quantum_mechanics" title="wikilink">quantum mechanics</a>, a quantum system is represented by a <a href="quantum_state" title="wikilink">state vector</a> (or <a href="bra–ket_notation" title="wikilink">ket</a>) 

<math display="inline" id="Density_matrix:15">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

. A quantum system with a state vector 

<math display="inline" id="Density_matrix:16">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 is called a <em>pure state</em>. However, it is also possible for a system to be in a <a href="statistical_ensemble" title="wikilink">statistical ensemble</a> of different state vectors: For example, there may be a 50% probability that the state vector is 

<math display="inline" id="Density_matrix:17">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{1}\rangle
  </annotation>
 </semantics>
</math>

 and a 50% chance that the state vector is 

<math display="inline" id="Density_matrix:18">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{2}\rangle
  </annotation>
 </semantics>
</math>

. This system would be in a <em>mixed state</em>. The density matrix is especially useful for mixed states, because any state, pure or mixed, can be characterized by a single density matrix.</p>

<p>A mixed state is different from a <a href="quantum_superposition" title="wikilink">quantum superposition</a>. In fact, a quantum superposition of pure states is another pure state, for example 

<math display="inline" id="Density_matrix:19">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>ψ</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>ψ</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=(|\psi_{1}\rangle+|\psi_{2}\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>A state is pure if and only if its density matrix 

<math display="inline" id="Density_matrix:20">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Density_matrix:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>ρ</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   tr(\rho^{2})=1
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="example-light-polarization">Example: Light polarization</h3>

<p>[[<a class="uri" href="File:vertical">File:vertical</a> polarization.svg|right|thumb|200px|The incandescent light bulb (1) emits completely random polarized photons (2) with mixed state density matrix<br/>
</p>
<center>

<p>

<math display="inline" id="Density_matrix:22">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn>0.5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0.5</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="float">0.5</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="float">0.5</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}0.5&0\\
0&0.5\\
\end{bmatrix}
  </annotation>
 </semantics>
</math>

 <span style="vertical-align:bottom">。</span></p>
</center>

<p><br/>
After passing through vertical plane polarizer (3), the remaining photons are all vertically polarized (4) and have pure state density matrix<br/>
</p>
<center>

<p>

<math display="inline" id="Density_matrix:23">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0\\
0&0\\
\end{bmatrix}
  </annotation>
 </semantics>
</math>

 <span style="vertical-align:bottom">。</span></p>
</center>

<p>]] An example of pure and mixed states is <a href="light_polarization" title="wikilink">light polarization</a>. Photons can have two <a href="circular_polarization" title="wikilink">helicities</a>, corresponding to two orthogonal quantum states, 

<math display="inline" id="Density_matrix:24">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R\rangle
  </annotation>
 </semantics>
</math>

 (right <a href="circular_polarization" title="wikilink">circular polarization</a>) and 

<math display="inline" id="Density_matrix:25">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>L</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |L\rangle
  </annotation>
 </semantics>
</math>

 (left <a href="circular_polarization" title="wikilink">circular polarization</a>). A photon can also be in a superposition state, such as 

<math display="inline" id="Density_matrix:26">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>R</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>L</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|R\rangle+|L\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

 (vertical polarization) or 

<math display="inline" id="Density_matrix:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>R</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>L</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|R\rangle-|L\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

 (horizontal polarization). More generally, it can be in any state 

<math display="inline" id="Density_matrix:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>R</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>L</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha|R\rangle+\beta|L\rangle
  </annotation>
 </semantics>
</math>

, corresponding to <a href="linear_polarization" title="wikilink">linear</a>, <a href="circular_polarization" title="wikilink">circular</a>, or <a href="elliptical_polarization" title="wikilink">elliptical polarization</a>. If we pass 

<math display="inline" id="Density_matrix:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>R</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>L</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|R\rangle+|L\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

 polarized light through a <a href="circular_polarizer" title="wikilink">circular polarizer</a> which allows either only 

<math display="inline" id="Density_matrix:30">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R\rangle
  </annotation>
 </semantics>
</math>

 polarized light, or only 

<math display="inline" id="Density_matrix:31">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>L</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |L\rangle
  </annotation>
 </semantics>
</math>

 polarized light, intensity would be reduced by half in both cases. This may make it <em>seem</em> like half of the photons are in state 

<math display="inline" id="Density_matrix:32">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R\rangle
  </annotation>
 </semantics>
</math>

 and the other half in state 

<math display="inline" id="Density_matrix:33">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>L</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |L\rangle
  </annotation>
 </semantics>
</math>

. But this is not correct: Both 

<math display="inline" id="Density_matrix:34">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Density_matrix:35">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>L</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |L\rangle
  </annotation>
 </semantics>
</math>

 photons are partly absorbed by a vertical <a href="linear_polarizer" title="wikilink">linear polarizer</a>, but the 

<math display="inline" id="Density_matrix:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>R</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>L</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|R\rangle+|L\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

 light will pass through that polarizer with no absorption whatsoever.</p>

<p>However, <a href="unpolarized_light" title="wikilink">unpolarized light</a> (such as the light from an <a href="incandescent_light_bulb" title="wikilink">incandescent light bulb</a>) is different from any state like 

<math display="inline" id="Density_matrix:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>R</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>L</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha|R\rangle+\beta|L\rangle
  </annotation>
 </semantics>
</math>

 (linear, circular, or elliptical polarization). Unlike linearly or elliptically polarized light, it passes through a polarizer with 50% intensity loss whatever the orientation of the polarizer; and unlike circularly polarized light, it cannot be made linearly polarized with any <a href="wave_plate" title="wikilink">wave plate</a>. Indeed, unpolarized light cannot be described as <em>any</em> state of the form 

<math display="inline" id="Density_matrix:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>R</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>L</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha|R\rangle+\beta|L\rangle
  </annotation>
 </semantics>
</math>

. However, unpolarized light <em>can</em> be described perfectly by assuming that each photon is either 

<math display="inline" id="Density_matrix:39">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R\rangle
  </annotation>
 </semantics>
</math>

 with 50% probability or 

<math display="inline" id="Density_matrix:40">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>L</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |L\rangle
  </annotation>
 </semantics>
</math>

 with 50% probability. The same behavior would occur if each photon was either vertically polarized with 50% probability or horizontally polarized with 50% probability.</p>

<p>Therefore, unpolarized light cannot be described by any pure state, but can be described as a <a href="statistical_ensemble" title="wikilink">statistical ensemble</a> of pure states in at least two ways (the ensemble of half left and half right circularly polarized, or the ensemble of half vertically and half horizontally linearly polarized). These two ensembles are completely indistinguishable experimentally, and therefore they are considered the same mixed state. One of the advantages of the density matrix is that there is just one density matrix for each mixed state, whereas there are many statistical ensembles of pure states for each mixed state. Nevertheless, the density matrix contains all the information necessary to calculate any measurable property of the mixed state.</p>

<p>Where do mixed states come from? To answer that, consider how to generate unpolarized light. One way is to use a system in <a href="thermal_equilibrium" title="wikilink">thermal equilibrium</a>, a statistical mixture of enormous numbers of <a href="Microstate_(statistical_mechanics)" title="wikilink">microstates</a>, each with a certain probability (the <a href="Boltzmann_factor" title="wikilink">Boltzmann factor</a>), switching rapidly from one to the next due to <a href="thermal_fluctuations" title="wikilink">thermal fluctuations</a>. Thermal randomness explains why an <a href="incandescent_light_bulb" title="wikilink">incandescent light bulb</a>, for example, emits unpolarized light. A second way to generate unpolarized light is to introduce uncertainty in the preparation of the system, for example, passing it through a <a href="birefringent_crystal" title="wikilink">birefringent crystal</a> with a rough surface, so that slightly different parts of the beam acquire different polarizations. A third way to generate unpolarized light uses an <a href="EPR_paradox" title="wikilink">EPR</a> setup: A radioactive decay can emit two photons traveling in opposite directions, in the quantum state 

<math display="inline" id="Density_matrix:41">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mi>R</mi>
       <mo>,</mo>
       <mi>L</mi>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mi>L</mi>
       <mo>,</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <list>
       <ci>R</ci>
       <ci>L</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <list>
       <ci>L</ci>
       <ci>R</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|R,L\rangle+|L,R\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

. The two photons <em>together</em> are in a pure state, but if you only look at one of the photons and ignore the other, the photon behaves just like unpolarized light.</p>

<p>More generally, mixed states commonly arise from a statistical mixture of the starting state (such as in thermal equilibrium), from uncertainty in the preparation procedure (such as slightly different paths that a photon can travel), or from looking at a subsystem entangled with something else.</p>
<h3 id="mathematical-description">Mathematical description</h3>

<p>The <a href="quantum_state" title="wikilink">state vector</a> 

<math display="inline" id="Density_matrix:42">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 of a pure state completely determines the statistical behavior of a measurement. For concreteness, take an observable quantity, and let <em>A</em> be the associated <a href="observable" title="wikilink">observable operator</a> that has a representation on the <a href="Hilbert_space" title="wikilink">Hilbert space</a> 

<math display="inline" id="Density_matrix:43">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 of the quantum system. For any real-valued, analytical function <em>F</em> defined on the real numbers,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> suppose that <em>F</em>(<em>A</em>) is the result of applying <em>F</em> to the outcome of a measurement. The expectation value of <em>F</em>(<em>A</em>) is</p>

<p>

<math display="block" id="Density_matrix:44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ψ</mi>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo rspace="4.2pt" stretchy="false">⟩</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">quantum-operator-product</csymbol>
    <ci>ψ</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>A</ci>
    </apply>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\psi|F(A)|\psi\rangle\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Now consider a mixed state prepared by statistically combining two different pure states 

<math display="inline" id="Density_matrix:45">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Density_matrix:46">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
 </semantics>
</math>

, with the associated probabilities <em>p</em> and , respectively. The associated probabilities mean that the preparation process for the quantum system ends in the state 

<math display="inline" id="Density_matrix:47">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 with probability <em>p</em> and in the state 

<math display="inline" id="Density_matrix:48">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
 </semantics>
</math>

 with probability .</p>

<p>It is not hard to show that the statistical properties of the observable for the system prepared in such a mixed state are completely determined. However, there is no state vector 

<math display="inline" id="Density_matrix:49">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ξ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\xi\rangle
  </annotation>
 </semantics>
</math>

 which determines this statistical behavior in the sense that the expectation value of <em>F</em>(<em>A</em>) is</p>

<p>

<math display="block" id="Density_matrix:50">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ξ</mi>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ξ</mi>
    <mo rspace="4.2pt" stretchy="false">⟩</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">quantum-operator-product</csymbol>
    <ci>ξ</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>A</ci>
    </apply>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\xi|F(A)|\xi\rangle\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Nevertheless, there <em>is</em> a unique operator <em>ρ</em> such that the expectation value of <em>F(A)</em> can be written as</p>

<p>

<math display="block" id="Density_matrix:51">
 <semantics>
  <mrow>
   <mrow>
    <mo>tr</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>ρ</mi>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>tr</ci>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>F</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}[\rho F(A)]\,,
  </annotation>
 </semantics>
</math>

</p>

<p>where the operator <em>ρ</em> is the density operator of the mixed system. A simple calculation shows that the operator <em>ρ</em> for the above discussion is given by</p>

<p>

<math display="block" id="Density_matrix:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>=</mo>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>ψ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>ψ</mi>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>p</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>ϕ</mi>
      <mo fence="true" rspace="4.2pt" stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <ci>ψ</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>p</ci>
       </apply>
      </apply>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">bra</csymbol>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=p|\psi\rangle\langle\psi|+(1-p)|\phi\rangle\langle\phi|\,.
  </annotation>
 </semantics>
</math>

</p>

<p>For the above example of unpolarized light, the density operator is</p>

<p>

<math display="block" id="Density_matrix:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>=</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>R</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>R</mi>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mo>+</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
      </mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>L</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>L</mi>
      <mo fence="true" stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <ci>R</ci>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">bra</csymbol>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\tfrac{1}{2}|R\rangle\langle R|+\tfrac{1}{2}|L\rangle\langle L|.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="formulation">Formulation</h2>

<p>For a finite-dimensional function space, the most general density operator is of the form</p>

<p>

<math display="block" id="Density_matrix:54">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>ψ</mi>
        <mi>j</mi>
       </msub>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\rang</mtext>
       </merror>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\lang</mtext>
       </merror>
       <msub>
        <mi>ψ</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>j</ci>
        </apply>
        <mtext>\rang</mtext>
        <mtext>\lang</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\sum_{j}p_{j}|\psi_{j}\rang\lang\psi_{j}|
  </annotation>
 </semantics>
</math>

</p>

<p>where the coefficients <em>p</em><sub><em>j</em></sub> are non-negative and add up to one. This represents a statistical mixture of pure states. If the given system is closed, then one can think of a mixed state as representing a single system with an uncertain preparation history, as explicitly detailed above; <em>or</em> we can regard the mixed state as representing an <a href="Statistical_ensemble_(mathematical_physics)" title="wikilink">ensemble</a> of systems, i.e. a large number of copies of the system in question, where <em>p</em><sub><em>j</em></sub> is the proportion of the ensemble being in the state 

<math display="inline" id="Density_matrix:55">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mi>j</mi>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <ci>j</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|\psi_{j}\rang
  </annotation>
 </semantics>
</math>

. An ensemble is described by a pure state if every copy of the system in that ensemble is in the same state, i.e. it is a <em>pure ensemble</em>. If the system is not closed, however, then it is simply not correct to claim that it has some definite but unknown state vector, as the density operator may record physical entanglements to other systems.</p>

<p>Consider a quantum ensemble of size <em>N</em> with occupancy numbers <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>,...,<em>n<sub>k</sub></em> corresponding to the orthonormal states 

<math display="inline" id="Density_matrix:56">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mn>1</mn>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mo stretchy="false">|</mo>
   <mi>k</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <cn type="integer">1</cn>
    <mtext>\rang</mtext>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <ci>normal-|</ci>
    <csymbol cd="unknown">k</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|1\rang,...,|k\rang
  </annotation>
 </semantics>
</math>

, respectively, where <em>n</em><sub>1</sub>+...+<em>n<sub>k</sub></em> = <em>N</em>, and, thus, the coefficients <em>p<sub>j</sub></em> = <em>n<sub>j</sub></em> /<em>N</em>. For a pure ensemble, where all <em>N</em> particles are in state 

<math display="inline" id="Density_matrix:57">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>i</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">i</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|i\rang
  </annotation>
 </semantics>
</math>

, we have <em>n<sub>j</sub></em> = 0, for all <em>j</em> ≠ <em>i</em>, from which we recover the corresponding density operator 

<math display="inline" id="Density_matrix:58">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>i</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\lang</mtext>
     </merror>
     <mi>i</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>i</ci>
      <mtext>\rang</mtext>
      <mtext>\lang</mtext>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\rho=|i\rang\lang i|
  </annotation>
 </semantics>
</math>

. However, the density operator of a mixed state does not capture all the information about the ingredients that went into the mixture; in particular, the coefficients <em>p</em><sub><em>j</em></sub> and the kets ψ<sub><em>j</em></sub> are not recoverable from the operator ρ without additional information. This non-uniqueness implies that different ensembles or mixtures may correspond to the same density operator. Such equivalent ensembles or mixtures cannot be distinguished by measurement of observables alone. This equivalence can be characterized precisely. Two ensembles ψ, ψ' define the same density operator <a href="if_and_only_if" title="wikilink">if and only if</a> there is a matrix U with</p>

<p>

<math display="block" id="Density_matrix:59">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>U</mi>
     <mo>*</mo>
    </msup>
    <mi>U</mi>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <times></times>
     </apply>
     <ci>U</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{*}U=I
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., U is <a href="Unitary_operator" title="wikilink">unitary</a> and such that</p>

<p>

<math display="block" id="Density_matrix:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msubsup>
       <mi>ψ</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <msqrt>
      <msubsup>
       <mi>p</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
     </msqrt>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>u</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>ψ</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msqrt>
       <msub>
        <mi>p</mi>
        <mi>j</mi>
       </msub>
      </msqrt>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{i}^{\prime}\rangle\sqrt{p_{i}^{\prime}}=\sum_{j}u_{ij}|\psi_{j}\rangle%
\sqrt{p_{j}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This is simply a restatement of the following fact from linear algebra: for two square matrices <em>M</em> and <em>N</em>, <em>M M</em><sup>*</sup> = <em>N N</em><sup>*</sup> if and only if <em>M</em> = <em>NU</em> for some unitary <em>U</em>. (See <a href="square_root_of_a_matrix" title="wikilink">square root of a matrix</a> for more details.) Thus there is a unitary freedom in the ket mixture or ensemble that gives the same density operator. However if the kets making up the mixture are restricted to be <a class="uri" href="orthonormal" title="wikilink">orthonormal</a>, then the original probabilities <em>p</em><sub><em>j</em></sub> are recoverable as the eigenvalues of the density matrix.</p>

<p>In operator language, a density operator is a <a href="positive-definite_matrix" title="wikilink">positive semidefinite</a>, <a class="uri" href="hermitian" title="wikilink">hermitian</a> operator of <a href="trace_class_operator" title="wikilink">trace 1</a> acting on the state space.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> A density operator describes a <a href="Purity_(quantum_mechanics)" title="wikilink">pure</a> state if it is a <a href="Rank_(linear_algebra)" title="wikilink">rank</a> one projection. Equivalently, a density operator ρ describes a <a href="Purity_(quantum_mechanics)" title="wikilink">pure</a> state if and only if</p>

<p>

<math display="block" id="Density_matrix:61">
 <semantics>
  <mrow>
   <mpadded lspace="2.8pt" width="+2.8pt">
    <mi>ρ</mi>
   </mpadded>
   <mo>=</mo>
   <msup>
    <mi>ρ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\rho=\rho^{2}
  </annotation>
 </semantics>
</math>

, i.e. the state is <a class="uri" href="idempotent" title="wikilink">idempotent</a>. This is true regardless of whether <em>H</em> is finite-dimensional or not.</p>

<p>Geometrically, when the state is not expressible as a <a href="convex_combination" title="wikilink">convex combination</a> of other states, it is a pure state.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The family of mixed states is a convex set and a state is pure if it is an <a href="extremal_point" title="wikilink">extremal point</a> of that set.</p>

<p>It follows from the <a href="compact_operator_on_Hilbert_space" title="wikilink">spectral theorem for compact self-adjoint operators</a> that every mixed state is a countable convex combination of pure states. This representation is not unique. Furthermore, a theorem of <a href="Andrew_Gleason" title="wikilink">Andrew Gleason</a> states that certain functions defined on the family of projections and taking values in [0,1] (which can be regarded as quantum analogues of probability measures) are determined by unique mixed states. See <a href="Quantum_logic#Statistical_structure" title="wikilink">quantum logic</a> for more details.</p>
<h2 id="measurement">Measurement</h2>

<p>Let <em>A</em> be an <a class="uri" href="observable" title="wikilink">observable</a> of the system, and suppose the ensemble is in a mixed state such that each of the pure states 

<math display="inline" id="Density_matrix:62">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mi>j</mi>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <ci>j</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|\psi_{j}\rang
  </annotation>
 </semantics>
</math>

 occurs with probability <em>p<sub>j</sub></em>. Then the corresponding density operator is:</p>

<p>

<math display="block" id="Density_matrix:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>ψ</mi>
         <mi>j</mi>
        </msub>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\lang</mtext>
        </merror>
        <msub>
         <mi>ψ</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>j</ci>
        </apply>
        <mtext>\rang</mtext>
        <mtext>\lang</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\sum_{j}p_{j}|\psi_{j}\rang\lang\psi_{j}|.
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Expectation_value_(quantum_mechanics)" title="wikilink">expectation value</a> of the measurement can be calculated by extending from the case of pure states (see <a href="Measurement_in_quantum_mechanics" title="wikilink">Measurement in quantum mechanics</a>):</p>

<p>

<math display="block" id="Density_matrix:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\lang</mtext>
     </merror>
     <mi>A</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>j</mi>
      </msub>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\lang</mtext>
      </merror>
      <msub>
       <mi>ψ</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>A</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <msub>
       <mi>ψ</mi>
       <mi>j</mi>
      </msub>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo>tr</mo>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mrow>
           <msub>
            <mi>ψ</mi>
            <mi>j</mi>
           </msub>
           <merror class="ltx_ERROR undefined undefined">
            <mtext>\rang</mtext>
           </merror>
           <merror class="ltx_ERROR undefined undefined">
            <mtext>\lang</mtext>
           </merror>
           <msub>
            <mi>ψ</mi>
            <mi>j</mi>
           </msub>
          </mrow>
          <mo stretchy="false">|</mo>
         </mrow>
         <mi>A</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <mo>tr</mo>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msub>
           <mi>ψ</mi>
           <mi>j</mi>
          </msub>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\rang</mtext>
          </merror>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\lang</mtext>
          </merror>
          <msub>
           <mi>ψ</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>A</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>tr</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>j</mi>
       </munder>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msub>
           <mi>ψ</mi>
           <mi>j</mi>
          </msub>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\rang</mtext>
          </merror>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\lang</mtext>
          </merror>
          <msub>
           <mi>ψ</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>A</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ρ</mi>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>\lang</mtext>
      <ci>A</ci>
      <mtext>\rang</mtext>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
       <mtext>\lang</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <abs></abs>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>j</ci>
       </apply>
       <mtext>\rang</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <ci>tr</ci>
        <apply>
         <times></times>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ψ</ci>
            <ci>j</ci>
           </apply>
           <mtext>\rang</mtext>
           <mtext>\lang</mtext>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ψ</ci>
            <ci>j</ci>
           </apply>
          </apply>
         </apply>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <ci>tr</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ψ</ci>
           <ci>j</ci>
          </apply>
          <mtext>\rang</mtext>
          <mtext>\lang</mtext>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ψ</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>tr</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ψ</ci>
           <ci>j</ci>
          </apply>
          <mtext>\rang</mtext>
          <mtext>\lang</mtext>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ψ</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>tr</ci>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lang A\rang=\sum_{j}p_{j}\lang\psi_{j}|A|\psi_{j}\rang=\sum_{j}p_{j}%
\operatorname{tr}\left(|\psi_{j}\rang\lang\psi_{j}|A\right)=\sum_{j}%
\operatorname{tr}\left(p_{j}|\psi_{j}\rang\lang\psi_{j}|A\right)=\operatorname%
{tr}\left(\sum_{j}p_{j}|\psi_{j}\rang\lang\psi_{j}|A\right)=\operatorname{tr}(%
\rho A),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Density_matrix:65">
 <semantics>
  <mo>tr</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>tr</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}
  </annotation>
 </semantics>
</math>

 denotes <a href="trace_(linear_algebra)" title="wikilink">trace</a>. Moreover, if <em>A</em> has spectral resolution</p>

<p>

<math display="block" id="Density_matrix:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>i</mi>
        </msub>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\lang</mtext>
        </merror>
        <msub>
         <mi>a</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>A</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
         <mtext>\rang</mtext>
         <mtext>\lang</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\sum_{i}a_{i}|a_{i}\rang\lang a_{i}|=\sum_{i}a_{i}P_{i},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Density_matrix:67">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\lang</mtext>
     </merror>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <mtext>\rang</mtext>
      <mtext>\lang</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}=|a_{i}\rang\lang a_{i}|
  </annotation>
 </semantics>
</math>

, the corresponding density operator after the measurement is given by:</p>

<p>

<math display="block" id="Density_matrix:68">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>ρ</mi>
     </mpadded>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mi>ρ</mi>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\rho^{\prime}=\sum_{i}P_{i}\rho P_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the above density operator describes the full ensemble after measurement. The sub-ensemble for which the measurement result was the particular value <em>a<sub>i</sub></em> is described by the different density operator</p>

<p>

<math display="block" id="Density_matrix:69">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>ρ</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mi>ρ</mi>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mrow>
      <mo>tr</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>ρ</mi>
        <msub>
         <mi>P</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <ci>tr</ci>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{i}^{\prime}=\frac{P_{i}\rho P_{i}}{\operatorname{tr}[\rho P_{i}]}.
  </annotation>
 </semantics>
</math>

</p>

<p>This is true assuming that 

<math display="inline" id="Density_matrix:70">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|a_{i}\rang
  </annotation>
 </semantics>
</math>

 is the only eigenket (up to <a href="phase_factor" title="wikilink">phase</a>) with <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> <em>a<sub>i</sub></em>; more generally, <em>P<sub>i</sub></em> in this expression would be replaced by the <a href="projection_operator" title="wikilink">projection operator</a> into the <a href="eigenspace" title="wikilink">eigen<em>space</em></a> corresponding to eigenvalue <em>a<sub>i</sub></em>.</p>
<h2 id="entropy">Entropy</h2>

<p>The <a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a> 

<math display="inline" id="Density_matrix:71">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of a mixture can be expressed in terms of the eigenvalues of 

<math display="inline" id="Density_matrix:72">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 or in terms of the <a href="Trace_(linear_algebra)" title="wikilink">trace</a> and <a href="Matrix_logarithm" title="wikilink">logarithm</a> of the density operator 

<math display="inline" id="Density_matrix:73">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Density_matrix:74">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 is a positive semi-definite operator, it has a <a href="spectral_theorem" title="wikilink">spectral decomposition</a> such that 

<math display="inline" id="Density_matrix:75">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>φ</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>φ</mi>
       <mi>i</mi>
      </msub>
      <mo fence="true" stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\sum_{i}\lambda_{i}|\varphi_{i}\rangle\langle\varphi_{i}|
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Density_matrix:76">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>φ</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\varphi_{i}\rangle
  </annotation>
 </semantics>
</math>

 are orthonormal vectors, 

<math display="inline" id="Density_matrix:77">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Density_matrix:78">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <msub>
     <mi>λ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\lambda_{i}=1
  </annotation>
 </semantics>
</math>

. Then the entropy of a quantum system with density matrix 

<math display="inline" id="Density_matrix:79">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Density_matrix:80">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mo>-</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <msub>
    <mi>λ</mi>
    <mi>i</mi>
   </msub>
   <mpadded width="+1.7pt">
    <mi>ln</mi>
   </mpadded>
   <msub>
    <mi>λ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mo>-</mo>
   <mo>tr</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mi>ln</mi>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>i</ci>
    </apply>
    <ln></ln>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <minus></minus>
    <ci>tr</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ln></ln>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=-\sum_{i}\lambda_{i}\ln\,\lambda_{i}=-\operatorname{tr}(\rho\ln\rho)\quad.
  </annotation>
 </semantics>
</math>

</p>

<p>Also it can be shown that</p>

<p>

<math display="block" id="Density_matrix:81">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo>(</mo>
    <mi>ρ</mi>
    <mo>=</mo>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>ρ</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ρ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\left(\rho=\sum_{i}p_{i}\rho_{i}\right)=H(p_{i})+\sum_{i}p_{i}S(\rho_{i})
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Density_matrix:82">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{i}
  </annotation>
 </semantics>
</math>

 have orthogonal support, where 

<math display="inline" id="Density_matrix:83">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(p)
  </annotation>
 </semantics>
</math>

 is the <a href="Shannon_entropy" title="wikilink">Shannon entropy</a>. This entropy can increase but never decrease with a projective measurement, however generalised measurements can decrease entropy.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The entropy of a pure state is zero, while that of a proper mixture always greater than zero. Therefore a pure state may be converted into a mixture by a measurement, but a proper mixture can <em>never</em> be converted into a pure state. Thus the act of measurement induces a fundamental <a href="irreversible_process" title="wikilink">irreversible</a> change on the density matrix; this is analogous to the "collapse" of the state vector, or <a href="wavefunction_collapse" title="wikilink">wavefunction collapse</a>. Perhaps counterintuitively, the measurement actually <em>decreases information</em> by erasing quantum interference in the composite system—cf. <a href="quantum_entanglement" title="wikilink">quantum entanglement</a>, <a class="uri" href="einselection" title="wikilink">einselection</a>, and <a href="quantum_decoherence" title="wikilink">quantum decoherence</a>.</p>

<p>(A subsystem of a larger system can be turned from a mixed to a pure state, but only by increasing the von Neumann entropy elsewhere in the system. This is analogous to how the entropy of an object can be lowered by putting it in a refrigerator: The air outside the refrigerator's heat-exchanger warms up, gaining even more entropy than was lost by the object in the refrigerator. See <a href="second_law_of_thermodynamics" title="wikilink">second law of thermodynamics</a>. See <a href="Entropy_in_thermodynamics_and_information_theory" title="wikilink">Entropy in thermodynamics and information theory</a>.)</p>
<h2 id="the-von-neumann-equation-for-time-evolution">The von Neumann equation for time evolution</h2>

<p>Just as the <a href="Schrödinger_equation" title="wikilink">Schrödinger equation</a> describes how pure states evolve in time, the <strong>von Neumann equation</strong> (also known as the <strong>Liouville–von Neumann equation</strong>) describes how a density operator evolves in time (in fact, the two equations are equivalent, in the sense that either can be derived from the other.) The von Neumann equation dictates that<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>

<math display="block" id="Density_matrix:84">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mi mathvariant="normal">ℏ</mi>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>ρ</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>ρ</mi>
     <mo rspace="5.8pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>i</ci>
     <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>ρ</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <interval closure="closed">
     <ci>H</ci>
     <ci>ρ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\hbar\frac{\partial\rho}{\partial t}=[H,\rho]~{},
  </annotation>
 </semantics>
</math>

</p>

<p>where the brackets denote a <a class="uri" href="commutator" title="wikilink">commutator</a>.</p>

<p>Note that this equation only holds when the density operator is taken to be in the <a href="Schrödinger_picture" title="wikilink">Schrödinger picture</a>, even though this equation seems at first look to emulate the Heisenberg equation of motion in the <a href="Heisenberg_picture" title="wikilink">Heisenberg picture</a>, with a crucial sign difference:</p>

<p>

<math display="block" id="Density_matrix:85">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mi mathvariant="normal">ℏ</mi>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <msup>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>H</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>H</mi>
      <mo>,</mo>
      <msup>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo rspace="5.8pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>i</ci>
     <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <interval closure="closed">
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>H</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\hbar\frac{dA^{(H)}}{dt}=-[H,A^{(H)}]~{},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Density_matrix:86">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>H</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{(H)}(t)
  </annotation>
 </semantics>
</math>

 is some <em>Heisenberg picture</em> operator; but in this picture the density matrix is <em>not time-dependent</em>, and the relative sign ensures that the time derivative of the expected value 

<math display="inline" id="Density_matrix:87">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>A</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle
  </annotation>
 </semantics>
</math>

 comes out <em>the same as in the Schrödinger picture</em>.</p>

<p>Taking the density operator to be in the Schrödinger picture makes sense, since it is composed of 'Schrödinger' kets and bras evolved in time, as per the Schrödinger picture. If the Hamiltonian is time-independent, this differential equation can be easily solved to yield</p>

<p>

<math display="block" id="Density_matrix:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mi>H</mi>
         <mi>t</mi>
        </mrow>
        <mo>/</mo>
        <mi mathvariant="normal">ℏ</mi>
       </mrow>
      </mrow>
     </msup>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mi>H</mi>
        <mi>t</mi>
       </mrow>
       <mo>/</mo>
       <mi mathvariant="normal">ℏ</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>H</ci>
         <ci>t</ci>
        </apply>
        <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
       </apply>
      </apply>
     </apply>
     <ci>ρ</ci>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>H</ci>
        <ci>t</ci>
       </apply>
       <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(t)=e^{-iHt/\hbar}\rho(0)e^{iHt/\hbar}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="quantum-liouville-moyals-equation">"Quantum Liouville", Moyal's equation</h2>

<p>The density matrix operator may also be realized in <a href="phase_space" title="wikilink">phase space</a>. Under the <a href="Wigner_quasi-probability_distribution#The_Wigner.E2.80.93Weyl_transformation" title="wikilink">Wigner map</a>, the density matrix transforms into the equivalent <a href="Wigner_quasi-probability_distribution" title="wikilink">Wigner function</a>,</p>

<p>

<math display="block" id="Density_matrix:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>π</mi>
       <mi mathvariant="normal">ℏ</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <msup>
        <mi>ψ</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mi>y</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>ψ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>y</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mi>e</mi>
         <mrow>
          <mrow>
           <mn>2</mn>
           <mi>i</mi>
           <mi>p</mi>
           <mi>y</mi>
          </mrow>
          <mo>/</mo>
          <mi mathvariant="normal">ℏ</mi>
         </mrow>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mpadded width="+3.3pt">
        <mi>y</mi>
       </mpadded>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <ci>W</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>p</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>π</ci>
       <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ψ</ci>
        <times></times>
       </apply>
       <apply>
        <plus></plus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <ci>ψ</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>i</ci>
          <ci>p</ci>
          <ci>y</ci>
         </apply>
         <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(x,p)\stackrel{\mathrm{def}}{=}\frac{1}{\pi\hbar}\int_{-\infty}^{\infty}\psi^%
{*}(x+y)\psi(x-y)e^{2ipy/\hbar}\,dy~{}.
  </annotation>
 </semantics>
</math>

 The equation for the time-evolution of the Wigner function is then the Wigner-transform of the above von Neumann equation,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Density_matrix:90">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <mi>W</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>q</mi>
       <mo>,</mo>
       <mi>p</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mi>W</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>q</mi>
         <mo>,</mo>
         <mi>p</mi>
         <mo>,</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>H</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>q</mi>
         <mo>,</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo rspace="5.8pt" stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <ci>W</ci>
      </apply>
      <vector>
       <ci>q</ci>
       <ci>p</ci>
       <ci>t</ci>
      </vector>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <set>
      <set>
       <apply>
        <times></times>
        <ci>W</ci>
        <vector>
         <ci>q</ci>
         <ci>p</ci>
         <ci>t</ci>
        </vector>
       </apply>
       <apply>
        <times></times>
        <ci>H</ci>
        <interval closure="open">
         <ci>q</ci>
         <ci>p</ci>
        </interval>
       </apply>
      </set>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial W(q,p,t)}{\partial t}=-\{\{W(q,p,t),H(q,p)\}\}~{},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where <em>H(q,p)</em> is the Hamiltonian, and { { •,• } } is the <a href="Moyal_bracket" title="wikilink">Moyal bracket</a>, the transform of the quantum <a class="uri" href="commutator" title="wikilink">commutator</a>.</p>

<p>The evolution equation for the Wigner function is then analogous to that of its classical limit, the <a href="Liouville's_theorem_(Hamiltonian)#Liouville_equations" title="wikilink">Liouville equation</a> of <a href="classical_physics" title="wikilink">classical physics</a>. In the limit of vanishing Planck's constant ħ, <em>W(q,p,t)</em> reduces to the classical Liouville probability density function in <a href="phase_space" title="wikilink">phase space</a>.</p>

<p>The classical Liouville equation can be solved using the <a href="method_of_characteristics" title="wikilink">method of characteristics</a> for partial differential equations, the characteristic equations being Hamilton's equations. The Moyal equation in quantum mechanics similarly admits formal solutions in terms of <a href="method_of_quantum_characteristics" title="wikilink">quantum characteristics</a>, predicated on the <a href="Moyal_product" title="wikilink">∗−product</a> of phase space, although, in actual practice, solution-seeking follows different methods.</p>
<h2 id="composite-systems">Composite systems</h2>

<p>The joint density matrix of a composite system of two systems A and B is described by 

<math display="inline" id="Density_matrix:91">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}
  </annotation>
 </semantics>
</math>

. Then the subsystems are described by their <a href="Reduced_density_matrix#Reduced_density_matrices" title="wikilink">reduced density operator</a>.</p>

<p>

<math display="block" id="Density_matrix:92">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>tr</mo>
     <mi>B</mi>
    </msub>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>tr</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{A}=\operatorname{tr}_{B}\rho_{AB}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Density_matrix:93">
 <semantics>
  <msub>
   <mo>tr</mo>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>tr</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}_{B}
  </annotation>
 </semantics>
</math>

 is called <em><a href="partial_trace" title="wikilink">partial trace</a></em> over system B. If A and B are two distinct and independent systems then 

<math display="inline" id="Density_matrix:94">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mi>A</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>ρ</mi>
     <mi>B</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}=\rho_{A}\otimes\rho_{B}
  </annotation>
 </semantics>
</math>

 which is a <em>product state</em>.</p>
<h2 id="c-algebraic-formulation-of-states">C*-algebraic formulation of states</h2>

<p>It is now generally accepted that the description of quantum mechanics in which all self-adjoint operators represent observables is untenable.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> For this reason, observables are identified with elements of an abstract <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> <em>A</em> (that is one without a distinguished representation as an algebra of operators) and <a href="state_(functional_analysis)" title="wikilink">states</a> are positive <a href="linear_functional" title="wikilink">linear functionals</a> on <em>A</em>. However, by using the <a href="GNS_construction" title="wikilink">GNS construction</a>, we can recover Hilbert spaces which realize <em>A</em> as a subalgebra of operators.</p>

<p>Geometrically, a pure state on a C*-algebra <em>A</em> is a state which is an extreme point of the set of all states on <em>A</em>. By properties of the GNS construction these states correspond to <a href="irreducible_representation" title="wikilink">irreducible representations</a> of <em>A</em>.</p>

<p>The states of the C*-algebra of <a href="compact_operator" title="wikilink">compact operators</a> <em>K</em>(<em>H</em>) correspond exactly to the density operators, and therefore the pure states of <em>K</em>(<em>H</em>) are exactly the pure states in the sense of quantum mechanics.</p>

<p>The C*-algebraic formulation can be seen to include both classical and quantum systems. When the system is classical, the algebra of observables become an abelian C*-algebra. In that case the states become probability measures, as noted in the introduction.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Atomic_electron_transition" title="wikilink">Atomic electron transition</a></li>
<li><a href="Born_rule" title="wikilink">Born rule</a></li>
<li><a href="Density_functional_theory" title="wikilink">Density functional theory</a></li>
<li><a href="Gleason's_theorem" title="wikilink">Gleason's theorem</a></li>
<li><a href="Green–Kubo_relations" title="wikilink">Green–Kubo relations</a></li>
<li><a href="Green's_function_(many-body_theory)" title="wikilink">Green's function (many-body theory)</a></li>
<li><a href="Lindblad_equation" title="wikilink">Lindblad equation</a></li>
<li><a href="Quantum_state" title="wikilink">Quantum state</a></li>
<li><a class="uri" href="POVM" title="wikilink">POVM</a> Generalized measurement of density states</li>
<li><a href="Purification_of_quantum_state" title="wikilink">Purification of quantum state</a></li>
<li><a href="Wave_function" title="wikilink">Wave function</a></li>
<li><a href="Wigner_quasi-probability_distribution" title="wikilink">Wigner quasi-probability distribution</a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>

<p>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a> <a href="Category:Functional_analysis" title="wikilink">Category:Functional analysis</a> <a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Statistical_mechanics" title="wikilink">Category:Statistical mechanics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Technically, <em>F</em> must be a Borel function<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">. Chapter 11: Entropy and information, Theorem 11.9, "Projective measurements cannot decrease entropy"<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">See appendix, <a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
