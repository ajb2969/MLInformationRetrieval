<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="105">BQP</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>BQP</h1>
<hr/>

<p> In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <strong>BQP</strong> (bounded error quantum polynomial time) is the class of <a href="decision_problems" title="wikilink">decision problems</a> solvable by a <a href="quantum_computer" title="wikilink">quantum computer</a> in <a href="polynomial_time" title="wikilink">polynomial time</a>, with an error probability of at most 1/3 for all instances. It is the quantum analogue of the complexity class <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong>.</p>

<p>In other words, there is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for a quantum computer (a <a href="quantum_algorithm" title="wikilink">quantum algorithm</a>) that solves the decision problem with <em>high</em> probability and is guaranteed to run in polynomial time. On any given run of the algorithm, it has a probability of at most 1/3 that it will give the wrong answer.</p>

<p>Similarly to other "bounded error" probabilistic classes the choice of 1/3 in the definition is arbitrary. We can run the algorithm a constant number of times and take a majority vote to achieve any desired probability of correctness less than 1, using the <a href="Chernoff_bound" title="wikilink">Chernoff bound</a>. Detailed analysis shows that the complexity class is unchanged by allowing error as high as 1/2 − <em>n</em><sup>−<em>c</em></sup> on the one hand, or requiring error as small as 2<sup>−<em>n<sup>c</sup></em></sup> on the other hand, where <em>c</em> is any positive constant, and <em>n</em> is the length of input.</p>
<h2 id="definition">Definition</h2>

<p><strong>BQP</strong> can also be viewed as a bounded-error uniform family of <a href="quantum_circuit" title="wikilink">quantum circuits</a>. A language <em>L</em> is in <strong>BQP</strong> if and only if there exists a <a href="Circuit_complexity#Polynomial-time_uniform" title="wikilink">polynomial-time uniform</a> family of quantum circuits 

<math display="inline" id="BQP:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>Q</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{Q_{n}:n\in\mathbb{N}\}
  </annotation>
 </semantics>
</math>

, such that</p>
<ul>
<li>For all 

<math display="inline" id="BQP:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

, <em>Q<sub>n</sub></em> takes <em>n</em> qubits as input and outputs 1 bit</li>
<li>For all <em>x</em> in <em>L</em>, 

<math display="inline" id="BQP:2">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mfrac>
    <mn>2</mn>
    <mn>3</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Pr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Pr}(Q_{|x|}(x)=1)\geq\tfrac{2}{3}
  </annotation>
 </semantics>
</math>

</li>
<li>For all <em>x</em> not in <em>L</em>, 

<math display="inline" id="BQP:3">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mfrac>
    <mn>2</mn>
    <mn>3</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Pr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Pr}(Q_{|x|}(x)=0)\geq\tfrac{2}{3}
  </annotation>
 </semantics>
</math>


</li>
</ul>
<h2 id="quantum-computation">Quantum computation</h2>

<p>The number of <a href="qubit" title="wikilink">qubits</a> in the computer is allowed to be a <a href="polynomial_function" title="wikilink">polynomial function</a> of the instance size. For example, algorithms are known for factoring an <em>n</em>-bit integer using just over 2<em>n</em> qubits (<a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>).</p>

<p>Usually, computation on a quantum computer ends with a <a href="Measurement_in_quantum_mechanics" title="wikilink">measurement</a>. This leads to a <a href="Wavefunction_collapse" title="wikilink">collapse</a> of quantum state to one of the <a href="Quantum_state" title="wikilink">basis states</a>. It can be said that the quantum state is measured to be in the correct state with high probability.</p>

<p>Quantum computers have gained widespread interest because some problems of practical interest are known to be in <strong>BQP</strong>, but suspected to be outside <strong>P</strong>. Some prominent examples are:</p>
<ul>
<li><a href="Integer_factorization" title="wikilink">Integer factorization</a> (see <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li><a href="Discrete_logarithm" title="wikilink">Discrete logarithm</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>Simulation of quantum systems (see <a href="universal_quantum_simulator" title="wikilink">universal quantum simulator</a>)</li>
<li>Computing the <a href="Jones_polynomial" title="wikilink">Jones polynomial</a> at certain roots of unity</li>
</ul>
<h2 id="relationship-to-other-complexity-classes">Relationship to other complexity classes</h2>

<p>This class is defined for a quantum computer and its natural corresponding class for an ordinary computer (or a <a href="Turing_machine" title="wikilink">Turing machine</a> plus a source of randomness) is <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong>. Just like <strong>P</strong> and <strong>BPP</strong>, <strong>BQP</strong> is <a href="low_(complexity)" title="wikilink">low</a> for itself, which means <strong>BQP</strong><sup><strong>BQP</strong></sup> = <strong>BQP</strong>. Informally, this is true because polynomial time algorithms are closed under composition. If a polynomial time algorithm calls as a subroutine polynomially many polynomial time algorithms, the resulting algorithm is still polynomial time.</p>

<p><strong>BQP</strong> contains <strong><a href="P_(complexity)" title="wikilink">P</a></strong> and <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong> and is contained in <strong><a href="Almost_Wide_Probabilistic_Polynomial-Time" title="wikilink">AWPP</a></strong>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In fact, <strong>BQP</strong> is <a href="low_(complexity)" title="wikilink">low</a> for <strong>PP</strong>, meaning that a <strong>PP</strong> machine achieves no benefit from being able to solve <strong>BQP</strong> problems instantly, an indication of the possible difference in power between these similar classes.</p>

<p>

<math display="block" id="BQP:4">
 <semantics>
  <mrow>
   <mi>𝐏</mi>
   <mo>⊆</mo>
   <mi>𝐁𝐏𝐏</mi>
   <mo>⊆</mo>
   <mi>𝐁𝐐𝐏</mi>
   <mo>⊆</mo>
   <mi>𝐀𝐖𝐏𝐏</mi>
   <mo>⊆</mo>
   <mi>𝐏𝐏</mi>
   <mo>⊆</mo>
   <mi>𝐏𝐒𝐏𝐀𝐂𝐄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <ci>𝐏</ci>
     <ci>𝐁𝐏𝐏</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐁𝐐𝐏</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐀𝐖𝐏𝐏</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐏𝐏</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐏𝐒𝐏𝐀𝐂𝐄</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}\subseteq\mathbf{BPP}\subseteq\mathbf{BQP}\subseteq\mathbf{AWPP}%
\subseteq\mathbf{PP}\subseteq\mathbf{PSPACE}
  </annotation>
 </semantics>
</math>

</p>

<p>As the problem of <strong>P</strong> ≟ <strong>PSPACE</strong> has not yet been solved, the proof of inequality between <strong>BQP</strong> and classes mentioned above is supposed to be difficult.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The relation between <strong>BQP</strong> and <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong> is not known.</p>

<p>Adding <a class="uri" href="postselection" title="wikilink">postselection</a> to <strong>BQP</strong> results in the complexity class <strong><a class="uri" href="PostBQP" title="wikilink">PostBQP</a></strong> which is equal to <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Probabilistic_complexity_classes" title="wikilink">Category:Probabilistic complexity classes</a> <a href="Category:Quantum_complexity_theory" title="wikilink">Category:Quantum complexity theory</a> <a href="Category:Quantum_computing" title="wikilink">Category:Quantum computing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.arxiv.org/abs/quant-ph/9508027">arXiv:quant-ph/9508027v2 <em>Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer</em>, Peter W. Shor</a><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">L. Adleman, J. DeMarrais, and M.-D. Huang. Quantum computability. SIAM J. Comput., 26(5):1524–1540, 1997.<a href="#fnref4">↩</a></li>
<li id="fn5">Bernstein and Vazirani, Quantum complexity theory, <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, 26(5):1411-1473, 1997. <a href="http://www.cs.berkeley.edu/~vazirani/bv.ps">1</a><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7">. Preprint available at <a href="http://arxiv.org/abs/quant-ph/0412187">2</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
