<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1963">Reinforcement learning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Reinforcement learning</h1>
<hr/>

<p><strong>Reinforcement learning</strong> is an area of <a href="machine_learning" title="wikilink">machine learning</a> inspired by <a href="Behaviorism" title="wikilink">behaviorist psychology</a>, concerned with how <a href="software_agent" title="wikilink">software agents</a> ought to take <em>actions</em> in an <em>environment</em> so as to maximize some notion of cumulative <em>reward</em>. The problem, due to its generality, is studied in many other disciplines, such as <a href="game_theory" title="wikilink">game theory</a>, <a href="control_theory" title="wikilink">control theory</a>, <a href="operations_research" title="wikilink">operations research</a>, <a href="information_theory" title="wikilink">information theory</a>, <a href="simulation-based_optimization" title="wikilink">simulation-based optimization</a>, <a href="Multi-agent_system" title="wikilink">multi-agent systems</a>, <a href="swarm_intelligence" title="wikilink">swarm intelligence</a>, <a class="uri" href="statistics" title="wikilink">statistics</a>, and <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>. In the operations research and control literature, the field where reinforcement learning methods are studied is called <em>approximate dynamic programming</em>. The problem has been studied in the <a href="optimal_control_theory" title="wikilink">theory of optimal control</a>, though most studies are concerned with the existence of optimal solutions and their characterization, and not with the learning or approximation aspects. In <a class="uri" href="economics" title="wikilink">economics</a> and <a href="game_theory" title="wikilink">game theory</a>, reinforcement learning may be used to explain how equilibrium may arise under <a href="bounded_rationality" title="wikilink">bounded rationality</a>.</p>

<p>In machine learning, the environment is typically formulated as a <a href="Markov_decision_process" title="wikilink">Markov decision process</a> (MDP) as many reinforcement learning algorithms for this context utilize <a href="dynamic_programming" title="wikilink">dynamic programming</a> techniques. The main difference between the classical techniques and reinforcement learning algorithms is that the latter do not need knowledge about the MDP and they target large MDPs where exact methods become infeasible.</p>

<p>Reinforcement learning differs from standard <a href="supervised_learning" title="wikilink">supervised learning</a> in that correct input/output pairs are never presented, nor sub-optimal actions explicitly corrected. Further, there is a focus on on-line performance, which involves finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge). The exploration vs. exploitation trade-off in reinforcement learning has been most thoroughly studied through the <a href="multi-armed_bandit" title="wikilink">multi-armed bandit</a> problem and in finite MDPs.</p>
<h2 id="introduction">Introduction</h2>

<p>The basic reinforcement learning model consists of:</p>
<ol>
<li>a set of environment states 

<math display="inline" id="Reinforcement_learning:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

;</li>
<li>a set of actions 

<math display="inline" id="Reinforcement_learning:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

;</li>
<li>rules of transitioning between states;</li>
<li>rules that determine the <em>scalar immediate reward</em> of a transition; and</li>
<li>rules that describe what the agent observes.</li>
</ol>

<p>The rules are often <a class="uri" href="stochastic" title="wikilink">stochastic</a>. The observation typically involves the scalar immediate reward associated with the last transition. In many works, the agent is also assumed to observe the current environmental state, in which case we talk about <em>full observability</em>, whereas in the opposing case we talk about <em>partial observability</em>. Sometimes the set of actions available to the agent is restricted (e.g., you cannot spend more money than what you possess).</p>

<p>A reinforcement learning agent interacts with its environment in discrete time steps. At each time 

<math display="inline" id="Reinforcement_learning:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, the agent receives an observation 

<math display="inline" id="Reinforcement_learning:3">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{t}
  </annotation>
 </semantics>
</math>

, which typically includes the reward 

<math display="inline" id="Reinforcement_learning:4">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}
  </annotation>
 </semantics>
</math>

. It then chooses an action 

<math display="inline" id="Reinforcement_learning:5">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

 from the set of actions available, which is subsequently sent to the environment. The environment moves to a new state 

<math display="inline" id="Reinforcement_learning:6">
 <semantics>
  <msub>
   <mi>s</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{t+1}
  </annotation>
 </semantics>
</math>

 and the reward 

<math display="inline" id="Reinforcement_learning:7">
 <semantics>
  <msub>
   <mi>r</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t+1}
  </annotation>
 </semantics>
</math>

 associated with the <em>transition</em> 

<math display="inline" id="Reinforcement_learning:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>s</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>t</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{t},a_{t},s_{t+1})
  </annotation>
 </semantics>
</math>

 is determined. The goal of a reinforcement learning agent is to collect as much reward as possible. The <a href="Software_agent" title="wikilink">agent</a> can choose any action as a function of the history and it can even randomize its action selection.</p>

<p>When the agent's performance is compared to that of an agent which acts optimally from the beginning, the difference in performance gives rise to the notion of <em>regret</em>. Note that in order to act near optimally, the agent must reason about the long term consequences of its actions: In order to maximize my future income I had better go to school now, although the immediate monetary reward associated with this might be negative.</p>

<p>Thus, reinforcement learning is particularly well suited to problems which include a long-term versus short-term reward trade-off. It has been applied successfully to various problems, including <a href="robot_control" title="wikilink">robot control</a>, elevator scheduling, <a class="uri" href="telecommunications" title="wikilink">telecommunications</a>, <a class="uri" href="backgammon" title="wikilink">backgammon</a> and <a class="uri" href="checkers" title="wikilink">checkers</a> (<a href="#refSutton1998" title="wikilink">Sutton and Barto 1998</a>, Chapter 11).</p>

<p>Two components make reinforcement learning powerful: The use of samples to optimize performance and the use of function approximation to deal with large environments. Thanks to these two key components, reinforcement learning can be used in large environments in any of the following situations:</p>
<ul>
<li>A model of the environment is known, but an analytic solution is not available;</li>
<li>Only a simulation model of the environment is given (the subject of <a href="simulation-based_optimization" title="wikilink">simulation-based optimization</a>);<ref></ref></li>
</ul>

<p></p>
<ul>
<li>The only way to collect information about the environment is by interacting with it.</li>
</ul>

<p>The first two of these problems could be considered planning problems (since some form of the model is available), while the last one could be considered as a genuine learning problem. However, under a reinforcement learning methodology both planning problems would be converted to <a href="machine_learning" title="wikilink">machine learning</a> problems.</p>
<h2 id="exploration">Exploration</h2>

<p>The reinforcement learning problem as described requires clever exploration mechanisms. Randomly selecting actions, without reference to an estimated probability distribution, is known to give rise to very poor performance. The case of (small) finite MDPs is relatively well understood by now. However, due to the lack of algorithms that would provably scale well with the number of states (or scale to problems with infinite state spaces), in practice people resort to simple exploration methods. One such method is 

<math display="inline" id="Reinforcement_learning:9">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-greedy, when the agent chooses the action that it believes has the best long-term effect with probability 

<math display="inline" id="Reinforcement_learning:10">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\epsilon
  </annotation>
 </semantics>
</math>

, and it chooses an action uniformly at random, otherwise. Here, 

<math display="inline" id="Reinforcement_learning:11">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>ϵ</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\epsilon<1
  </annotation>
 </semantics>
</math>

 is a tuning parameter, which is sometimes changed, either according to a fixed schedule (making the agent explore less as time goes by), or adaptively based on some heuristics <a href="#refTokic2010" title="wikilink">(Tokic &amp; Palm, 2011)</a>.</p>
<h2 id="algorithms-for-control-learning">Algorithms for control learning</h2>

<p>Even if the issue of exploration is disregarded and even if the state was observable (which we assume from now on), the problem remains to find out which actions are good based on past experience.</p>
<h3 id="criterion-of-optimality">Criterion of optimality</h3>

<p>For simplicity, assume for a moment that the problem studied is <em>episodic</em>, an episode ending when some <em>terminal state</em> is reached. Assume further that no matter what course of actions the agent takes, termination is inevitable. Under some additional mild regularity conditions the expectation of the total reward is then well-defined, for <em>any</em> policy and any initial distribution over the states. Here, a policy refers to a mapping that assigns some probability distribution over the actions to all possible histories.</p>

<p>Given a fixed initial distribution 

<math display="inline" id="Reinforcement_learning:12">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

, we can thus assign the expected return 

<math display="inline" id="Reinforcement_learning:13">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mi>π</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\pi}
  </annotation>
 </semantics>
</math>

 to policy 

<math display="inline" id="Reinforcement_learning:14">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Reinforcement_learning:15">
 <semantics>
  <mrow>
   <msup>
    <mi>ρ</mi>
    <mi>π</mi>
   </msup>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>R</mi>
    <mo stretchy="false">|</mo>
    <mi>π</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>π</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\pi}=E[R|\pi],
  </annotation>
 </semantics>
</math>

</p>

<p>where the random variable 

<math display="inline" id="Reinforcement_learning:16">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 denotes the <em>return</em> and is defined by</p>

<p>

<math display="block" id="Reinforcement_learning:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\sum_{t=0}^{N-1}r_{t+1},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Reinforcement_learning:18">
 <semantics>
  <msub>
   <mi>r</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t+1}
  </annotation>
 </semantics>
</math>

 is the reward received after the 

<math display="inline" id="Reinforcement_learning:19">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-th transition, the initial state is sampled at random from 

<math display="inline" id="Reinforcement_learning:20">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and actions are selected by policy 

<math display="inline" id="Reinforcement_learning:21">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

. Here, 

<math display="inline" id="Reinforcement_learning:22">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 denotes the (random) time when a terminal state is reached, i.e., the time when the episode terminates.</p>

<p>In the case of non-episodic problems the return is often <em>discounted</em>,</p>

<p>

<math display="block" id="Reinforcement_learning:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msup>
       <mi>γ</mi>
       <mi>t</mi>
      </msup>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>γ</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\sum_{t=0}^{\infty}\gamma^{t}r_{t+1},
  </annotation>
 </semantics>
</math>

</p>

<p>giving rise to the total expected discounted reward criterion. Here 

<math display="inline" id="Reinforcement_learning:24">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>γ</mi>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>γ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\gamma\leq 1
  </annotation>
 </semantics>
</math>

 is the so-called <em>discount-factor</em>. Since the undiscounted return is a special case of the discounted return, from now on we will assume discounting. Although this looks innocent enough, discounting is in fact problematic if one cares about online performance. This is because discounting makes the initial time steps more important. Since a learning agent is likely to make mistakes during the first few steps after its "life" starts, no uninformed learning algorithm can achieve near-optimal performance under discounting even if the class of environments is restricted to that of finite MDPs. (This does not mean though that, given enough time, a learning agent cannot figure how to act near-optimally, if time was restarted.)</p>

<p>The problem then is to specify an algorithm that can be used to find a policy with maximum expected return. From the theory of MDPs it is known that, without loss of generality, the search can be restricted to the set of the so-called <em>stationary</em> policies. A policy is called stationary if the action-distribution returned by it depends only on the last state visited (which is part of the observation history of the agent, by our simplifying assumption). In fact, the search can be further restricted to <em>deterministic</em> stationary policies. A deterministic stationary policy is one which deterministically selects actions based on the current state. Since any such policy can be identified with a mapping from the set of states to the set of actions, these policies can be identified with such mappings with no loss of generality.</p>
<h3 id="brute-force">Brute force</h3>

<p>The <a href="brute-force_search" title="wikilink">brute force</a> approach entails the following two steps:</p>
<ol>
<li>For each possible policy, sample returns while following it</li>
<li>Choose the policy with the largest expected return</li>
</ol>

<p>One problem with this is that the number of policies can be extremely large, or even infinite. Another is that variance of the returns might be large, in which case a large number of samples will be required to accurately estimate the return of each policy.</p>

<p>These problems can be ameliorated if we assume some structure and perhaps allow samples generated from one policy to influence the estimates made for another. The two main approaches for achieving this are <a href="value_function_approaches" title="wikilink">value function estimation</a> and <a href="direct_policy_search" title="wikilink">direct policy search</a>.</p>
<h3 id="value-function-approaches">Value function approaches</h3>

<p>Value function approaches attempt to find a policy that maximizes the return by maintaining a set of estimates of expected returns for some policy (usually either the "current" or the optimal one).</p>

<p>These methods rely on the theory of MDPs, where optimality is defined in a sense which is stronger than the above one: A policy is called optimal if it achieves the best expected return from <em>any</em> initial state (i.e., initial distributions play no role in this definition). Again, one can always find an optimal policy amongst stationary policies.</p>

<p>To define optimality in a formal manner, define the value of a policy 

<math display="inline" id="Reinforcement_learning:25">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Reinforcement_learning:26">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mi>π</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>R</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>π</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>π</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\pi}(s)=E[R|s,\pi],
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Reinforcement_learning:27">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 stands for the random return associated with following 

<math display="inline" id="Reinforcement_learning:28">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 from the initial state 

<math display="inline" id="Reinforcement_learning:29">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. Define 

<math display="inline" id="Reinforcement_learning:30">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <times></times>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}(s)
  </annotation>
 </semantics>
</math>

 as the maximum possible value of 

<math display="inline" id="Reinforcement_learning:31">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mi>π</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>π</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\pi}(s)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Reinforcement_learning:32">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 is allowed to change:</p>

<p>

<math display="block" id="Reinforcement_learning:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>V</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mi>π</mi>
     </munder>
     <mrow>
      <msup>
       <mi>V</mi>
       <mi>π</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <times></times>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <ci>π</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <ci>π</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}(s)=\sup\limits_{\pi}V^{\pi}(s).
  </annotation>
 </semantics>
</math>

</p>

<p>A policy which achieves these <em>optimal values</em> in <em>each</em> state is called <em>optimal</em>. Clearly, a policy optimal in this strong sense is also optimal in the sense that it maximizes the expected return 

<math display="inline" id="Reinforcement_learning:34">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mi>π</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\pi}
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Reinforcement_learning:35">
 <semantics>
  <mrow>
   <msup>
    <mi>ρ</mi>
    <mi>π</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msup>
       <mi>V</mi>
       <mi>π</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <ci>π</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\pi}=E[V^{\pi}(S)]
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Reinforcement_learning:36">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is a state randomly sampled from the distribution 

<math display="inline" id="Reinforcement_learning:37">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

.</p>

<p>Although state-values suffice to define optimality, it will prove to be useful to define action-values. Given a state 

<math display="inline" id="Reinforcement_learning:38">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, an action 

<math display="inline" id="Reinforcement_learning:39">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and a policy 

<math display="inline" id="Reinforcement_learning:40">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, the action-value of the pair 

<math display="inline" id="Reinforcement_learning:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a)
  </annotation>
 </semantics>
</math>

 under 

<math display="inline" id="Reinforcement_learning:42">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 is defined by</p>

<p>

<math display="block" id="Reinforcement_learning:43">
 <semantics>
  <mrow>
   <msup>
    <mi>Q</mi>
    <mi>π</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>R</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>π</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>π</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{\pi}(s,a)=E[R|s,a,\pi],\,
  </annotation>
 </semantics>
</math>

</p>

<p>where, now, 

<math display="inline" id="Reinforcement_learning:44">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 stands for the random return associated with first taking action 

<math display="inline" id="Reinforcement_learning:45">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Reinforcement_learning:46">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and following 

<math display="inline" id="Reinforcement_learning:47">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, thereafter.</p>

<p>It is well-known from the theory of MDPs that if someone gives us 

<math display="inline" id="Reinforcement_learning:48">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 for an optimal policy, we can always choose optimal actions (and thus act optimally) by simply choosing the action with the highest value at each state. The <em>action-value function</em> of such an optimal policy is called the <em>optimal action-value function</em> and is denoted by 

<math display="inline" id="Reinforcement_learning:49">
 <semantics>
  <msup>
   <mi>Q</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Q</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{*}
  </annotation>
 </semantics>
</math>

. In summary, the knowledge of the optimal action-value function <em>alone</em> suffices to know how to act optimally.</p>

<p>Assuming full knowledge of the MDP, there are two basic approaches to compute the optimal action-value function, <a href="value_iteration" title="wikilink">value iteration</a> and <a href="policy_iteration" title="wikilink">policy iteration</a>. Both algorithms compute a sequence of functions 

<math display="inline" id="Reinforcement_learning:50">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{k}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Reinforcement_learning:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0,1,2,\ldots,
  </annotation>
 </semantics>
</math>

) which converge to 

<math display="inline" id="Reinforcement_learning:52">
 <semantics>
  <msup>
   <mi>Q</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Q</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{*}
  </annotation>
 </semantics>
</math>

. Computing these functions involves computing expectations over the whole state-space, which is impractical for all, but the smallest (finite) MDPs, never mind the case when the MDP is unknown. In reinforcement learning methods the expectations are approximated by averaging over samples and one uses function approximation techniques to cope with the need to represent value functions over large state-action spaces.</p>
<h4 id="monte-carlo-methods">Monte Carlo methods</h4>

<p>The simplest <a href="Monte_Carlo_sampling" title="wikilink">Monte Carlo methods</a> can be used in an algorithm that mimics policy iteration. Policy iteration consists of two steps: <em>policy evaluation</em> and <em>policy improvement</em>. The Monte Carlo methods are used in the policy evaluation step. In this step, given a stationary, deterministic policy 

<math display="inline" id="Reinforcement_learning:53">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, the goal is to compute the function values 

<math display="inline" id="Reinforcement_learning:54">
 <semantics>
  <mrow>
   <msup>
    <mi>Q</mi>
    <mi>π</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>π</ci>
    </apply>
    <interval closure="open">
     <ci>s</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{\pi}(s,a)
  </annotation>
 </semantics>
</math>

 (or a good approximation to them) for all state-action pairs 

<math display="inline" id="Reinforcement_learning:55">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a)
  </annotation>
 </semantics>
</math>

. Assume (for simplicity) that the MDP is finite and in fact a table representing the action-values fits into the memory. Further, assume that the problem is episodic and after each episode a new one starts from some random initial state. Then, the estimate of the value of a given state-action pair 

<math display="inline" id="Reinforcement_learning:56">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a)
  </annotation>
 </semantics>
</math>

can be computed by simply averaging the sampled returns which originated from 

<math display="inline" id="Reinforcement_learning:57">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a)
  </annotation>
 </semantics>
</math>

 over time. Given enough time, this procedure can thus construct a precise estimate 

<math display="inline" id="Reinforcement_learning:58">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 of the action-value function 

<math display="inline" id="Reinforcement_learning:59">
 <semantics>
  <msup>
   <mi>Q</mi>
   <mi>π</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Q</ci>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{\pi}
  </annotation>
 </semantics>
</math>

. This finishes the description of the policy evaluation step. In the policy improvement step, as it is done in the standard policy iteration algorithm, the next policy is obtained by computing a <em>greedy</em> policy with respect to 

<math display="inline" id="Reinforcement_learning:60">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

: Given a state 

<math display="inline" id="Reinforcement_learning:61">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, this new policy returns an action that maximizes 

<math display="inline" id="Reinforcement_learning:62">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>s</ci>
     <ci>normal-⋅</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(s,\cdot)
  </annotation>
 </semantics>
</math>

. In practice one often avoids computing and storing the new policy, but uses <a href="lazy_evaluation" title="wikilink">lazy evaluation</a> to defer the computation of the maximizing actions to when they are actually needed.</p>

<p>A few problems with this procedure are as follows:</p>
<ul>
<li>The procedure may waste too much time on evaluating a suboptimal policy;</li>
<li>It uses samples inefficiently in that a long trajectory is used to improve the estimate only of the <em>single</em> state-action pair that started the trajectory;</li>
<li>When the returns along the trajectories have <em>high variance</em>, convergence will be slow;</li>
<li>It works in <em>episodic problems only</em>;</li>
<li>It works in <em>small, finite MDPs only</em>.</li>
</ul>
<h4 id="temporal-difference-methods">Temporal difference methods</h4>

<p>The first issue is easily corrected by allowing the procedure to change the policy (at all, or at some states) before the values settle. However good this sounds, this may be dangerous as this might prevent convergence. Still, most current algorithms implement this idea, giving rise to the class of <em>generalized policy iteration</em> algorithm. We note in passing that <a href="actor_critic" title="wikilink">actor critic</a> methods belong to this category.</p>

<p>The second issue can be corrected within the algorithm by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is to use <a href="#refSutton84,#refSutton88" title="wikilink">Sutton</a>'s <a href="temporal_difference" title="wikilink">temporal difference</a> (TD) methods which are based on the recursive <a href="Bellman_equations" title="wikilink">Bellman equation</a>. Note that the computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are collected and then the estimates are computed once based on a large number of transitions). Batch methods, a prime example of which is the <a href="least-squares_temporal_difference_method" title="wikilink">least-squares temporal difference method</a> due to <a href="#refBradtke1996" title="wikilink">Bradtke and Barto (1996)</a>, may use the information in the samples better, whereas incremental methods are the only choice when batch methods become infeasible due to their high computational or memory complexity. In addition, there exist methods that try to unify the advantages of the two approaches. Methods based on temporal differences also overcome the second but last issue.</p>

<p>In order to address the last issue mentioned in the previous section, <em>function approximation methods</em> are used. In <em>linear function approximation</em> one starts with a mapping 

<math display="inline" id="Reinforcement_learning:63">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair 

<math display="inline" id="Reinforcement_learning:64">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a)
  </annotation>
 </semantics>
</math>

 are obtained by linearly combining the components of 

<math display="inline" id="Reinforcement_learning:65">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>s</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(s,a)
  </annotation>
 </semantics>
</math>

 with some <em>weights</em> 

<math display="inline" id="Reinforcement_learning:66">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Reinforcement_learning:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>d</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>ϕ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>a</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>d</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>i</ci>
      </apply>
      <interval closure="open">
       <ci>s</ci>
       <ci>a</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(s,a)=\sum\limits_{i=1}^{d}\theta_{i}\phi_{i}(s,a)
  </annotation>
 </semantics>
</math>

.</p>

<p>The algorithms then adjust the weights, instead of adjusting the values associated with the individual state-action pairs. However, linear function approximation is not the only choice. More recently, methods based on ideas from <a href="nonparametric_statistics" title="wikilink">nonparametric statistics</a> (which can be seen to construct their own features) have been explored.</p>

<p>So far, the discussion was restricted to how policy iteration can be used as a basis of the designing reinforcement learning algorithms. Equally importantly, value iteration can also be used as a starting point, giving rise to the <a class="uri" href="Q-Learning" title="wikilink">Q-Learning</a> algorithm <a href="#refWatkins1989" title="wikilink">(Watkins 1989)</a> and its many variants.</p>

<p>The problem with methods that use action-values is that they may need highly precise estimates of the competing action values, which can be hard to obtain when the returns are noisy. Though this problem is mitigated to some extent by temporal difference methods and if one uses the so-called compatible function approximation method, more work remains to be done to increase generality and efficiency. Another problem specific to temporal difference methods comes from their reliance on the recursive Bellman equation. Most temporal difference methods have a so-called 

<math display="inline" id="Reinforcement_learning:68">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 parameter 

<math display="inline" id="Reinforcement_learning:69">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>0</mn>
    <mo>≤</mo>
    <mi>λ</mi>
    <mo>≤</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>λ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0\leq\lambda\leq 1)
  </annotation>
 </semantics>
</math>

 that allows one to continuously interpolate between Monte-Carlo methods (which do not rely on the Bellman equations) and the basic temporal difference methods (which rely entirely on the Bellman equations), which can thus be effective in palliating this issue.</p>
<h3 id="direct-policy-search">Direct policy search</h3>

<p>An alternative method to find a good policy is to search directly in (some subset of) the policy space, in which case the problem becomes an instance of <a href="stochastic_optimization" title="wikilink">stochastic optimization</a>. The two approaches available are gradient-based and gradient-free methods.</p>

<p>Gradient-based methods (giving rise to the so-called <em>policy gradient methods</em>) start with a mapping from a finite-dimensional (parameter) space to the space of policies: given the parameter vector 

<math display="inline" id="Reinforcement_learning:70">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Reinforcement_learning:71">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>θ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{\theta}
  </annotation>
 </semantics>
</math>

 denote the policy associated to 

<math display="inline" id="Reinforcement_learning:72">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. Define the performance function by</p>

<p>

<math display="block" id="Reinforcement_learning:73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>ρ</mi>
     <msub>
      <mi>π</mi>
      <mi>θ</mi>
     </msub>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\theta)=\rho^{\pi_{\theta}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Under mild conditions this function will be differentiable as a function of the parameter vector 

<math display="inline" id="Reinforcement_learning:74">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. If the gradient of 

<math display="inline" id="Reinforcement_learning:75">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 was known, one could use <a href="gradient_descent" title="wikilink">gradient ascent</a>. Since an analytic expression for the gradient is not available, one must rely on a noisy estimate. Such an estimate can be constructed in many ways, giving rise to algorithms like <a href="#refWilliams1987" title="wikilink">Williams'</a> REINFORCE method (which is also known as the <a href="likelihood_ratio_method" title="wikilink">likelihood ratio method</a> in the <a href="simulation-based_optimization" title="wikilink">simulation-based optimization</a> literature). Policy gradient methods have received a lot of attention in the last couple of years (e.g., <a href="#refPeters2003" title="wikilink">Peters et al. (2003)</a>), but they remain an active field. An overview of policy search methods in the context of robotics has been given by Deisenroth, Neumann and Peters.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The issue with many of these methods is that they may get stuck in local optima (as they are based on <a href="Local_search_(optimization)" title="wikilink">local search</a>).</p>

<p>A large class of methods avoids relying on gradient information. These include <a href="simulated_annealing" title="wikilink">simulated annealing</a>, <a href="cross-entropy_method" title="wikilink">cross-entropy search</a> or methods of <a href="evolutionary_computation" title="wikilink">evolutionary computation</a>. Many gradient-free methods can achieve (in theory and in the limit) a global optimum. In a number of cases they have indeed demonstrated remarkable performance.</p>

<p>The issue with policy search methods is that they may converge slowly if the information based on which they act is noisy. For example, this happens when in episodic problems the trajectories are long and the variance of the returns is large. As argued beforehand, value-function based methods that rely on temporal differences might help in this case. In recent years, several actor-critic algorithms have been proposed following this idea and were demonstrated to perform well in various problems.</p>
<h2 id="theory">Theory</h2>

<p>The theory for small, finite MDPs is quite mature. Both the asymptotic and finite-sample behavior of most algorithms is well-understood. As mentioned beforehand, algorithms with provably good online performance (addressing the exploration issue) are known. The theory of large MDPs needs more work. Efficient exploration is largely untouched (except for the case of bandit problems). Although finite-time performance bounds appeared for many algorithms in the recent years, these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages, as well as the limitations of these algorithms. For incremental algorithm asymptotic convergence issues have been settled. Recently, new incremental, temporal-difference-based algorithms have appeared which converge under a much wider set of conditions than was previously possible (for example, when used with arbitrary, smooth function approximation).</p>
<h2 id="current-research">Current research</h2>

<p>Current research topics include: adaptive methods which work with fewer (or no) parameters under a large number of conditions, addressing the exploration problem in large MDPs, large-scale empirical evaluations, learning and acting under <a href="Partially_observable_Markov_decision_process" title="wikilink">partial information</a> (e.g., using <a href="Predictive_State_Representation" title="wikilink">Predictive State Representation</a>), modular and hierarchical reinforcement learning, improving existing value-function and policy search methods, algorithms that work well with large (or continuous) action spaces, transfer learning, lifelong learning, efficient sample-based planning (e.g., based on <a href="Monte-Carlo_tree_search" title="wikilink">Monte-Carlo tree search</a>). Multiagent or Distributed Reinforcement Learning is also a topic of interest in current research. There is also a growing interest in real life applications of reinforcement learning. Successes of reinforcement learning are collected on <a href="http://umichrl.pbworks.com/Successes-of-Reinforcement-Learning/">here</a> and <a href="http://rl-community.org/wiki/Successes_Of_RL">here</a>.</p>

<p>Reinforcement learning algorithms such as TD learning are also being investigated as a model for <a class="uri" href="Dopamine" title="wikilink">Dopamine</a>-based learning in the brain. In this model, the dopaminergic projections from the substantia nigra to the basal ganglia function as the prediction error. Reinforcement learning has also been used as a part of the model for human skill learning, especially in relation to the interaction between implicit and explicit learning in skill acquisition (the first publication on this application was in 1995-1996, and there have been many follow-up studies). See <a class="uri" href="http://webdocs.cs.ualberta.ca/~sutton/RL-FAQ.html#behaviorism">http://webdocs.cs.ualberta.ca/~sutton/RL-FAQ.html#behaviorism</a> for further details of these research areas above.</p>
<h2 id="literature">Literature</h2>
<h3 id="conferences-journals">Conferences, journals</h3>

<p>Most reinforcement learning papers are published at the major machine learning and AI conferences (ICML, NIPS, AAAI, IJCAI, UAI, AI and Statistics) and journals (<a href="http://www.jair.org">JAIR</a>, <a href="http://www.jmlr.org">JMLR</a>, <a href="http://www.springer.com/computer/ai/journal/10994">Machine learning journal</a>, <a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=4804728">IEEE T-CIAIG</a>). Some theory papers are published at COLT and ALT. However, many papers appear in robotics conferences (<a class="uri" href="IROS" title="wikilink">IROS</a>, <a href="International_Conference_on_Robotics_and_Automation" title="wikilink">ICRA</a>) and the "agent" conference AAMAS. Operations researchers publish their papers at the INFORMS conference and, for example, in the <a href="http://or.pubs.informs.org">Operation Research</a>, and the <a href="http://mor.pubs.informs.org">Mathematics of Operations Research</a> journals. Control researchers publish their papers at the CDC and ACC conferences, or, e.g., in the journals <a href="http://www.nd.edu/~ieeetac/">IEEE Transactions on Automatic Control</a>, or <a href="http://www.elsevier.com/locate/automatica">Automatica</a>, although applied works tend to be published in more specialized journals. The <a href="http://www.wintersim.org/">Winter Simulation Conference</a> also publishes many relevant papers. Other than this, papers also published in the major conferences of the neural networks, fuzzy, and evolutionary computation communities. The annual IEEE symposium titled Approximate Dynamic Programming and Reinforcement Learning (ADPRL) and the biannual European Workshop on Reinforcement Learning (<a href="http://ewrl.wordpress.com/">EWRL</a>) are two regularly held meetings where RL researchers meet.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Temporal_difference_learning" title="wikilink">Temporal difference learning</a></li>
<li><a class="uri" href="Q-learning" title="wikilink">Q-learning</a></li>
<li><a href="State-Action-Reward-State-Action" title="wikilink">SARSA</a></li>
<li><a href="Fictitious_play" title="wikilink">Fictitious play</a></li>
<li><a href="Learning_classifier_system" title="wikilink">Learning classifier system</a></li>
<li><a href="Optimal_control" title="wikilink">Optimal control</a></li>
<li><a href="Dynamic_treatment_regimes" title="wikilink">Dynamic treatment regimes</a></li>
<li><a href="Error-driven_learning" title="wikilink">Error-driven learning</a></li>
<li><a href="Multi-agent_system" title="wikilink">Multi-agent system</a></li>
<li><a href="Distributed_artificial_intelligence" title="wikilink">Distributed artificial intelligence</a></li>
</ul>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a href="http://glue.rl-community.org/">RL-Glue</a> provides a standard interface that allows you to connect agents, environments, and experiment programs together, even if they are written in different languages.</li>
<li><a href="http://mmlf.sourceforge.net/">Maja Machine Learning Framework</a> The Maja Machine Learning Framework (MMLF) is a general framework for problems in the domain of Reinforcement Learning (RL) written in python.</li>
<li><a href="http://jamh-web.appspot.com/download.htm">Software Tools for Reinforcement Learning (Matlab and Python)</a></li>
<li><a href="http://www.pybrain.org/">PyBrain(Python)</a></li>
<li><a href="http://servicerobotik.hs-weingarten.de/en/teachingbox.php">TeachingBox</a> is a Java reinforcement learning framework supporting many features like RBF networks, gradient descent learning methods, ...</li>
<li><a href="http://webdocs.cs.ualberta.ca/~vanhasse/code.html">C++ and Python implementations</a> for some well known reinforcement learning algorithms with source.</li>
<li><a href="Orange_(software)" title="wikilink">Orange</a>, a free data mining software suite, module <a href="http://www.ailab.si/orange/doc/modules/orngReinforcement.htm">orngReinforcement</a></li>
<li><a href="http://www.ias.informatik.tu-darmstadt.de/Research/PolicyGradientToolbox">Policy Gradient Toolbox</a> provides a package for learning about policy gradient approaches.</li>
<li><a href="http://burlap.cs.brown.edu">BURLAP</a> is an open source Java library that provides a wide range of single and multi-agent learning and planning methods.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html">Website for <em>Reinforcement Learning: An Introduction</em></a> (1998), by Rich Sutton and Andrew Barto, MIT Press, including a link to an html version of the book.</li>
<li><a href="http://www-anw.cs.umass.edu/rlr/">Reinforcement Learning Repository</a></li>
<li><a href="http://spaces.facsci.ualberta.ca/rlai/">Reinforcement Learning and Artificial Intelligence</a> (RLAI, Rich Sutton's lab at the University of Alberta)</li>
<li><a href="http://www-all.cs.umass.edu/">Autonomous Learning Laboratory</a> (ALL, Andrew Barto's lab at the University of Massachusetts Amherst)</li>
<li><a href="http://glue.rl-community.org">RL-Glue</a></li>
<li><a href="http://jamh-web.appspot.com/download.htm">Software Tools for Reinforcement Learning (Matlab and Python)</a></li>
<li><a href="http://www.igi.tugraz.at/ril-toolbox">The Reinforcement Learning Toolbox from the (Graz University of Technology)</a></li>
<li><a href="http://www.cogsci.rpi.edu/~rsun/hybrid-rl.html">Hybrid reinforcement learning</a></li>
<li><a href="http://sourceforge.net/projects/piqle/">Piqle: a Generic Java Platform for Reinforcement Learning</a></li>
<li><a href="http://webdocs.cs.ualberta.ca/~vanhasse/rl_algs/rl_algs.html">A Short Introduction To Some Reinforcement Learning Algorithms</a></li>
<li><a href="http://www.lwebzem.com/cgi-bin/ttt/ttt.html">Reinforcement Learning applied to Tic-Tac-Toe Game</a></li>
<li><a href="http://www.scholarpedia.org/article/Reinforcement_Learning">Scholarpedia Reinforcement Learning</a></li>
<li><a href="http://www.scholarpedia.org/article/Temporal_difference_learning">Scholarpedia Temporal Difference Learning</a></li>
<li>[<a class="uri" href="http://www.troovoo.com/vid.php?a=Stanford&amp;c">http://www.troovoo.com/vid.php?a=Stanford&amp;c;</a>;=Machine+Learning&amp;l;=Applications+of+Reinforcement+Learning Stanford Reinforcement Learning Course]</li>
<li><a href="http://www.dcsc.tudelft.nl/~robotics/media.html">Real-world reinforcement learning experiments</a> at <a href="Delft_University_of_Technology" title="wikilink">Delft University of Technology</a></li>
<li><a href="http://busoniu.net/repository.php">Reinforcement Learning Tools for Matlab</a></li>
<li>[<a class="uri" href="https://www.youtube.com/watch?v=RtxI449ZjSc&amp;feature">https://www.youtube.com/watch?v=RtxI449ZjSc&amp;feature;</a>;=relmfu Stanford University Andrew Ng Lecture on Reinforcement Learning]</li>
</ul>

<p>"</p>

<p><a href="Category:Markov_models" title="wikilink">Category:Markov models</a> <a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a> <a href="Category:Belief_revision" title="wikilink">Category:Belief revision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
