<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1103">Word problem for groups</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Word problem for groups</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, especially in the area of <a href="abstract_algebra" title="wikilink">abstract algebra</a> known as <a href="combinatorial_group_theory" title="wikilink">combinatorial group theory</a>, the <strong>word problem</strong> for a <a href="finitely_generated_group" title="wikilink">finitely generated group</a> <em>G</em> is the algorithmic problem of deciding whether two words in the generators represent the same element. More precisely, if <em>A</em> is a finite set of <a href="Generating_set_of_a_group" title="wikilink">generators</a> for <em>G</em> then the word problem is the membership problem for the <a href="formal_language" title="wikilink">formal language</a> of all words in <em>A</em> and a formal set of inverses that map to the identity under the natural map from the <a href="free_monoid_with_involution" title="wikilink">free monoid with involution</a> on <em>A</em> to the group <em>G</em>. If <em>B</em> is another finite generating set for <em>G</em>, then the word problem over the generating set <em>B</em> is equivalent to the word problem over the generating set <em>A</em>. Thus one can speak unambiguously of the decidability of the word problem for the finitely generated group <em>G</em>.</p>

<p>The related but different <strong>uniform word problem</strong> for a class <em>K</em> of recursively presented groups is the algorithmic problem of deciding, given as input a <a href="presentation_of_a_group" title="wikilink">presentation</a> <em>P</em> for a group <em>G</em> in the class <em>K</em> and two words in the generators of <em>G</em>, whether the words represent the same element of <em>G</em>. Some authors require the class <em>K</em> to be definable by a <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> set of presentations.</p>
<h2 id="history">History</h2>

<p>Throughout the history of the subject, computations in groups have been carried out using various <a href="Normal_form_(abstract_rewriting)" title="wikilink">normal forms</a>. These usually implicitly solve the word problem for the groups in question. In 1911 <a href="Max_Dehn" title="wikilink">Max Dehn</a> proposed that the word problem was an important area of study in its own right, , together with the <a href="conjugacy_problem" title="wikilink">conjugacy problem</a> and the <a href="group_isomorphism_problem" title="wikilink">group isomorphism problem</a>. In 1912 he gave an algorithm that solves both the word and conjugacy problem for the <a href="fundamental_group" title="wikilink">fundamental groups</a> of closed orientable two-dimensional manifolds of genus greater than or equal to 2, . Subsequent authors have greatly extended <a href="Small_cancellation_theory#Dehn's_algorithm" title="wikilink">Dehn's algorithm</a> and applied it to a wide range of group theoretic <a href="decision_problem" title="wikilink">decision problems</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>It was shown by <a href="Pyotr_Novikov" title="wikilink">Pyotr Novikov</a> in 1955 that there exists a finitely presented group <em>G</em> such that the word problem for <em>G</em> is <a href="Undecidable_problem" title="wikilink">undecidable</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It follows immediately that the uniform word problem is also undecidable. A different proof was obtained by <a href="William_Boone_(mathematician)" title="wikilink">William Boone</a> in 1958.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The word problem was one of the first examples of an unsolvable problem to be found not in <a href="mathematical_logic" title="wikilink">mathematical logic</a> or the <a href="theory_of_algorithms" title="wikilink">theory of algorithms</a>, but in one of the central branches of classical mathematics, <a href="abstract_algebra" title="wikilink">algebra</a>. As a result of its unsolvability, several other problems in combinatorial group theory have been shown to be unsolvable as well.</p>

<p>It is important to realize that the word problem is in fact solvable for many groups <em>G</em>. For example, <a href="polycyclic_group" title="wikilink">polycyclic groups</a> have solvable word problems since the normal form of an arbitrary word in a polycyclic presentation is readily computable; other algorithms for groups may, in suitable circumstances, also solve the word problem, see the <a href="Todd–Coxeter_algorithm" title="wikilink">Todd–Coxeter algorithm</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and the <a href="Knuth–Bendix_completion_algorithm" title="wikilink">Knuth–Bendix completion algorithm</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> On the other hand the fact that a particular algorithm does not solve the word problem for a particular group does not show that the group has unsolvable word problem. For instance Dehn's algorithm does not solve the word problem for the fundamental group of the <a class="uri" href="torus" title="wikilink">torus</a>. However this group is the direct product of two infinite cyclic groups and so has solvable word problem.</p>
<h2 id="a-more-concrete-description">A more concrete description</h2>

<p>In more concrete terms, the uniform word problem can be expressed as a <a class="uri" href="rewriting" title="wikilink">rewriting</a> question, for <a href="literal_string" title="wikilink">literal strings</a>, . For a presentation <em>P</em> of a group <em>G</em>, <em>P</em> will specify a certain number of generators</p>
<dl>
<dd><em>x</em>, <em>y</em>, <em>z</em>, ...
</dd>
</dl>

<p>for <em>G</em>. We need to introduce one letter for <em>x</em> and another (for convenience) for the group element represented by <em>x</em><sup>−1</sup>. Call these letters (twice as many as the generators) the alphabet 

<math display="inline" id="Word_problem_for_groups:0">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 for our problem. Then each element in <em>G</em> is represented in <em>some way</em> by a product</p>
<dl>
<dd><em>abc ... pqr</em>
</dd>
</dl>

<p>of symbols from 

<math display="inline" id="Word_problem_for_groups:1">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, of some length, multiplied in <em>G</em>. The string of length 0 (<a href="Empty_string" title="wikilink">null string</a>) stands for the <a href="identity_element" title="wikilink">identity element</a> <em>e</em> of <em>G</em>. The crux of the whole problem is to be able to recognise <em>all</em> the ways <em>e</em> can be represented, given some relations.</p>

<p>The effect of the <em>relations</em> in <em>G</em> is to make various such strings represent the same element of <em>G</em>. In fact the relations provide a list of strings that can be either introduced where we want, or cancelled out whenever we see them, without changing the 'value', i.e. the group element that is the result of the multiplication.</p>

<p>For a simple example, take the presentation {<em>a</em> | <em>a</em><sup>3</sup>}. Writing <em>A</em> for the inverse of <em>a</em>, we have possible strings combining any number of the symbols <em>a</em> and <em>A</em>. Whenever we see <em>aaa</em>, or <em>aA</em> or <em>Aa</em> we may strike these out. We should also remember to strike out <em>AAA</em>; this says that since the cube of <em>a</em> is the identity element of <em>G</em>, so is the cube of the inverse of <em>a</em>. Under these conditions the word problem becomes easy. First reduce strings to the empty string, <em>a</em>, <em>aa</em>, <em>A</em> or <em>AA</em>. Then note that we may also multiply by <em>aaa</em>, so we can convert <em>A</em> to <em>aa</em> and convert <em>AA</em> to <em>a</em>. The result is that the word problem, here for the <a href="cyclic_group" title="wikilink">cyclic group</a> of order three, is solvable.</p>

<p>This is not, however, the typical case. For the example, we have a <a href="canonical_form" title="wikilink">canonical form</a> available that reduces any string to one of length at most three, by decreasing the length monotonically. In general, it is not true that one can get a canonical form for the elements, by stepwise cancellation. One may have to use relations to expand a string many-fold, in order eventually to find a cancellation that brings the length right down.</p>

<p>The upshot is, in the worst case, that the relation between strings that says they are equal in <em>G</em> is not <em><a href="Decidability_(logic)" title="wikilink">decidable</a></em>.</p>
<h2 id="examples">Examples</h2>

<p>The following groups have a solvable word problem:</p>
<ul>
<li><a href="Automatic_group" title="wikilink">Automatic groups</a>, including:
<ul>
<li><a href="Finite_group" title="wikilink">Finite groups</a></li>
<li><a href="Polycyclic_group" title="wikilink">Polycyclic groups</a></li>
<li><a href="Negatively_curved_group" title="wikilink">Negatively curved (aka. hyperbolic) groups</a></li>
<li><a href="Euclidean_group" title="wikilink">Euclidean groups</a></li>
<li><a href="Coxeter_group" title="wikilink">Coxeter groups</a></li>
<li><a href="Braid_group" title="wikilink">Braid groups</a></li>
<li><a href="Geometrically_finite_group" title="wikilink">Geometrically finite groups</a></li>
</ul></li>
<li>Finitely generated recursively <a href="Absolute_presentation_of_a_group" title="wikilink">absolutely presented groups</a>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> including:
<ul>
<li>Finitely presented simple groups.</li>
</ul></li>
<li>Finitely presented <a href="residually_finite" title="wikilink">residually finite</a> groups</li>
<li>One relator groups<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (this is a theorem of Magnus), including:
<ul>
<li>Fundamental groups of closed orientable two-dimensional manifolds.</li>
</ul></li>
<li>Combable groups</li>
</ul>

<p>Examples with unsolvable word problems are also known:</p>
<ul>
<li>Given a recursively enumerable set <em>A</em> of positive integers that has insoluble membership problem, <em>⟨a,b,c,d | a<sup>n</sup>ba<sup>n</sup> = c<sup>n</sup>dc<sup>n</sup> : n ∈ A⟩</em> is a finitely generated group with a recursively enumerable presentation whose word problem is insoluble </li>
<li>Every finitely generated group with a recursively enumerable presentation and insoluble word problem is a subgroup of a finitely presented group with insoluble word problem </li>
<li>The number of relators in a finitely presented group with insoluble word problem may be as low as 14 by  or even 12 by , .</li>
<li>An explicit example of a reasonable short presentation with insoluble word problem is given in :<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
</ul>

<p>

<math display="block" id="Word_problem_for_groups:2">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mo stretchy="false">⟨</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>c</mi>
      <mo>,</mo>
      <mi>d</mi>
      <mo>,</mo>
      <mi>e</mi>
      <mo>,</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>q</mi>
      <mo>,</mo>
      <mi>r</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mi>a</mi>
      <mo>=</mo>
      <mi>a</mi>
      <mi>p</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <mi>a</mi>
      <mi>c</mi>
      <mi>q</mi>
      <mi>r</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>r</mi>
      <mi>p</mi>
      <mi>c</mi>
      <mi>a</mi>
      <mi>q</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>r</mi>
      <mi>a</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>a</mi>
      <mi>r</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mi>b</mi>
      <mo>=</mo>
      <mi>b</mi>
      <mi>p</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>2</mn>
      </msup>
      <mi>a</mi>
      <mi>d</mi>
      <msup>
       <mi>q</mi>
       <mn>2</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>2</mn>
      </msup>
      <mi>d</mi>
      <mi>a</mi>
      <msup>
       <mi>q</mi>
       <mn>2</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>r</mi>
      <mi>b</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>b</mi>
      <mi>r</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mi>c</mi>
      <mo>=</mo>
      <mi>c</mi>
      <mi>p</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>3</mn>
      </msup>
      <mi>b</mi>
      <mi>c</mi>
      <msup>
       <mi>q</mi>
       <mn>3</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>3</mn>
      </msup>
      <mi>c</mi>
      <mi>b</mi>
      <msup>
       <mi>q</mi>
       <mn>3</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>r</mi>
      <mi>c</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>c</mi>
      <mi>r</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mi>d</mi>
      <mo>=</mo>
      <mi>d</mi>
      <mi>p</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>4</mn>
      </msup>
      <mi>b</mi>
      <mi>d</mi>
      <msup>
       <mi>q</mi>
       <mn>4</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>4</mn>
      </msup>
      <mi>d</mi>
      <mi>b</mi>
      <msup>
       <mi>q</mi>
       <mn>4</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>r</mi>
      <mi>d</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>d</mi>
      <mi>r</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mi>e</mi>
      <mo>=</mo>
      <mi>e</mi>
      <mi>p</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>5</mn>
      </msup>
      <mi>c</mi>
      <mi>e</mi>
      <msup>
       <mi>q</mi>
       <mn>5</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>5</mn>
      </msup>
      <mi>e</mi>
      <mi>c</mi>
      <mi>a</mi>
      <msup>
       <mi>q</mi>
       <mn>5</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>e</mi>
      <mi>r</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>a</mi>
      <mi>q</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mo>=</mo>
      <mi>q</mi>
      <mi>a</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>6</mn>
      </msup>
      <mi>d</mi>
      <mi>e</mi>
      <msup>
       <mi>q</mi>
       <mn>6</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>6</mn>
      </msup>
      <mi>e</mi>
      <mi>d</mi>
      <mi>b</mi>
      <msup>
       <mi>q</mi>
       <mn>6</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <mi>t</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>t</mi>
      <mi>p</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>b</mi>
      <mi>q</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mo>=</mo>
      <mi>q</mi>
      <mi>b</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>7</mn>
      </msup>
      <mi>c</mi>
      <mi>d</mi>
      <mi>c</mi>
      <msup>
       <mi>q</mi>
       <mn>7</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>7</mn>
      </msup>
      <mi>c</mi>
      <mi>d</mi>
      <mi>c</mi>
      <mi>e</mi>
      <msup>
       <mi>q</mi>
       <mn>7</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>q</mi>
      <mi>t</mi>
      <mo>;</mo>
      <mo>=</mo>
      <mi>t</mi>
      <mi>q</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>c</mi>
      <mi>q</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mo>=</mo>
      <mi>q</mi>
      <mi>c</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>8</mn>
      </msup>
      <mi>c</mi>
      <msup>
       <mi>a</mi>
       <mn>3</mn>
      </msup>
      <msup>
       <mi>q</mi>
       <mn>8</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>8</mn>
      </msup>
      <msup>
       <mi>a</mi>
       <mn>3</mn>
      </msup>
      <msup>
       <mi>q</mi>
       <mn>8</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>d</mi>
      <mi>q</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mo>=</mo>
      <mi>q</mi>
      <mi>d</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>p</mi>
      <msup>
       <mo>;</mo>
       <mn>9</mn>
      </msup>
      <mi>d</mi>
      <msup>
       <mi>a</mi>
       <mn>3</mn>
      </msup>
      <msup>
       <mi>q</mi>
       <mn>9</mn>
      </msup>
      <mi>r</mi>
      <mo>=</mo>
      <mi>r</mi>
      <msup>
       <mi>p</mi>
       <mn>9</mn>
      </msup>
      <msup>
       <mi>a</mi>
       <mn>3</mn>
      </msup>
      <msup>
       <mi>q</mi>
       <mn>9</mn>
      </msup>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>e</mi>
      <mi>q</mi>
      <msup>
       <mo>;</mo>
       <mn>10</mn>
      </msup>
      <mo>=</mo>
      <mi>q</mi>
      <mi>e</mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>a</mi>
      <msup>
       <mo>;</mo>
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </msup>
      <mi>t</mi>
      <msup>
       <mi>a</mi>
       <mn>3</mn>
      </msup>
      <mi>k</mi>
      <mo>=</mo>
      <mi>k</mi>
      <msup>
       <mi>a</mi>
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </msup>
      <mi>t</mi>
      <msup>
       <mi>a</mi>
       <mn>3</mn>
      </msup>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="left">
     <mo stretchy="false">⟩</mo>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>normal-⟨</ci>
     <list>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>d</ci>
      <ci>e</ci>
      <ci>p</ci>
      <ci>q</ci>
      <ci>r</ci>
      <ci>t</ci>
      <ci>k</ci>
     </list>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <csymbol cd="unknown">a</csymbol>
      <eq></eq>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <csymbol cd="unknown">b</csymbol>
      <eq></eq>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">2</cn>
      </apply>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">2</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <csymbol cd="unknown">c</csymbol>
      <eq></eq>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">3</cn>
      </apply>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">3</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <csymbol cd="unknown">d</csymbol>
      <eq></eq>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">4</cn>
      </apply>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">4</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">4</cn>
      </apply>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <csymbol cd="unknown">e</csymbol>
      <eq></eq>
      <csymbol cd="unknown">e</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">5</cn>
      </apply>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">5</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">5</cn>
      </apply>
      <csymbol cd="unknown">e</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">5</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">e</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <eq></eq>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">6</cn>
      </apply>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">6</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">6</cn>
      </apply>
      <csymbol cd="unknown">e</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">6</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <eq></eq>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">7</cn>
      </apply>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">7</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">7</cn>
      </apply>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">7</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-;</ci>
      <eq></eq>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <eq></eq>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">8</cn>
      </apply>
      <csymbol cd="unknown">c</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">8</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">8</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">8</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <eq></eq>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">9</cn>
      </apply>
      <csymbol cd="unknown">d</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">9</cn>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <eq></eq>
      <csymbol cd="unknown">r</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">9</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">9</cn>
      </apply>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">10</cn>
      </apply>
      <eq></eq>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-,</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-;</ci>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <csymbol cd="unknown">t</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <csymbol cd="unknown">k</csymbol>
      <eq></eq>
      <csymbol cd="unknown">k</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <csymbol cd="unknown">t</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-⟩</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lllll}\langle&a,b,c,d,e,p,q,r,t,k&|&&\\
&p;^{10}a=ap,&pacqr;=rpcaq,&ra;=ar,&\\
&p;^{10}b=bp,&p;^{2}adq^{2}r=rp^{2}daq^{2},&rb;=br,&\\
&p;^{10}c=cp,&p;^{3}bcq^{3}r=rp^{3}cbq^{3},&rc;=cr,&\\
&p;^{10}d=dp,&p;^{4}bdq^{4}r=rp^{4}dbq^{4},&rd;=dr,&\\
&p;^{10}e=ep,&p;^{5}ceq^{5}r=rp^{5}ecaq^{5},&re;=er,&\\
&aq;^{10}=qa,&p;^{6}deq^{6}r=rp^{6}edbq^{6},&pt;=tp,&\\
&bq;^{10}=qb,&p;^{7}cdcq^{7}r=rp^{7}cdceq^{7},&qt;=tq,&\\
&cq;^{10}=qc,&p;^{8}ca^{3}q^{8}r=rp^{8}a^{3}q^{8},&&\\
&dq;^{10}=qd,&p;^{9}da^{3}q^{9}r=rp^{9}a^{3}q^{9},&&\\
&eq;^{10}=qe,&a;^{-3}ta^{3}k=ka^{-3}ta^{3}&&\rangle\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="partial-solution-of-the-word-problem">Partial solution of the word problem</h2>

<p>The word problem for a recursively presented group can be partially solved in the following sense:</p>
<dl>
<dd><dl>
<dd>Given a recursive presentation <em>P</em> = ⟨<em>X</em>|<em>R</em>⟩ for a group <em>G</em>, define:

<p>

<math display="block" id="Word_problem_for_groups:3">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>u</mi>
      <mtext>and</mtext>
      <mi>v</mi>
      <mtext>are words in</mtext>
      <mi>X</mi>
      <mtext>and</mtext>
      <mi>u</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>v</mi>
      <mtext>in</mtext>
      <mpadded width="+5pt">
       <mi>G</mi>
      </mpadded>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <list>
      <ci>u</ci>
      <ci>v</ci>
     </list>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>u</ci>
       <mtext>and</mtext>
       <ci>v</ci>
       <mtext>are words in</mtext>
       <ci>X</ci>
       <mtext>and</mtext>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <ci>v</ci>
       <mtext>in</mtext>
       <ci>G</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{\langle u,v\rangle:u\mbox{ and }v\mbox{ are words in }X\mbox{ and }u=v%
\mbox{ in }G\ \}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>then there is a partial recursive function <em>f<sub>P</sub></em> such that:

<p>:<math>f_P(\langle u,v \rangle) =</math></p>
</dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ \langle u,v \rangle \in S \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ \langle u,v \rangle \notin S \end{matrix}\right.</p>

<p>More informally, there is an algorithm that halts if <em>u=v</em>, but does not do so otherwise.</p>

<p>It follows that to solve the word problem for <em>P</em> it is sufficient to construct a recursive function g such that:</p>
<dl>
<dd><dl>
<dd><math>g(\langle u,v \rangle) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ \langle u,v \rangle \notin S \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ \langle u,v \rangle \in S \end{matrix}\right.</p>

<p>However <em>u=v</em> in <em>G</em> if and only if <em>uv<sup>−1</sup>=1</em> in <em>G</em>. It follows that to solve the word problem for <em>P</em> it is sufficient to construct a recursive function <em>h</em> such that:</p>
<dl>
<dd><dl>
<dd><math>h(x) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ x\neq1\ \mbox{in}\ G \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ x=1\ \mbox{in}\ G \end{matrix}\right.</p>
<h3 id="example">Example</h3>

<p>The following will be proved as an example of the use of this technique:</p>
<dl>
<dd><dl>
<dd><strong>Theorem:</strong> A finitely presented residually finite group has solvable word problem.
</dd>
</dl>
</dd>
</dl>

<p><em>Proof:</em> Suppose <em>G</em> = ⟨<em>X</em>|<em>R</em>⟩ is a finitely presented, residually finite group.</p>

<p>Let <em>S</em> be the group of all permutations of <strong>N</strong>, the natural numbers, that fixes all but finitely many numbers then:</p>
<ol>
<li><em>S</em> is <a href="locally_finite_group" title="wikilink">locally finite</a> and contains a copy of every finite group.</li>
<li>The word problem in <em>S</em> is solvable by calculating products of permutations.</li>
<li>There is a recursive enumeration of all mappings of the finite set <em>X</em> into <em>S</em>.</li>
<li>Since <em>G</em> is residually finite, if <em>w</em> is a word in the generators <em>X</em> of <em>G</em> then <em>w ≠ 1</em> in <em>G</em> if and only of some mapping of <em>X</em> into <em>S</em> induces a homomorphism such that <em>w ≠ 1</em> in <em>S</em>.</li>
</ol>

<p>Given these facts, algorithm defined by the following pseudocode:</p>
<dl>
<dd>For every mapping of <em>X</em> into <em>S</em>
<dl>
<dd>If every relator in <em>R</em> is satisfied in <em>S</em>
<dl>
<dd>If <em>w ≠ 1</em> in <em>S</em>
<dl>
<dd>return 0
</dd>
</dl>
</dd>
<dd>End if
</dd>
</dl>
</dd>
<dd>End if
</dd>
</dl>
</dd>
<dd>End for
</dd>
</dl>

<p>defines a recursive function <em>h</em> such that:</p>
<dl>
<dd><dl>
<dd><math>h(x) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ x\neq 1\ \mbox{in}\ G \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ x=1\ \mbox{in}\ G \end{matrix}\right. </p>

<p>This shows that <em>G</em> has solvable word problem.</p>
<h2 id="unsolvability-of-the-uniform-word-problem">Unsolvability of the uniform word problem</h2>

<p>The criterion, given above for the solvability of the word problem in a single group can be extended to a criterion for the uniform solvability of the word problem for a class of finitely presented groups by a straightforward argument. The result is:</p>
<dl>
<dd><dl>
<dd>To solve the uniform word problem for a class <em>K</em> of groups it is sufficient to find a recursive function <em>f(P,w)</em> that takes a finite presentation <em>P</em> for a group <em>G</em> and a word <em>w</em> in the generators of <em>G</em> such that whenever in <em>G ∈ K</em>:

<p>:<math>f(P,w) =</math></p>
</dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ w\neq1\ \mbox{in}\ G \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ w=1\ \mbox{in}\ G \end{matrix}\right.</p>
<dl>
<dd><dl>
<dd><strong>Boone- Rogers Theorem:</strong> There is no uniform <a href="partial_algorithm" title="wikilink">partial algorithm</a> that solves the word problem in all finitely presented groups with solvable word problem.
</dd>
</dl>
</dd>
</dl>

<p>In other words the uniform word problem for the class of all finitely presented groups with solvable word problem is unsolvable. This has some interesting consequences. For instance the <a href="Higman_embedding_theorem" title="wikilink">Higman embedding theorem</a> can be used to construct a group containing an isomorphic copy of every finitely presented group with solvable word problem. It seems natural to ask whether this group can have solvable word problem. But it is a consequence of the Boone-Rogers result that:</p>
<dl>
<dd><dl>
<dd><strong>Corollary:</strong> There is no universal solvable word problem group. That is, if <em>G</em> is a finitely presented group that contains an isomorphic copy of every finitely presented group with solvable word problem, then <em>G</em> itself must have unsolvable word problem.
</dd>
</dl>
</dd>
</dl>

<p><strong>Remark:</strong> Suppose <em>G = ⟨X|R⟩</em> is a finitely presented group with solvable word problem and <em>H</em> is a finite subset <em>G</em>. Let <em>H</em><sup>*</sup> = ⟨<em>H</em>⟩, be the group generated by <em>H</em>. Then the word problem in <em>H</em><sup>*</sup> is solvable: given two words <em>h, k</em> in the generators <em>H</em> of <em>H</em><sup>*</sup>, write them as words in <em>X</em> and compare them using the solution to the word problem in <em>G</em>. It is easy to think that this demonstrates a uniform solution the word problem for the class <em>K</em> (say) of finitely generated groups that can be embedded in <em>G</em>. If this were the case the non-existence of a universal solvable word problem group would follow easily from Boone-Rogers. However, solution just exhibited for the word problem for groups in <em>K</em> is not uniform. To see this consider a group <em>J = ⟨Y|T⟩ ∈ K</em>, in order to use the above argument to solve the word problem in <em>J</em>, it is first necessary to exhibit a mapping <em>e: Y → G</em> that extends to an embedding <em>e<sup>*</sup>: J → G</em>. If there were a recursive function that mapped (finitely generated) presentations of groups in <em>K</em> to embeddings into <em>G</em>, then a uniform solution the word problem in <em>K</em> could indeed be constructed. But there is no reason, in general, to suppose that such a recursive function exists. However, it turns out that, using a more sophisicated argument, the word problem in <em>J</em> can be solved <em>without</em> using an embedding <em>e: J → G</em>. Instead an <em>enumeration of homomorphisms</em> is used, and since such enumeration can be constructed uniformly, it results in a uniform solution to the word problem in <em>K</em>.</p>
<h3 id="proof-that-there-is-no-universal-solvable-word-problem-group">Proof that there is no universal solvable word problem group</h3>

<p>Suppose <em>G</em> were a universal solvable word problem group. Given a finite presentation <em>P = ⟨X|R⟩</em> of a group <em>H</em>, one can recursively enumerate all homomorphisms <em>h: H → G</em> by first enumerating all mappings <em>h<sup>†</sup>: X → G</em>. Not all of these mappings extend to homomorphisms, but, since <em>h<sup>†</sup>(R)</em>, is finite, it is possible to distinguish between homomorphism and non-homomorphisms by using the solution to the word problem in <em>G</em>. "Weeding out" non-homomorphisms gives the required recursive enumeration: <em>h<sub>1</sub></em>, <em>h<sub>2</sub></em>, ..., <em>h<sub>n</sub></em>, ... .</p>

<p>If <em>H</em> has solvable word problem, then at least one of these homomorphism must be an embedding. So given a word <em>w</em> in the generators of <em>H</em>:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Word_problem_for_groups:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mtext>If</mtext>
     </mpadded>
     <mi>w</mi>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mpadded width="+5pt">
      <mn>1</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>in</mtext>
     </mpadded>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mpadded width="+5pt">
      <mn>1</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>in</mtext>
     </mpadded>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>for some</mtext>
     </mpadded>
     <msub>
      <mi>h</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <neq></neq>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <ci>w</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>in</mtext>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>n</ci>
      </apply>
      <ci>w</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>in</mtext>
      <ci>G</ci>
      <mtext>for some</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{If}\ w\neq 1\ \mbox{in}\ H,\ h_{n}(w)\neq 1\ \mbox{in}\ G\ \mbox{for %
some}\ h_{n}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Word_problem_for_groups:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mtext>If</mtext>
     </mpadded>
     <mi>w</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <mn>1</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>in</mtext>
     </mpadded>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <mn>1</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>in</mtext>
     </mpadded>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>for all</mtext>
     </mpadded>
     <msub>
      <mi>h</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <ci>w</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>in</mtext>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>n</ci>
      </apply>
      <ci>w</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>in</mtext>
      <ci>G</ci>
      <mtext>for all</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{If}\ w=1\ \mbox{in}\ H,\ h_{n}(w)=1\ \mbox{in}\ G\ \mbox{for all}\ h_{n}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Consider the algorithm described by the pseudocode:</p>
<dl>
<dd><dl>
<dd>Let <em>n</em>=<em>0</em>
</dd>
<dd>Let <em>repeat</em>=TRUE
</dd>
<dd>while (<em>repeat</em>==TRUE)
<dl>
<dd>increase <em>n</em> by <em>1</em>
</dd>
<dd>if (solution to word problem in <em>G</em> reveals <em>h<sub>n</sub>(w) ≠ 1</em> in <em>G</em>)
<dl>
<dd>Let <em>repeat</em>==FALSE
</dd>
</dl>
</dd>
</dl>
</dd>
<dd>output 0.
</dd>
</dl>
</dd>
</dl>

<p>This describes a recursive function:</p>
<dl>
<dd><dl>
<dd><math>f(w) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ w\neq1\ \mbox{in}\ H \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ w=1\ \mbox{in}\ H. \end{matrix}\right.</p>

<p>The function <em>f</em> clearly depends on the presentation <em>P</em>. Considering it to be a function of the two variables, a recursive function <em>f(P,w)</em> has been constructed that takes a finite presentation <em>P</em> for a group <em>G</em> and a word <em>w</em> in the generators of <em>G</em> such that whenever <em>G</em> has soluble word problem:</p>
<dl>
<dd><dl>
<dd><math>f(P,w) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ w\neq1\ \mbox{in}\ H \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ w=1\ \mbox{in}\ H. \end{matrix}\right.</p>

<p>But this uniformly solves the word problem for the class of all finitely presented groups with solvable word problem contradicting Boone-Rogers. This contradiction proves <em>G</em> cannot exist.</p>
<h2 id="algebraic-structure-and-the-word-problem">Algebraic structure and the word problem</h2>

<p>There are a number of results that relate solvability of the word problem and algebraic structure. The most significant of these is the <a href="Boone-Higman_theorem" title="wikilink">Boone-Higman theorem</a>:</p>
<dl>
<dd><dl>
<dd>A finitely presented group has solvable word problem if and only if it can be embedded in a <a href="simple_group" title="wikilink">simple group</a> that can be embedded in a finitely presented group.
</dd>
</dl>
</dd>
</dl>

<p>It is widely believed that it should be possible to do the construction so that the simple group itself is finitely presented. If so one would expect it to be difficult to prove as the mapping from presentations to simple groups would have to be non-recursive.</p>

<p>The following has been proved by <a href="Bernhard_Neumann" title="wikilink">Bernhard Neumann</a> and <a href="Angus_Macintyre" title="wikilink">Angus Macintyre</a>:</p>
<dl>
<dd><dl>
<dd>A finitely presented group has solvable word problem if and only if it can be embedded in every <a href="algebraically_closed_group" title="wikilink">algebraically closed group</a>
</dd>
</dl>
</dd>
</dl>

<p>What is remarkable about this is that the algebraically closed groups are so wild that none of them has a recursive presentation.</p>

<p>The oldest result relating algebraic structure to solvability of the word problem is <a class="uri" href="Kuznetsov" title="wikilink">Kuznetsov</a>'s theorem:</p>
<dl>
<dd><dl>
<dd>A recursively presented simple group <em>S</em> has solvable word problem.
</dd>
</dl>
</dd>
</dl>

<p>To prove this let <em>⟨X|R⟩</em> be a recursive presentation for <em>S</em>. Choose <em>a ∈ S</em> such that <em>a ≠ 1</em> in <em>S</em>.</p>

<p>If <em>w</em> is a word on the generators <em>X</em> of <em>S</em>, then let:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Word_problem_for_groups:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mi>w</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>X</mi>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>R</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>w</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>X</ci>
     <apply>
      <union></union>
      <ci>R</ci>
      <set>
       <ci>w</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{w}=\langle X|R\cup\{w\}\rangle.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>There is a recursive function 

<math display="inline" id="Word_problem_for_groups:7">
 <semantics>
  <msub>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>R</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>w</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>X</ci>
     <apply>
      <union></union>
      <ci>R</ci>
      <set>
       <ci>w</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\langle X|R\cup\{w\}\rangle}
  </annotation>
 </semantics>
</math>

 such that:</p>
<dl>
<dd><dl>
<dd><math>f_{\langle X | R\cup \{w\} \rangle}(x) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ x=1\ \mbox{in}\ S_w\\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ x\neq 1\ \mbox{in}\ S_w. \end{matrix}\right.</p>

<p>Write:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Word_problem_for_groups:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>R</mi>
        <mo>∪</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>w</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>w</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <ci>X</ci>
       <apply>
        <union></union>
        <ci>R</ci>
        <set>
         <ci>w</ci>
        </set>
       </apply>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(w,x)=f_{\langle X|R\cup\{w\}\rangle}(x).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Then because the construction of <em>f</em> was uniform, this is a recursive function of two variables.</p>

<p>It follows that: <em>h(w)=g(w, a)</em> is recursive. By construction:</p>
<dl>
<dd><dl>
<dd><math>h(w) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ a=1\ \mbox{in}\ S_w\\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ a\neq 1\ \mbox{in}\ S_w. \end{matrix}\right.</p>

<p>Since <em>S</em> is a simple group, its only quotient groups are itself and the trivial group. Since <em>a ≠ 1</em> in <em>S</em>, we see <em>a</em> = 1 in <em>S<sub>w</sub></em> if and only if <em>S<sub>w</sub></em> is trivial if and only if <em>w ≠ 1</em> in <em>S</em>. Therefore:</p>
<dl>
<dd><dl>
<dd><math>h(w) =
</math></dd>
</dl>
</dd>
</dl>

<p>\left\{\begin{matrix} 0 &amp;\mbox{if}\ w\ne 1\ \mbox{in}\ S\\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ w=1\ \mbox{in}\ S. \end{matrix}\right.</p>

<p>The existence of such a function is sufficient to prove the word problem is solvable for <em>S</em>.</p>

<p>This proof does not prove the existence of a uniform algorithm for solving the word problem for this class of groups. The non-uniformity resides in choosing a non-trivial element of the simple group. There is no reason to suppose that there is a recursive function that maps a presentation of a simple groups to a non-trivial element of the group. However, in the case of a finitely presented group we know that not all the generators can be trivial (Any individual generator could be, of course). Using this fact it is possible to modify the proof to show:</p>
<dl>
<dd>The word problem is uniformly solvable for the class of finitely presented simple groups.
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Combinatorics_on_words" title="wikilink">Combinatorics on words</a></li>
<li><a href="SQ-universal_group" title="wikilink">SQ-universal group</a></li>
<li><a href="Word_problem_(mathematics)" title="wikilink">Word problem (mathematics)</a></li>
<li><a href="Reachability_problem" title="wikilink">Reachability problem</a></li>
<li><a href="Nested_stack_automaton#Properties" title="wikilink">Nested stack automata</a> (have been used to solve the word problem for groups)</li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>W. W. Boone, F. B. Cannonito, and <a href="Roger_Lyndon" title="wikilink">R. C. Lyndon</a>. <em>Word Problems: Decision Problem in Group Theory.</em> Netherlands: North-Holland. 1973.</li>
<li>W. W. Boone and G. Higman, "An algebraic characterization of the solvability of the word problem", <em>J. Austral. Math. Soc.</em> <strong>18</strong>, 41-53 (1974)</li>
<li>W. W. Boone and H. Rogers Jr., "On a problem of J. H. C. Whitehead and a problem of Alonzo Church", <em>Math. Scand.</em> <strong>19</strong>, 185-192 (1966).'</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>A. V. Kuznetsov, "Algorithms as operations in algebraic systems", <em>Izvestia Akad. Nauk SSSR Ser Mat</em> (1958)</li>
<li>C. F. Miller. "Decision problems for groups -- survey and reflections." In <em>Algorithms and Classification in Combinatorial Group Theory</em>, pages 1–60. Springer, 1991.</li>
<li></li>
<li>J. Stillwell. "The word problem and the isomorphism problem for groups." <em>Bulletin AMS</em> <strong>6</strong> (1982), pp 33–56.</li>
</ul>

<p>"</p>

<p><a href="Category:Group_theory" title="wikilink">Category:Group theory</a> <a href="Category:Combinatorics_on_words" title="wikilink">Category:Combinatorics on words</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">J.A. Todd and H.S.M. Coxeter. "A practical method for enumerating coset of a finite abstract group", <em>Proc, Edinburgh Math Soc.</em> (2), <strong>5</strong>, 25---34. 1936<a href="#fnref6">↩</a></li>
<li id="fn7">D. Knuth and P. Bendix. "Simple word problems in universal algebras." <em>Computational Problems in Abstract Algebra</em> (Ed. J. Leech) pages 263--297, 1970.<a href="#fnref7">↩</a></li>
<li id="fn8">H.Simmons, "The word problem for absolute presentations." <em>J. London Math. Soc.</em> (2) 6, 275-280 1973<a href="#fnref8">↩</a></li>
<li id="fn9">Roger C. Lyndon, Paul E Schupp, Combinatorial Group Theory, Springer, 2001<a href="#fnref9">↩</a></li>
<li id="fn10">We use the corrected version from <a href="http://shell.cas.usf.edu/~eclark/algctlg/groups.html">John Pedersen's A Catalogue of Algebraic Systems</a><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
