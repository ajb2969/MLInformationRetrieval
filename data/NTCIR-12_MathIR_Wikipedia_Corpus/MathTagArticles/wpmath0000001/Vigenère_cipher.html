<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1994">Vigenère cipher</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Vigenère cipher</h1>
<hr/>

<p> </p>

<p>The <strong>Vigenère cipher</strong> is a method of <a href="encryption" title="wikilink">encrypting</a> <a href="alphabet" title="wikilink">alphabetic</a> text by using a series of different <a href="Caesar_cipher" title="wikilink">Caesar ciphers</a> based on the letters of a keyword. It is a simple form of <a href="Polyalphabetic_cipher" title="wikilink">polyalphabetic substitution</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The Vigenère () cipher has been reinvented many times. The method was originally described by <a href="Giovan_Battista_Bellaso" title="wikilink">Giovan Battista Bellaso</a> in his 1553 book <em>La cifra del. Sig. Giovan Battista Bellaso</em>; however, the scheme was later misattributed to <a href="Blaise_de_Vigenère" title="wikilink">Blaise de Vigenère</a> in the 19th century, and is now widely known as the "Vigenère cipher".</p>

<p>Though the cipher is easy to understand and implement, for three centuries it resisted all attempts to break it; this earned it the description <strong>le chiffre indéchiffrable</strong> (French for 'the indecipherable cipher'). Many people have tried to implement encryption schemes that are essentially Vigenère ciphers.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="Friedrich_Kasiski" title="wikilink">Friedrich Kasiski</a> was the first to publish a general method of deciphering a Vigenère cipher.</p>
<h2 id="history">History</h2>

<p>The first well documented description of a polyalphabetic cipher was formulated by <a href="Leon_Battista_Alberti" title="wikilink">Leon Battista Alberti</a> around 1467 and used a metal cipher disc to switch between cipher alphabets. Alberti's system only switched alphabets after several words, and switches were indicated by writing the letter of the corresponding alphabet in the ciphertext. Later, in 1508, <a href="Johannes_Trithemius" title="wikilink">Johannes Trithemius</a>, in his work <em>Poligraphia</em>, invented the <a href="tabula_recta" title="wikilink">tabula recta</a>, a critical component of the Vigenère cipher. The <a href="Trithemius_cipher" title="wikilink">Trithemius cipher</a>, however, only provided a progressive, rigid and predictable system for switching between cipher alphabets.</p>

<p>What is now known as the Vigenère cipher was originally described by <a href="Giovan_Battista_Bellaso" title="wikilink">Giovan Battista Bellaso</a> in his 1553 book <em>La cifra del. Sig. Giovan Battista Bellaso</em>. He built upon the tabula recta of Trithemius, but added a repeating "countersign" (a <a href="Key_(cryptography)" title="wikilink">key</a>) to switch cipher alphabets every letter. Whereas Alberti and Trithemius used a fixed pattern of substitutions, Bellaso's scheme meant the pattern of substitutions could be easily changed simply by selecting a new key. Keys were typically single words or short phrases, known to both parties in advance, or transmitted "out of band" along with the message. Bellaso's method thus required strong security for only the key. As it is relatively easy to secure a short key phrase, say by a previous private conversation, Bellaso's system was considerably more secure.</p>

<p><a href="Blaise_de_Vigenère" title="wikilink">Blaise de Vigenère</a> published his description of a similar but stronger <a href="autokey_cipher" title="wikilink">autokey cipher</a> before the court of <a href="Henry_III_of_France" title="wikilink">Henry III of France</a>, in 1586. Later, in the 19th century, the invention of Bellaso's cipher was misattributed to Vigenère. David Kahn in his book <em>The Codebreakers</em> lamented the misattribution by saying that history had "ignored this important contribution and instead named a regressive and elementary cipher for him [Vigenère] though he had nothing to do with it".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The Vigenère cipher gained a reputation for being exceptionally strong. Noted author and mathematician Charles Lutwidge Dodgson (<a href="Lewis_Carroll" title="wikilink">Lewis Carroll</a>) called the Vigenère cipher unbreakable in his 1868 piece "<a href="The_Alphabet_Cipher" title="wikilink">The Alphabet Cipher</a>" in a children's magazine. In 1917, <em><a href="Scientific_American" title="wikilink">Scientific American</a></em> described the Vigenère cipher as "impossible of translation".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This reputation was not deserved. <a href="Charles_Babbage" title="wikilink">Charles Babbage</a> is known to have broken a variant of the cipher as early as 1854; however, he didn't publish his work.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Kasiski entirely broke the cipher and published the technique in the 19th century. Even before this, though, some skilled cryptanalysts could occasionally break the cipher in the 16th century.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p> The Vigenère cipher is simple enough to be a field cipher if it is used in conjunction with cipher disks.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The <a href="Confederate_States_of_America" title="wikilink">Confederate States of America</a>, for example, used a brass cipher disk to implement the Vigenère cipher during the <a href="American_Civil_War" title="wikilink">American Civil War</a>. The Confederacy's messages were far from secret and the Union regularly cracked their messages. Throughout the war, the Confederate leadership primarily relied upon three key phrases, "Manchester Bluff", "Complete Victory" and, as the war came to a close, "Come Retribution".<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p><a href="Gilbert_Vernam" title="wikilink">Gilbert Vernam</a> tried to repair the broken cipher (creating the Vernam-Vigenère cipher in 1918), but, no matter what he did, the cipher was still vulnerable to cryptanalysis. Vernam's work, however, eventually led to the <a href="one-time_pad" title="wikilink">one-time pad</a>, a provably unbreakable cipher.</p>
<h2 id="description">Description</h2>
<figure><b>(Figure)</b>
<figcaption>The Vigenère square or Vigenère table, also known as the <em><a href="tabula_recta" title="wikilink">tabula recta</a></em>, can be used for encryption and decryption.</figcaption>
</figure>

<p>In a <a href="Caesar_cipher" title="wikilink">Caesar cipher</a>, each letter of the alphabet is shifted along some number of places; for example, in a Caesar cipher of shift 3, <code>A</code> would become <code>D</code>, <code>B</code> would become <code>E</code>, <code>Y</code> would become <code>B</code> and so on. The Vigenère cipher consists of several Caesar ciphers in sequence with different shift values.</p>

<p>To encrypt, a table of alphabets can be used, termed a <em><a href="tabula_recta" title="wikilink">tabula recta</a></em>, <em>Vigenère square</em>, or <em>Vigenère table</em>. It consists of the alphabet written out 26 times in different rows, each alphabet shifted cyclically to the left compared to the previous alphabet, corresponding to the 26 possible Caesar ciphers. At different points in the encryption process, the cipher uses a different alphabet from one of the rows. The alphabet used at each point depends on a repeating keyword.</p>

<p>For example, suppose that the <a class="uri" href="plaintext" title="wikilink">plaintext</a> to be encrypted is:</p>
<dl>
<dd><code>ATTACKATDAWN</code>
</dd>
</dl>

<p>The person sending the message chooses a keyword and repeats it until it matches the length of the plaintext, for example, the keyword "LEMON":</p>
<dl>
<dd><code>LEMONLEMONLE</code>
</dd>
</dl>

<p>Each row starts with a key letter. The remainder of the row holds the letters A to Z (in shifted order). Although there are 26 key rows shown, you will only use as many keys (different alphabets) as there are unique letters in the key string, here just 5 keys, {L, E, M, O, N}. For successive letters of the message, we are going to take successive letters of the key string, and encipher each message letter using its corresponding key row. Choose the next letter of the key, go along that row to find the column heading that matches the message character; the letter at the intersection of [key-row, msg-col] is the enciphered letter.</p>

<p>For example, the first letter of the plaintext, <code>A</code>, is paired with <code>L</code>, the first letter of the key. So use row <code>L</code> and column <code>A</code> of the Vigenère square, namely <code>L</code>. Similarly, for the second letter of the plaintext, the second letter of the key is used; the letter at row <code>E</code> and column <code>T</code> is <code>X</code>. The rest of the plaintext is enciphered in a similar fashion:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Plaintext:</p></td>
<td style="text-align: left;">
<p><code>ATTACKATDAWN</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Key:</p></td>
<td style="text-align: left;">
<p><code>LEMONLEMONLE</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Ciphertext:</p></td>
<td style="text-align: left;">
<p><code>LXFOPVEFRNHR</code></p></td>
</tr>
</tbody>
</table>

<p>Decryption is performed by going to the row in the table corresponding to the key, finding the position of the ciphertext letter in this row, and then using the column's label as the plaintext. For example, in row <code>L</code> (from <em>L</em>EMON), the ciphertext <code>L</code> appears in column <code>A</code>, which is the first plaintext letter. Next we go to row <code>E</code> (from L<em>E</em>MON), locate the ciphertext <code>X</code> which is found in column <code>T</code>, thus <code>T</code> is the second plaintext letter.</p>
<h2 id="algebraic-description">Algebraic description</h2>

<p>Vigenère can also be viewed algebraically. If the letters <code>A</code>–<code>Z</code> are taken to be the numbers 0–25, and addition is performed <a href="modular_arithmetic" title="wikilink">modulo</a> 26, then Vigenère encryption 

<math display="inline" id="Vigenère_cipher:0">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 using the key 

<math display="inline" id="Vigenère_cipher:1">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 can be written,</p>

<p>

<math display="block" id="Vigenère_cipher:2">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>M</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>K</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>26</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">26</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}=E_{K}(M_{i})=(M_{i}+K_{i})\mod{26}
  </annotation>
 </semantics>
</math>

</p>

<p>and decryption 

<math display="inline" id="Vigenère_cipher:3">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 using the key 

<math display="inline" id="Vigenère_cipher:4">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Vigenère_cipher:5">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>C</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>K</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>26</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">26</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}=D_{K}(C_{i})=(C_{i}-K_{i})\mod{26}
  </annotation>
 </semantics>
</math>

,</p>

<p>whereas 

<math display="inline" id="Vigenère_cipher:6">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>M</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=M_{1}\dots M_{n}
  </annotation>
 </semantics>
</math>

 is the message, 

<math display="inline" id="Vigenère_cipher:7">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=C_{1}\dots C_{n}
  </annotation>
 </semantics>
</math>

 is the ciphertext and 

<math display="inline" id="Vigenère_cipher:8">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>K</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>K</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=K_{1}\dots K_{n}
  </annotation>
 </semantics>
</math>

 is the key obtained by repeating the keyword 

<math display="inline" id="Vigenère_cipher:9">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil n/m\rceil
  </annotation>
 </semantics>
</math>

 times, where 

<math display="inline" id="Vigenère_cipher:10">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the keyword length.</p>

<p>Thus using the previous example, to encrypt 

<math display="inline" id="Vigenère_cipher:11">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mover accent="true">
    <mo>=</mo>
    <mo>^</mo>
   </mover>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <ci>normal-^</ci>
     <eq></eq>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\widehat{=}0
  </annotation>
 </semantics>
</math>

 with key letter 

<math display="inline" id="Vigenère_cipher:12">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mover accent="true">
    <mo>=</mo>
    <mo>^</mo>
   </mover>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <apply>
     <ci>normal-^</ci>
     <eq></eq>
    </apply>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\widehat{=}11
  </annotation>
 </semantics>
</math>

 the calculation would result in 

<math display="inline" id="Vigenère_cipher:13">
 <semantics>
  <mrow>
   <mn>11</mn>
   <mover accent="true">
    <mo>=</mo>
    <mo>^</mo>
   </mover>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">11</cn>
    <apply>
     <ci>normal-^</ci>
     <eq></eq>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   11\widehat{=}L
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Vigenère_cipher:14">
 <semantics>
  <mrow>
   <mn>11</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>0</mn>
      <mo>+</mo>
      <mn>11</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>26</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">11</cn>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <cn type="integer">0</cn>
      <cn type="integer">11</cn>
     </apply>
     <cn type="integer">26</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   11=(0+11)\mod{26}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore to decrypt 

<math display="inline" id="Vigenère_cipher:15">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mover accent="true">
    <mo>=</mo>
    <mo>^</mo>
   </mover>
   <mn>17</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <ci>normal-^</ci>
     <eq></eq>
    </apply>
    <cn type="integer">17</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\widehat{=}17
  </annotation>
 </semantics>
</math>

 with key letter 

<math display="inline" id="Vigenère_cipher:16">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mover accent="true">
    <mo>=</mo>
    <mo>^</mo>
   </mover>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <ci>normal-^</ci>
     <eq></eq>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\widehat{=}4
  </annotation>
 </semantics>
</math>

 the calculation would result in 

<math display="inline" id="Vigenère_cipher:17">
 <semantics>
  <mrow>
   <mn>13</mn>
   <mover accent="true">
    <mo>=</mo>
    <mo>^</mo>
   </mover>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">13</cn>
    <apply>
     <ci>normal-^</ci>
     <eq></eq>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   13\widehat{=}N
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Vigenère_cipher:18">
 <semantics>
  <mrow>
   <mn>13</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>17</mn>
      <mo>-</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>26</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">13</cn>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">17</cn>
      <cn type="integer">4</cn>
     </apply>
     <cn type="integer">26</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   13=(17-4)\mod{26}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="cryptanalysis">Cryptanalysis</h2>

<p>The idea behind the Vigenère cipher, like all polyalphabetic ciphers, is to disguise plaintext <a href="letter_frequencies" title="wikilink">letter frequencies</a>, which interferes with a straightforward application of <a href="frequency_analysis" title="wikilink">frequency analysis</a>. For instance, if <code>P</code> is the most frequent letter in a ciphertext whose plaintext is in <a href="English_language" title="wikilink">English</a>, one might suspect that <code>P</code> corresponds to <code>E</code>, because <code>E</code> is the most frequently used letter in English. However, using the Vigenère cipher, <code>E</code> can be enciphered as different ciphertext letters at different points in the message, thus defeating simple frequency analysis.</p>

<p>The primary weakness of the Vigenère cipher is the repeating nature of its <a href="Key_(cryptography)" title="wikilink">key</a>. If a cryptanalyst correctly guesses the key's length, then the cipher text can be treated as interwoven <a href="Caesar_cipher" title="wikilink">Caesar ciphers</a>, which individually are easily broken. The <a href="#Kasiski_examination" title="wikilink">Kasiski examination</a> and <a href="#Friedman_test" title="wikilink">Friedman test</a> can help determine the key length.</p>
<h3 id="kasiski-examination">Kasiski examination</h3>
<dl>
<dd><em>For more details on this topic, see <a href="Kasiski_examination" title="wikilink">Kasiski examination</a>.</em>
</dd>
</dl>

<p>In 1863 <a href="Friedrich_Kasiski" title="wikilink">Friedrich Kasiski</a> was the first to publish a successful general attack on the Vigenère cipher. Earlier attacks relied on knowledge of the plaintext, or use of a recognizable word as a key. Kasiski's method had no such dependencies. Kasiski was the first to publish an account of the attack, but it is clear that there were others who were aware of it. In 1854, <a href="Charles_Babbage" title="wikilink">Charles Babbage</a> was goaded into breaking the Vigenère cipher when John Hall Brock Thwaites submitted a "new" cipher to the Journal of the Society of the Arts. When Babbage showed that Thwaites' cipher was essentially just another recreation of the Vigenère cipher, Thwaites challenged Babbage to break his cipher encoded twice, with keys of different length. Babbage succeeded in decrypting a sample, which turned out to be the poem "The Vision of Sin", by <a href="Alfred_Tennyson" title="wikilink">Alfred Tennyson</a>, encrypted according to the keyword "Emily", the first name of Tennyson's wife. Babbage never explained the method he used. Studies of Babbage's notes reveal that he had used the method later published by Kasiski, and suggest that he had been using the method as early as 1846.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The <a href="Kasiski_examination" title="wikilink">Kasiski examination</a>, also called the Kasiski test, takes advantage of the fact that repeated words may, by chance, sometimes be encrypted using the same key letters, leading to repeated groups in the ciphertext. For example, Consider the following encryption using the keyword <code>ABCD</code>:</p>

<p><code>Key:        ABCDABCDABCDABCDABCDABCDABCD</code><br/>
<code>Plaintext:  </code><strong><em><code>CRYPTO</code><strong><em><code>ISSHORTFOR</code></em></strong><code>CRYPTO</code></em></strong><code>GRAPHY</code><br/>
<code>Ciphertext: </code><strong><em><code>CSASTP</code><strong><em><code>KVSIQUTGQU</code></em></strong><code>CSASTP</code></em></strong><code>IUAQJB</code></p>

<p>There is an easily seen repetition in the ciphertext, and the Kasiski test will be effective. Here the distance between the repetitions of <code>CSASTP</code> is 16. Assuming that the repeated segments represent the same plaintext segments, this implies that the key is 16, 8, 4, 2, or 1 characters long. (All <a href="Factorization" title="wikilink">factors</a> of the distance are possible key lengths—a key of length one is just a simple <a href="caesar_cipher" title="wikilink">caesar cipher</a>, where cryptanalysis is much easier.) Since key lengths 2 and 1 are unrealistically short, one only needs to try lengths 16, 8, or 4. Longer messages make the test more accurate because they usually contain more repeated ciphertext segments. The following ciphertext has two segments that are repeated:</p>

<p><code>Ciphertext: </code><strong><em><code>VHVS</code><strong><em><code>SP</code></em></strong><code>QUCE</code><strong><em><code>MRVBVBBB</code></em></strong><code>VHVS</code><strong><em><code>URQGIBDUGRNICJ</code></em></strong><code>QUCE</code></em></strong><code>RVUAXSSR</code></p>

<p>The distance between the repetitions of <code>VHVS</code> is 18. Assuming that the repeated segments represent the same plaintext segments, this implies that the key is 18, 9, 6, 3, 2, or 1 characters long. The distance between the repetitions of <code>QUCE</code> is 30 characters. This means that the key length could be 30, 15, 10, 6, 5, 3, 2, or 1 characters long. By taking the <a href="Intersection_(set_theory)" title="wikilink">intersection</a> of these sets one could safely conclude that the most likely key length is 6, since 3, 2, and 1 are unrealistically short.</p>
<h3 id="friedman-test">Friedman test</h3>

<p>The Friedman test (sometimes known as the kappa test) was invented during the 1920s by <a href="William_F._Friedman" title="wikilink">William F. Friedman</a>. Friedman used the <a href="index_of_coincidence" title="wikilink">index of coincidence</a>, which measures the unevenness of the cipher letter frequencies to break the cipher. By knowing the probability 

<math display="inline" id="Vigenère_cipher:19">
 <semantics>
  <msub>
   <mi>κ</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>κ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa_{p}
  </annotation>
 </semantics>
</math>

 that any two randomly chosen source-language letters are the same (around 0.067 for monocase English) and the probability of a coincidence for a uniform random selection from the alphabet 

<math display="inline" id="Vigenère_cipher:20">
 <semantics>
  <msub>
   <mi>κ</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>κ</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa_{r}
  </annotation>
 </semantics>
</math>

 (1/26 = 0.0385 for English), the key length can be estimated as:</p>

<p>

<math display="block" id="Vigenère_cipher:21">
 <semantics>
  <mfrac>
   <mrow>
    <msub>
     <mi>κ</mi>
     <mi>p</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>κ</mi>
     <mi>r</mi>
    </msub>
   </mrow>
   <mrow>
    <msub>
     <mi>κ</mi>
     <mi>o</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>κ</mi>
     <mi>r</mi>
    </msub>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\kappa_{p}-\kappa_{r}}\over{\kappa_{o}-\kappa_{r}}
  </annotation>
 </semantics>
</math>

</p>

<p>from the observed coincidence rate</p>

<p>

<math display="block" id="Vigenère_cipher:22">
 <semantics>
  <mrow>
   <msub>
    <mi>κ</mi>
    <mi>o</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>c</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>κ</ci>
     <ci>o</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa_{o}=\frac{\sum_{i=1}^{c}n_{i}(n_{i}-1)}{N(N-1)}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>c</em> is the size of the alphabet (26 for English), <em>N</em> is the length of the text, and <em>n</em><sub>1</sub> through <em>n</em><sub><em>c</em></sub> are the observed ciphertext <a href="letter_frequencies" title="wikilink">letter frequencies</a>, as integers.</p>

<p>This is, however, only an approximation whose accuracy increases with the size of the text. It would in practice be necessary to try various key lengths close to the estimate.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> A better approach for repeating-key ciphers is to copy the ciphertext into rows of a matrix having as many columns as an assumed key length, then compute the average <a href="Index_of_coincidence#Example" title="wikilink">index of coincidence</a> with each column considered separately; when this is done for each possible key length, the highest average I.C. then corresponds to the most likely key length.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Such tests may be supplemented by information from the Kasiski examination.</p>
<h3 id="frequency-analysis">Frequency analysis</h3>

<p>Once the length of the key is known, the ciphertext can be rewritten into that many columns, with each column corresponding to a single letter of the key. Each column consists of plaintext that has been encrypted by a single <a href="Caesar_cipher" title="wikilink">Caesar cipher</a>; the Caesar key (shift) is just the letter of the Vigenère key that was used for that column. Using methods similar to those used to break the Caesar cipher, the letters in the ciphertext can be discovered.</p>

<p>An improvement to the Kasiski examination, known as <a href="Auguste_Kerckhoffs" title="wikilink">Kerckhoffs</a>' method, matches each column's letter frequencies to shifted plaintext frequencies to discover the key letter (Caesar shift) for that column. Once every letter in the key is known, the cryptanalyst can simply decrypt the ciphertext and reveal the plaintext.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Kerckhoffs' method is not applicable when the Vigenère table has been scrambled, rather than using normal alphabetic sequences, although Kasiski examination and coincidence tests can still be used to determine key length in that case.</p>
<h3 id="key-elimination">Key elimination</h3>

<p>The Vigenère cipher function is essentially modulo arithmetic, and thus commutative. So if the key length is known (or guessed) then subtracting the cipher text from itself, offset by the key length will produce the cipher text encrypted with itself. If any words in the cipher text are known or can be guessed, then the plain text and also the key, will be revealed. This is useful if the key is an obscure sequence of letters because the plain text will generally be ordinary words. Key elimination is useful for making short versions of the plain text.</p>
<h2 id="variants">Variants</h2>
<figure><b>(Figure)</b>
<figcaption>Confederate cipher wheel, captured at the surrender of <a href="Mobile,_Alabama" title="wikilink">Mobile, Alabama</a>, in May 1865 – <a href="National_Cryptologic_Museum" title="wikilink">National Cryptologic Museum</a></figcaption>
</figure>

<p>The <a href="running_key_cipher" title="wikilink">running key</a> variant of the Vigenère cipher was also considered unbreakable at one time. This version uses as the key a block of text as long as the plaintext. Since the key is as long as the message the Friedman and Kasiski tests no longer work (the key is not repeated). In 1920, Friedman was the first to discover this variant's weaknesses. The problem with the running key Vigenère cipher is that the cryptanalyst has statistical information about the key (assuming that the block of text is in a known language) and that information will be reflected in the ciphertext.</p>

<p>If using a key which is truly random, is at least as long as the encrypted message and is used only once, the Vigenère cipher is theoretically unbreakable. However, in this case it is the key, not the cipher, which provides cryptographic strength and such systems are properly referred to collectively as <a href="one-time_pad" title="wikilink">one-time pad</a> systems, irrespective of which ciphers are employed.</p>

<p>Vigenère actually invented a stronger cipher: an <a href="autokey_cipher" title="wikilink">autokey cipher</a>. The name "Vigenère cipher" became associated with a simpler polyalphabetic cipher instead. In fact, the two ciphers were often confused, and both were sometimes called "<em>le chiffre indéchiffrable</em>". Babbage actually broke the much stronger autokey cipher, while Kasiski is generally credited with the first published solution to the fixed-key polyalphabetic ciphers.</p>

<p>A simple variant is to encrypt using the Vigenère decryption method, and decrypt using Vigenère encryption. This method is sometimes referred to as "Variant Beaufort". This is different from the <a href="Beaufort_cipher" title="wikilink">Beaufort cipher</a>, created by Sir <a href="Francis_Beaufort" title="wikilink">Francis Beaufort</a>, which nonetheless is similar to Vigenère but uses a slightly modified enciphering mechanism and tableau. The Beaufort cipher is a <a href="reciprocal_cipher" title="wikilink">reciprocal cipher</a>.</p>

<p>Despite the Vigenère cipher's apparent strength it never became widely used throughout Europe. The Gronsfeld cipher is a variant created by Count Gronsfeld which is identical to the Vigenère cipher, except that it uses just 10 different cipher alphabets (corresponding to the digits 0 to 9). The Gronsfeld cipher is strengthened because its key is not a word, but it is weakened because it has just 10 cipher alphabets. Gronsfeld's cipher did become widely used throughout Germany and Europe, despite its weaknesses.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Roger_Frontenac" title="wikilink">Roger Frontenac</a> (<a class="uri" href="Nostradamus" title="wikilink">Nostradamus</a> quatrain decryptor, 1950)</li>
</ul>
<h2 id="references">References</h2>
<h3 id="citations">Citations</h3>
<h3 id="sources">Sources</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<dl>
<dt>Articles</dt>
</dl>
<ul>
<li><a href="http://home.att.net/~tleary/cryptolo.htm">History of the cipher from Cryptologia</a></li>
<li><a href="http://www.bbc.co.uk/dna/h2g2/alabaster/A613135">Basic Cryptanalysis</a> at H2G2</li>
<li><a href="http://www.math.ucdenver.edu/~wcherowi/courses/m5410/m5410cc.html">Lecture Notes on Classical Cryptology including an explanation and derivation of the Friedman Test</a></li>
<li></li>
</ul>
<dl>
<dt>Programming</dt>
</dl>
<ul>
<li><a href="http://inventwithpython.com/hacking"><em>Hacking Secret Ciphers with Python</em></a> <a href="http://inventwithpython.com/hacking/chapter19.html">Chapter 19, The Vigenère Cipher</a>, <a href="http://inventwithpython.com/hacking/chapter21.html">Chapter 21, Hacking the Vigenère Cipher</a>, with Python source code.</li>
<li><a href="http://www.asecuritysite.com/security/Coding/vigcalc">Online Vigenère Cipher</a></li>
<li><a href="http://sharkysoft.com/misc/vigenere/">Sharky's Online Vigenere Cipher</a> – Encode and decode messages, using a known key, within a Web browser (<a class="uri" href="JavaScript" title="wikilink">JavaScript</a>)</li>
<li><a href="http://smurfoncrack.com/pygenere/">PyGenere: an online tool for automatically deciphering Vigenère-encoded texts</a> (6 languages supported)</li>
<li><a href="http://ljplawcom00.web707.discountasp.net/Vigenere/Vigenere.aspx/">Vigenère Cipher encryption and decryption program (browser version, English only)</a></li>
<li>[<a class="uri" href="https://metacpan.org/module/Crypt">https://metacpan.org/module/Crypt</a>::Vigenere Crypt::Vigenere] – a <a class="uri" href="CPAN" title="wikilink">CPAN</a> module implementing the Vigenère cipher</li>
<li><a href="http://www.perlmonks.org/?node_id=550450">Breaking the indecipherable cipher: Perl code to decipher Vigenère text, with the source in the shape of Babbage's head</a></li>
<li><a href="http://papacharliefox3.wordpress.com/2009/04/02/desafio-de-crypto-ii-cifra-de-vigenere/">Vigenère in BASH</a></li>
<li><a href="http://www.vigenere.tk">Java Vigenere</a> applet with source code (<a href="GNU_General_Public_License" title="wikilink">GNU GPL</a>)</li>
<li><a href="http://log.flirt-wind.net/2010/08/vigenere-cipher-in-java/">Vigenere Cipher in Java</a></li>
<li><a href="http://sourceforge.net/projects/tstools/">Vijner 974 Encryption Tool in C# (Vigenere Algorithm)</a></li>
<li><a href="http://www.vigenere.net/">Vigenère Cipher encryption tool</a> – Browser</li>
<li><a href="https://chrome.google.com/webstore/detail/jefmgpafeddooefhpnhccodndbcpbmhj">Vigenère Cipher encryption tool</a> – Google Chrome extension</li>
</ul>

<p><a class="uri" href="de:Polyalphabetische_Substitution#Vigen.C3.A8re-Verschl.C3.BCsselung" title="wikilink">de:Polyalphabetische_Substitution#Vigen.C3.A8re-Verschl.C3.BCsselung</a>"</p>

<p><a href="Category:Classical_ciphers" title="wikilink">Category:Classical ciphers</a> <a href="Category:Stream_ciphers" title="wikilink">Category:Stream ciphers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="http://www.vectorsite.net/ttcode_03.html#m2">Codes, Ciphers, &amp; Codebreaking</a> (The Rise Of Field Ciphers)<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Franksen, O. I. (1985) Mr. Babbage's Secret: The Tale of a Cipher—and APL. Prentice Hall.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"> Published in two parts.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
</ol>
</section>
</body>
</html>
