<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="827">Pushdown automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pushdown automaton</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>pushdown automaton</strong> (<strong>PDA</strong>) is a type of <a href="Automata_theory" title="wikilink">automaton</a> that employs a <a href="Stack_(data_structure)" title="wikilink">stack</a>.</p>

<p>Pushdown automata are used in theories about what can be computed by machines. They are more capable than <a href="finite-state_machine" title="wikilink">finite-state machines</a> but less capable than <a href="Turing_machine" title="wikilink">Turing machines</a>. <a href="Deterministic_pushdown_automata" title="wikilink">Deterministic pushdown automata</a> can recognize all <a href="deterministic_context-free_language" title="wikilink">deterministic context-free languages</a> while nondeterministic ones can recognize all <a href="context-free_language" title="wikilink">context-free languages</a>. Mainly the former are used in <a class="uri" href="parser" title="wikilink">parser</a> design.</p>

<p>The term "pushdown" refers to the fact that the <a href="Stack_(abstract_data_type)" title="wikilink">stack</a> can be regarded as being "pushed down" like a tray dispenser at a cafeteria, since the operations never work on elements other than the top element. A <strong>stack automaton</strong>, by contrast, does allow access to and operations on deeper elements. Stack automata can recognize a strictly larger set of languages than pushdown automata.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A <a href="nested_stack_automaton" title="wikilink">nested stack automaton</a> allows full access, and also allows stacked values to be entire sub-stacks rather than just single finite symbols.</p>

<p>The remainder of this article describes the nondeterministic pushdown automaton.</p>
<h2 id="operation">Operation</h2>

<p> Pushdown automata differ from <a href="finite_state_machine" title="wikilink">finite state machines</a> in two ways:</p>
<ol>
<li>They can use the top of the stack to decide which transition to take.</li>
<li>They can manipulate the stack as part of performing a transition.</li>
</ol>

<p>Pushdown automata choose a transition by indexing a table by input signal, current state, and the symbol at the top of the stack. This means that those three parameters completely determine the transition path that is chosen. Finite state machines just look at the input signal and the current state: they have no stack to work with. Pushdown automata add the stack as a parameter for choice.</p>

<p>Pushdown automata can also manipulate the stack, as part of performing a transition. Finite state machines choose a new state, the result of following the transition. The manipulation can be to push a particular symbol to the top of the stack, or to pop off the top of the stack. The automaton can alternatively ignore the stack, and leave it as it is. The choice of manipulation (or no manipulation) is determined by the transition table.</p>

<p>Put together: Given an input signal, current state, and stack symbol, the automaton can follow a transition to another state, and optionally manipulate (push or pop) the stack.</p>

<p>In general, pushdown automata may have several computations on a given input string, some of which may be halting in accepting configurations. If only one computation exists for all accepted strings, the result is a <a href="deterministic_pushdown_automaton" title="wikilink">deterministic pushdown automaton</a> (DPDA) and the language of these strings is a <a href="deterministic_context-free_language" title="wikilink">deterministic context-free language</a>. Not all context-free languages are deterministic.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> As a consequence of the above the DPDA is a strictly weaker variant of the PDA and there exists no algorithm for converting a PDA to an equivalent DPDA, if such a DPDA exists.</p>

<p>If we allow a finite automaton access to two stacks instead of just one, we obtain a more powerful device, equivalent in power to a <a href="Turing_machine" title="wikilink">Turing machine</a>. A <a href="linear_bounded_automaton" title="wikilink">linear bounded automaton</a> is a device which is more powerful than a pushdown automaton but less so than a Turing machine.</p>
<h2 id="relation-to-backtracking">Relation to backtracking</h2>

<p>Nondeterministic PDAs are able to handle situations where more than one choice of action is available. In principle it is enough to create in every such case new automaton instances that will handle the extra choices. The problem with this approach is that in practice most of these instances fail. This can severely affect the automaton's performance as the execution of multiple instances is a costly operation. Situations such as these can be identified in the design phase of the automaton by examining the grammar the automaton uses. This makes possible the use of <a class="uri" href="backtracking" title="wikilink">backtracking</a> in every such case in order to improve the performance of pushdown automaton.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>We use standard formal language notation

<math display="block" id="Pushdown_automaton:0">
 <semantics>
  <msup>
   <mi mathvariant="normal">Γ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Γ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma^{*}
  </annotation>
 </semantics>
</math>

 denotes the set of strings over alphabet 

<math display="inline" id="Pushdown_automaton:1">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Pushdown_automaton:2">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 denotes the <a href="empty_string" title="wikilink">empty string</a>.</p>

<p>A PDA is formally defined as a 7-tuple:</p>

<p>

<math display="inline" id="Pushdown_automaton:3">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>δ</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>Z</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <ci>normal-Γ</ci>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>Z</ci>
     <ci>F</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\ \Sigma,\ \Gamma,\ \delta,\ q_{0},\ Z,\ F)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Pushdown_automaton:4">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>Q</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Q
  </annotation>
 </semantics>
</math>

 is a finite set of <em>states</em></li>
<li>

<math display="inline" id="Pushdown_automaton:5">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi mathvariant="normal">Σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Sigma
  </annotation>
 </semantics>
</math>

 is a finite set which is called the <em>input alphabet</em></li>
<li>

<math display="inline" id="Pushdown_automaton:6">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi mathvariant="normal">Γ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Gamma
  </annotation>
 </semantics>
</math>

 is a finite set which is called the <em>stack alphabet</em></li>
<li>

<math display="inline" id="Pushdown_automaton:7">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>δ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\delta
  </annotation>
 </semantics>
</math>

 is a finite subset of 

<math display="inline" id="Pushdown_automaton:8">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>ε</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mi mathvariant="normal">Γ</mi>
   <mo>×</mo>
   <mi>Q</mi>
   <mo>×</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <apply>
     <union></union>
     <ci>normal-Σ</ci>
     <set>
      <ci>ε</ci>
     </set>
    </apply>
    <ci>normal-Γ</ci>
    <ci>Q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\times(\Sigma\cup\{\varepsilon\})\times\Gamma\times Q\times\Gamma^{*}
  </annotation>
 </semantics>
</math>

, the <em>transition relation</em>.</li>
<li>

<math display="inline" id="Pushdown_automaton:9">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>q</mi>
    </mpadded>
    <mn>0</mn>
   </msub>
   <mo rspace="4.2pt">∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,q_{0}\in\,Q
  </annotation>
 </semantics>
</math>

 is the <em>start state</em></li>
<li>

<math display="inline" id="Pushdown_automaton:10">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>Z</mi>
   </mpadded>
   <mo rspace="4.2pt">∈</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>Z</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Z\in\,\Gamma
  </annotation>
 </semantics>
</math>

 is the <em>initial stack symbol</em></li>
<li>

<math display="inline" id="Pushdown_automaton:11">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq Q
  </annotation>
 </semantics>
</math>

 is the set of <em>accepting states</em></li>
</ul>

<p>An element 

<math display="inline" id="Pushdown_automaton:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>p</ci>
     <ci>a</ci>
     <ci>A</ci>
     <ci>q</ci>
     <ci>α</ci>
    </vector>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,a,A,q,\alpha)\in\delta
  </annotation>
 </semantics>
</math>

 is a transition of 

<math display="inline" id="Pushdown_automaton:13">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. It has the intended meaning that 

<math display="inline" id="Pushdown_automaton:14">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, in state 

<math display="inline" id="Pushdown_automaton:15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in Q
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Pushdown_automaton:16">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ε</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <union></union>
     <ci>normal-Σ</ci>
     <set>
      <ci>ε</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\Sigma\cup\{\varepsilon\}
  </annotation>
 </semantics>
</math>

 on the input and with 

<math display="inline" id="Pushdown_automaton:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\Gamma
  </annotation>
 </semantics>
</math>

 as topmost stack symbol, may read 

<math display="inline" id="Pushdown_automaton:18">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, change the state to 

<math display="inline" id="Pushdown_automaton:19">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, pop 

<math display="inline" id="Pushdown_automaton:20">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, replacing it by pushing 

<math display="inline" id="Pushdown_automaton:21">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in\Gamma^{*}
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Pushdown_automaton:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ε</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Σ</ci>
    <set>
     <ci>ε</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma\cup\{\varepsilon\})
  </annotation>
 </semantics>
</math>

 component of the transition relation is used to formalize that the PDA can either read a letter from the input, or proceed leaving the input untouched.</p>

<p>In many texts the transition relation is replaced by an (equivalent) formalization, where</p>
<ul>
<li>

<math display="inline" id="Pushdown_automaton:23">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>δ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\delta
  </annotation>
 </semantics>
</math>

 is the <em>transition function</em>, mapping 

<math display="inline" id="Pushdown_automaton:24">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>ε</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <apply>
     <union></union>
     <ci>normal-Σ</ci>
     <set>
      <ci>ε</ci>
     </set>
    </apply>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\times(\Sigma\cup\{\varepsilon\})\times\Gamma
  </annotation>
 </semantics>
</math>

 into finite subsets of 

<math display="inline" id="Pushdown_automaton:25">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>×</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\times\Gamma^{*}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Here 

<math display="inline" id="Pushdown_automaton:26">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <vector>
     <ci>p</ci>
     <ci>a</ci>
     <ci>A</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(p,a,A)
  </annotation>
 </semantics>
</math>

 contains all possible actions in state 

<math display="inline" id="Pushdown_automaton:27">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Pushdown_automaton:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 on the stack, while reading 

<math display="inline" id="Pushdown_automaton:29">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 on the input. One writes 

<math display="inline" id="Pushdown_automaton:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>q</ci>
     <ci>α</ci>
    </interval>
    <apply>
     <times></times>
     <ci>δ</ci>
     <vector>
      <ci>p</ci>
      <ci>a</ci>
      <ci>A</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,\alpha)\in\delta(p,a,A)
  </annotation>
 </semantics>
</math>

 for the function precisely when 

<math display="inline" id="Pushdown_automaton:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>p</ci>
     <ci>a</ci>
     <ci>A</ci>
     <ci>q</ci>
     <ci>α</ci>
    </vector>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,a,A,q,\alpha)\in\delta
  </annotation>
 </semantics>
</math>

 for the relation. Note that <em>finite</em> in this definition is essential.</p>

<p>''' <em>Computations</em> '''</p>

<p> In order to formalize the semantics of the pushdown automaton a description of the current situation is introduced. Any 3-tuple 

<math display="inline" id="Pushdown_automaton:32">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>Q</mi>
    <mo>×</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo>×</mo>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>p</ci>
     <ci>w</ci>
     <ci>β</ci>
    </vector>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Γ</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,w,\beta)\in Q\times\Sigma^{*}\times\Gamma^{*}
  </annotation>
 </semantics>
</math>

 is called an instantaneous description (ID) of 

<math display="inline" id="Pushdown_automaton:33">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, which includes the current state, the part of the input tape that has not been read, and the contents of the stack (topmost symbol written first). The transition relation 

<math display="inline" id="Pushdown_automaton:34">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 defines the step-relation 

<math display="inline" id="Pushdown_automaton:35">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>M</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{M}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Pushdown_automaton:36">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on instantaneous descriptions. For instruction 

<math display="inline" id="Pushdown_automaton:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>p</ci>
     <ci>a</ci>
     <ci>A</ci>
     <ci>q</ci>
     <ci>α</ci>
    </vector>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,a,A,q,\alpha)\in\delta
  </annotation>
 </semantics>
</math>

 there exists a step 

<math display="inline" id="Pushdown_automaton:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>x</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mi>γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mo>⊢</mo>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mi>γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">γ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>M</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">α</csymbol>
     <csymbol cd="unknown">γ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,ax,A\gamma)\vdash_{M}(q,x,\alpha\gamma)
  </annotation>
 </semantics>
</math>

, for every 

<math display="inline" id="Pushdown_automaton:39">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Sigma^{*}
  </annotation>
 </semantics>
</math>

 and every 

<math display="inline" id="Pushdown_automaton:40">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in\Gamma^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>In general pushdown automata are nondeterministic meaning that in a given instantaneous description 

<math display="inline" id="Pushdown_automaton:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>w</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <ci>w</ci>
    <ci>β</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,w,\beta)
  </annotation>
 </semantics>
</math>

 there may be several possible steps. Any of these steps can be chosen in a computation. With the above definition in each step always a single symbol (top of the stack) is popped, replacing it with as many symbols as necessary. As a consequence no step is defined when the stack is empty.</p>

<p>Computations of the pushdown automaton are sequences of steps. The computation starts in the initial state 

<math display="inline" id="Pushdown_automaton:42">
 <semantics>
  <msub>
   <mi>q</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}
  </annotation>
 </semantics>
</math>

 with the initial stack symbol 

<math display="inline" id="Pushdown_automaton:43">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 on the stack, and a string 

<math display="inline" id="Pushdown_automaton:44">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 on the input tape, thus with initial description 

<math display="inline" id="Pushdown_automaton:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi>w</mi>
   <mo>,</mo>
   <mi>Z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>w</ci>
    <ci>Z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q_{0},w,Z)
  </annotation>
 </semantics>
</math>

. There are two modes of accepting. The pushdown automaton either accepts by final state, which means after reading its input the automaton reaches an accepting state (in 

<math display="inline" id="Pushdown_automaton:46">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

), or it accepts by empty stack (

<math display="inline" id="Pushdown_automaton:47">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

), which means after reading its input the automaton empties its stack. The first acceptance mode uses the internal memory (state), the second the external memory (stack).</p>

<p>Formally one defines</p>
<ol>
<li>

<math display="inline" id="Pushdown_automaton:48">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>w</mi>
    <mo>∈</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi>w</mi>
     <mo>,</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mo>⊢</mo>
     <mi>M</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>ε</mi>
     <mo>,</mo>
     <mi>γ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">w</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">Z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <ci>M</ci>
      </apply>
      <times></times>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">ε</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">γ</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(M)=\{w\in\Sigma^{*}|(q_{0},w,Z)\vdash_{M}^{*}(f,\varepsilon,\gamma)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Pushdown_automaton:49">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in F
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Pushdown_automaton:50">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">γ</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in\Gamma^{*}\}
  </annotation>
 </semantics>
</math>

 (final state)</li>
<li>

<math display="inline" id="Pushdown_automaton:51">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>w</mi>
    <mo>∈</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi>w</mi>
     <mo>,</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mo>⊢</mo>
     <mi>M</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>ε</mi>
     <mo>,</mo>
     <mi>ε</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">w</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">Z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <ci>M</ci>
      </apply>
      <times></times>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">ε</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">ε</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(M)=\{w\in\Sigma^{*}|(q_{0},w,Z)\vdash_{M}^{*}(q,\varepsilon,\varepsilon)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Pushdown_automaton:52">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <mi>Q</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <in></in>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in Q\}
  </annotation>
 </semantics>
</math>

 (empty stack)</li>
</ol>

<p>Here 

<math display="inline" id="Pushdown_automaton:53">
 <semantics>
  <msubsup>
   <mo>⊢</mo>
   <mi>M</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>M</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{M}^{*}
  </annotation>
 </semantics>
</math>

 represents the reflexive and transitive closure of the step relation 

<math display="inline" id="Pushdown_automaton:54">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>M</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{M}
  </annotation>
 </semantics>
</math>

 meaning any number of consecutive steps (zero, one or more).</p>

<p>For each single pushdown automaton these two languages need to have no relation: they may be equal but usually this is not the case. A specification of the automaton should also include the intended mode of acceptance. Taken over all pushdown automata both acceptance conditions define the same family of languages.</p>

<p><strong>Theorem.</strong> For each pushdown automaton 

<math display="inline" id="Pushdown_automaton:55">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 one may construct a pushdown automaton 

<math display="inline" id="Pushdown_automaton:56">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Pushdown_automaton:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>M</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(M)=N(M^{\prime})
  </annotation>
 </semantics>
</math>

, and vice versa, for each pushdown automaton 

<math display="inline" id="Pushdown_automaton:58">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 one may construct a pushdown automaton 

<math display="inline" id="Pushdown_automaton:59">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Pushdown_automaton:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>M</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(M)=L(M^{\prime})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="example">Example</h2>

<p>The following is the formal description of the PDA which recognizes the language 

<math display="inline" id="Pushdown_automaton:61">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mn>0</mn>
     <mi>n</mi>
    </msup>
    <msup>
     <mn>1</mn>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">0</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0^{n}1^{n}\mid n\geq 0\}
  </annotation>
 </semantics>
</math>

 by final state:</p>

<p> 

<math display="inline" id="Pushdown_automaton:62">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>δ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>p</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>Z</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <ci>normal-Γ</ci>
     <ci>δ</ci>
     <ci>p</ci>
     <ci>Z</ci>
     <ci>F</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\ \Sigma,\ \Gamma,\ \delta,\ p,\ Z,\ F)
  </annotation>
 </semantics>
</math>

, where</p>

<p><strong>states:</strong> 

<math display="inline" id="Pushdown_automaton:63">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>r</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\{p,q,r\}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>input alphabet:</strong> 

<math display="inline" id="Pushdown_automaton:64">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=\{0,1\}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>stack alphabet:</strong> 

<math display="inline" id="Pushdown_automaton:65">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Γ</ci>
    <set>
     <ci>A</ci>
     <ci>Z</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=\{A,Z\}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>start state:</strong> 

<math display="inline" id="Pushdown_automaton:66">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}=p
  </annotation>
 </semantics>
</math>

</p>

<p><strong>start stack symbol:</strong> 

<math display="inline" id="Pushdown_automaton:67">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

</p>

<p><strong>accepting states:</strong> 

<math display="inline" id="Pushdown_automaton:68">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>r</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <set>
     <ci>r</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\{r\}
  </annotation>
 </semantics>
</math>

</p>

<p>The transition relation 

<math display="inline" id="Pushdown_automaton:69">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 consists of the following six instructions:</p>

<p>

<math display="inline" id="Pushdown_automaton:70">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>Z</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mrow>
    <mi>A</mi>
    <mi>Z</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <cn type="integer">0</cn>
    <ci>Z</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>Z</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,0,Z,p,AZ)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mrow>
    <mi>A</mi>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <cn type="integer">0</cn>
    <ci>A</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>A</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,0,A,p,AA)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:72">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo>,</mo>
   <mi>Z</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>Z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <ci>ϵ</ci>
    <ci>Z</ci>
    <ci>q</ci>
    <ci>Z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,\epsilon,Z,q,Z)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>A</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <ci>ϵ</ci>
    <ci>A</ci>
    <ci>q</ci>
    <ci>A</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,\epsilon,A,q,A)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:74">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>q</ci>
    <cn type="integer">1</cn>
    <ci>A</ci>
    <ci>q</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,1,A,q,\epsilon)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Pushdown_automaton:75">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo>,</mo>
   <mi>Z</mi>
   <mo>,</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mi>Z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>q</ci>
    <ci>ϵ</ci>
    <ci>Z</ci>
    <ci>r</ci>
    <ci>Z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,\epsilon,Z,r,Z)
  </annotation>
 </semantics>
</math>

.</p>

<p>In words, the first two instructions say that in state 

<math display="inline" id="Pushdown_automaton:76">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 any time the symbol 

<math display="inline" id="Pushdown_automaton:77">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 is read, one 

<math display="inline" id="Pushdown_automaton:78">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is pushed onto the stack. Pushing symbol 

<math display="inline" id="Pushdown_automaton:79">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 on top of another 

<math display="inline" id="Pushdown_automaton:80">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is formalized as replacing top 

<math display="inline" id="Pushdown_automaton:81">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Pushdown_automaton:82">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AA
  </annotation>
 </semantics>
</math>

 (and similarly for pushing symbol 

<math display="inline" id="Pushdown_automaton:83">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 on top of a 

<math display="inline" id="Pushdown_automaton:84">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

).</p>

<p>The third and fourth instructions say that, at any moment the automaton may move from state 

<math display="inline" id="Pushdown_automaton:85">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to state 

<math display="inline" id="Pushdown_automaton:86">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

.</p>

<p>The fifth instruction says that in state 

<math display="inline" id="Pushdown_automaton:87">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, for each symbol 

<math display="inline" id="Pushdown_automaton:88">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 read, one 

<math display="inline" id="Pushdown_automaton:89">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is popped.</p>

<p>Finally, the sixth instruction says that the machine may move from state 

<math display="inline" id="Pushdown_automaton:90">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 to accepting state 

<math display="inline" id="Pushdown_automaton:91">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 only when the stack consists of a single 

<math display="inline" id="Pushdown_automaton:92">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

.</p>

<p>There seems to be no generally used representation for PDA. Here we have depicted the instruction 

<math display="inline" id="Pushdown_automaton:93">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <ci>a</ci>
    <ci>A</ci>
    <ci>q</ci>
    <ci>α</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,a,A,q,\alpha)
  </annotation>
 </semantics>
</math>

 by an edge from state 

<math display="inline" id="Pushdown_automaton:94">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to state 

<math display="inline" id="Pushdown_automaton:95">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 labelled by 

<math display="inline" id="Pushdown_automaton:96">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>;</mo>
   <mrow>
    <mi>A</mi>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <apply>
     <divide></divide>
     <ci>A</ci>
     <ci>α</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a;A/\alpha
  </annotation>
 </semantics>
</math>

 (read 

<math display="inline" id="Pushdown_automaton:97">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

; replace 

<math display="inline" id="Pushdown_automaton:98">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Pushdown_automaton:99">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="understanding-the-computation-process">Understanding the computation process</h2>

<p> The following illustrates how the above PDA computes on different input strings. The subscript 

<math display="inline" id="Pushdown_automaton:100">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 from the step symbol 

<math display="inline" id="Pushdown_automaton:101">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

 is here omitted.</p>

<p>(a) Input string = 0011. There are various computations, depending on the moment the move from state 

<math display="inline" id="Pushdown_automaton:102">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to state 

<math display="inline" id="Pushdown_automaton:103">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is made. Only one of these is accepting.</p>
<dl>
<dd>(i) 

<math display="inline" id="Pushdown_automaton:104">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>0011</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>0011</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mn>0011</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <vector>
      <ci>p</ci>
      <cn type="integer">0011</cn>
      <ci>Z</ci>
     </vector>
     <vector>
      <ci>q</ci>
      <cn type="integer">0011</cn>
      <ci>Z</ci>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>r</ci>
      <cn type="integer">0011</cn>
      <ci>Z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,0011,Z)\vdash(q,0011,Z)\vdash(r,0011,Z)
  </annotation>
 </semantics>
</math>

. The final state is accepting, but the input is not accepted this way as it has not been read.
</dd>
</dl>
<dl>
<dd>(ii) 

<math display="inline" id="Pushdown_automaton:105">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>0011</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>011</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>011</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <vector>
      <ci>p</ci>
      <cn type="integer">0011</cn>
      <ci>Z</ci>
     </vector>
     <vector>
      <ci>p</ci>
      <cn type="integer">011</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>q</ci>
      <cn type="integer">011</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,0011,Z)\vdash(p,011,AZ)\vdash(q,011,AZ)
  </annotation>
 </semantics>
</math>

. No further steps possible.
</dd>
</dl>
<dl>
<dd>(iii) 

<math display="inline" id="Pushdown_automaton:106">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>0011</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>011</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <vector>
      <ci>p</ci>
      <cn type="integer">0011</cn>
      <ci>Z</ci>
     </vector>
     <vector>
      <ci>p</ci>
      <cn type="integer">011</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>p</ci>
      <cn type="integer">11</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>q</ci>
      <cn type="integer">11</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,0011,Z)\vdash(p,011,AZ)\vdash(p,11,AAZ)\vdash(q,11,AAZ)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Pushdown_automaton:107">
 <semantics>
  <mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>A</mi>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϵ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash(q,1,AZ)\vdash(q,\epsilon,Z)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Pushdown_automaton:108">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <vector>
     <ci>r</ci>
     <ci>ϵ</ci>
     <ci>Z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash(r,\epsilon,Z)
  </annotation>
 </semantics>
</math>

. Accepting computation: ends in accepting state, while complete input has been read.
</dd>
</dl>

<p>(b) Input string = 00111. Again there are various computations. None of these is accepting.</p>
<dl>
<dd>(i) 

<math display="inline" id="Pushdown_automaton:109">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>00111</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>00111</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mn>00111</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <vector>
      <ci>p</ci>
      <cn type="integer">00111</cn>
      <ci>Z</ci>
     </vector>
     <vector>
      <ci>q</ci>
      <cn type="integer">00111</cn>
      <ci>Z</ci>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>r</ci>
      <cn type="integer">00111</cn>
      <ci>Z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,00111,Z)\vdash(q,00111,Z)\vdash(r,00111,Z)
  </annotation>
 </semantics>
</math>

. The final state is accepting, but the input is not accepted this way as it has not been read.
</dd>
</dl>
<dl>
<dd>(ii) 

<math display="inline" id="Pushdown_automaton:110">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>00111</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>0111</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>0111</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <vector>
      <ci>p</ci>
      <cn type="integer">00111</cn>
      <ci>Z</ci>
     </vector>
     <vector>
      <ci>p</ci>
      <cn type="integer">0111</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>q</ci>
      <cn type="integer">0111</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,00111,Z)\vdash(p,0111,AZ)\vdash(q,0111,AZ)
  </annotation>
 </semantics>
</math>

. No further steps possible.
</dd>
</dl>
<dl>
<dd>(iii) 

<math display="inline" id="Pushdown_automaton:111">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>00111</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>0111</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mn>111</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>111</mn>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>A</mi>
     <mi>Z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <vector>
      <ci>p</ci>
      <cn type="integer">00111</cn>
      <ci>Z</ci>
     </vector>
     <vector>
      <ci>p</ci>
      <cn type="integer">0111</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>p</ci>
      <cn type="integer">111</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>q</ci>
      <cn type="integer">111</cn>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>A</ci>
       <ci>Z</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,00111,Z)\vdash(p,0111,AZ)\vdash(p,111,AAZ)\vdash(q,111,AAZ)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Pushdown_automaton:112">
 <semantics>
  <mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mi>A</mi>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <cn type="integer">11</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash(q,11,AZ)\vdash(q,1,Z)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Pushdown_automaton:113">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <vector>
     <ci>r</ci>
     <cn type="integer">1</cn>
     <ci>Z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash(r,1,Z)
  </annotation>
 </semantics>
</math>

. The final state is accepting, but the input is not accepted this way as it has not been (completely) read.
</dd>
</dl>
<h2 id="pda-and-context-free-languages">PDA and context-free languages</h2>

<p>Every context-free grammar can be transformed into an equivalent nondeterministic pushdown automaton. The derivation process of the grammar is simulated in a leftmost way. Where the grammar rewrites a nonterminal, the PDA takes the topmost nonterminal from its stack and replaces it by the right-hand part of a grammatical rule (expand). Where the grammar generates a terminal symbol, the PDA reads a symbol from input when it is the topmost symbol on the stack (match). In a sense the stack of the PDA contains the unprocessed data of the grammar, corresponding to a pre-order traversal of a derivation tree.</p>

<p>Technically, given a context-free grammar, the PDA is constructed as follows.</p>
<ol>
<li>

<math display="inline" id="Pushdown_automaton:114">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi>ε</mi>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi>α</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">1</cn>
    <ci>ε</ci>
    <ci>A</ci>
    <cn type="integer">1</cn>
    <ci>α</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,\varepsilon,A,1,\alpha)
  </annotation>
 </semantics>
</math>

 for each rule 

<math display="inline" id="Pushdown_automaton:115">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to\alpha
  </annotation>
 </semantics>
</math>

 (<em>expand</em>)</li>
<li>

<math display="inline" id="Pushdown_automaton:116">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi>ε</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">1</cn>
    <ci>a</ci>
    <ci>a</ci>
    <cn type="integer">1</cn>
    <ci>ε</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,a,a,1,\varepsilon)
  </annotation>
 </semantics>
</math>

 for each terminal symbol 

<math display="inline" id="Pushdown_automaton:117">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 (<em>match</em>)</li>
</ol>

<p>As a result we obtain a single state pushdown automata, the state here is 

<math display="inline" id="Pushdown_automaton:118">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

, accepting the context-free language by empty stack. Its initial stack symbol equals the axiom of the context-free grammar.</p>

<p>The converse, finding a grammar for a given PDA, is not that easy. The trick is to code two states of the PDA into the nonterminals of the grammar.</p>

<p><strong>Theorem.</strong> For each pushdown automaton 

<math display="inline" id="Pushdown_automaton:119">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 one may construct a context-free grammar 

<math display="inline" id="Pushdown_automaton:120">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Pushdown_automaton:121">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(M)=L(G)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="generalized-pushdown-automaton-gpda">Generalized pushdown automaton (GPDA)</h2>

<p>A GPDA is a PDA which writes an entire string of some known length to the stack or removes an entire string from the stack in one step.</p>

<p>A GPDA is formally defined as a 6-tuple:</p>

<p>

<math display="block" id="Pushdown_automaton:122">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>δ</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <ci>normal-Γ</ci>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>F</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\ \Sigma,\ \Gamma,\ \delta,\ q_{0},\ F)
  </annotation>
 </semantics>
</math>

 where Q, 

<math display="inline" id="Pushdown_automaton:123">
 <semantics>
  <mpadded width="+1.7pt">
   <mi mathvariant="normal">Σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:124">
 <semantics>
  <mpadded width="+1.7pt">
   <mi mathvariant="normal">Γ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\,
  </annotation>
 </semantics>
</math>

, q<sub>0</sub> and F are defined the same way as a PDA.</p>

<p>

<math display="block" id="Pushdown_automaton:125">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>δ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\delta
  </annotation>
 </semantics>
</math>



<math display="block" id="Pushdown_automaton:126">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>×</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>ϵ</mi>
    </msub>
    <mo>×</mo>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>⟶</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Q</mi>
      <mo>×</mo>
      <msup>
       <mi mathvariant="normal">Γ</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⟶</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>ϵ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Γ</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\times\Sigma_{\epsilon}\times\Gamma^{*}\longrightarrow P(Q\times\Gamma^{*})
  </annotation>
 </semantics>
</math>

 is the transition function.</p>

<p>Computation rules for a GPDA are the same as a PDA except that the a<sub>i+1</sub>'s and b<sub>i+1</sub>'s are now strings instead of symbols.</p>

<p>GPDA's and PDA's are equivalent in that if a language is recognized by a PDA, it is also recognized by a GPDA and vice versa.</p>

<p>One can formulate an analytic proof for the equivalence of GPDA's and PDA's using the following simulation:</p>

<p>Let 

<math display="inline" id="Pushdown_automaton:127">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

(q<sub>1</sub>, w, x<sub>1</sub>x<sub>2</sub>...x<sub>m</sub>) 

<math display="inline" id="Pushdown_automaton:128">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (q<sub>2</sub>, y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>) be a transition of the GPDA</p>

<p>where 

<math display="inline" id="Pushdown_automaton:129">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>q</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>q</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1},q_{2}\in Q
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:130">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mi>ϵ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\Sigma_{\epsilon}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:131">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2},\ldots,x_{m}\in\Gamma^{*}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:132">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>m</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\geq 0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:133">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},y_{2},\ldots,y_{n}\in\Gamma^{*}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:134">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq 0
  </annotation>
 </semantics>
</math>

.</p>

<p>Construct the following transitions for the PDA:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:135">
 <semantics>
  <msup>
   <mi>δ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

(q<sub>1</sub>, w, x<sub>1</sub>) 

<math display="inline" id="Pushdown_automaton:136">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (p<sub>1</sub>, 

<math display="inline" id="Pushdown_automaton:137">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:138">
 <semantics>
  <msup>
   <mi>δ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

(p<sub>1</sub>, 

<math display="inline" id="Pushdown_automaton:139">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, x<sub>2</sub>) 

<math display="inline" id="Pushdown_automaton:140">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (p<sub>2</sub>, 

<math display="inline" id="Pushdown_automaton:141">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:142">
 <semantics>
  <mi mathvariant="normal">⋮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdots
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:143">
 <semantics>
  <msup>
   <mi>δ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

(p<sub>m-1</sub>, 

<math display="inline" id="Pushdown_automaton:144">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, x<sub>m</sub>) 

<math display="inline" id="Pushdown_automaton:145">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (p<sub>m</sub>, 

<math display="inline" id="Pushdown_automaton:146">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:147">
 <semantics>
  <msup>
   <mi>δ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

(p<sub>m</sub>, 

<math display="inline" id="Pushdown_automaton:148">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:149">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 ) 

<math display="inline" id="Pushdown_automaton:150">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (p<sub>m+1</sub>, y<sub>n</sub>)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:151">
 <semantics>
  <msup>
   <mi>δ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

(p<sub>m+1</sub>, 

<math display="inline" id="Pushdown_automaton:152">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:153">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 ) 

<math display="inline" id="Pushdown_automaton:154">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (p<sub>m+2</sub>, y<sub>n-1</sub>)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:155">
 <semantics>
  <mi mathvariant="normal">⋮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdots
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Pushdown_automaton:156">
 <semantics>
  <msup>
   <mi>δ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

(p<sub>m+n-1</sub>, 

<math display="inline" id="Pushdown_automaton:157">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Pushdown_automaton:158">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 ) 

<math display="inline" id="Pushdown_automaton:159">
 <semantics>
  <mo>⟶</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⟶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \longrightarrow
  </annotation>
 </semantics>
</math>

 (q<sub>2</sub>, y<sub>1</sub>)
</dd>
</dl>
</dd>
</dl>
<h2 id="stack-automaton">Stack automaton</h2>

<p>As a generalization of pushdown automata, Ginsburg, Greibach, and Harrison (1967) investigated <strong>stack automata</strong>, which may additionally step left or right in the input string (surrounded by special endmarker symbols to prevent slipping out), and step up or down in the stack in read-only mode.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A stack automaton is called <em>nonerasing</em> if it never pops from the stack. The class of languages accepted by nondeterministic, nonerasing stack automata is <em><a class="uri" href="NSPACE" title="wikilink">NSPACE</a></em>(<em>n</em><sup>2</sup>), which is a superset of the <a href="context-sensitive_languages#Computational_properties" title="wikilink">context-sensitive languages</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The class of languages accepted by deterministic, nonerasing stack automata is <em><a class="uri" href="DSPACE" title="wikilink">DSPACE</a></em>(<em>n</em>⋅log(<em>n</em>)).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Stack_machine" title="wikilink">Stack machine</a></li>
<li><a href="Context-free_grammar" title="wikilink">Context-free grammar</a></li>
<li><a href="Finite_automaton" title="wikilink">Finite automaton</a></li>
<li><a href="Counter_automaton" title="wikilink">Counter automaton</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>

<p>Section 2.2: Pushdown Automata, pp. 101–114.</p></li>
<li>Jean-Michel Autebert, Jean Berstel, Luc Boasson, <a href="http://www-igm.univ-mlv.fr/~berstel/Articles/1997CFLPDA.pdf">Context-Free Languages and Push-Down Automata</a>, in: G. Rozenberg, A. Salomaa (eds.), Handbook of Formal Languages, Vol. 1, Springer-Verlag, 1997, 111-174.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.jflap.org">JFLAP</a>, simulator for several types of automata including nondeterministic pushdown automata</li>
</ul>

<p>"</p>

<p><a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"> Here: Sect.6.4.3, p.249: The set of even-length <a href="Palindrome#Computation_theory" title="wikilink">palindromes</a> of bits can't be recognized by a deterministic PDA, but is a <a href="context-free_language" title="wikilink">context-free language</a>, with the <a href="context-free_grammar" title="wikilink">grammar</a> <em>S</em> → ε | 0<em>S</em>0 | 1<em>S</em>1.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
</ol>
</section>
</body>
</html>
