<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1612">Communication complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Communication complexity</h1>
<hr/>

<p>The notion of <strong>communication complexity</strong> was introduced by <a href="Andrew_Yao" title="wikilink">Yao</a> in 1979,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> who investigated the following problem involving two separated parties (<a href="Alice_and_Bob" title="wikilink">Alice and Bob</a>). Alice receives an n-<a class="uri" href="bit" title="wikilink">bit</a> string x and Bob another n-bit string y, and the goal is for one of them (say Bob) to compute a certain function f(x,y) with the least amount of <a class="uri" href="communication" title="wikilink">communication</a> between them. Note that here we are not concerned about the number of computational steps, or the size of the <a href="computer_memory" title="wikilink">computer memory</a> used. Communication <a class="uri" href="complexity" title="wikilink">complexity</a> tries to quantify the amount of communication required for such <a href="distributed_computation" title="wikilink">distributed computations</a>.</p>

<p>Of course they can always succeed by having Alice send her whole n-bit string to Bob, who then computes the <a href="Function_(programming)" title="wikilink">function</a>, but the idea here is to find clever ways of calculating f with fewer than n bits of communication.</p>

<p>This abstract problem is relevant in many contexts: in <a class="uri" href="VLSI" title="wikilink">VLSI</a> circuit design, for example, one wants to minimize energy used by decreasing the amount of electric signals required between the different components during a distributed computation. The problem is also relevant in the study of data structures, and in the optimization of computer networks. For a survey of the field, see the book by Kushilevitz and Nisan.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Let 

<math display="inline" id="Communication_complexity:0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

: X 

<math display="inline" id="Communication_complexity:1">
 <semantics>
  <mo>×</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times
  </annotation>
 </semantics>
</math>

 Y 

<math display="inline" id="Communication_complexity:2">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

 Z where we assume in the typical case that 

<math display="inline" id="Communication_complexity:3">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=Y=\{0,1\}^{n}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Communication_complexity:4">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\{0,1\}
  </annotation>
 </semantics>
</math>

. Alice draws an n-bit string 

<math display="inline" id="Communication_complexity:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:6">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 X while Bob draws an n-bit string 

<math display="inline" id="Communication_complexity:7">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:8">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>


 Y. By communicating to each other one <a class="uri" href="bit" title="wikilink">bit</a> at a time (adopting some <a href="Protocol_(computing)" title="wikilink"><em>communication protocol</em></a>), Alice and Bob want to compute the value of 

<math display="inline" id="Communication_complexity:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 such that at least one party knows the value at the end of the communication. At this point the answer can be communicated back so that at the cost of one extra bit, both parties will know the answer. The worst case communication complexity of this communication protocol, denoted as 

<math display="inline" id="Communication_complexity:10">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(f)
  </annotation>
 </semantics>
</math>

, is then defined to be</p>

<p>

<math display="block" id="Communication_complexity:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>f</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(f)=
  </annotation>
 </semantics>
</math>

 minimum number of bits exchanged between Alice and Bob in the worst case</p>

<p>Using the above definition, it is useful to think of the function 

<math display="inline" id="Communication_complexity:12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 as a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> 

<math display="inline" id="Communication_complexity:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 (called the <em>input matrix</em>) where each row of the matrix corresponds to 

<math display="inline" id="Communication_complexity:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:15">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 X and each column corresponds to 

<math display="inline" id="Communication_complexity:16">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:17">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 Y. An entry in the input matrix is 

<math display="inline" id="Communication_complexity:18">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi mathvariant="normal">x</mi>
     <mo>,</mo>
     <mi mathvariant="normal">y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <list>
      <ci>normal-x</ci>
      <ci>normal-y</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathrm{x,y}}=f(x,y)
  </annotation>
 </semantics>
</math>


. Initially both Alice and Bob have a copy of the entire matrix A (assuming the function 

<math display="inline" id="Communication_complexity:19">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is known to both). Then, the problem of computing the function value can be rephrased as "zeroing-in" on the corresponding matrix entry. This problem can be solved if either Alice or Bob knows both 

<math display="inline" id="Communication_complexity:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communication_complexity:21">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. At the start of communication, the number of choices for the value of the function on the inputs is the size of matrix, i.e. 

<math display="inline" id="Communication_complexity:22">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2n}
  </annotation>
 </semantics>
</math>

. Then, as and when each party communicates a bit to the other, the number of choices for the answer reduces as this eliminates a set of rows/columns resulting in a <a class="uri" href="submatrix" title="wikilink">submatrix</a> of A.</p>

<p>More formally, a set R 

<math display="inline" id="Communication_complexity:23">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>


 X 

<math display="inline" id="Communication_complexity:24">
 <semantics>
  <mo>×</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times
  </annotation>
 </semantics>
</math>

 Y is called a <em>(combinatorial) rectangle</em> if whenever 

<math display="inline" id="Communication_complexity:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:26">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 R and 

<math display="inline" id="Communication_complexity:27">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{2},y_{2})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:28">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>


 R then 

<math display="inline" id="Communication_complexity:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{2})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:30">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 R. Equivalently, R can also be viewed as a submatrix of the input matrix A such that R = M 

<math display="inline" id="Communication_complexity:31">
 <semantics>
  <mo>×</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times
  </annotation>
 </semantics>
</math>

 N where M 

<math display="inline" id="Communication_complexity:32">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 X and N 

<math display="inline" id="Communication_complexity:33">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>


 Y. Consider the case when 

<math display="inline" id="Communication_complexity:34">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 bits are already exchanged between the parties. Now, for a particular 

<math display="inline" id="Communication_complexity:35">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:36">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:37">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}^{k}
  </annotation>
 </semantics>
</math>

, let us define a matrix</p>

<p>

<math display="block" id="Communication_complexity:38">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi mathvariant="normal">h</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>normal-h</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\mathrm{h}}=\{(x,y):
  </annotation>
 </semantics>
</math>

 the k-bits exchanged on input 

<math display="inline" id="Communication_complexity:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Communication_complexity:40">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\}
  </annotation>
 </semantics>
</math>

</p>

<p>Then, 

<math display="inline" id="Communication_complexity:41">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi mathvariant="normal">h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>normal-h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\mathrm{h}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Communication_complexity:42">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 X 

<math display="inline" id="Communication_complexity:43">
 <semantics>
  <mo>×</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times
  </annotation>
 </semantics>
</math>


 Y, and 

<math display="inline" id="Communication_complexity:44">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi mathvariant="normal">h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>normal-h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\mathrm{h}}
  </annotation>
 </semantics>
</math>

 is a rectangle and a submatrix of A.</p>
<h3 id="example-eq">Example: EQ</h3>

<p>We consider the case where Alice and Bob try to determine if they both have the same string. That is, we are trying to determine if 

<math display="inline" id="Communication_complexity:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Communication_complexity:46">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. It is easy to prove that the equality problem (EQ) will always require you to communicate 

<math display="inline" id="Communication_complexity:47">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits in the worst case if you want to be absolutely sure 

<math display="inline" id="Communication_complexity:48">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Communication_complexity:49">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are equal. Consider the simple case of 

<math display="inline" id="Communication_complexity:50">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communication_complexity:51">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 being 3 bits. The equality function in this case can be represented by the matrix below. The rows representing all the possibilities of 

<math display="inline" id="Communication_complexity:52">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, the columns those of 

<math display="inline" id="Communication_complexity:53">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


.</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>EQ</p></td>
<td style="text-align: left;">
<p>000</p></td>
<td style="text-align: left;">
<p>001</p></td>
<td style="text-align: left;">
<p>010</p></td>
<td style="text-align: left;">
<p>011</p></td>
<td style="text-align: left;">
<p>100</p></td>
<td style="text-align: left;">
<p>101</p></td>
<td style="text-align: left;">
<p>110</p></td>
<td style="text-align: left;">
<p>111</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>000</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>001</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>010</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>011</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>100</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>101</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>110</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>111</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>
</center>

<p>As you can see, the function only evaluates to 1 when 

<math display="inline" id="Communication_complexity:54">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 equals 

<math display="inline" id="Communication_complexity:55">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 (i.e., on the diagonal). It is also fairly easy to see how communicating a single bit divides your possibilities in half. If you know that the first bit of 

<math display="inline" id="Communication_complexity:56">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is 1, you only need to consider half of the columns (where 

<math display="inline" id="Communication_complexity:57">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 can equal 100, 101, 110, or 111).</p>

<p><strong>Theorem

<math display="block" id="Communication_complexity:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(EQ)=n
  </annotation>
 </semantics>
</math>

.</strong><br/>
Proof. Assume that 

<math display="inline" id="Communication_complexity:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(EQ)\leq n-1
  </annotation>
 </semantics>
</math>

. This means that there exists an 

<math display="inline" id="Communication_complexity:60">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>x</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,x)
  </annotation>
 </semantics>
</math>

 and an 

<math display="inline" id="Communication_complexity:61">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x^{\prime},x^{\prime})
  </annotation>
 </semantics>
</math>

 having the same history, 

<math display="inline" id="Communication_complexity:62">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

. Since this history defines a rectangle, 

<math display="inline" id="Communication_complexity:63">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,x^{\prime})
  </annotation>
 </semantics>
</math>


 must also be 1. By definition 

<math display="inline" id="Communication_complexity:64">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq x^{\prime}
  </annotation>
 </semantics>
</math>

 and we know that equality is only true for 

<math display="inline" id="Communication_complexity:65">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Communication_complexity:66">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b
  </annotation>
 </semantics>
</math>

. Thus, we have a contradiction.</p>

<p>Intuitively, for 

<math display="inline" id="Communication_complexity:67">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(EQ)
  </annotation>
 </semantics>
</math>

 less than 

<math display="inline" id="Communication_complexity:68">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


, we need to be able to define a rectangle in the EQ matrix greater in size than a single cell. All of the cells in this rectangle must contain 1 for us to be able to generalize that this rectangle equals 1. It is not possible to form such a rectangle in the equality matrix.</p>
<h2 id="randomized-communication-complexity">Randomized communication complexity</h2>

<p>In the above definition, we are concerned with the number of bits that must be <em>deterministically</em> transmitted between two parties. If both the parties are given access to a random number generator, can they determine the value of 

<math display="inline" id="Communication_complexity:69">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 with much less information exchanged? Yao, in his seminal paper<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> answers this question by defining randomized communication complexity.</p>

<p>A randomized protocol 

<math display="inline" id="Communication_complexity:70">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 for a function 

<math display="inline" id="Communication_complexity:71">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 has two-sided error.</p>

<p>

<math display="block" id="Communication_complexity:72">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>></mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>if</mtext>
     </mpadded>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <gt></gt>
     <apply>
      <ci>Pr</ci>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>R</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[R(x,y)=0]>\frac{1}{2},\textrm{if }\,f(x,y)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Communication_complexity:73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>></mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>if</mtext>
     </mpadded>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <gt></gt>
     <apply>
      <ci>Pr</ci>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>R</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[R(x,y)=1]>\frac{1}{2},\textrm{if }\,f(x,y)=1
  </annotation>
 </semantics>
</math>

</p>

<p>A randomized protocol is a deterministic protocol that uses an extra random string in addition to its normal input. There are two models for this: a <em>public string</em> is a random string that is known by both parties beforehand, while a <em>private string</em> is generated by one party and must be communicated to the other party. A theorem presented below shows that any public string protocol can be simulated by a private string protocol that uses <em>O(log n)</em> additional bits compared to the original.</p>

<p>Note that in the probability inequalities above, the outcome of the protocol is understood to depend <em>only</em> on the random string; both strings <em>x</em> and <em>y</em> remain fixed. In other words, if R(x,y) yields g(x,y,r) when using random string <em>r</em>, then g(x,y,r) = f(x,y) for at least half of all choices for the string <em>r</em>.</p>

<p>The randomized complexity is simply defined as the number of bits exchanged in such a protocol.</p>

<p>Note that it is also possible to define a randomized protocol with one-sided error, and the complexity is defined similarly.</p>
<h3 id="example-eq-1">Example: EQ</h3>

<p>Returning to the previous example of <em>EQ</em>, if certainty is not required, Alice and Bob can check for equality using only <em>O(log n)</em> messages. Consider the following protocol: Assume that Alice and Bob both have access to the same random string 

<math display="inline" id="Communication_complexity:74">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>z</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\in\{0,1\}^{n}
  </annotation>
 </semantics>
</math>

. Alice computes 

<math display="inline" id="Communication_complexity:75">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>⋅</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>z</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\cdot x
  </annotation>
 </semantics>
</math>

 and sends this bit (call it <em>b</em>) to Bob. (The 

<math display="inline" id="Communication_complexity:76">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>⋅</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\cdot)
  </annotation>
 </semantics>
</math>

 is the <a href="dot_product" title="wikilink">dot product</a> in <a href="finite_field#Some_small_finite_fields" title="wikilink">GF(2)</a>.) Then Bob compares <em>b</em> to 

<math display="inline" id="Communication_complexity:77">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>⋅</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>z</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\cdot y
  </annotation>
 </semantics>
</math>

. If they are the same, then Bob accepts, saying <em>x</em> equals <em>y</em>. Otherwise, he rejects.</p>

<p>Clearly, if 

<math display="inline" id="Communication_complexity:78">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>


, then 

<math display="inline" id="Communication_complexity:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>⋅</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>z</mi>
    <mo>⋅</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>z</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>z</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\cdot x=z\cdot y
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Communication_complexity:80">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>r</mi>
    <mi>o</mi>
    <msub>
     <mi>b</mi>
     <mi>z</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>A</mi>
      <mi>c</mi>
      <mi>c</mi>
      <mi>e</mi>
      <mi>p</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>r</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>c</ci>
       <ci>c</ci>
       <ci>e</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Prob_{z}[Accept]=1
  </annotation>
 </semantics>
</math>

. If <em>x</em> does not equal <em>y</em>, it is still possible that 

<math display="inline" id="Communication_complexity:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>⋅</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>z</mi>
    <mo>⋅</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>z</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>z</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\cdot x=z\cdot y
  </annotation>
 </semantics>
</math>

, which would give Bob the wrong answer. How does this happen?</p>

<p>If <em>x</em> and <em>y</em> are not equal, they must differ in some locations:</p>

<p>

<math display="block" id="Communication_complexity:82">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mi>p</mi>
    <mi mathvariant="normal">…</mi>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <ci>p</ci>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=c_{1}c_{2}\ldots p\ldots p^{\prime}\ldots x_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Communication_complexity:83">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mi>q</mi>
    <mi mathvariant="normal">…</mi>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <ci>q</ci>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=c_{1}c_{2}\ldots q\ldots q^{\prime}\ldots y_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Communication_complexity:84">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>z</mi>
     <mi>i</mi>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>z</mi>
     <mi>j</mi>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=z_{1}z_{2}\ldots z_{i}\ldots z_{j}\ldots z_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Communication_complexity:85">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communication_complexity:86">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 agree, 

<math display="inline" id="Communication_complexity:87">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>i</mi>
    </msub>
    <mo>*</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>i</mi>
    </msub>
    <mo>*</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>i</mi>
    </msub>
    <mo>*</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}*x_{i}=z_{i}*c_{i}=z_{i}*y_{i}
  </annotation>
 </semantics>
</math>

 so those terms affect the dot products equally. We can safely ignore those terms and look only at where 

<math display="inline" id="Communication_complexity:88">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Communication_complexity:89">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 differ. Furthermore, we can swap the bits 

<math display="inline" id="Communication_complexity:90">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communication_complexity:91">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 without changing whether or not the dot products are equal. This means we can swap bits so that 

<math display="inline" id="Communication_complexity:92">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 contains only zeros and 

<math display="inline" id="Communication_complexity:93">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 contains only ones:</p>

<p>

<math display="block" id="Communication_complexity:94">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mn>00</mn>
    <mi mathvariant="normal">…</mi>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">00</cn>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}=00\ldots 0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Communication_complexity:95">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mn>11</mn>
    <mi mathvariant="normal">…</mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">11</cn>
     <ci>normal-…</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=11\ldots 1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Communication_complexity:96">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>z</mi>
     <msup>
      <mi>n</mi>
      <mo>′</mo>
     </msup>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}=z_{1}z_{2}\ldots z_{n^{\prime}}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that 

<math display="inline" id="Communication_complexity:97">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}\cdot x^{\prime}=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communication_complexity:98">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mi>z</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}\cdot y^{\prime}=\Sigma_{i}z^{\prime}_{i}
  </annotation>
 </semantics>
</math>


. Now, the question becomes: for some random string 

<math display="inline" id="Communication_complexity:99">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

, what is the probability that 

<math display="inline" id="Communication_complexity:100">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mi>z</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{i}z^{\prime}_{i}=0
  </annotation>
 </semantics>
</math>

? Since each 

<math display="inline" id="Communication_complexity:101">
 <semantics>
  <msubsup>
   <mi>z</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}_{i}
  </annotation>
 </semantics>
</math>

 is equally likely to be 

<math display="inline" id="Communication_complexity:102">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 or 

<math display="inline" id="Communication_complexity:103">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>


, this probability is just 

<math display="inline" id="Communication_complexity:104">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

. Thus, when 

<math display="inline" id="Communication_complexity:105">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 does not equal 

<math display="inline" id="Communication_complexity:106">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Communication_complexity:107">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>r</mi>
    <mi>o</mi>
    <msub>
     <mi>b</mi>
     <mi>z</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>A</mi>
      <mi>c</mi>
      <mi>c</mi>
      <mi>e</mi>
      <mi>p</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>r</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>c</ci>
       <ci>c</ci>
       <ci>e</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Prob_{z}[Accept]=1/2
  </annotation>
 </semantics>
</math>

. The algorithm can be repeated many times to increase its accuracy. This fits the requirements for a randomized communication algorithm.</p>

<p>This shows that <em>if Alice and Bob share a random string of length n</em>, they can send one bit to each other to compute 

<math display="inline" id="Communication_complexity:108">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   EQ(x,y)
  </annotation>
 </semantics>
</math>


. In the next section, it is shown that Alice and Bob can exchange only <em>O(log n)</em> bits that are as good as sharing a random string of length <em>n</em>. Once that is shown, it follows that <em>EQ</em> can be computed in <em>O(log n)</em> messages.</p>
<h3 id="public-coins-versus-private-coins">Public coins versus private coins</h3>

<p>It is easier to create random protocols when both parties have access to the same random string (shared string protocol). It is still possible to use these protocols even when the two parties don't share a random string (private string protocol) with a small communication cost. Any shared string random protocol using an 

<math display="inline" id="Communication_complexity:109">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-bit string can be simulated by a private string protocol that uses an extra <em>O(log n)</em> bits.</p>

<p>Intuitively, we can find some set of strings that has enough randomness in it to run the random protocol with only a small increase in error. This set can be shared beforehand, and instead of drawing a random string, Alice and Bob need only agree on which string to choose from the shared set. This set is small enough that the choice can be communicated efficiently. A formal proof follows.</p>

<p>Consider some random protocol <em>P</em> with a maximum error rate of 0.1. Let 

<math display="inline" id="Communication_complexity:110">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Communication_complexity:111">
 <semantics>
  <mrow>
   <mn>100</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">100</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   100n
  </annotation>
 </semantics>
</math>

 strings of length <em>n</em>, numbered 

<math display="inline" id="Communication_complexity:112">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>r</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>r</mi>
    <mrow>
     <mn>100</mn>
     <mi>n</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <times></times>
      <cn type="integer">100</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1},r_{2},\dots,r_{100n}
  </annotation>
 </semantics>
</math>

. Given such an 

<math display="inline" id="Communication_complexity:113">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


, define a new protocol 

<math display="inline" id="Communication_complexity:114">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>R</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}_{R}
  </annotation>
 </semantics>
</math>

 which randomly picks some 

<math display="inline" id="Communication_complexity:115">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}
  </annotation>
 </semantics>
</math>

 and then runs <em>P</em> using 

<math display="inline" id="Communication_complexity:116">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}
  </annotation>
 </semantics>
</math>

 as the shared random string. It takes <em>O</em>(log 100<em>n</em>) = <em>O</em>(log <em>n</em>) bits to communicate the choice of 

<math display="inline" id="Communication_complexity:117">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>Let us define 

<math display="inline" id="Communication_complexity:118">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x,y)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Communication_complexity:119">
 <semantics>
  <mrow>
   <msubsup>
    <mi>p</mi>
    <mi>R</mi>
    <mo>′</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}_{R}(x,y)
  </annotation>
 </semantics>
</math>

 to be the probabilities that 

<math display="inline" id="Communication_complexity:120">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communication_complexity:121">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>R</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}_{R}
  </annotation>
 </semantics>
</math>

 compute the correct value for the input 

<math display="inline" id="Communication_complexity:122">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

.</p>

<p>For a fixed 

<math display="inline" id="Communication_complexity:123">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


, we can use <a href="Hoeffding's_inequality" title="wikilink">Hoeffding's inequality</a> to get the following equation:</p>

<p>

<math display="block" id="Communication_complexity:124">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>Pr</mi>
     <mi>R</mi>
    </munder>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <msubsup>
          <mi>p</mi>
          <mi>R</mi>
          <mo>′</mo>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>≥</mo>
      <mn>0.1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mrow>
          <mn>2</mn>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>0.1</mn>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
         <mo>⋅</mo>
         <mn>100</mn>
        </mrow>
        <mi>n</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <geq></geq>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>p</ci>
            <ci>normal-′</ci>
           </apply>
           <ci>R</ci>
          </apply>
          <interval closure="open">
           <ci>x</ci>
           <ci>y</ci>
          </interval>
         </apply>
         <apply>
          <times></times>
          <ci>p</ci>
          <interval closure="open">
           <ci>x</ci>
           <ci>y</ci>
          </interval>
         </apply>
        </apply>
       </apply>
       <cn type="float">0.1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <ci>normal-⋅</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <cn type="float">0.1</cn>
            <cn type="integer">2</cn>
           </apply>
          </apply>
          <cn type="integer">100</cn>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr_{R}[|p^{\prime}_{R}(x,y)-p(x,y)|\geq 0.1]\leq 2\exp(-2(0.1)^{2}\cdot 100n)%
<2^{-2n}
  </annotation>
 </semantics>
</math>

</p>

<p>Thus when we don't have 

<math display="inline" id="Communication_complexity:125">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 fixed:</p>

<p>

<math display="block" id="Communication_complexity:126">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>Pr</mi>
     <mi>R</mi>
    </munder>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mrow>
          <msubsup>
           <mi>p</mi>
           <mi>R</mi>
           <mo>′</mo>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mo>≥</mo>
       <mn>0.1</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mi>Pr</mi>
      <mi>R</mi>
     </munder>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mrow>
          <msubsup>
           <mi>p</mi>
           <mi>R</mi>
           <mo>′</mo>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mo>≥</mo>
       <mn>0.1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </munder>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <exists></exists>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <geq></geq>
        <apply>
         <abs></abs>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>p</ci>
             <ci>normal-′</ci>
            </apply>
            <ci>R</ci>
           </apply>
           <interval closure="open">
            <ci>x</ci>
            <ci>y</ci>
           </interval>
          </apply>
          <apply>
           <times></times>
           <ci>p</ci>
           <interval closure="open">
            <ci>x</ci>
            <ci>y</ci>
           </interval>
          </apply>
         </apply>
        </apply>
        <cn type="float">0.1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Pr</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <geq></geq>
        <apply>
         <abs></abs>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>p</ci>
             <ci>normal-′</ci>
            </apply>
            <ci>R</ci>
           </apply>
           <interval closure="open">
            <ci>x</ci>
            <ci>y</ci>
           </interval>
          </apply>
          <apply>
           <times></times>
           <ci>p</ci>
           <interval closure="open">
            <ci>x</ci>
            <ci>y</ci>
           </interval>
          </apply>
         </apply>
        </apply>
        <cn type="float">0.1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr_{R}[\exists(x,y):\,|p^{\prime}_{R}(x,y)-p(x,y)|\geq 0.1]\leq\sum_{(x,y)}%
\Pr_{R}[|p^{\prime}_{R}(x,y)-p(x,y)|\geq 0.1]<\sum_{(x,y)}2^{-2n}=1
  </annotation>
 </semantics>
</math>

</p>

<p>The last equality above holds because there are 

<math display="inline" id="Communication_complexity:127">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2n}
  </annotation>
 </semantics>
</math>

 different pairs 

<math display="inline" id="Communication_complexity:128">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


. Since the probability does not equal 1, there is some 

<math display="inline" id="Communication_complexity:129">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{0}
  </annotation>
 </semantics>
</math>

 so that for all 

<math display="inline" id="Communication_complexity:130">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Communication_complexity:131">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mi>p</mi>
       <msub>
        <mi>R</mi>
        <mn>0</mn>
       </msub>
       <mo>′</mo>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mn>0.1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |p^{\prime}_{R_{0}}(x,y)-p(x,y)|<0.1
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Communication_complexity:132">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 has at most 0.1 error probability, 

<math display="inline" id="Communication_complexity:133">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <msub>
    <mi>R</mi>
    <mn>0</mn>
   </msub>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}_{R_{0}}
  </annotation>
 </semantics>
</math>


 can have at most 0.2 error probability.</p>
<h2 id="quantum-communication-complexity">Quantum communication complexity</h2>

<p>Quantum communication complexity tries to quantify the communication reduction possible by using quantum effects during a distributed computation.</p>

<p>At least three quantum generalizations of communication complexity have been proposed; for a survey see the suggested text by G. Brassard.</p>

<p>The first one is the <a href="Quantum_entanglement" title="wikilink">qubit-communication model</a>, where the parties can use quantum communication instead of classical communication, for example by exchanging <a class="uri" href="photons" title="wikilink">photons</a> through an <a href="optical_fiber" title="wikilink">optical fiber</a>.</p>

<p>In a second model the communication is still performed with classical bits, but the parties are allowed to manipulate an unlimited supply of quantum entangled states as part of their protocols. By doing measurements on their entangled states, the parties can save on classical communication during a distributed computation.</p>

<p>The third model involves access to previously shared entanglement in addition to <a class="uri" href="qubit" title="wikilink">qubit</a> communication, and is the least explored of the three quantum models.</p>
<h2 id="nondeterministic-communication-complexity">Nondeterministic communication complexity</h2>

<p>In nondeterministic communication complexity, Alice and Bob have access to an oracle. After receiving the oracle's word, the parties communicate to deduce <em>f(x,y)</em>. The nondeterministic communication complexity is then the maximum over all pairs <em>(x,y)</em> over the sum of number of bits exchanged and the coding length of the oracle word.</p>

<p>Viewed differently, this amounts to covering all 1-entries of the 0/1-matrix by combinatorial 1-rectangles (i.e., non-contiguous, non-convex submatrices, whose entries are all one (see Kushilevitz and Nisan or Dietzfelbinger et al.)). The nondeterministic communication complexity is the binary logarithm of the <em>rectangle covering number</em> of the matrix: the minimum number of combinatorial 1-rectangles required to cover all 1-entries of the matrix, without covering any 0-entries.</p>

<p>Nondeterministic communication complexity occurs as a means to obtaining lower bounds for deterministic communication complexity (see Dietzfelbinger et al.), but also in the theory of nonnegative matrices, where it gives a lower bound on the <a href="Nonnegative_rank_(linear_algebra)" title="wikilink">nonnegative rank</a> of a nonnegative matrix.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="open-problems">Open problems</h2>

<p>Considering a 0/1 input matrix 

<math display="inline" id="Communication_complexity:134">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
     </mrow>
     <mo>∈</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <in></in>
      <list>
       <ci>x</ci>
       <ci>y</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{f}=[f(x,y)]_{x,y\in\{0,1\}^{n}}
  </annotation>
 </semantics>
</math>

, the minimum number of bits exchanged to compute 

<math display="inline" id="Communication_complexity:135">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 deterministically in the worst case, 

<math display="inline" id="Communication_complexity:136">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(f)
  </annotation>
 </semantics>
</math>

, is known to be bounded from below by the logarithm of the <a href="Rank_(linear_algebra)" title="wikilink">rank</a> of the matrix 

<math display="inline" id="Communication_complexity:137">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{f}
  </annotation>
 </semantics>
</math>

. The log rank conjecture proposes that the communication complexity, 

<math display="inline" id="Communication_complexity:138">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(f)
  </annotation>
 </semantics>
</math>


, of 

<math display="inline" id="Communication_complexity:139">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{f}
  </annotation>
 </semantics>
</math>

 is bounded from above by a constant power of the logarithm of the rank of 

<math display="inline" id="Communication_complexity:140">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{f}
  </annotation>
 </semantics>
</math>

. Since D(f) is bounded from above and below by polynomials of log rank

<math display="inline" id="Communication_complexity:141">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>M</mi>
    <mi>f</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{f})
  </annotation>
 </semantics>
</math>

, we can say D(f) is polynomially related to log rank

<math display="inline" id="Communication_complexity:142">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>M</mi>
    <mi>f</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{f})
  </annotation>
 </semantics>
</math>

. Since the rank of a matrix is polynomial time computable in the size of the matrix, such an upper bound would allow the matrix's communication complexity to be approximated in polynomial time. Note, however, that the size of the matrix itself is exponential in the size of the input.</p>

<p>For a randomized protocol, the number of bits exchanged in the worst case, R(f), is conjectured to be polynomially related to the following formula:</p>

<p>

<math display="block" id="Communication_complexity:143">
 <semantics>
  <mrow>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mtext>rank</mtext>
        <mrow>
         <mo stretchy="false">(</mo>
         <msubsup>
          <mi>M</mi>
          <mi>f</mi>
          <mo>′</mo>
         </msubsup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>:</mo>
       <mrow>
        <mrow>
         <msubsup>
          <mi>M</mi>
          <mi>f</mi>
          <mo>′</mo>
         </msubsup>
         <mo>∈</mo>
         <msup>
          <mi>ℝ</mi>
          <mrow>
           <msup>
            <mn>2</mn>
            <mi>n</mi>
           </msup>
           <mo>×</mo>
           <msup>
            <mn>2</mn>
            <mi>n</mi>
           </msup>
          </mrow>
         </msup>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>M</mi>
             <mi>f</mi>
            </msub>
            <mo>-</mo>
            <msubsup>
             <mi>M</mi>
             <mi>f</mi>
             <mo>′</mo>
            </msubsup>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi mathvariant="normal">∞</mi>
         </msub>
         <mo>≤</mo>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mn>3</mn>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <min></min>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <mtext>rank</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>M</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>M</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>f</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ℝ</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cn type="integer">2</cn>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cn type="integer">2</cn>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <leq></leq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>M</ci>
           <ci>f</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>M</ci>
            <ci>normal-′</ci>
           </apply>
           <ci>f</ci>
          </apply>
         </apply>
         <infinity></infinity>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log\min(\textrm{rank}(M^{\prime}_{f}):M^{\prime}_{f}\in\mathbb{R}^{2^{n}%
\times 2^{n}},(M_{f}-M^{\prime}_{f})_{\infty}\leq 1/3).
  </annotation>
 </semantics>
</math>

</p>

<p>Such log rank conjectures are valuable because they reduce the question of a matrix's communication complexity to a question of linearly independent rows (columns) of the matrix. This reveals that the essence of the communication complexity problem, for example in the EQ case above, is figuring out where in the matrix the inputs are, in order to find out if they're equivalent.</p>
<h2 id="applications">Applications</h2>

<p>Lower bounds in communication complexity can be used to prove lower bounds in <a href="decision_tree_complexity" title="wikilink">decision tree complexity</a>, <a href="VLSI_circuit" title="wikilink">VLSI circuits</a>, data structures, <a href="streaming_algorithms" title="wikilink">streaming algorithms</a>, <a href="space–time_tradeoff" title="wikilink">space–time tradeoffs</a> for Turing machines and more.</p>
<h2 id="references">References</h2>
<ul>
<li>Kushilevitz, E. and <a href="Noam_Nisan" title="wikilink">N. Nisan</a>. Communication complexity. Cambridge University Press, 1997.</li>
<li>Brassard, G. Quantum communication complexity: a survey. <a href="http://arxiv.org/abs/quant-ph/0101005"></a><a class="uri" href="http://arxiv.org/abs/quant-ph/0101005">http://arxiv.org/abs/quant-ph/0101005</a></li>
<li>Dietzfelbinger, M., J. Hromkovic, J., and G. Schnitger, "A comparison of two lower-bound methods for communication complexity", Theoret. Comput. Sci. 168, 1996. 39-51.</li>
<li><a href="Ran_Raz" title="wikilink">Raz, Ran</a>. "Circuit and Communication Complexity." In Computational Complexity Theory. Steven Rudich and Avi Wigderson, eds. American Mathematical Society Institute for Advanced Study, 2004. 129-137.</li>
<li>A. C. Yao, "Some Complexity Questions Related to Distributed Computing", Proc. of 11th STOC, pp. 209–213, 1979. 14</li>
<li>I. Newman, Private vs. Common Random Bits in Communication Complexity, Information Processing Letters 39, 1991, pp. 67–71.</li>
</ul>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a class="uri" href="Category:Communication" title="wikilink">Category:Communication</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Quantum_complexity_theory" title="wikilink">Category:Quantum complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
