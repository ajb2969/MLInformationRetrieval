<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="212">Context-free grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Context-free grammar</h1>
<hr/>

<p>In <a href="formal_language_theory" title="wikilink">formal language theory</a>, a <strong>context-free grammar</strong> (<strong>CFG</strong>) is a <a href="formal_grammar" title="wikilink">formal grammar</a> in which every <a href="Production_(computer_science)" title="wikilink">production rule</a> is of the form</p>
<dl>
<dd><em>V</em> → <em>w</em>
</dd>
</dl>

<p>where <em>V</em> is a <em>single</em> <a class="uri" href="nonterminal" title="wikilink">nonterminal</a> symbol, and <em>w</em> is a string of <a href="Terminal_and_nonterminal_symbols" title="wikilink">terminals</a> and/or nonterminals (<em>w</em> can be empty). A formal grammar is considered "context free" when its production rules can be applied regardless of the context of a nonterminal. No matter which symbols surround it, the single nonterminal on the left hand side can always be replaced by the right hand side. This is what distinguishes it from a <a href="context-sensitive_grammar" title="wikilink">context-sensitive grammar</a>.</p>

<p><a href="formal_language" title="wikilink">Languages</a> generated by context-free grammars are known as <a href="context-free_language" title="wikilink">context-free languages</a> (CFL). Different context-free grammars can generate the same context-free language. It is important to distinguish properties of the language (intrinsic properties) from properties of a particular grammar (extrinsic properties). The <a href="#Language_equality" title="wikilink">language equality</a> question (do two given context-free grammars generate the same language?) is <a href="Decidability_(logic)" title="wikilink">undecidable</a>.</p>

<p>Context-free grammars arise in <a class="uri" href="linguistics" title="wikilink">linguistics</a> where they are used to describe the structure of sentences and words in <a href="natural_language" title="wikilink">natural language</a>, and they were in fact invented by the linguist <a href="Noam_Chomsky" title="wikilink">Noam Chomsky</a> for this purpose, but have not really lived up to their original expectation. By contrast, in <a href="computer_science" title="wikilink">computer science</a>, as the use of recursively defined concepts increased, they were used more and more. In an early application, grammars are used to describe the structure of <a href="programming_language" title="wikilink">programming languages</a>. In a newer application, they are used in an essential part of the <a href="Extensible_Markup_Language" title="wikilink">Extensible Markup Language</a> (XML) called the <em><a href="Document_Type_Definition" title="wikilink">Document Type Definition</a></em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In <a class="uri" href="linguistics" title="wikilink">linguistics</a>, some authors use the term <strong><a href="phrase_structure_grammar" title="wikilink">phrase structure grammar</a></strong> to refer to context-free grammars, whereby phrase structure grammars are distinct from <a href="dependency_grammar" title="wikilink">dependency grammars</a>. In <a href="computer_science" title="wikilink">computer science</a>, a popular notation for context-free grammars is <a href="Backus–Naur_Form" title="wikilink">Backus–Naur Form</a>, or <em>BNF</em>.</p>
<h2 id="background">Background</h2>

<p>Since the time of <a class="uri" href="Pāṇini" title="wikilink">Pāṇini</a>, at least, linguists have described the <a href="grammar" title="wikilink">grammars</a> of languages in terms of their <a href="block_structure" title="wikilink">block structure</a>, and described how sentences are <a href="recursion" title="wikilink">recursively</a> built up from smaller phrases, and eventually individual words or word elements. An essential property of these block structures is that logical units never overlap. For example, the sentence:</p>
<dl>
<dd>John, whose blue car was in the garage, walked to the grocery store.
</dd>
</dl>

<p>can be logically parenthesized as follows:</p>
<dl>
<dd>(John, ((whose blue car) (was (in the garage))), (walked (to (the grocery store)))).
</dd>
</dl>

<p>A context-free grammar provides a simple and mathematically precise mechanism for describing the methods by which phrases in some natural language are built from smaller blocks, capturing the "block structure" of sentences in a natural way. Its simplicity makes the formalism amenable to rigorous mathematical study. Important features of natural language syntax such as <a href="agreement_(linguistics)" title="wikilink">agreement</a> and <a class="uri" href="reference" title="wikilink">reference</a> are not part of the context-free grammar, but the basic recursive structure of sentences, the way in which clauses nest inside other clauses, and the way in which lists of adjectives and adverbs are swallowed by nouns and verbs, is described exactly.</p>

<p>The formalism of context-free grammars was developed in the mid-1950s by <a href="Noam_Chomsky" title="wikilink">Noam Chomsky</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and also their <a href="Chomsky_hierarchy" title="wikilink">classification as a special type</a> of <a href="formal_grammar" title="wikilink">formal grammar</a> (which he called <a href="phrase-structure_grammar" title="wikilink">phrase-structure grammars</a>).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> What Chomsky called a phrase structure grammar is also known now as a constituency grammar, whereby constituency grammars stand in contrast to <a href="dependency_grammar" title="wikilink">dependency grammars</a>. In Chomsky's <a href="generative_grammar" title="wikilink">generative grammar</a> framework, the syntax of natural language was described by context-free rules combined with transformation rules.</p>

<p>Block structure was introduced into computer <a href="programming_language" title="wikilink">programming languages</a> by the <a href="Algol_(programming_language)" title="wikilink">Algol</a> project (1957–1960), which, as a consequence, also featured a context-free grammar to describe the resulting Algol syntax. This became a standard feature of computer languages, and the notation for grammars used in concrete descriptions of computer languages came to be known as <a href="Backus-Naur_Form" title="wikilink">Backus-Naur Form</a>, after two members of the Algol language design committee.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The "block structure" aspect that context-free grammars capture is so fundamental to grammar that the terms syntax and grammar are often identified with context-free grammar rules, especially in computer science. Formal constraints not captured by the grammar are then considered to be part of the "semantics" of the language.</p>

<p>Context-free grammars are simple enough to allow the construction of efficient <a href="list_of_algorithms#Parsing" title="wikilink">parsing algorithms</a> which, for a given string, determine whether and how it can be generated from the grammar. An <a href="Earley_parser" title="wikilink">Earley parser</a> is an example of such an algorithm, while the widely used <a href="LR_parser" title="wikilink">LR</a> and <a href="LL_parser" title="wikilink">LL parsers</a> are simpler algorithms that deal only with more restrictive subsets of context-free grammars.</p>
<h2 id="formal-definitions">Formal definitions</h2>

<p>A context-free grammar <em>G</em> is defined by the 4-<a class="uri" href="tuple" title="wikilink">tuple</a>:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> 

<math display="inline" id="Context-free_grammar:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mi>V</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>S</mi>
    </mpadded>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>V</ci>
     <ci>normal-Σ</ci>
     <ci>R</ci>
     <ci>S</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V\,,\Sigma\,,R\,,S\,)
  </annotation>
 </semantics>
</math>

 where</p>
<ol>
<li>

<math display="inline" id="Context-free_grammar:1">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

 is a finite set; each element 

<math display="inline" id="Context-free_grammar:2">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 is called <em>a non-terminal character</em> or a <em>variable</em>. Each variable represents a different type of phrase or clause in the sentence. Variables are also sometimes called syntactic categories. Each variable defines a sub-language of the language defined by 

<math display="inline" id="Context-free_grammar:3">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Context-free_grammar:4">
 <semantics>
  <mpadded width="+1.7pt">
   <mi mathvariant="normal">Σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma\,
  </annotation>
 </semantics>
</math>

 is a finite set of <em>terminal</em>s, disjoint from 

<math display="inline" id="Context-free_grammar:5">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

, which make up the actual content of the sentence. The set of terminals is the alphabet of the language defined by the grammar 

<math display="inline" id="Context-free_grammar:6">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Context-free_grammar:7">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 is a finite relation from 

<math display="inline" id="Context-free_grammar:8">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Context-free_grammar:9">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mo>∪</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <union></union>
     <ci>V</ci>
     <ci>normal-Σ</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

, where the asterisk represents the <a href="Kleene_star" title="wikilink">Kleene star</a> operation. The members of 

<math display="inline" id="Context-free_grammar:10">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 are called the <em>(rewrite) rule</em>s or <em>production</em>s of the grammar. (also commonly symbolized by a 

<math display="inline" id="Context-free_grammar:11">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

)</li>
<li>

<math display="inline" id="Context-free_grammar:12">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 is the start variable (or start symbol), used to represent the whole sentence (or program). It must be an element of 

<math display="inline" id="Context-free_grammar:13">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h3 id="production-rule-notation">Production rule notation</h3>

<p>A <a href="Formal_grammar#The_syntax_of_grammars" title="wikilink">production rule</a> in 

<math display="inline" id="Context-free_grammar:14">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 is formalized mathematically as a pair 

<math display="inline" id="Context-free_grammar:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>,</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>α</ci>
     <ci>β</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta)\in R
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Context-free_grammar:16">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in V
  </annotation>
 </semantics>
</math>

 is a non-terminal and 

<math display="inline" id="Context-free_grammar:17">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">Σ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>β</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>V</ci>
      <ci>normal-Σ</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\in(V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

 is a <a href="string_(computer_science)" title="wikilink">string</a> of variables and/or terminals; rather than using <a href="ordered_pair" title="wikilink">ordered pair</a> notation, production rules are usually written using an arrow operator with 

<math display="inline" id="Context-free_grammar:18">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 as its left hand side and 

<math display="inline" id="Context-free_grammar:19">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 as its right hand side: 

<math display="inline" id="Context-free_grammar:20">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\beta
  </annotation>
 </semantics>
</math>

.</p>

<p>It is allowed for 

<math display="inline" id="Context-free_grammar:21">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 to be the <a href="empty_string" title="wikilink">empty string</a>, and in this case it is customary to denote it by ε. The form 

<math display="inline" id="Context-free_grammar:22">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\varepsilon
  </annotation>
 </semantics>
</math>

 is called an ε-production.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>It is common to list all right-hand sides for the same left-hand side on the same line, using | (the <a href="pipe_symbol" title="wikilink">pipe symbol</a>) to separate them. Rules 

<math display="inline" id="Context-free_grammar:23">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\beta_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Context-free_grammar:24">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\beta_{2}
  </annotation>
 </semantics>
</math>

 can hence be written as 

<math display="inline" id="Context-free_grammar:25">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\beta_{1}\mid\beta_{2}
  </annotation>
 </semantics>
</math>

. In this case, 

<math display="inline" id="Context-free_grammar:26">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Context-free_grammar:27">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{2}
  </annotation>
 </semantics>
</math>

 is called the first and second alternative, respectively.</p>
<h3 id="rule-application">Rule application</h3>

<p>For any strings 

<math display="inline" id="Context-free_grammar:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">Σ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>V</ci>
      <ci>normal-Σ</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v\in(V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

, we say 

<math display="inline" id="Context-free_grammar:29">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\,
  </annotation>
 </semantics>
</math>

 directly yields 

<math display="inline" id="Context-free_grammar:30">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\,
  </annotation>
 </semantics>
</math>

, written as 

<math display="inline" id="Context-free_grammar:31">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⇒</mo>
   <mpadded width="+1.7pt">
    <mi>v</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Rightarrow v\,
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Context-free_grammar:32">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <interval closure="open">
      <ci>α</ci>
      <ci>β</ci>
     </interval>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists(\alpha,\beta)\in R
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Context-free_grammar:33">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in V
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Context-free_grammar:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">Σ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>V</ci>
      <ci>normal-Σ</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{1},u_{2}\in(V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Context-free_grammar:35">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>u</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mi>α</mi>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\,=u_{1}\alpha u_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Context-free_grammar:36">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>v</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mi>β</mi>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>β</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\,=u_{1}\beta u_{2}
  </annotation>
 </semantics>
</math>

. Thus, 

<math display="inline" id="Context-free_grammar:37">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!v
  </annotation>
 </semantics>
</math>

 is a result of applying the rule 

<math display="inline" id="Context-free_grammar:38">
 <semantics>
  <mrow>
   <mo lspace="0.8pt" stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>α</ci>
    <ci>β</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(\alpha,\beta)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Context-free_grammar:39">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!u
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="repetitive-rule-application">Repetitive rule application</h3>

<p>For any strings 

<math display="inline" id="Context-free_grammar:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <mo>∪</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>V</ci>
      <ci>normal-Σ</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v\in(V\cup\Sigma)^{*},
  </annotation>
 </semantics>
</math>

 we say 

<math display="inline" id="Context-free_grammar:41">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 <strong>yields</strong> 

<math display="inline" id="Context-free_grammar:42">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, written as 

<math display="inline" id="Context-free_grammar:43">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mover>
    <mo movablelimits="false">⇒</mo>
    <mo>*</mo>
   </mover>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-⇒</ci>
     <times></times>
    </apply>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\stackrel{*}{\Rightarrow}v
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Context-free_grammar:44">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⇒</mo>
   <mo>⇒</mo>
   <mpadded width="+1.7pt">
    <mi>v</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <ci>normal-⇒</ci>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">v</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Rightarrow\Rightarrow v\,
  </annotation>
 </semantics>
</math>

 in some textbooks), if 

<math display="inline" id="Context-free_grammar:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>k</mi>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>1</mn>
      </mpadded>
      <mrow>
       <mo rspace="4.2pt">∃</mo>
       <msub>
        <mi>u</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>k</mi>
    </msub>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <mo>∪</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <exists></exists>
      <ci>k</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <apply>
        <exists></exists>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </list>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <union></union>
       <ci>V</ci>
       <ci>normal-Σ</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists k\geq 1\,\exists\,u_{1},\cdots,u_{k}\in(V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Context-free_grammar:46">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo rspace="4.2pt">=</mo>
   <msub>
    <mi>u</mi>
    <mn>1</mn>
   </msub>
   <mo>⇒</mo>
   <msub>
    <mi>u</mi>
    <mn>2</mn>
   </msub>
   <mo>⇒</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⇒</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>u</mi>
     <mi>k</mi>
    </msub>
   </mpadded>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=\,u_{1}\Rightarrow u_{2}\Rightarrow\cdots\Rightarrow u_{k}\,=v
  </annotation>
 </semantics>
</math>

. In this case, if 

<math display="inline" id="Context-free_grammar:47">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 2
  </annotation>
 </semantics>
</math>

 (i.e., 

<math display="inline" id="Context-free_grammar:48">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>≠</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\neq v
  </annotation>
 </semantics>
</math>

), the relation 

<math display="inline" id="Context-free_grammar:49">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mover>
    <mo movablelimits="false">⇒</mo>
    <mo>+</mo>
   </mover>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-⇒</ci>
     <plus></plus>
    </apply>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\stackrel{+}{\Rightarrow}v
  </annotation>
 </semantics>
</math>

 holds. In other words, 

<math display="inline" id="Context-free_grammar:50">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mover>
    <mo movablelimits="false">⇒</mo>
    <mo>*</mo>
   </mover>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-⇒</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\stackrel{*}{\Rightarrow})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Context-free_grammar:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mover>
    <mo movablelimits="false">⇒</mo>
    <mo>+</mo>
   </mover>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-⇒</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\stackrel{+}{\Rightarrow})
  </annotation>
 </semantics>
</math>

 are the <a href="reflexive_transitive_closure" title="wikilink">reflexive transitive closure</a> (allowing a word to yield itself) and the <a href="transitive_closure" title="wikilink">transitive closure</a> (requiring at least one step) of 

<math display="inline" id="Context-free_grammar:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>⇒</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇒</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Rightarrow)
  </annotation>
 </semantics>
</math>

, respectively.</p>
<h3 id="context-free-language">Context-free language</h3>

<p>The language of a grammar 

<math display="inline" id="Context-free_grammar:53">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mi>V</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>S</mi>
    </mpadded>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>V</ci>
     <ci>normal-Σ</ci>
     <ci>R</ci>
     <ci>S</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V\,,\Sigma\,,R\,,S\,)
  </annotation>
 </semantics>
</math>

 is the set</p>

<p>

<math display="block" id="Context-free_grammar:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>w</mi>
     <mo>∈</mo>
     <msup>
      <mi mathvariant="normal">Σ</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>S</mi>
     <mover>
      <mo movablelimits="false">⇒</mo>
      <mo>*</mo>
     </mover>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-⇒</ci>
       <times></times>
      </apply>
      <ci>S</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(G)=\{w\in\Sigma^{*}:S\stackrel{*}{\Rightarrow}w\}
  </annotation>
 </semantics>
</math>

</p>

<p>A language 

<math display="inline" id="Context-free_grammar:55">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 is said to be a context-free language (CFL), if there exists a CFG 

<math display="inline" id="Context-free_grammar:56">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Context-free_grammar:57">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>L</mi>
   </mpadded>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,=\,L(G)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="proper-cfgs">Proper CFGs</h3>

<p>A context-free grammar is said to be <em>proper</em>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> if it has</p>
<ul>
<li>no <a href="unreachable_symbol" title="wikilink">unreachable symbols</a>

<math display="block" id="Context-free_grammar:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>N</mi>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>∃</mo>
      <mi>α</mi>
     </mrow>
     <mo>,</mo>
     <mi>β</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <mo>∪</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mover>
     <mo movablelimits="false">⇒</mo>
     <mo>*</mo>
    </mover>
    <mrow>
     <mi>α</mi>
     <mi>N</mi>
     <mi>β</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>N</ci>
      </apply>
      <ci>V</ci>
     </apply>
     <apply>
      <in></in>
      <list>
       <apply>
        <exists></exists>
        <ci>α</ci>
       </apply>
       <ci>β</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <union></union>
        <ci>V</ci>
        <ci>normal-Σ</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-⇒</ci>
       <times></times>
      </apply>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>N</ci>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall N\in V:\exists\alpha,\beta\in(V\cup\Sigma)^{*}:S\stackrel{*}{%
\Rightarrow}\alpha{N}\beta
  </annotation>
 </semantics>
</math>

</li>
<li>no <a href="unproductive_symbol" title="wikilink">unproductive symbols</a>

<math display="block" id="Context-free_grammar:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>N</mi>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>w</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>N</mi>
    <mover>
     <mo movablelimits="false">⇒</mo>
     <mo>*</mo>
    </mover>
    <mi>w</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>N</ci>
      </apply>
      <ci>V</ci>
     </apply>
     <apply>
      <in></in>
      <apply>
       <exists></exists>
       <ci>w</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-⇒</ci>
       <times></times>
      </apply>
      <ci>N</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall N\in V:\exists w\in\Sigma^{*}:N\stackrel{*}{\Rightarrow}w
  </annotation>
 </semantics>
</math>

</li>
<li>no ε-productions

<math display="block" id="Context-free_grammar:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∃</mo>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>ε</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <exists></exists>
       <ci>N</ci>
      </apply>
     </apply>
     <ci>V</ci>
    </apply>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>N</ci>
      <ci>ε</ci>
     </interval>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\exists N\in V:(N,\varepsilon)\in R
  </annotation>
 </semantics>
</math>

</li>
<li>no cycles

<math display="block" id="Context-free_grammar:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∃</mo>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>N</mi>
    <mover>
     <mo movablelimits="false">⇒</mo>
     <mo>+</mo>
    </mover>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <exists></exists>
       <ci>N</ci>
      </apply>
     </apply>
     <ci>V</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⇒</ci>
      <plus></plus>
     </apply>
     <ci>N</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\exists N\in V:N\stackrel{+}{\Rightarrow}N
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Every context-free grammar can be effectively transformed into a <a href="weak_equivalence_(formal_languages)" title="wikilink">weakly equivalent</a> one without unreachable symbols,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> a weakly equivalent one without unproductive symbols,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and a weakly equivalent one without cycles.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Every context-free grammar not producing ε can be effectively transformed into a weakly equivalent one without ε-productions;<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> altogether, every such grammar can be effectively transformed into a weakly equivalent proper CFG.</p>
<h3 id="example">Example</h3>

<p>The grammar 

<math display="inline" id="Context-free_grammar:62">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>S</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <set>
      <ci>S</ci>
     </set>
     <set>
      <ci>a</ci>
      <ci>b</ci>
     </set>
     <ci>P</ci>
     <ci>S</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(\{S\},\{a,b\},P,S)
  </annotation>
 </semantics>
</math>

, with productions</p>
<dl>
<dd>S → aSa,
</dd>
<dd>S → bSb,
</dd>
<dd>S → ε,
</dd>
</dl>

<p>is context-free. It is not proper since it includes an ε-production. A typical derivation in this grammar is</p>
<dl>
<dd>S → aSa → aaSaa → aabSbaa → aabbaa.
</dd>
</dl>

<p>This makes it clear that 

<math display="inline" id="Context-free_grammar:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>w</mi>
     <msup>
      <mi>w</mi>
      <mi>R</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>w</mi>
     <mo>∈</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <ci>a</ci>
        <ci>b</ci>
       </set>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(G)=\{ww^{R}:w\in\{a,b\}^{*}\}
  </annotation>
 </semantics>
</math>

. The language is context-free, however it can be proved that it is not <a href="Regular_language" title="wikilink">regular</a>.</p>
<h2 id="examples">Examples</h2>
<h3 id="well-formed-parentheses">Well-formed parentheses</h3>

<p>The canonical example of a context free grammar is parenthesis matching, which is representative of the general case. There are two terminal symbols "(" and ")" and one nonterminal symbol S. The production rules are</p>
<dl>
<dd>S → SS
</dd>
<dd>S → (S)
</dd>
<dd>S → ()
</dd>
</dl>

<p>The first rule allows Ss to multiply; the second rule allows Ss to become enclosed by matching parentheses; and the third rule terminates the recursion.</p>
<h3 id="well-formed-nested-parentheses-and-square-brackets">Well-formed nested parentheses and square brackets</h3>

<p>A second canonical example is two different kinds of matching nested parentheses, described by the productions:</p>
<dl>
<dd>S → SS
</dd>
<dd>S → ()
</dd>
<dd>S → (S)
</dd>
<dd>S → []
</dd>
<dd>S → [S]
</dd>
</dl>

<p>with terminal symbols [ ] ( ) and nonterminal S.</p>

<p>The following sequence can be derived in that grammar:</p>
<dl>
<dd>([ [ [ ()() [ ][ ] ] ]([ ]) ])
</dd>
</dl>

<p>However, there is no context-free grammar for generating all sequences of two different types of parentheses, each separately balanced disregarding the other, but where the two types need not nest inside one another, for example:</p>
<dl>
<dd>[ ( ] )
</dd>
</dl>

<p>or</p>
<dl>
<dd>[ [ [ [(((( ] ] ] ]))))(([ ))(([ ))([ )( ])( ])( ])
</dd>
</dl>
<h3 id="a-regular-grammar">A regular grammar</h3>

<p>Every regular grammar is context-free, but not all context-free grammars are regular. The following context-free grammar, however, is also regular.</p>
<dl>
<dd>S → a
</dd>
<dd>S → aS
</dd>
<dd>S → bS
</dd>
</dl>

<p>The terminals here are <em>a</em> and <em>b</em>, while the only non-terminal is S. The language described is all nonempty strings of 

<math display="inline" id="Context-free_grammar:64">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

s and 

<math display="inline" id="Context-free_grammar:65">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

s that end in 

<math display="inline" id="Context-free_grammar:66">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</p>

<p>This grammar is <a href="regular_grammar" title="wikilink">regular</a>: no rule has more than one nonterminal in its right-hand side, and each of these nonterminals is at the same end of the right-hand side.</p>

<p>Every regular grammar corresponds directly to a <a href="nondeterministic_finite_automaton" title="wikilink">nondeterministic finite automaton</a>, so we know that this is a <a href="regular_language" title="wikilink">regular language</a>.</p>

<p>Using pipe symbols, the grammar above can be described more tersely as follows:</p>
<dl>
<dd>S → a | aS | bS
</dd>
</dl>
<h3 id="matching-pairs">Matching pairs</h3>

<p>In a context-free grammar, we can pair up characters the way we do with <a href="bracket" title="wikilink">brackets</a>. The simplest example:</p>
<dl>
<dd>S → aSb
</dd>
<dd>S → ab
</dd>
</dl>

<p>This grammar generates the language 

<math display="inline" id="Context-free_grammar:67">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a^{n}b^{n}:n\geq 1\}
  </annotation>
 </semantics>
</math>

, which is not <a href="regular_language" title="wikilink">regular</a> (according to the <a href="pumping_lemma_for_regular_languages" title="wikilink">pumping lemma for regular languages</a>).</p>

<p>The special character ε stands for the empty string. By changing the above grammar to</p>
<dl>
<dd>S → aSb | ε
</dd>
</dl>

<p>we obtain a grammar generating the language 

<math display="inline" id="Context-free_grammar:68">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a^{n}b^{n}:n\geq 0\}
  </annotation>
 </semantics>
</math>

 instead. This differs only in that it contains the empty string while the original grammar did not.</p>
<h3 id="algebraic-expressions">Algebraic expressions</h3>

<p>Here is a context-free grammar for syntactically correct <a href="Infix_notation" title="wikilink">infix</a> algebraic expressions in the variables x, y and z:</p>
<ol>
<li>S → x</li>
<li>S → y</li>
<li>S → z</li>
<li>S → S + S</li>
<li>S → S - S</li>
<li>S → S * S</li>
<li>S → S / S</li>
<li>S → ( S )</li>
</ol>

<p>This grammar can, for example, generate the string</p>
<dl>
<dd>( x + y ) * x - z * y / ( x + x )
</dd>
</dl>

<p>as follows:</p>
<dl>
<dd>S (the start symbol)
</dd>
<dd>→ S - S (by rule 5)
</dd>
<dd>→ S * S - S (by rule 6, applied to the leftmost S)
</dd>
<dd>→ S * S - S / S (by rule 7, applied to the rightmost S)
</dd>
<dd>→ ( S ) * S - S / S (by rule 8, applied to the leftmost S)
</dd>
<dd>→ ( S ) * S - S / ( S ) (by rule 8, applied to the rightmost S)
</dd>
<dd>→ ( S + S ) * S - S / ( S ) (etc.)
</dd>
<dd>→ ( S + S ) * S - S * S / ( S )
</dd>
<dd>→ ( S + S ) * S - S * S / ( S + S )
</dd>
<dd>→ ( x + S ) * S - S * S / ( S + S )
</dd>
<dd>→ ( x + y ) * S - S * S / ( S + S )
</dd>
<dd>→ ( x + y ) * x - S * y / ( S + S )
</dd>
<dd>→ ( x + y ) * x - S * y / ( x + S )
</dd>
<dd>→ ( x + y ) * x - z * y / ( x + S )
</dd>
<dd>→ ( x + y ) * x - z * y / ( x + x )
</dd>
</dl>

<p>Note that many choices were made underway as to which rewrite was going to be performed next. These choices look quite arbitrary. As a matter of fact, they are, in the sense that the string finally generated is always the same. For example, the second and third rewrites</p>
<dl>
<dd>→ S * S - S (by rule 6, applied to the leftmost S)
</dd>
<dd>→ S * S - S / S (by rule 7, applied to the rightmost S)
</dd>
</dl>

<p>could be done in the opposite order:</p>
<dl>
<dd>→ S - S / S (by rule 7, applied to the rightmost S)
</dd>
<dd>→ S * S - S / S (by rule 6, applied to the leftmost S)
</dd>
</dl>

<p>Also, many choices were made on which rule to apply to each selected <code>S</code>. Changing the choices made and not only the order they were made in usually affects which terminal string comes out at the end.</p>

<p>Let's look at this in more detail. Consider the <a href="parse_tree" title="wikilink">parse tree</a> of this derivation:</p>

<p><code>           S</code><br/>
<code>           |</code><br/>
<code>          /|\</code><br/>
<code>         S - S</code><br/>
<code>        /     \</code><br/>
<code>       /|\    /|\</code><br/>
<code>      S * S  S / S</code><br/>
<code>     /    |  |    \</code><br/>
<code>    /|\   x /|\   /|\</code><br/>
<code>   ( S )   S * S ( S )</code><br/>
<code>    /      |   |    \   </code><br/>
<code>   /|\     z   y   /|\</code><br/>
<code>  S + S           S + S</code><br/>
<code>  |   |           |   |</code><br/>
<code>  x   y           x   x</code></p>

<p>Starting at the top, step by step, an S in the tree is expanded, until no more unexpanded <code>S</code>es (non-terminals) remain. Picking a different order of expansion will produce a different derivation, but the same parse tree. The parse tree will only change if we pick a different rule to apply at some position in the tree.</p>

<p>But can a different parse tree still produce the same terminal string, which is <code>( x + y ) * x - z * y / ( x + x )</code> in this case? Yes, for this particular grammar, this is possible. Grammars with this property are called <a href="ambiguous_grammar" title="wikilink">ambiguous</a>.</p>

<p>For example, <code>x + y * z</code> can be produced with these two different parse trees:</p>

<p><code>         S               S</code><br/>
<code>         |               |</code><br/>
<code>        /|\             /|\</code><br/>
<code>       S * S           S + S    </code><br/>
<code>      /     \         /     \</code><br/>
<code>     /|\     z       x     /|\</code><br/>
<code>    S + S                 S * S    </code><br/>
<code>    |   |                 |   |</code><br/>
<code>    x   y                 y   z</code></p>

<p>However, the <em>language</em> described by this grammar is not inherently ambiguous: an alternative, unambiguous grammar can be given for the language, for example:</p>
<dl>
<dd>T → x
</dd>
<dd>T → y
</dd>
<dd>T → z
</dd>
<dd>S → S + T
</dd>
<dd>S → S - T
</dd>
<dd>S → S * T
</dd>
<dd>S → S / T
</dd>
<dd>T → ( S )
</dd>
<dd>S → T
</dd>
</dl>

<p>(once again picking <code>S</code> as the start symbol). This alternative grammar will produce <code>x + y * z</code> with a parse tree similar to the left one above, i.e. implicitly assuming the association <code>(x + y) * z</code>, which is not according to standard operator precedence. More elaborate, unambiguous and context-free grammars can be constructed that produce parse trees that obey all desired <a href="Operator-precedence_parser" title="wikilink">operator precedence</a> and associativity rules.</p>
<h3 id="further-examples">Further examples</h3>
<h4 id="example-1">Example 1</h4>

<p>A context-free grammar for the language consisting of all strings over {a,b} containing an unequal number of a's and b's:</p>
<dl>
<dd>S → U | V
</dd>
<dd>U → TaU | TaT | UaT
</dd>
<dd>V → TbV | TbT | VbT
</dd>
<dd>T → aTbT | bTaT | ε
</dd>
</dl>

<p>Here, the nonterminal T can generate all strings with the same number of a's as b's, the nonterminal U generates all strings with more a's than b's and the nonterminal V generates all strings with fewer a's than b's. Omitting the third alternative in the rule for U and V doesn't restrict the grammar's language.</p>
<h4 id="example-2">Example 2</h4>

<p>Another example of a non-regular language is 

<math display="inline" id="Context-free_grammar:69">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>a</mi>
     <mi>m</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <geq></geq>
      <ci>m</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b^{n}a^{m}b^{2n}:n\geq 0,m\geq 0\}
  </annotation>
 </semantics>
</math>

. It is context-free as it can be generated by the following context-free grammar:</p>
<dl>
<dd>S → bSbb | A
</dd>
<dd>A → aA | ε
</dd>
</dl>
<h4 id="other-examples">Other examples</h4>

<p>The <a href="First-order_logic#Formation_rules" title="wikilink">formation rules</a> for the terms and formulas of formal logic fit the definition of context-free grammar, except that the set of symbols may be infinite and there may be more than one start symbol.</p>
<h3 id="derivations-and-syntax-trees">Derivations and syntax trees</h3>

<p>A <em>derivation</em> of a string for a grammar is a sequence of grammar rule applications that transforms the start symbol into the string. A derivation proves that the string belongs to the grammar's language.</p>

<p>A derivation is fully determined by giving, for each step:</p>
<ul>
<li>the rule applied in that step</li>
<li>the occurrence of its left hand side to which it is applied</li>
</ul>

<p>For clarity, the intermediate string is usually given as well.</p>

<p>For instance, with the grammar:</p>

<p><code> (1)  S → S + S</code><br/>
<code> (2)  S → 1</code><br/>
<code> (3)  S → a</code></p>

<p>the string</p>

<p><code>1 + 1 + a</code></p>

<p>can be derived with the derivation:</p>

<p><code>S</code><br/>
<code>    → (rule 1 on first S)</code><br/>
<code> S+S</code><br/>
<code>    → (rule 1 on second S)</code><br/>
<code> S+S+S</code><br/>
<code>    → (rule 2 on second S)</code><br/>
<code> S+1+S</code><br/>
<code>    → (rule 3 on third S)</code><br/>
<code> S+1+a</code><br/>
<code>    → (rule 2 on first S)</code><br/>
<code> 1+1+a</code></p>

<p>Often, a strategy is followed that deterministically determines the next nonterminal to rewrite:</p>
<ul>
<li>in a <em>leftmost derivation</em>, it is always the leftmost nonterminal;</li>
<li>in a <em>rightmost derivation</em>, it is always the rightmost nonterminal.</li>
</ul>

<p>Given such a strategy, a derivation is completely determined by the sequence of rules applied. For instance, the leftmost derivation</p>

<p><code>S</code><br/>
<code>    → (rule 1 on first S)</code><br/>
<code> S+S</code><br/>
<code>    → (rule 2 on first S)</code><br/>
<code> 1+S</code><br/>
<code>    → (rule 1 on first S)</code><br/>
<code> 1+S+S</code><br/>
<code>    → (rule 2 on first S)</code><br/>
<code> 1+1+S</code><br/>
<code>    → (rule 3 on first S)</code><br/>
<code> 1+1+a</code></p>

<p>can be summarized as</p>

<p><code>rule 1, rule 2, rule 1, rule 2, rule 3</code></p>

<p>The distinction between leftmost derivation and rightmost derivation is important because in most <a href="parsing" title="wikilink">parsers</a> the transformation of the input is defined by giving a piece of code for every grammar rule that is executed whenever the rule is applied. Therefore it is important to know whether the parser determines a leftmost or a rightmost derivation because this determines the order in which the pieces of code will be executed. See for an example <a href="LL_parser" title="wikilink">LL parsers</a> and <a href="LR_parser" title="wikilink">LR parsers</a>.</p>

<p>A derivation also imposes in some sense a hierarchical structure on the string that is derived. For example, if the string "1 + 1 + a" is derived according to the leftmost derivation:</p>
<dl>
<dd>S → S + S (1)
</dd>
<dd>   → 1 + S (2)
</dd>
<dd>   → 1 + S + S (1)
</dd>
<dd>   → 1 + 1 + S (2)
</dd>
<dd>   → 1 + 1 + a (3)
</dd>
</dl>

<p>the structure of the string would be:</p>
<dl>
<dd>{ { 1 }<sub>S</sub> + { { 1 }<sub>S</sub> + { a }<sub>S</sub> }<sub>S</sub> }<sub>S</sub>
</dd>
</dl>

<p>where { ... }<sub>S</sub> indicates a substring recognized as belonging to S. This hierarchy can also be seen as a tree:</p>

<p><code>           S</code><br/>
<code>          /|\</code><br/>
<code>         / | \</code><br/>
<code>        /  |  \</code><br/>
<code>       S  '+'  S</code><br/>
<code>       |      /|\</code><br/>
<code>       |     / | \</code><br/>
<code>      '1'   S '+' S</code><br/>
<code>            |     |</code><br/>
<code>           '1'   'a'</code></p>

<p>This tree is called a <em><a href="parse_tree" title="wikilink">parse tree</a></em> or "concrete syntax tree" of the string, by contrast with the <a href="abstract_syntax_tree" title="wikilink">abstract syntax tree</a>. In this case the presented leftmost and the rightmost derivations define the same parse tree; however, there is another (rightmost) derivation of the same string</p>
<dl>
<dd>S → S + S (1)
</dd>
<dd>   → S + a (3)
</dd>
<dd>   → S + S + a (1)
</dd>
<dd>   → S + 1 + a (2)
</dd>
<dd>   → 1 + 1 + a (2)
</dd>
</dl>

<p>and this defines the following parse tree:</p>

<p><code>           S </code><br/>
<code>          /|\</code><br/>
<code>         / | \</code><br/>
<code>        /  |  \</code><br/>
<code>       S  '+'  S</code><br/>
<code>      /|\      |</code><br/>
<code>     / | \     |</code><br/>
<code>    S '+' S   'a'</code><br/>
<code>    |     |</code><br/>
<code>   '1'   '1'</code></p>

<p>If, for certain strings in the language of the grammar, there is more than one parsing tree, then the grammar is said to be an <em><a href="ambiguous_grammar" title="wikilink">ambiguous grammar</a></em>. Such grammars are usually hard to parse because the parser cannot always decide which grammar rule it has to apply. Usually, ambiguity is a feature of the grammar, not the language, and an unambiguous grammar can be found that generates the same context-free language. However, there are certain languages that can only be generated by ambiguous grammars; such languages are called <em><a href="inherently_ambiguous_language" title="wikilink">inherently ambiguous languages</a></em>.</p>
<h2 id="normal-forms">Normal forms</h2>

<p>Every context-free grammar that does not generate the empty string can be transformed into one in which there is no ε-production (that is, a rule that has the empty string as a product). If a grammar does generate the empty string, it will be necessary to include the rule 

<math display="inline" id="Context-free_grammar:70">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow\epsilon
  </annotation>
 </semantics>
</math>

, but there need be no other ε-rule. Every context-free grammar with no ε-production has an equivalent grammar in <a href="Chomsky_normal_form" title="wikilink">Chomsky normal form</a> or <a href="Greibach_normal_form" title="wikilink">Greibach normal form</a>. "Equivalent" here means that the two grammars generate the same language.</p>

<p>The especially simple form of production rules in Chomsky Normal Form grammars has both theoretical and practical implications. For instance, given a context-free grammar, one can use the Chomsky Normal Form to construct a <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> algorithm that decides whether a given string is in the language represented by that grammar or not (the <a href="CYK_algorithm" title="wikilink">CYK algorithm</a>).</p>
<h2 id="closure-properties">Closure properties</h2>

<p>Context-free languages are <a href="Closure_(mathematics)" title="wikilink">closed</a> under <a href="set_union" title="wikilink">union</a>, <a href="string_concatenation#Concatenation_of_sets_of_strings" title="wikilink">concatenation</a>, <a href="Kleene_star" title="wikilink">Kleene star</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a href="string_substitution" title="wikilink">substitution</a> (in particular <a href="string_homomorphism" title="wikilink">homomorphism</a>),<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a href="string_homomorphism" title="wikilink">inverse homomorphism</a>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and <a href="set_intersection" title="wikilink">intersection</a> with a <a href="regular_language" title="wikilink">regular language</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> They are not closed under general intersection (hence neither under <a href="set_complement" title="wikilink">complementation</a>) and set difference.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="decidable-problems">Decidable problems</h2>

<p>There are algorithms to decide whether a context-free language is empty, and whether it is finite.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="undecidable-problems">Undecidable problems</h2>

<p>Some questions that are undecidable for wider classes of grammars become decidable for context-free grammars; e.g. the emptiness problem (whether the grammar generates any terminal strings at all), is undecidable for <a href="context-sensitive_grammar" title="wikilink">context-sensitive grammars</a>, but decidable for context-free grammars.</p>

<p>However, many problems are <a href="Undecidable_problem" title="wikilink">undecidable</a> even for context-free grammars. Examples are:</p>
<h3 id="universality">Universality</h3>

<p>Given a CFG, does it generate the language of all strings over the alphabet of terminal symbols used in its rules?<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>A reduction can be demonstrated to this problem from the well-known undecidable problem of determining whether a <a href="Turing_machine" title="wikilink">Turing machine</a> accepts a particular input (the <a href="halting_problem" title="wikilink">halting problem</a>). The reduction uses the concept of a <em><a href="computation_history" title="wikilink">computation history</a></em>, a string describing an entire computation of a <a href="Turing_machine" title="wikilink">Turing machine</a>. A CFG can be constructed that generates all strings that are not accepting computation histories for a particular Turing machine on a particular input, and thus it will accept all strings only if the machine doesn't accept that input.</p>
<h3 id="language-equality">Language equality</h3>

<p>Given two CFGs, do they generate the same language?<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>The undecidability of this problem is a direct consequence of the previous: it is impossible to even decide whether a CFG is equivalent to the trivial CFG defining the language of all strings.</p>
<h3 id="language-inclusion">Language inclusion</h3>

<p>Given two CFGs, can the first one generate all strings that the second one can generate?<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>If this problem was decidable, then language equality could be decided too: two CFGs G1 and G2 generate the same language if L(G1) is a subset of L(G2) and L(G2) is a subset of L(G1).</p>
<h3 id="being-in-a-lower-or-higher-level-of-the-chomsky-hierarchy">Being in a lower or higher level of the Chomsky hierarchy</h3>

<p>Using <a href="Greibach's_theorem" title="wikilink">Greibach's theorem</a>, it can be shown that the two following problems are undecidable:</p>
<ul>
<li>Given a <a href="context-sensitive_grammar" title="wikilink">context-sensitive grammar</a>, does it describe a context-free language?</li>
<li>Given a context-free grammar, does it describe a <a href="regular_language" title="wikilink">regular language</a>?<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></li>
</ul>
<h3 id="grammar-ambiguity">Grammar ambiguity</h3>

<p>Given a CFG, is it <a href="Ambiguous_grammar" title="wikilink">ambiguous</a>?</p>

<p>The undecidability of this problem follows from the fact that if an algorithm to determine ambiguity existed, the <a href="Post_correspondence_problem" title="wikilink">Post correspondence problem</a> could be decided, which is known to be undecidable.</p>
<h3 id="language-disjointness">Language disjointness</h3>

<p>Given two CFGs, is there any string derivable from both grammars?</p>

<p>If this problem was decidable, the undecidable <a href="Post_correspondence_problem" title="wikilink">Post correspondence problem</a> could be decided, too: given strings 

<math display="inline" id="Context-free_grammar:71">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mi>N</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1},\ldots,\alpha_{N},\beta_{1},\ldots,\beta_{N}
  </annotation>
 </semantics>
</math>

 over some alphabet 

<math display="inline" id="Context-free_grammar:72">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>k</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a_{1},\ldots,a_{k}\}
  </annotation>
 </semantics>
</math>

, let the grammar G1 consist of the rule</p>
<dl>
<dd>S → 

<math display="inline" id="Context-free_grammar:73">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

 S 

<math display="inline" id="Context-free_grammar:74">
 <semantics>
  <msubsup>
   <mi>β</mi>
   <mn>1</mn>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>v</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}^{rev}
  </annotation>
 </semantics>
</math>

 | ... | 

<math display="inline" id="Context-free_grammar:75">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{N}
  </annotation>
 </semantics>
</math>

 S 

<math display="inline" id="Context-free_grammar:76">
 <semantics>
  <msubsup>
   <mi>β</mi>
   <mi>N</mi>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>v</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{N}^{rev}
  </annotation>
 </semantics>
</math>

 | 

<math display="inline" id="Context-free_grammar:77">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

;
</dd>
</dl>

<p>where 

<math display="inline" id="Context-free_grammar:78">
 <semantics>
  <msubsup>
   <mi>β</mi>
   <mi>i</mi>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>v</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}^{rev}
  </annotation>
 </semantics>
</math>

 denotes the <a href="String_(computer_science)#Reversal" title="wikilink">reversed</a> string 

<math display="inline" id="Context-free_grammar:79">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Context-free_grammar:80">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 doesn't occur among the 

<math display="inline" id="Context-free_grammar:81">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

; and let grammar G2 consist of the rule</p>
<dl>
<dd>T → 

<math display="inline" id="Context-free_grammar:82">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}
  </annotation>
 </semantics>
</math>

 T 

<math display="inline" id="Context-free_grammar:83">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}
  </annotation>
 </semantics>
</math>

 | ... | 

<math display="inline" id="Context-free_grammar:84">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k}
  </annotation>
 </semantics>
</math>

 T 

<math display="inline" id="Context-free_grammar:85">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k}
  </annotation>
 </semantics>
</math>

 | 

<math display="inline" id="Context-free_grammar:86">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

;
</dd>
</dl>

<p>Then the Post problem given by 

<math display="inline" id="Context-free_grammar:87">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mi>N</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1},\ldots,\alpha_{N},\beta_{1},\ldots,\beta_{N}
  </annotation>
 </semantics>
</math>

 has a solution if and only if L(G1) and L(G2) share a derivable string.</p>
<h2 id="extensions">Extensions</h2>

<p>An obvious way to extend the context-free grammar formalism is to allow nonterminals to have arguments, the values of which are passed along within the rules. This allows natural language features such as <a href="Agreement_(linguistics)" title="wikilink">agreement</a> and <a class="uri" href="reference" title="wikilink">reference</a>, and programming language analogs such as the correct use and definition of identifiers, to be expressed in a natural way. E.g. we can now easily express that in English sentences, the subject and verb must agree in number. In computer science, examples of this approach include <a href="affix_grammar" title="wikilink">affix grammars</a>, <a href="attribute_grammar" title="wikilink">attribute grammars</a>, <a href="indexed_grammar" title="wikilink">indexed grammars</a>, and Van Wijngaarden <a href="two-level_grammar" title="wikilink">two-level grammars</a>. Similar extensions exist in linguistics.</p>

<p>An <strong>extended context-free grammar</strong> (or <strong>regular right part grammar</strong>) is one in which the right-hand side of the production rules is allowed to be a <a href="regular_expression" title="wikilink">regular expression</a> over the grammar's terminals and nonterminals. Extended context-free grammars describe exactly the context-free languages.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>Another extension is to allow additional terminal symbols to appear at the left hand side of rules, constraining their application. This produces the formalism of <a href="context-sensitive_grammar" title="wikilink">context-sensitive grammars</a>.</p>
<h2 id="subclasses">Subclasses</h2>

<p>There are a number of important subclasses of the context-free grammars:</p>
<ul>
<li><a href="LR_parser" title="wikilink">LR(<em>k</em>)</a> grammars (also known as <a href="deterministic_context-free_grammar" title="wikilink">deterministic context-free grammars</a>) allow <a class="uri" href="parsing" title="wikilink">parsing</a> (string recognition) with <a href="deterministic_pushdown_automaton" title="wikilink">deterministic pushdown automata</a> (PDA), but they can only describe <a href="deterministic_context-free_language" title="wikilink">deterministic context-free languages</a>.</li>
</ul>
<ul>
<li><a href="SLR_grammar" title="wikilink">Simple LR</a>, <a href="LALR_parser" title="wikilink">Look-Ahead LR</a> grammars are subclasses that allow further simplification of parsing. SLR and LALR are recognized using the same PDA as LR, but with simpler tables, in most cases.</li>
</ul>
<ul>
<li><a href="LL_parser" title="wikilink">LL(<em>k</em>) and LL(<em>*</em>)</a> grammars allow parsing by direct construction of a leftmost derivation as described above, and describe even fewer languages.</li>
</ul>
<ul>
<li><a href="Simple_grammar" title="wikilink">Simple grammars</a> are a subclass of the LL(1) grammars mostly interesting for its theoretical property that language equality of simple grammars is decidable, while language inclusion is not.</li>
</ul>
<ul>
<li><a href="Bracketed_grammar" title="wikilink">Bracketed grammars</a> have the property that the terminal symbols are divided into left and right bracket pairs that always match up in rules.</li>
</ul>
<ul>
<li><a href="Linear_grammar" title="wikilink">Linear grammars</a> have no rules with more than one nonterminal in the right hand side.</li>
</ul>
<ul>
<li><a href="Regular_grammar" title="wikilink">Regular grammars</a> are a subclass of the linear grammars and describe the <a href="regular_language" title="wikilink">regular</a> languages, i.e. they correspond to <a href="finite_automaton" title="wikilink">finite automata</a> and <a href="regular_expression" title="wikilink">regular expressions</a>.</li>
</ul>

<p>LR parsing extends LL parsing to support a larger range of grammars; in turn, <a href="GLR_parser" title="wikilink">generalized LR parsing</a> extends LR parsing to support arbitrary context-free grammars. On LL grammars and LR grammars, it essentially performs LL parsing and LR parsing, respectively, while on <a href="nondeterministic_grammar" title="wikilink">nondeterministic grammars</a>, it is as efficient as can be expected. Although GLR parsing was developed in the 1980s, many new language definitions and <a href="parser_generator" title="wikilink">parser generators</a> continue to be based on LL, LALR or LR parsing up to the present day.</p>
<h2 id="linguistic-applications">Linguistic applications</h2>

<p><a href="Noam_Chomsky" title="wikilink">Chomsky</a> initially hoped to overcome the limitations of context-free grammars by adding <a href="transformational_grammar" title="wikilink">transformation rules</a>.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Such rules are another standard device in traditional linguistics; e.g. <a href="grammatical_voice" title="wikilink">passivization</a> in English. Much of <a href="generative_grammar" title="wikilink">generative grammar</a> has been devoted to finding ways of refining the descriptive mechanisms of phrase-structure grammar and transformation rules such that exactly the kinds of things can be expressed that natural language actually allows. Allowing arbitrary transformations doesn't meet that goal: they are much too powerful, being <a href="Turing_complete" title="wikilink">Turing complete</a> unless significant restrictions are added (e.g. no transformations that introduce and then rewrite symbols in a context-free fashion).</p>

<p>Chomsky's general position regarding the non-context-freeness of natural language has held up since then,<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> although his specific examples regarding the inadequacy of context-free grammars in terms of their weak generative capacity were later disproved.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> <a href="Gerald_Gazdar" title="wikilink">Gerald Gazdar</a> and <a href="Geoffrey_Pullum" title="wikilink">Geoffrey Pullum</a> have argued that despite a few non-context-free constructions in natural language (such as <a href="cross-serial_dependencies" title="wikilink">cross-serial dependencies</a> in <a href="Swiss_German" title="wikilink">Swiss German</a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> and <a class="uri" href="reduplication" title="wikilink">reduplication</a> in <a href="Bambara_language" title="wikilink">Bambara</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a>), the vast majority of forms in natural language are indeed context-free.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Parsing_expression_grammar" title="wikilink">Parsing expression grammar</a></li>
<li><a href="Stochastic_context-free_grammar" title="wikilink">Stochastic context-free grammar</a></li>
<li><a href="Context-free_grammar_generation_algorithms" title="wikilink">Algorithms for context-free grammar generation</a></li>
<li><a href="Pumping_lemma_for_context-free_languages" title="wikilink">Pumping lemma for context-free languages</a></li>
</ul>
<h3 id="parsing-algorithms">Parsing algorithms</h3>
<ul>
<li><a href="CYK_algorithm" title="wikilink">CYK algorithm</a></li>
<li><a href="GLR_parser" title="wikilink">GLR parser</a></li>
<li><a href="LL_parser" title="wikilink">LL parser</a></li>
<li><a href="Earley_algorithm" title="wikilink">Earley algorithm</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>. Chapter 4: Context-Free Grammars, pp. 77–106; Chapter 6: Properties of Context-Free Languages, pp. 125–137.</p></li>
<li>

<p>. Chapter 2: Context-Free Grammars, pp. 91–122; Section 4.1.2: Decidable problems concerning context-free languages, pp. 156–159; Section 5.1.1: Reductions via computation histories: pp. 176–183.</p></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:1956_in_computer_science" title="wikilink">Category:1956 in computer science</a> <a href="Category:Compiler_construction" title="wikilink">Category:Compiler construction</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Programming_language_topics" title="wikilink">Category:Programming language topics</a> <a href="Category:Wikipedia_articles_with_ASCII_art" title="wikilink">Category:Wikipedia articles with ASCII art</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><em>Introduction to Automata Theory, Languages, and Computation</em>, John E. Hopcroft, Rajeen Motwani, Jeffrey D. Ullman, Addison Wesley, 2001, p.191<a href="#fnref1">↩</a></li>
<li id="fn2">, p. 106.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">The notation here is that of , p. 94.  (p. 79) define context-free grammars as 4-tuples in the same way, but with different variable names.<a href="#fnref5">↩</a></li>
<li id="fn6">, pp. 90–92.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">Hopcroft &amp; Ullman (1979), p.88, Lemma 4.1<a href="#fnref8">↩</a></li>
<li id="fn9">Hopcroft &amp; Ullman (1979), p.89, Lemma 4.2<a href="#fnref9">↩</a></li>
<li id="fn10">This is a consequence of the unit-production elimination theorem in Hopcroft &amp; Ullman (1979), p.91, Theorem 4.4<a href="#fnref10">↩</a></li>
<li id="fn11">Hopcroft &amp; Ullman (1979), p.91, Theorem 4.4<a href="#fnref11">↩</a></li>
<li id="fn12">Hopcroft &amp; Ullman (1979), p.131, Theorem 6.1<a href="#fnref12">↩</a></li>
<li id="fn13">Hopcroft &amp; Ullman (1979), p.131-132, Theorem 6.2<a href="#fnref13">↩</a></li>
<li id="fn14">Hopcroft &amp; Ullman (1979), p.132-134, Theorem 6.3<a href="#fnref14">↩</a></li>
<li id="fn15">Hopcroft &amp; Ullman (1979), p.135-136, Theorem 6.5<a href="#fnref15">↩</a></li>
<li id="fn16">Hopcroft &amp; Ullman (1979), p.134-135, Theorem 6.4<a href="#fnref16">↩</a></li>
<li id="fn17">Hopcroft &amp; Ullman (1979), p.137-138, Theorem 6.6<a href="#fnref17">↩</a></li>
<li id="fn18">, Theorem 5.10, p. 181.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20">, p. 281.<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25">.<a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28">.<a href="#fnref28">↩</a></li>
<li id="fn29">.<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31">.<a href="#fnref31">↩</a></li>
<li id="fn32"></li>
</ol>
</section>
</body>
</html>
