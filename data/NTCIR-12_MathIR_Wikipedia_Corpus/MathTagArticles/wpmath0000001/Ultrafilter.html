<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1076">Ultrafilter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ultrafilter</h1>
<hr/>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> field of <a href="set_theory" title="wikilink">set theory</a>, an <strong>ultrafilter</strong> is a <a href="maximal_element" title="wikilink">maximal</a> <a href="filter_(mathematics)" title="wikilink">filter</a>, that is, a filter that cannot be enlarged. Filters and ultrafilters are special subsets of <a href="partially_ordered_set" title="wikilink">partially ordered sets</a>. Ultrafilters can also be defined on <a href="Boolean_algebras" title="wikilink">Boolean algebras</a> and <a href="set_(mathematics)" title="wikilink">sets</a>:</p>
<ul>
<li>An ultrafilter on a poset <em>P</em> is a maximal filter on <em>P</em>.</li>
<li>An ultrafilter on a Boolean algebra <em>B</em> is an ultrafilter on the poset of non-zero elements of <em>B</em>.</li>
<li>An ultrafilter on a set <em>X</em> is an ultrafilter on the Boolean algebra of subsets of <em>X</em>.</li>
</ul>

<p>Rather confusingly, an ultrafilter on a poset <em>P</em> or Boolean algebra <em>B</em> is a subset of <em>P</em> or <em>B</em>, while an ultrafilter on a set <em>X</em> is a collection of subsets of <em>X</em>. Ultrafilters have many applications in set theory, <a href="model_theory" title="wikilink">model theory</a>, and <a class="uri" href="topology" title="wikilink">topology</a>.</p>

<p>An ultrafilter on a set <em>X</em> has some special properties. For example, given any subset <em>A</em> of <em>X</em>, the ultrafilter must contain either <em>A</em> or its <a href="relative_complement" title="wikilink">complement</a> . In addition, an ultrafilter on a set <em>X</em> may be considered as a <a href="finitely_additive" title="wikilink">finitely additive</a> <a href="measure_(mathematics)" title="wikilink">measure</a>. In this view, every subset of <em>X</em> is either considered "<a href="Almost_everywhere" title="wikilink">almost everything</a>" (has measure 1) or "almost nothing" (has measure 0).</p>
<h2 id="formal-definition-for-ultrafilter-on-a-set">Formal definition for ultrafilter on a set</h2>

<p>Given a set <em>X</em>, an ultrafilter on <em>X</em> is a set <em>U</em> consisting of subsets of <em>X</em> such that</p>
<ol>
<li>The empty set is not an element of <em>U</em></li>
<li>If <em>A</em> and <em>B</em> are subsets of <em>X</em>, <em>A</em> is a subset of <em>B</em>, and <em>A</em> is an element of <em>U</em>, then <em>B</em> is also an element of <em>U</em>.</li>
<li>If <em>A</em> and <em>B</em> are elements of <em>U</em>, then so is the <a href="Intersection_(set_theory)" title="wikilink">intersection</a> of <em>A</em> and <em>B</em>.</li>
<li>If <em>A</em> is a subset of <em>X</em>, then either <em>A</em> or <em>X</em> \ <em>A</em> is an element of <em>U</em>. (Note: axioms 1 and 3 imply that <em>A</em> and  cannot <em>both</em> be elements of <em>U</em>.)</li>
</ol>

<p>A characterization is given by the following theorem. A <a href="filter_(mathematics)" title="wikilink">filter</a> <em>U</em> on a set <em>X</em> is an ultrafilter if any of the following conditions are true:</p>
<ol>
<li>There is no filter <em>F</em> <a href="Filter_(mathematics)#Filter_on_a_set" title="wikilink">finer</a> than <em>U</em>, i.e., 

<math display="inline" id="Ultrafilter:0">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>⊆</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>U</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\subseteq F
  </annotation>
 </semantics>
</math>

 implies <em>U</em> = <em>F</em>.</li>
<li>

<math display="inline" id="Ultrafilter:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∪</mo>
    <mi>B</mi>
   </mrow>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <union></union>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cup B\in U
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Ultrafilter:2">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in U
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Ultrafilter:3">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>B</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\in U
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Ultrafilter:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>⊆</mo>
    <mi>X</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <in></in>
     <ci>A</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\subseteq X\colon A\in U
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Ultrafilter:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>∖</mo>
    <mi>A</mi>
   </mrow>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <setdiff></setdiff>
     <ci>X</ci>
     <ci>A</ci>
    </apply>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\setminus A\in U
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Another way of looking at ultrafilters on a set <em>X</em> is to define a function <em>m</em> on the <a href="power_set" title="wikilink">power set</a> of <em>X</em> by setting <em>m</em>(<em>A</em>) = 1 if <em>A</em> is an element of <em>U</em> and <em>m</em>(<em>A</em>) = 0 otherwise. Such a function is called a <a href="2-valued_morphism" title="wikilink">2-valued morphism</a>. Then <em>m</em> is a finitely additive measure on <em>X</em>, and every property of elements of <em>X</em> is either true <a href="almost_everywhere" title="wikilink">almost everywhere</a> or false almost everywhere. Note that this does not define a <a href="measure_(mathematics)" title="wikilink">measure</a> in the usual sense, which is required to be <em>countably additive</em>.</p>

<p>For a filter <em>F</em> that is not an ultrafilter, one would say <em>m</em>(<em>A</em>) = 1 if <em>A</em> ∈ <em>F</em> and <em>m</em>(<em>A</em>) = 0 if <em>X</em> \ <em>A</em> ∈ <em>F</em>, leaving <em>m</em> undefined elsewhere.</p>

<p>A simple example of an ultrafilter is a <em>principal ultrafilter</em>, which consists of subsets of <em>X</em> that contain a given element <em>x</em> of <em>X</em>. All ultrafilters on a finite set are principal.</p>
<h2 id="completeness">Completeness</h2>

<p>The <strong>completeness</strong> of an ultrafilter <em>U</em> on a set is the smallest <a href="Cardinal_number" title="wikilink">cardinal</a> κ such that there are κ elements of <em>U</em> whose intersection is not in <em>U</em>. The definition implies that the completeness of any ultrafilter is at least 

<math display="inline" id="Ultrafilter:6">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}
  </annotation>
 </semantics>
</math>

. An ultrafilter whose completeness is <em>greater</em> than 

<math display="inline" id="Ultrafilter:7">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}
  </annotation>
 </semantics>
</math>

—that is, the intersection of any countable collection of elements of <em>U</em> is still in <em>U</em>—is called <strong>countably complete</strong> or 

<math display="inline" id="Ultrafilter:8">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

<strong>-complete</strong>.</p>

<p>The completeness of a countably complete <a href="#Types_and_existence_of_ultrafilters" title="wikilink">nonprincipal</a> ultrafilter on a set is always a <a href="measurable_cardinal" title="wikilink">measurable cardinal</a>.</p>
<h2 id="generalization-to-partial-orders">Generalization to partial orders</h2>

<p>In <a href="order_theory" title="wikilink">order theory</a>, an <strong>ultrafilter</strong> is a <a class="uri" href="subset" title="wikilink">subset</a> of a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> (a <em>poset</em>) that is <a href="maximal_element" title="wikilink">maximal</a> among all <a href="filter_(mathematics)#General_definition" title="wikilink">proper filters</a>. Formally, this states that any filter that properly contains an ultrafilter has to be equal to the whole poset.</p>
<h2 id="special-case-boolean-algebra">Special case: Boolean algebra</h2>

<p>An important special case of the concept occurs if the considered poset is a <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a>, as in the case of an ultrafilter on a set (defined as a filter of the corresponding <a class="uri" href="powerset" title="wikilink">powerset</a>). In this case, ultrafilters are characterized by containing, for each element <em>a</em> of the Boolean algebra, exactly one of the elements <em>a</em> and ¬<em>a</em> (the latter being the <a href="Boolean_algebra#Nonmonotone_laws" title="wikilink">Boolean complement</a> of <em>a</em>).</p>

<p>Ultrafilters on a Boolean algebra can be identified with <a href="ideal_(order_theory)#Prime_ideals" title="wikilink">prime ideals</a>, <a href="maximal_ideal" title="wikilink">maximal ideals</a>, and <a href="homomorphism" title="wikilink">homomorphisms</a> to the 2-element Boolean algebra {true, false}, as follows:</p>
<ul>
<li>Maximal ideals of a Boolean algebra are the same as prime ideals.</li>
<li>Given a homomorphism of a Boolean algebra onto {true, false}, the inverse image of "true" is an ultrafilter, and the inverse image of "false" is a maximal ideal.</li>
<li>Given a maximal ideal of a Boolean algebra, its complement is an ultrafilter, and there is a unique homomorphism onto {true, false} taking the maximal ideal to "false".</li>
<li>Given an ultrafilter of a Boolean algebra, its complement is a maximal ideal, and there is a unique homomorphism onto {true, false} taking the ultrafilter to "true".</li>
</ul>

<p>Let us see another theorem, which could be used for the definition of the concept of “ultrafilter”. Let <strong>B</strong> denote a Boolean algebra and <em>F</em> a proper filter<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in it. <em>F</em> is an ultrafilter iff:</p>
<dl>
<dd>for all 

<math display="inline" id="Ultrafilter:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>𝐁</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <ci>𝐁</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\in\mathbf{B}
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Ultrafilter:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b\in F
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Ultrafilter:11">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in F
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Ultrafilter:12">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>b</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\in F
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>(To avoid confusion: the sign 

<math display="inline" id="Ultrafilter:13">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>

 denotes the join operation of the Boolean algebra, and logical connectives are rendered by English circumlocutions.) See details (and proof) in.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="types-and-existence-of-ultrafilters">Types and existence of ultrafilters</h2>

<p>There are two very different types of ultrafilter: principal and free. A <strong>principal</strong> (or <strong>fixed</strong>, or <strong>trivial</strong>) ultrafilter is a filter containing a <a href="least_element" title="wikilink">least element</a>. Consequently, principal ultrafilters are of the form <em>F</em><sub><em>a</em></sub> = {<em>x</em> | <em>a</em> ≤ <em>x</em>} for some (but not all) elements <em>a</em> of the given poset. In this case <em>a</em> is called the <em>principal element</em> of the ultrafilter. For the case of ultrafilters on sets, the elements that qualify as principals are exactly the one-element sets. Thus, a principal ultrafilter on a set <em>S</em> consists of all sets containing a particular point of <em>S</em>. An ultrafilter on a finite set is principal. Any ultrafilter that is not principal is called a <strong>free</strong> (or <strong>non-principal</strong>) ultrafilter.</p>

<p>Note that an ultrafilter on an infinite set S is non-principal if and only if it contains the <a href="Fréchet_filter" title="wikilink">Fréchet filter</a> of <a href="cofinite_subset" title="wikilink">cofinite subsets</a> of S. This is obvious, since a non-principal ultrafilter contains no finite set, it means that, by taking complements, it contains all cofinite subsets of S, which is exactly the Fréchet filter.</p>

<p>One can show that every filter of a Boolean algebra (or more generally, any subset with the <a href="finite_intersection_property" title="wikilink">finite intersection property</a>) is contained in an ultrafilter (see <a href="Ultrafilter_lemma" title="wikilink">Ultrafilter lemma</a>) and that free ultrafilters therefore exist, but the proofs involve the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> (AC) in the form of <a href="Zorn's_Lemma" title="wikilink">Zorn's Lemma</a>. On the other hand, the statement that every filter is contained in an ultrafilter does not imply AC. Indeed, it is equivalent to the <a href="Boolean_prime_ideal_theorem" title="wikilink">Boolean prime ideal theorem</a> (BPIT), a well-known intermediate point between the axioms of Zermelo-Fraenkel set theory (ZF) and the ZF theory augmented by the axiom of choice (ZFC). Proofs involving the axiom of choice do not produce explicit examples of free ultrafilters. Nonetheless, almost all ultrafilters on an infinite set are free. By contrast, every ultrafilter of a finite poset (or <em>on</em> a finite set) is principal, since any finite filter has a least element. In ZF without the axiom of choice, it is possible that every ultrafilter is principal.</p>
<h2 id="applications">Applications</h2>

<p>Ultrafilters on sets are useful in <a class="uri" href="topology" title="wikilink">topology</a>, especially in relation to <a href="Compact_space" title="wikilink">compact</a> <a href="Hausdorff_space" title="wikilink">Hausdorff</a> spaces, and in <a href="model_theory" title="wikilink">model theory</a> in the construction of <a href="ultraproduct" title="wikilink">ultraproducts and ultrapowers</a>. Every ultrafilter on a compact Hausdorff space converges to exactly one point. Likewise, ultrafilters on posets are most important if the poset is a Boolean algebra, since in this case the ultrafilters coincide with the <a href="prime_filter" title="wikilink">prime filters</a>. Ultrafilters in this form play a central role in <a href="Stone's_representation_theorem_for_Boolean_algebras" title="wikilink">Stone's representation theorem for Boolean algebras</a>.</p>

<p>The set <em>G</em> of all ultrafilters of a poset <em>P</em> can be topologized in a natural way, that is in fact closely related to the above-mentioned representation theorem. For any element <em>a</em> of <em>P</em>, let <em>D</em><sub><em>a</em></sub> = {<em>U</em> ∈ <em>G</em> | <em>a</em> ∈ <em>U</em>}. This is most useful when <em>P</em> is again a Boolean algebra, since in this situation the set of all <em>D</em><sub><em>a</em></sub> is a base for a compact Hausdorff topology on <em>G</em>. Especially, when considering the ultrafilters on a set <em>S</em> (i.e., the case that <em>P</em> is the powerset of <em>S</em> ordered via subset inclusion), the resulting <a href="topological_space" title="wikilink">topological space</a> is the <a href="Stone–Čech_compactification" title="wikilink">Stone–Čech compactification</a> of a <a href="discrete_space" title="wikilink">discrete space</a> of cardinality |<em>S</em>|.</p>

<p>The <a class="uri" href="ultraproduct" title="wikilink">ultraproduct</a> construction in <a href="model_theory" title="wikilink">model theory</a> uses ultrafilters to produce <a href="elementary_extension" title="wikilink">elementary extensions</a> of structures. For example, in constructing <a href="hyperreal_number" title="wikilink">hyperreal numbers</a> as an ultraproduct of the <a href="real_numbers" title="wikilink">real numbers</a>, we first extend the <a href="domain_of_discourse" title="wikilink">domain of discourse</a> from the real numbers to sequences of real numbers. This sequence space is regarded as a <a class="uri" href="superset" title="wikilink">superset</a> of the reals by identifying each real with the corresponding constant sequence. To extend the familiar functions and relations (e.g., + and ). Mihara (1997,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> 1999<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>) shows, however, such rules are practically of limited interest to social scientists, since they are non-algorithmic or non-computable.</p>
<h2 id="ordering-on-ultrafilters">Ordering on ultrafilters</h2>

<p><strong>Rudin–Keisler ordering</strong> is a <a class="uri" href="preorder" title="wikilink">preorder</a> on the class of ultrafilters defined as follows: if <em>U</em> is an ultrafilter on <em>X</em>, and <em>V</em> an ultrafilter on <em>Y</em>, then 

<math display="inline" id="Ultrafilter:14">
 <semantics>
  <mrow>
   <mi>V</mi>
   <msub>
    <mo>≤</mo>
    <mrow>
     <mi>R</mi>
     <mi>K</mi>
    </mrow>
   </msub>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <ci>V</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\leq_{RK}U
  </annotation>
 </semantics>
</math>

 if and only if there exists a function <em>f</em>: <em>X</em> → <em>Y</em> such that</p>

<p>

<math display="block" id="Ultrafilter:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>C</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <in></in>
     <ci>C</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>C</ci>
      </apply>
     </apply>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\in V\iff f^{-1}[C]\in U
  </annotation>
 </semantics>
</math>

 for every subset <em>C</em> of <em>Y</em>.</p>

<p>Ultrafilters <em>U</em> and <em>V</em> are <strong>Rudin–Keisler equivalent</strong>, 

<math display="inline" id="Ultrafilter:16">
 <semantics>
  <mrow>
   <mi>U</mi>
   <msub>
    <mo>≡</mo>
    <mrow>
     <mi>R</mi>
     <mi>K</mi>
    </mrow>
   </msub>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\equiv_{RK}V
  </annotation>
 </semantics>
</math>

, if there exist sets 

<math display="inline" id="Ultrafilter:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in U
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ultrafilter:18">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>B</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\in V
  </annotation>
 </semantics>
</math>

, and a <a class="uri" href="bijection" title="wikilink">bijection</a> <em>f</em>: <em>A</em> → <em>B</em> that satisfies the condition above. (If <em>X</em> and <em>Y</em> have the same cardinality, the definition can be simplified by fixing <em>A</em> = <em>X</em>, <em>B</em> = <em>Y</em>.)</p>

<p>It is known that 

<math display="inline" id="Ultrafilter:19">
 <semantics>
  <msub>
   <mo>≡</mo>
   <mrow>
    <mi>R</mi>
    <mi>K</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv_{RK}
  </annotation>
 </semantics>
</math>

 is the <a href="kernel_(set_theory)" title="wikilink">kernel</a> of 

<math display="inline" id="Ultrafilter:20">
 <semantics>
  <msub>
   <mo>≤</mo>
   <mrow>
    <mi>R</mi>
    <mi>K</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{RK}
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Ultrafilter:21">
 <semantics>
  <mrow>
   <mi>U</mi>
   <msub>
    <mo>≡</mo>
    <mrow>
     <mi>R</mi>
     <mi>K</mi>
    </mrow>
   </msub>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\equiv_{RK}V
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Ultrafilter:22">
 <semantics>
  <mrow>
   <mi>U</mi>
   <msub>
    <mo>≤</mo>
    <mrow>
     <mi>R</mi>
     <mi>K</mi>
    </mrow>
   </msub>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\leq_{RK}V
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ultrafilter:23">
 <semantics>
  <mrow>
   <mi>V</mi>
   <msub>
    <mo>≤</mo>
    <mrow>
     <mi>R</mi>
     <mi>K</mi>
    </mrow>
   </msub>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <ci>V</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\leq_{RK}U
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="ultrafilters-on-ω">Ultrafilters on <em>ω</em></h2>

<p>There are several special properties that an ultrafilter on <em>ω</em> may possess, which prove useful in various areas of set theory and topology.</p>
<ul>
<li>A non-principal ultrafilter <em>U</em> is a <strong>P-point</strong> (or <strong>weakly selective</strong>) iff for every <a href="partition_of_a_set" title="wikilink">partition</a> of <em>ω</em>, 

<math display="inline" id="Ultrafilter:24">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>∣</mo>
   <mrow>
    <mi>n</mi>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <lt></lt>
     <ci>n</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{C_{n}\mid n<\omega\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Ultrafilter:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
    <mo>∉</mo>
    <mi>U</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>n</mi>
    </mrow>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <notin></notin>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
     <ci>U</ci>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>n</ci>
     </apply>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}\not\in U,\forall n<\omega
  </annotation>
 </semantics>
</math>

, there exists 

<math display="inline" id="Ultrafilter:26">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in U
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Ultrafilter:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <msub>
       <mi>C</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>n</mi>
    </mrow>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <apply>
       <intersect></intersect>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>n</ci>
     </apply>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\cap C_{n}|<\omega,\forall n<\omega
  </annotation>
 </semantics>
</math>

.</li>
<li>A non-principal ultrafilter <em>U</em> is <strong>Ramsey</strong> (or <strong>selective</strong>) iff for every partition of <em>ω</em>, 

<math display="inline" id="Ultrafilter:28">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>∣</mo>
   <mrow>
    <mi>n</mi>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <lt></lt>
     <ci>n</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{C_{n}\mid n<\omega\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Ultrafilter:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
    <mo>∉</mo>
    <mi>U</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>n</mi>
    </mrow>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <notin></notin>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
     <ci>U</ci>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>n</ci>
     </apply>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}\not\in U,\forall n<\omega
  </annotation>
 </semantics>
</math>

, there exists 

<math display="inline" id="Ultrafilter:30">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in U
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Ultrafilter:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <msub>
       <mi>C</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>n</mi>
    </mrow>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <intersect></intersect>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>n</ci>
     </apply>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\cap C_{n}|=1,\forall n<\omega
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>It is a trivial observation that all Ramsey ultrafilters are P-points. <a href="Walter_Rudin" title="wikilink">Walter Rudin</a> proved that the <a href="continuum_hypothesis" title="wikilink">continuum hypothesis</a> implies the existence of Ramsey ultrafilters.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In fact, many hypotheses imply the existence of Ramsey ultrafilters, including <a href="Martin's_axiom" title="wikilink">Martin's axiom</a>. <a href="Saharon_Shelah" title="wikilink">Saharon Shelah</a> later showed that it is consistent that there are no P-point ultrafilters.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Therefore the existence of these types of ultrafilters is <a href="independence_(mathematical_logic)" title="wikilink">independent</a> of <a class="uri" href="ZFC" title="wikilink">ZFC</a>.</p>

<p>P-points are called as such because they are topological <a href="P-point" title="wikilink">P-points</a> in the usual topology of the space <a href="Stone–Čech_compactification" title="wikilink"></a> of non-principal ultrafilters. The name Ramsey comes from <a href="Ramsey's_theorem" title="wikilink">Ramsey's theorem</a>. To see why, one can prove that an ultrafilter is Ramsey if and only if for every 2-coloring of 

<math display="inline" id="Ultrafilter:32">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>ω</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>ω</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\omega]^{2}
  </annotation>
 </semantics>
</math>

 there exists an element of the ultrafilter that has a homogeneous color.</p>

<p>An ultrafilter on <em>ω</em> is Ramsey if and only if it is <a href="minimal_element" title="wikilink">minimal</a> in the Rudin–Keisler ordering of non-principal ultrafilters.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Universal_net" title="wikilink">Universal net</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Order_theory" title="wikilink">Category:Order theory</a> <a href="Category:Set_families" title="wikilink">Category:Set families</a> <a href="Category:Non-standard_analysis" title="wikilink">Category:Non-standard analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">I.e., a filter <em>F</em> with the surplus restriction 

<math display="inline" id="Ultrafilter:33">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <cn type="integer">0</cn>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\notin F
  </annotation>
 </semantics>
</math>

, i.e., being a filter that does not “degenerate” to coincide with the whole (universe of the) Boolean algebra<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.math.uwaterloo.ca/~snburris/htdocs/ualg.html">A Course in Universal Algebra</a> (written by <a href="http://www.math.uwaterloo.ca/~snburris/index.html">Stanley N. Burris</a> and H.P. Sankappanavar), Corollary 3.13 on p. 149.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
