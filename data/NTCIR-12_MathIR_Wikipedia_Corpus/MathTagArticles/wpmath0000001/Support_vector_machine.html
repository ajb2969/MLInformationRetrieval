<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1940">Support vector machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Support vector machine</h1>
<hr/>

<p>In <a href="machine_learning" title="wikilink">machine learning</a>, <strong>support vector machines</strong> (<strong>SVMs</strong>, also <strong>support vector networks</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) are <a href="supervised_learning" title="wikilink">supervised learning</a> models with associated learning <a href="algorithm" title="wikilink">algorithms</a> that analyze data and recognize patterns, used for <a href="Statistical_classification" title="wikilink">classification</a> and <a href="regression_analysis" title="wikilink">regression analysis</a>. Given a set of training examples, each marked for belonging to one of two categories, an SVM training algorithm builds a model that assigns new examples into one category or the other, making it a non-<a href="probabilistic_classification" title="wikilink">probabilistic</a> <a href="binary_classifier" title="wikilink">binary</a> <a href="linear_classifier" title="wikilink">linear classifier</a>. An SVM model is a representation of the examples as points in space, mapped so that the examples of the separate categories are divided by a clear gap that is as wide as possible. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall on.</p>

<p>In addition to performing linear classification, SVMs can efficiently perform a non-linear classification using what is called the <a href="kernel_trick" title="wikilink">kernel trick</a>, implicitly mapping their inputs into high-dimensional feature spaces.</p>
<h2 id="definition">Definition</h2>

<p>More formally, a support vector machine constructs a <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> or set of hyperplanes in a <a href="high-dimensional_space" title="wikilink">high-</a> or infinite-dimensional space, which can be used for classification, regression, or other tasks. Intuitively, a good separation is achieved by the hyperplane that has the largest distance to the nearest training-data point of any class (so-called functional margin), since in general the larger the margin the lower the <a href="generalization_error" title="wikilink">generalization error</a> of the classifier.</p>

<p>Whereas the original problem may be stated in a finite dimensional space, it often happens that the sets to discriminate are not <a href="Linear_separability" title="wikilink">linearly separable</a> in that space. For this reason, it was proposed that the original finite-dimensional space be mapped into a much higher-dimensional space, presumably making the separation easier in that space. To keep the computational load reasonable, the mappings used by SVM schemes are designed to ensure that <a href="dot_product" title="wikilink">dot products</a> may be computed easily in terms of the variables in the original space, by defining them in terms of a <a href="Positive-definite_kernel" title="wikilink">kernel function</a> 

<math display="inline" id="Support_vector_machine:0">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)
  </annotation>
 </semantics>
</math>

 selected to suit the problem.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The hyperplanes in the higher-dimensional space are defined as the set of points whose dot product with a vector in that space is constant. The vectors defining the hyperplanes can be chosen to be linear combinations with parameters 

<math display="inline" id="Support_vector_machine:1">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 of images of feature vectors 

<math display="inline" id="Support_vector_machine:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 that occur in the data base. With this choice of a hyperplane, the points 

<math display="inline" id="Support_vector_machine:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 in the feature space that are mapped into the hyperplane are defined by the relation

<math display="block" id="Support_vector_machine:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>i</mi>
      </msub>
     </mstyle>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>constant</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </interval>
     </apply>
    </apply>
    <ci>constant</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\sum_{i}\alpha_{i}k(x_{i},x)=\mathrm{constant}.
  </annotation>
 </semantics>
</math>

 Note that if 

<math display="inline" id="Support_vector_machine:5">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)
  </annotation>
 </semantics>
</math>

 becomes small as 

<math display="inline" id="Support_vector_machine:6">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 grows further away from 

<math display="inline" id="Support_vector_machine:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, each term in the sum measures the degree of closeness of the test point 

<math display="inline" id="Support_vector_machine:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 to the corresponding data base point 

<math display="inline" id="Support_vector_machine:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

. In this way, the sum of kernels above can be used to measure the relative nearness of each test point to the data points originating in one or the other of the sets to be discriminated. Note the fact that the set of points 

<math display="inline" id="Support_vector_machine:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 mapped into any hyperplane can be quite convoluted as a result, allowing much more complex discrimination between sets which are not convex at all in the original space.</p>
<h2 id="history">History</h2>

<p>The original SVM algorithm was invented by <a href="Vladimir_N._Vapnik" title="wikilink">Vladimir N. Vapnik</a> and <a href="Alexey_Chervonenkis" title="wikilink">Alexey Ya. Chervonenkis</a> in 1963. In 1992, <a href="Bernhard_E._Boser" title="wikilink">Bernhard E. Boser</a>, <a href="Isabelle_M._Guyon" title="wikilink">Isabelle M. Guyon</a> and <a href="Vladimir_N._Vapnik" title="wikilink">Vladimir N. Vapnik</a> suggested a way to create nonlinear classifiers by applying the <a href="kernel_trick" title="wikilink">kernel trick</a> to maximum-margin hyperplanes.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The current standard incarnation (soft margin) was proposed by <a href="Corinna_Cortes" title="wikilink">Corinna Cortes</a> and Vapnik in 1993 and published in 1995.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="motivation">Motivation</h2>

<p> <a href="Statistical_classification" title="wikilink">Classifying data</a> is a common task in <a href="machine_learning" title="wikilink">machine learning</a>. Suppose some given data points each belong to one of two classes, and the goal is to decide which class a <em>new</em> data point will be in. In the case of support vector machines, a data point is viewed as a 

<math display="inline" id="Support_vector_machine:11">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-dimensional vector (a list of 

<math display="inline" id="Support_vector_machine:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 numbers), and we want to know whether we can separate such points with a 

<math display="inline" id="Support_vector_machine:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p-1)
  </annotation>
 </semantics>
</math>


-dimensional <a class="uri" href="hyperplane" title="wikilink">hyperplane</a>. This is called a <a href="linear_classifier" title="wikilink">linear classifier</a>. There are many hyperplanes that might classify the data. One reasonable choice as the best hyperplane is the one that represents the largest separation, or margin, between the two classes. So we choose the hyperplane so that the distance from it to the nearest data point on each side is maximized. If such a hyperplane exists, it is known as the <em><a href="maximum-margin_hyperplane" title="wikilink">maximum-margin hyperplane</a></em> and the linear classifier it defines is known as a <em>maximum <a href="margin_classifier" title="wikilink">margin classifier</a></em>; or equivalently, the <em><a class="uri" href="perceptron" title="wikilink">perceptron</a> of optimal stability.</em></p>
<h2 id="linear-svm">Linear SVM</h2>

<p>Given some training data 

<math display="inline" id="Support_vector_machine:14">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

, a set of 

<math display="inline" id="Support_vector_machine:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 points of the form</p>

<p>

<math display="block" id="Support_vector_machine:16">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>𝐱</mi>
        <mi>i</mi>
       </msub>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>p</mi>
       </msup>
      </mrow>
      <mo rspace="4.2pt">,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒟</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </interval>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ℝ</ci>
          <ci>p</ci>
         </apply>
        </apply>
        <apply>
         <in></in>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <set>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">1</cn>
         </set>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}=\left\{(\mathbf{x}_{i},y_{i})\mid\mathbf{x}_{i}\in\mathbb{R}^{p},%
\,y_{i}\in\{-1,1\}\right\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="Support_vector_machine:17">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 is either 1 or −1, indicating the class to which the point 

<math display="inline" id="Support_vector_machine:18">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{i}
  </annotation>
 </semantics>
</math>


 belongs. Each 

<math display="inline" id="Support_vector_machine:19">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Support_vector_machine:20">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-dimensional <a href="real_number" title="wikilink">real</a> vector. We want to find the maximum-margin hyperplane that divides the points having 

<math display="inline" id="Support_vector_machine:21">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=1
  </annotation>
 </semantics>
</math>

 from those having 

<math display="inline" id="Support_vector_machine:22">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=-1
  </annotation>
 </semantics>
</math>

. Any hyperplane can be written as the set of points 

<math display="inline" id="Support_vector_machine:23">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>


 satisfying </p>

<p>

<math display="block" id="Support_vector_machine:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>𝐰</mi>
      <mo>⋅</mo>
      <mi>𝐱</mi>
     </mrow>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\mathbf{x}-b=0,\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Support_vector_machine:25">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

 denotes the <a href="dot_product" title="wikilink">dot product</a> and 

<math display="inline" id="Support_vector_machine:26">
 <semantics>
  <mi>𝐰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{w}}
  </annotation>
 </semantics>
</math>

 the (not necessarily normalized) <a href="Normal_(geometry)" title="wikilink">normal vector</a> to the hyperplane. The parameter 

<math display="inline" id="Support_vector_machine:27">
 <semantics>
  <mfrac>
   <mi>b</mi>
   <mrow>
    <mo>∥</mo>
    <mi>𝐰</mi>
    <mo>∥</mo>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>𝐰</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{b}{\|\mathbf{w}\|}
  </annotation>
 </semantics>
</math>

 determines the offset of the hyperplane from the origin along the normal vector 

<math display="inline" id="Support_vector_machine:28">
 <semantics>
  <mi>𝐰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{w}}
  </annotation>
 </semantics>
</math>


.</p>

<p>If the training data are <a href="linearly_separable" title="wikilink">linearly separable</a>, we can select two hyperplanes in a way that they separate the data and there are no points between them, and then try to maximize their distance. The region bounded by them is called "the margin". These hyperplanes can be described by the equations</p>

<p>

<math display="block" id="Support_vector_machine:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐰</mi>
     <mo>⋅</mo>
     <mi>𝐱</mi>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\mathbf{x}-b=1\,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Support_vector_machine:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐰</mi>
     <mo>⋅</mo>
     <mi>𝐱</mi>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>1.</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\mathbf{x}-b=-1.\,
  </annotation>
 </semantics>
</math>

</p>

<p>By using geometry, we find the distance between these two hyperplanes is 

<math display="inline" id="Support_vector_machine:31">
 <semantics>
  <mfrac>
   <mn>2</mn>
   <mrow>
    <mo>∥</mo>
    <mi>𝐰</mi>
    <mo>∥</mo>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>𝐰</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{2}{\|\mathbf{w}\|}
  </annotation>
 </semantics>
</math>

, so we want to minimize 

<math display="inline" id="Support_vector_machine:32">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>𝐰</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>𝐰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{w}\|
  </annotation>
 </semantics>
</math>

. As we also have to prevent data points from falling into the margin, we add the following constraint: for each 

<math display="inline" id="Support_vector_machine:33">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 either</p>

<p>

<math display="block" id="Support_vector_machine:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐰</mi>
     <mo>⋅</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mrow>
     <mtext>for</mtext>
     <msub>
      <mi>𝐱</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\mathbf{x}_{i}-b\geq 1\qquad\text{ for }\mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

 of the first class</p>

<p>or</p>

<p>

<math display="block" id="Support_vector_machine:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐰</mi>
     <mo>⋅</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mi>b</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mtext>for</mtext>
     <msub>
      <mi>𝐱</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <list>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\mathbf{x}_{i}-b\leq-1\qquad\text{ for }\mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

 of the second.</p>

<p>This can be rewritten as:</p>

<p>

<math display="block" id="Support_vector_machine:36">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐰</mi>
    <mo>⋅</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
   <mo rspace="12.5pt">,</mo>
   <mtext>for all</mtext>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>i</ci>
     </apply>
     <minus></minus>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <mtext>for all</mtext>
    <cn type="integer">1</cn>
    <leq></leq>
    <csymbol cd="unknown">i</csymbol>
    <leq></leq>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x}_{i}-b)\geq 1,\quad\text{ for all }1\leq i\leq n%
.\qquad\qquad(1)
  </annotation>
 </semantics>
</math>

</p>

<p>We can put this together to get the optimization problem:</p>

<p>Minimize (in 

<math display="inline" id="Support_vector_machine:37">
 <semantics>
  <mrow>
   <mi>𝐰</mi>
   <mo>,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐰</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{w},b}
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:38">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>𝐰</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>𝐰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{w}\|
  </annotation>
 </semantics>
</math>

</p>

<p>subject to (for any 

<math display="inline" id="Support_vector_machine:39">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,n
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>𝐰</mi>
       <mo>⋅</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐢</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mpadded width="+1.7pt">
    <mn>1.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>𝐰</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)\geq 1.\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="primal-form">Primal form</h3>

<p>The optimization problem presented in the preceding section is difficult to solve because it depends on 

<math display="inline" id="Support_vector_machine:41">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>𝐰</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>𝐰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{w}\|
  </annotation>
 </semantics>
</math>

, the norm of 

<math display="inline" id="Support_vector_machine:42">
 <semantics>
  <mi>𝐰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}
  </annotation>
 </semantics>
</math>

, which involves a square root. Fortunately it is possible to alter the equation by substituting 

<math display="inline" id="Support_vector_machine:43">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>𝐰</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>𝐰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{w}\|
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Support_vector_machine:44">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mi>𝐰</mi>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>𝐰</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{2}\|\mathbf{w}\|^{2}
  </annotation>
 </semantics>
</math>

 (the factor of 

<math display="inline" id="Support_vector_machine:45">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}
  </annotation>
 </semantics>
</math>

 being used for mathematical convenience) without changing the solution (the minimum of the original and the modified equation have the same 

<math display="inline" id="Support_vector_machine:46">
 <semantics>
  <mi>𝐰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Support_vector_machine:47">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

). This is a <a href="quadratic_programming" title="wikilink">quadratic programming</a> <a href="Optimization_(mathematics)" title="wikilink">optimization</a> problem. More clearly:</p>

<p>

<math display="block" id="Support_vector_machine:48">
 <semantics>
  <mrow>
   <mi>arg</mi>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐰</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </munder>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>𝐰</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <arg></arg>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <interval closure="open">
       <ci>𝐰</ci>
       <ci>b</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>𝐰</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\min_{(\mathbf{w},b)}\frac{1}{2}\|\mathbf{w}\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>subject to (for any 

<math display="inline" id="Support_vector_machine:49">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,n
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>𝐰</mi>
       <mo>⋅</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐢</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>𝐰</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)\geq 1.
  </annotation>
 </semantics>
</math>

</p>

<p>By introducing <a href="Lagrange_multiplier" title="wikilink">Lagrange multipliers</a> 

<math display="inline" id="Support_vector_machine:51">
 <semantics>
  <mi>𝜶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}
  </annotation>
 </semantics>
</math>

, the previous constrained problem can be expressed as</p>

<p>

<math display="block" id="Support_vector_machine:52">
 <semantics>
  <mrow>
   <mi>arg</mi>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>𝐰</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>𝜶</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
        <msup>
         <mrow>
          <mo>∥</mo>
          <mi>𝐰</mi>
          <mo>∥</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>α</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mrow>
            <msub>
             <mi>y</mi>
             <mi>i</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mrow>
               <mi>𝐰</mi>
               <mo>⋅</mo>
               <msub>
                <mi>𝐱</mi>
                <mi>𝐢</mi>
               </msub>
              </mrow>
              <mo>-</mo>
              <mi>b</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <arg></arg>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <list>
       <ci>𝐰</ci>
       <ci>b</ci>
      </list>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <geq></geq>
        <ci>𝜶</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <ci>𝐰</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <minus></minus>
             <apply>
              <ci>normal-⋅</ci>
              <ci>𝐰</ci>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>𝐱</ci>
               <ci>𝐢</ci>
              </apply>
             </apply>
             <ci>b</ci>
            </apply>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\min_{\mathbf{w},b}\max_{\boldsymbol{\alpha}\geq 0}\left\{\frac{1}{2}\|%
\mathbf{w}\|^{2}-\sum_{i=1}^{n}{\alpha_{i}[y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}%
-b)-1]}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>that is we look for a <a href="saddle_point" title="wikilink">saddle point</a>. In doing so all the points which can be separated as 

<math display="inline" id="Support_vector_machine:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>𝐰</mi>
        <mo>⋅</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>𝐢</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>𝐰</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>𝐢</ci>
        </apply>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)-1>0
  </annotation>
 </semantics>
</math>


 do not matter since we must set the corresponding 

<math display="inline" id="Support_vector_machine:54">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 to zero.</p>

<p>This problem can now be solved by standard <a href="quadratic_programming" title="wikilink">quadratic programming</a> techniques and programs. The "stationary" <a href="Karush–Kuhn–Tucker_conditions" title="wikilink">Karush–Kuhn–Tucker condition</a> implies that the solution can be expressed as a linear combination of the training vectors</p>

<p>

<math display="block" id="Support_vector_machine:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐰</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>𝐱</mi>
       <mi>𝐢</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐰</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}=\sum_{i=1}^{n}{\alpha_{i}y_{i}\mathbf{x_{i}}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Only a few 

<math display="inline" id="Support_vector_machine:56">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 will be greater than zero. The corresponding 

<math display="inline" id="Support_vector_machine:57">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>𝐢</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>𝐢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x_{i}}
  </annotation>
 </semantics>
</math>

 are exactly the <em>support vectors</em>, which lie on the margin and satisfy 

<math display="inline" id="Support_vector_machine:58">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>𝐰</mi>
       <mo>⋅</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐢</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>𝐰</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)=1
  </annotation>
 </semantics>
</math>


. From this one can derive that the support vectors also satisfy</p>

<p>

<math display="block" id="Support_vector_machine:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>𝐰</mi>
      <mo>⋅</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>𝐢</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>b</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>𝐰</mi>
      <mo>⋅</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>𝐢</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>𝐰</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>𝐢</ci>
        </apply>
       </apply>
       <ci>b</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>𝐰</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\mathbf{x_{i}}-b=\frac{1}{y_{i}}=y_{i}\iff b=\mathbf{w}\cdot%
\mathbf{x_{i}}-y_{i}
  </annotation>
 </semantics>
</math>

 which allows one to define the offset 

<math display="inline" id="Support_vector_machine:60">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Support_vector_machine:61">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 depends on 

<math display="inline" id="Support_vector_machine:62">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Support_vector_machine:63">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>


, so it will vary for each data point in the sample. In practice, it is more robust to average over all 

<math display="inline" id="Support_vector_machine:64">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>S</mi>
    <mi>V</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{SV}
  </annotation>
 </semantics>
</math>

 support vectors, since the average over the sample is an <a href="Bias_of_an_estimator" title="wikilink">unbiased estimator</a> of the population mean:</p>

<p>

<math display="block" id="Support_vector_machine:65">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>S</mi>
       <mi>V</mi>
      </mrow>
     </msub>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <msub>
       <mi>N</mi>
       <mrow>
        <mi>S</mi>
        <mi>V</mi>
       </mrow>
      </msub>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>𝐰</mi>
        <mo>⋅</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>𝐢</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>V</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>𝐰</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>𝐢</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=\frac{1}{N_{SV}}\sum_{i=1}^{N_{SV}}{(\mathbf{w}\cdot\mathbf{x_{i}}-y_{i})}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="dual-form">Dual form</h3>

<p>Writing the classification rule in its unconstrained <a href="dual_problem" title="wikilink">dual form</a> reveals that the <em><a href="maximum-margin_hyperplane" title="wikilink">maximum-margin hyperplane</a></em> and therefore the classification task is only a function of the <em>support vectors</em>, the subset of the training data that lie on the margin.</p>

<p>Using the fact that 

<math display="inline" id="Support_vector_machine:66">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mi>𝐰</mi>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐰</mi>
     <mi>T</mi>
    </msup>
    <mo>⋅</mo>
    <mi>𝐰</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>𝐰</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐰</ci>
      <ci>T</ci>
     </apply>
     <ci>𝐰</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{w}\|^{2}=\mathbf{w}^{T}\cdot\mathbf{w}
  </annotation>
 </semantics>
</math>

 and substituting 

<math display="inline" id="Support_vector_machine:67">
 <semantics>
  <mrow>
   <mi>𝐰</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐢</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐰</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}=\sum_{i=1}^{n}{\alpha_{i}y_{i}\mathbf{x_{i}}}
  </annotation>
 </semantics>
</math>

, one can show that the dual of the SVM reduces to the following optimization problem:</p>

<p>Maximize (in 

<math display="inline" id="Support_vector_machine:68">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>


 )</p>

<p>

<math display="block" id="Support_vector_machine:69">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>L</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>α</mi>
        <mi>j</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>j</mi>
       </msub>
       <msubsup>
        <mi>𝐱</mi>
        <mi>i</mi>
        <mi>T</mi>
       </msubsup>
       <msub>
        <mi>𝐱</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>α</mi>
        <mi>j</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>j</mi>
       </msub>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>L</ci>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <list>
          <ci>i</ci>
          <ci>j</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>i</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <list>
          <ci>i</ci>
          <ci>j</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>j</ci>
         </apply>
         <ci>k</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>j</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{L}(\mathbf{\alpha})=\sum_{i=1}^{n}\alpha_{i}-\frac{1}{2}\sum_{i,j}%
\alpha_{i}\alpha_{j}y_{i}y_{j}\mathbf{x}_{i}^{T}\mathbf{x}_{j}=\sum_{i=1}^{n}%
\alpha_{i}-\frac{1}{2}\sum_{i,j}\alpha_{i}\alpha_{j}y_{i}y_{j}k(\mathbf{x}_{i}%
,\mathbf{x}_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>subject to (for any 

<math display="inline" id="Support_vector_machine:70">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,n
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:71">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}\geq 0,\,
  </annotation>
 </semantics>
</math>

</p>

<p>and to the constraint from the minimization in 

<math display="inline" id="Support_vector_machine:72">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Support_vector_machine:73">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}\alpha_{i}y_{i}=0.
  </annotation>
 </semantics>
</math>

 Here the kernel is defined by 

<math display="inline" id="Support_vector_machine:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mi>i</mi>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(\mathbf{x}_{i},\mathbf{x}_{j})=\mathbf{x}_{i}\cdot\mathbf{x}_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Support_vector_machine:75">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 can be computed thanks to the 

<math display="inline" id="Support_vector_machine:76">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 terms:</p>

<p>

<math display="block" id="Support_vector_machine:77">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐰</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>𝐱</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐰</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}=\sum_{i}\alpha_{i}y_{i}\mathbf{x}_{i}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="biased-and-unbiased-hyperplanes">Biased and unbiased hyperplanes</h3>

<p>For simplicity reasons, sometimes it is required that the hyperplane pass through the origin of the coordinate system. Such hyperplanes are called <em>unbiased</em>, whereas general hyperplanes not necessarily passing through the origin are called <em>biased</em>. An unbiased hyperplane can be enforced by setting 

<math display="inline" id="Support_vector_machine:78">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=0
  </annotation>
 </semantics>
</math>


 in the primal optimization problem. The corresponding dual is identical to the dual given above without the equality constraint</p>

<p>

<math display="block" id="Support_vector_machine:79">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}\alpha_{i}y_{i}=0
  </annotation>
 </semantics>
</math>

</p>
<h2 id="soft-margin">Soft margin</h2>

<p>In 1995, <a href="Corinna_Cortes" title="wikilink">Corinna Cortes</a> and <a href="Vladimir_N._Vapnik" title="wikilink">Vladimir N. Vapnik</a> suggested a modified maximum margin idea that allows for mislabeled examples.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> If there exists no hyperplane that can split the "yes" and "no" examples, the <em>Soft Margin</em> method will choose a hyperplane that splits the examples as cleanly as possible, while still maximizing the distance to the nearest cleanly split examples. The method introduces non-negative slack variables, 

<math display="inline" id="Support_vector_machine:80">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{i}
  </annotation>
 </semantics>
</math>

, which measure the degree of misclassification of the data 

<math display="inline" id="Support_vector_machine:81">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Support_vector_machine:82">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐰</mi>
    <mo>⋅</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>𝐢</mi>
    </msub>
    <mo>-</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
   <mo>-</mo>
   <msub>
    <mi>ξ</mi>
    <mi>i</mi>
   </msub>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>𝐢</ci>
     </apply>
     <minus></minus>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">1</cn>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <ci>i</ci>
    </apply>
    <ci></ci>
    <cn type="integer">1</cn>
    <leq></leq>
    <csymbol cd="unknown">i</csymbol>
    <leq></leq>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)\geq 1-\xi_{i}\quad 1\leq i\leq n.\quad%
\quad(2)
  </annotation>
 </semantics>
</math>

</p>

<p>The objective function is then increased by a function which penalizes non-zero 

<math display="inline" id="Support_vector_machine:83">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{i}
  </annotation>
 </semantics>
</math>


, and the optimization becomes a trade off between a large margin and a small error penalty. If the penalty function is linear, the optimization problem becomes:</p>

<p>

<math display="block" id="Support_vector_machine:84">
 <semantics>
  <mrow>
   <mi>arg</mi>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>𝐰</mi>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mi>𝐰</mi>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>C</mi>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <msub>
         <mi>ξ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <arg></arg>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <list>
       <ci>𝐰</ci>
       <ci>ξ</ci>
       <ci>b</ci>
      </list>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>𝐰</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ξ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\min_{\mathbf{w},\mathbf{\xi},b}\left\{\frac{1}{2}\|\mathbf{w}\|^{2}+C\sum%
_{i=1}^{n}\xi_{i}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>subject to (for any 

<math display="inline" id="Support_vector_machine:85">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots n
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:86">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>𝐰</mi>
        <mo>⋅</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>𝐢</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msub>
      <mi>ξ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo rspace="15.7pt">,</mo>
   <mrow>
    <msub>
     <mi>ξ</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>𝐰</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>𝐢</ci>
        </apply>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)\geq 1-\xi_{i},~{}~{}~{}~{}\xi_{i}\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>Using the <a href="Multivariate_adaptive_regression_splines#Hinge_functions" title="wikilink">hinge function</a> notation like that in <a href="Multivariate_adaptive_regression_splines" title="wikilink">MARS</a>, this optimization problem can be rewritten as 

<math display="inline" id="Support_vector_machine:87">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>w</mi>
           <mo>⋅</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>+</mo>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>w</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <ci>normal-⋅</ci>
           <ci>w</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
          <ci>b</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>w</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}[1-y_{i}(w\cdot x_{i}+b)]_{+}+\lambda\|w\|^{2}
  </annotation>
 </semantics>
</math>

, wherein let 

<math display="inline" id="Support_vector_machine:88">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>w</mi>
           <mo>⋅</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>+</mo>
    </msub>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>ξ</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>+</mo>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>ξ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mi>C</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <ci>normal-⋅</ci>
            <ci>w</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
           <ci>b</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <plus></plus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ξ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>λ</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1-y_{i}(w\cdot x_{i}+b)]_{+}=[\xi_{i}]_{+}=\xi_{i},\quad\lambda=1/2C
  </annotation>
 </semantics>
</math>


.</p>

<p>This constraint in (2) along with the objective of minimizing 

<math display="inline" id="Support_vector_machine:89">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>𝐰</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>𝐰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{w}\|
  </annotation>
 </semantics>
</math>

 can be solved using <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a> as done above. One then has to solve the following problem:</p>

<p>

<math display="block" id="Support_vector_machine:90">
 <semantics>
  <mrow>
   <mi>arg</mi>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>𝐰</mi>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>𝜶</mi>
       <mo>,</mo>
       <mi>𝜷</mi>
      </mrow>
     </munder>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mrow>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
         <msup>
          <mrow>
           <mo>∥</mo>
           <mi>𝐰</mi>
           <mo>∥</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>C</mi>
         <mrow>
          <munderover>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>n</mi>
          </munderover>
          <msub>
           <mi>ξ</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>α</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mrow>
            <mrow>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <mrow>
                <mi>𝐰</mi>
                <mo>⋅</mo>
                <msub>
                 <mi>𝐱</mi>
                 <mi>𝐢</mi>
                </msub>
               </mrow>
               <mo>-</mo>
               <mi>b</mi>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo>+</mo>
           <msub>
            <mi>ξ</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>β</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>ξ</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <arg></arg>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <list>
       <ci>𝐰</ci>
       <ci>ξ</ci>
       <ci>b</ci>
      </list>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <list>
        <ci>𝜶</ci>
        <ci>𝜷</ci>
       </list>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">norm</csymbol>
           <ci>𝐰</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>C</ci>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>i</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ξ</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <plus></plus>
           <apply>
            <minus></minus>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <ci>i</ci>
             </apply>
             <apply>
              <minus></minus>
              <apply>
               <ci>normal-⋅</ci>
               <ci>𝐰</ci>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <ci>𝐱</ci>
                <ci>𝐢</ci>
               </apply>
              </apply>
              <ci>b</ci>
             </apply>
            </apply>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ξ</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ξ</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\min_{\mathbf{w},\mathbf{\xi},b}\max_{\boldsymbol{\alpha},\boldsymbol{%
\beta}}\left\{\frac{1}{2}\|\mathbf{w}\|^{2}+C\sum_{i=1}^{n}\xi_{i}-\sum_{i=1}^%
{n}{\alpha_{i}[y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)-1+\xi_{i}]}-\sum_{i=1}^{%
n}\beta_{i}\xi_{i}\right\}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Support_vector_machine:91">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>β</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i},\beta_{i}\geq 0
  </annotation>
 </semantics>
</math>

.</p>
<figure><b>(Figure)</b>
<embed src="SVM with soft margin.pdf" title="An example for a result of soft-margin SVM"></embed><figcaption>An example for a result of soft-margin SVM</figcaption>
</figure>
<h3 id="dual-form-1">Dual form</h3>

<p>Maximize (in 

<math display="inline" id="Support_vector_machine:92">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 )</p>

<p>

<math display="block" id="Support_vector_machine:93">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>L</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>α</mi>
        <mi>j</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi>j</mi>
       </msub>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>L</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>j</ci>
        </apply>
        <ci>k</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>j</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{L}(\mathbf{\alpha})=\sum_{i=1}^{n}\alpha_{i}-\frac{1}{2}\sum_{i,j}%
\alpha_{i}\alpha_{j}y_{i}y_{j}k(\mathbf{x}_{i},\mathbf{x}_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>subject to (for any 

<math display="inline" id="Support_vector_machine:94">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,n
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:95">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>≤</mo>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo>≤</mo>
    <mi>C</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\alpha_{i}\leq C,\,
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Support_vector_machine:96">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}\alpha_{i}y_{i}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>The key advantage of a linear penalty function is that the slack variables vanish from the dual problem, with the constant <em>C</em> appearing only as an additional constraint on the Lagrange multipliers. For the above formulation and its huge impact in practice, Cortes and Vapnik received the 2008 <a href="Association_for_Computing_Machinery" title="wikilink">ACM</a> <a href="Paris_Kanellakis_Award" title="wikilink">Paris Kanellakis Award</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="uri" href="Nonlinear" title="wikilink">Nonlinear</a> penalty functions have been used, particularly to reduce the effect of outliers on the classifier, but unless care is taken the problem becomes non-convex, and thus it is considerably more difficult to find a global solution.</p>
<h2 id="nonlinear-classification">Nonlinear classification</h2>

<p> The original optimal hyperplane algorithm proposed by Vapnik in 1963 was a <a href="linear_classifier" title="wikilink">linear classifier</a>. However, in 1992, <a href="Bernhard_E._Boser" title="wikilink">Bernhard E. Boser</a>, <a href="Isabelle_M._Guyon" title="wikilink">Isabelle M. Guyon</a> and <a href="Vladimir_N._Vapnik" title="wikilink">Vladimir N. Vapnik</a> suggested a way to create nonlinear classifiers by applying the <a href="kernel_trick" title="wikilink">kernel trick</a> (originally proposed by Aizerman et al.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>) to maximum-margin hyperplanes.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The resulting algorithm is formally similar, except that every <a href="dot_product" title="wikilink">dot product</a> is replaced by a nonlinear <a href="kernel_(integral_operator)" title="wikilink">kernel</a> function. This allows the algorithm to fit the maximum-margin hyperplane in a transformed <a href="feature_space" title="wikilink">feature space</a>. The transformation may be nonlinear and the transformed space high dimensional; thus though the classifier is a hyperplane in the high-dimensional feature space, it may be nonlinear in the original input space.</p>

<p>If the kernel used is a <a class="uri" href="Gaussian" title="wikilink">Gaussian</a> <a href="radial_basis_function" title="wikilink">radial basis function</a>, the corresponding feature space is a <a href="Hilbert_space" title="wikilink">Hilbert space</a> of infinite dimensions. Maximum margin classifiers are well <a href="regularization_(mathematics)" title="wikilink">regularized</a>, and previously it was widely believed that the infinite dimensions do not spoil the results. However, it has been shown that higher dimensions do increase the <a href="generalization_error" title="wikilink">generalization error</a>, although the amount is bounded.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Some common kernels include:</p>
<ul>
<li><a href="Homogeneous_polynomial" title="wikilink">Polynomial (homogeneous)</a>

<math display="block" id="Support_vector_machine:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐣</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>𝐱</mi>
       <mi>𝐢</mi>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>𝐣</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐣</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐣</ci>
      </apply>
     </apply>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(\mathbf{x_{i}},\mathbf{x_{j}})=(\mathbf{x_{i}}\cdot\mathbf{x_{j}})^{d}
  </annotation>
 </semantics>
</math>

</li>
<li><a href="Polynomial_kernel" title="wikilink">Polynomial</a> (inhomogeneous)

<math display="block" id="Support_vector_machine:98">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐣</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐢</mi>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐣</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐣</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐣</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(\mathbf{x_{i}},\mathbf{x_{j}})=(\mathbf{x_{i}}\cdot\mathbf{x_{j}}+1)^{d}
  </annotation>
 </semantics>
</math>

</li>
<li>Gaussian <a href="Radial_basis_function_kernel" title="wikilink">radial basis function</a>

<math display="block" id="Support_vector_machine:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐣</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>γ</mi>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <msub>
           <mi>𝐱</mi>
           <mi>𝐢</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>𝐱</mi>
           <mi>𝐣</mi>
          </msub>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐣</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>𝐢</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>𝐣</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(\mathbf{x_{i}},\mathbf{x_{j}})=\exp(-\gamma\|\mathbf{x_{i}}-\mathbf{x_{j}}\|%
^{2})
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Support_vector_machine:100">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>γ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma>0
  </annotation>
 </semantics>
</math>

. Sometimes parametrized using 

<math display="inline" id="Support_vector_machine:101">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <msup>
     <mi>σ</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=1/{2\sigma^{2}}
  </annotation>
 </semantics>
</math>

</li>
<li><a href="Hyperbolic_function" title="wikilink">Hyperbolic tangent</a>

<math display="block" id="Support_vector_machine:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐣</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>tanh</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>κ</mi>
        <msub>
         <mi>𝐱</mi>
         <mi>𝐢</mi>
        </msub>
       </mrow>
       <mo>⋅</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐣</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐣</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <tanh></tanh>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>κ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>𝐢</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐣</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(\mathbf{x_{i}},\mathbf{x_{j}})=\tanh(\kappa\mathbf{x_{i}}\cdot\mathbf{x_{j}}%
+c)
  </annotation>
 </semantics>
</math>

, for some (not every) 

<math display="inline" id="Support_vector_machine:103">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>κ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Support_vector_machine:104">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c<0
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The kernel is related to the transform 

<math display="inline" id="Support_vector_machine:105">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>𝐢</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>𝐢</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(\mathbf{x_{i}})
  </annotation>
 </semantics>
</math>

 by the equation 

<math display="inline" id="Support_vector_machine:106">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐣</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>𝐢</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>φ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>𝐣</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>𝐣</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>φ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
      </apply>
      <ci>φ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>𝐣</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(\mathbf{x_{i}},\mathbf{x_{j}})=\varphi(\mathbf{x_{i}})\cdot\varphi(\mathbf{x%
_{j}})
  </annotation>
 </semantics>
</math>

. The value <strong>w</strong> is also in the transformed space, with 

<math display="inline" id="Support_vector_machine:107">
 <semantics>
  <mrow>
   <mi>𝐰</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐰</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathbf{w}=\sum_{i}\alpha_{i}y_{i}\varphi(\mathbf{x}_{i})
  </annotation>
 </semantics>
</math>

. Dot products with <strong>w</strong> for classification can again be computed by the kernel trick, i.e. 

<math display="inline" id="Support_vector_machine:108">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐰</mi>
     <mo>⋅</mo>
     <mi>φ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <ci>φ</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>i</ci>
       </apply>
       <ci>𝐱</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathbf{w}\cdot\varphi(\mathbf{x})=\sum_{i}\alpha_{i}y_{i}k(\mathbf{%
x}_{i},\mathbf{x})
  </annotation>
 </semantics>
</math>

. However, there does not in general exist a value <strong>w</strong>' such that 

<math display="inline" id="Support_vector_machine:109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐰</mi>
     <mo>⋅</mo>
     <mi>φ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝐰</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐰</ci>
      <ci>φ</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐰</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>𝐱</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}\cdot\varphi(\mathbf{x})=k(\mathbf{w^{\prime}},\mathbf{x})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>

<p>SVMs belong to a family of generalized <a href="linear_classifier" title="wikilink">linear classifiers</a> and can be interpreted as an extension of the <a class="uri" href="perceptron" title="wikilink">perceptron</a>. They can also be considered a special case of <a href="Tikhonov_regularization" title="wikilink">Tikhonov regularization</a>. A special property is that they simultaneously minimize the empirical <em>classification error</em> and maximize the <em>geometric margin</em>; hence they are also known as <strong>maximum <a href="margin_classifier" title="wikilink">margin classifiers</a></strong>.</p>

<p>A comparison of the SVM to other classifiers has been made by Meyer, Leisch and Hornik.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="parameter-selection">Parameter selection</h3>

<p>The effectiveness of SVM depends on the selection of kernel, the kernel's parameters, and soft margin parameter C. A common choice is a Gaussian kernel, which has a single parameter <em>

<math display="inline" id="Support_vector_machine:110">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

</em>. The best combination of <em>C</em> and <em>

<math display="inline" id="Support_vector_machine:111">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

</em> is often selected by a <a href="grid_search" title="wikilink">grid search</a> with exponentially growing sequences of <em>C</em> and <em>

<math display="inline" id="Support_vector_machine:112">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

</em>, for example, 

<math display="inline" id="Support_vector_machine:113">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>5</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mn>13</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mn>15</mn>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>C</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">5</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">13</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">15</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\in\{2^{-5},2^{-3},\dots,2^{13},2^{15}\}
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Support_vector_machine:114">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>15</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>13</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mn>1</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">15</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">13</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in\{2^{-15},2^{-13},\dots,2^{1},2^{3}\}
  </annotation>
 </semantics>
</math>

. Typically, each combination of parameter choices is checked using <a href="Cross-validation_(statistics)" title="wikilink">cross validation</a>, and the parameters with best cross-validation accuracy are picked. Alternatively, recent work in <a href="Bayesian_optimization" title="wikilink">Bayesian optimization</a> can be used to select <em>C</em> and <em>

<math display="inline" id="Support_vector_machine:115">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

</em> , often requiring the evaluation of far fewer parameter combinations than grid search. The final model, which is used for testing and for classifying new data, is then trained on the whole training set using the selected parameters.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="issues">Issues</h3>

<p>Potential drawbacks of the SVM are the following three aspects:</p>
<ul>
<li>Uncalibrated <a href="class_membership_probabilities" title="wikilink">class membership probabilities</a></li>
<li>The SVM is only directly applicable for two-class tasks. Therefore, algorithms that reduce the multi-class task to several binary problems have to be applied; see the multi-class SVM section.</li>
<li>Parameters of a solved model are difficult to interpret.</li>
</ul>
<h2 id="extensions">Extensions</h2>
<h3 id="multiclass-svm">Multiclass SVM</h3>

<p>Multiclass SVM aims to assign labels to instances by using support vector machines, where the labels are drawn from a finite set of several elements.</p>

<p>The dominant approach for doing so is to reduce the single <a href="multiclass_problem" title="wikilink">multiclass problem</a> into multiple <a href="binary_classification" title="wikilink">binary classification</a> problems.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Common methods for such reduction include:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<ul>
<li>Building binary classifiers which distinguish between (i) one of the labels and the rest (<em>one-versus-all</em>) or (ii) between every pair of classes (<em>one-versus-one</em>). Classification of new instances for the one-versus-all case is done by a winner-takes-all strategy, in which the classifier with the highest output function assigns the class (it is important that the output functions be calibrated to produce comparable scores). For the one-versus-one approach, classification is done by a max-wins voting strategy, in which every classifier assigns the instance to one of the two classes, then the vote for the assigned class is increased by one vote, and finally the class with the most votes determines the instance classification.</li>
<li><a href="Directed_acyclic_graph" title="wikilink">Directed acyclic graph</a> SVM (DAGSVM)<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li>Error-correcting output codes<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>

<p>Crammer and Singer proposed a multiclass SVM method which casts the multiclass classification problem into a single optimization problem, rather than decomposing it into multiple binary classification problems.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> See also Lee, Lin and Wahba.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="transductive-support-vector-machines">Transductive support vector machines</h3>

<p>Transductive support vector machines extend SVMs in that they could also treat partially labeled data in <a href="semi-supervised_learning" title="wikilink">semi-supervised learning</a> by following the principles of <a href="Transduction_(machine_learning)" title="wikilink">transduction</a>. Here, in addition to the training set 

<math display="inline" id="Support_vector_machine:116">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

, the learner is also given a set</p>

<p>

<math display="block" id="Support_vector_machine:117">
 <semantics>
  <mrow>
   <msup>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    <mo>⋆</mo>
   </msup>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msubsup>
     <mrow>
      <mo stretchy="false">{</mo>
      <msubsup>
       <mi>𝐱</mi>
       <mi>i</mi>
       <mo>⋆</mo>
      </msubsup>
      <mo stretchy="false">|</mo>
      <mrow>
       <msubsup>
        <mi>𝐱</mi>
        <mi>i</mi>
        <mo>⋆</mo>
       </msubsup>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>p</mi>
       </msup>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝒟</ci>
     <ci>normal-⋆</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐱</ci>
         <ci>normal-⋆</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐱</ci>
          <ci>normal-⋆</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ℝ</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}^{\star}=\{\mathbf{x}^{\star}_{i}|\mathbf{x}^{\star}_{i}\in\mathbb{%
R}^{p}\}_{i=1}^{k}\,
  </annotation>
 </semantics>
</math>

</p>

<p>of test examples to be classified. Formally, a transductive support vector machine is defined by the following primal optimization problem:<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>Minimize (in 

<math display="inline" id="Support_vector_machine:118">
 <semantics>
  <mrow>
   <mi>𝐰</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <msup>
    <mi>𝐲</mi>
    <mo>⋆</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐰</ci>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐲</ci>
     <ci>normal-⋆</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{w},b,\mathbf{y^{\star}}}
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:119">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mi>𝐰</mi>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>𝐰</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\|\mathbf{w}\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>subject to (for any 

<math display="inline" id="Support_vector_machine:120">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,n
  </annotation>
 </semantics>
</math>

 and any 

<math display="inline" id="Support_vector_machine:121">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\dots,k
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Support_vector_machine:122">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>𝐰</mi>
        <mo>⋅</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>𝐢</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>𝐰</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>𝐢</ci>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(\mathbf{w}\cdot\mathbf{x_{i}}-b)\geq 1,\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Support_vector_machine:123">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>y</mi>
      <mi>j</mi>
      <mo>⋆</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>𝐰</mi>
        <mo>⋅</mo>
        <msubsup>
         <mi>𝐱</mi>
         <mi>𝐣</mi>
         <mo>⋆</mo>
        </msubsup>
       </mrow>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-⋆</ci>
      </apply>
      <ci>j</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>𝐰</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐱</ci>
         <ci>normal-⋆</ci>
        </apply>
        <ci>𝐣</ci>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\star}_{j}(\mathbf{w}\cdot\mathbf{x^{\star}_{j}}-b)\geq 1,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Support_vector_machine:124">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>y</mi>
     <mi>j</mi>
     <mo>⋆</mo>
    </msubsup>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-⋆</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\star}_{j}\in\{-1,1\}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Transductive support vector machines were introduced by Vladimir N. Vapnik in 1998.</p>
<h3 id="structured-svm">Structured SVM</h3>

<p>SVMs have been generalized to <a href="structured_SVM" title="wikilink">structured SVMs</a>, where the label space is structured and of possibly infinite size.</p>
<h3 id="regression">Regression</h3>

<p>A version of SVM for <a href="regression_analysis" title="wikilink">regression</a> was proposed in 1996 by <a href="Vladimir_N._Vapnik" title="wikilink">Vladimir N. Vapnik</a>, Harris Drucker, Christopher J. C. Burges, Linda Kaufman and Alexander J. Smola.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> This method is called support vector regression (SVR). The model produced by support vector classification (as described above) depends only on a subset of the training data, because the cost function for building the model does not care about training points that lie beyond the margin. Analogously, the model produced by SVR depends only on a subset of the training data, because the cost function for building the model ignores any training data close to the model prediction. Another SVM version known as <a href="least_squares_support_vector_machine" title="wikilink">least squares support vector machine</a> (LS-SVM) has been proposed by Suykens and Vandewalle.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Training the original SVR means solving<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<dl>
<dd>minimize 

<math display="inline" id="Support_vector_machine:125">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mi>w</mi>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>w</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\|w\|^{2}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to <math>\begin{cases}
</math></dd>
</dl>

<p><code>                   y_i - \langle w, x_i \rangle  - b \le \epsilon  \\</code><br/>
<code>                   \langle w, x_i \rangle + b - y_i \le \epsilon</code><br/>
<code>                 \end{cases}</code></p>

<p>where 

<math display="inline" id="Support_vector_machine:126">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is a training sample with target value 

<math display="inline" id="Support_vector_machine:127">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

. The inner product plus intercept 

<math display="inline" id="Support_vector_machine:128">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>w</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <list>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </list>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle w,x_{i}\rangle+b
  </annotation>
 </semantics>
</math>

 is the prediction for that sample, and 

<math display="inline" id="Support_vector_machine:129">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is a free parameter that serves as a threshold: all predictions have to be within an 

<math display="inline" id="Support_vector_machine:130">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 range of the true predictions. Slack variables are usually added into the above to allow for errors and to allow approximation in the case the above problem is infeasible.</p>
<h2 id="interpreting-svm-models">Interpreting SVM models</h2>

<p>The SVM algorithm has been widely applied in the biological and other sciences. Permutation tests based on SVM weights have been suggested as a mechanism for interpretation of SVM models.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Support vector machine weights have also been used to interpret SVM models in the past.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Posthoc interpretation of support vector machine models in order to identify features used by the model to make predictions is a relatively new area of research with special significance in the biological sciences.</p>
<h2 id="implementation">Implementation</h2>

<p>The parameters of the maximum-margin hyperplane are derived by solving the optimization. There exist several specialized algorithms for quickly solving the <a href="quadratic_programming" title="wikilink">QP</a> problem that arises from SVMs, mostly relying on heuristics for breaking the problem down into smaller, more-manageable chunks. A common method is Platt's <a href="sequential_minimal_optimization" title="wikilink">sequential minimal optimization</a> (SMO) <a class="uri" href="algorithm" title="wikilink">algorithm</a>, which breaks the problem down into 2-dimensional sub-problems that may be solved analytically, eliminating the need for a numerical optimization algorithm.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Another approach is to use an <a href="interior_point_method" title="wikilink">interior point method</a> that uses <a href="Newton's_method" title="wikilink">Newton</a>-like iterations to find a solution of the <a href="Karush–Kuhn–Tucker_conditions" title="wikilink">Karush–Kuhn–Tucker conditions</a> of the primal and dual problems.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Instead of solving a sequence of broken down problems, this approach directly solves the problem altogether. To avoid solving a linear system involving the large kernel matrix, a low rank approximation to the matrix is often used in the kernel trick.</p>

<p>The special case of linear support vector machines can be solved more efficiently by the same kind of algorithms used to optimize its close cousin, <a href="logistic_regression" title="wikilink">logistic regression</a>; this class of algorithms includes <a href="Stochastic_gradient_descent" title="wikilink">sub-gradient descent</a> (e.g., PEGASOS<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a>) and <a href="coordinate_descent" title="wikilink">coordinate descent</a> (e.g., LIBLINEAR<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a>). LIBLINEAR has some attractive training time properties. Each convergence iteration takes time linear in the time taken to read the train data and the iterations also have a <a href="Rate_of_convergence" title="wikilink">Q-Linear Convergence</a> property, making the algorithm extremely fast.</p>

<p>The general kernel SVMs can also be solved more efficiently using <a href="Stochastic_gradient_descent" title="wikilink">sub-gradient descent</a> (e.g. P-packSVM<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a>), especially when parallelization is allowed.</p>

<p>Kernel SVMs are available in many machine learning toolkits, including <a class="uri" href="LIBSVM" title="wikilink">LIBSVM</a>, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, <a href="http://support.sas.com/documentation/cdl/en/whatsnew/64209/HTML/default/viewer.htm#emdocwhatsnew71.htm">SAS</a>, SVMlight, <a href="http://cran.r-project.org/package=kernlab">kernlab</a>, <a class="uri" href="scikit-learn" title="wikilink">scikit-learn</a>, <a href="Shogun_(toolbox)" title="wikilink">Shogun</a>, <a href="Weka_(machine_learning)" title="wikilink">Weka</a>, <a href="http://image.diku.dk/shark/">Shark</a>, <a href="https://mloss.org/software/view/409/">JKernelMachines</a> and others.</p>
<h2 id="applications">Applications</h2>

<p>SVMs can be used to solve various real world problems:</p>
<ul>
<li>SVMs are helpful in text and hypertext categorization as their application can significantly reduce the need for labeled training instances in both the standard inductive and transductive settings.</li>
<li>Classification of images can also be performed using SVMs. Experimental results show that SVMs achieve significantly higher search accuracy than traditional query refinement schemes after just three to four rounds of relevance feedback. </li>
<li>SVMs are also useful in medical science to classify proteins with up to 90% of the compounds classified correctly.</li>
<li>Hand-written characters can be recognized using SVM.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="In_situ_adaptive_tabulation" title="wikilink">In situ adaptive tabulation</a></li>
<li><a href="Kernel_machines" title="wikilink">Kernel machines</a></li>
<li><a href="Fisher_kernel" title="wikilink">Fisher kernel</a></li>
<li><a href="Platt_scaling" title="wikilink">Platt scaling</a></li>
<li><a href="Polynomial_kernel" title="wikilink">Polynomial kernel</a></li>
<li><a href="Predictive_analytics" title="wikilink">Predictive analytics</a></li>
<li><a href="Regularization_perspectives_on_support_vector_machines" title="wikilink">Regularization perspectives on support vector machines</a></li>
<li><a href="Relevance_vector_machine" title="wikilink">Relevance vector machine</a>, a probabilistic sparse kernel model identical in functional form to SVM</li>
<li><a href="Sequential_minimal_optimization" title="wikilink">Sequential minimal optimization</a></li>
<li><a href="Winnow_(algorithm)" title="wikilink">Winnow (algorithm)</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.support-vector.net">www.support-vector.net</a> The key book about the method, "An Introduction to Support Vector Machines" with online software</li>
<li>Burges, Christopher J. C.; <a href="http://research.microsoft.com/en-us/um/people/cburges/papers/svmtutorial.pdf">A Tutorial on Support Vector Machines for Pattern Recognition</a>, Data Mining and Knowledge Discovery 2:121–167, 1998</li>
<li><a href="http://www.kernel-machines.org">www.kernel-machines.org</a> <em>(general information and collection of research papers)</em></li>
<li><a href="http://www.support-vector-machines.org">www.support-vector-machines.org</a> <em>(Literature, Review, Software, Links related to Support Vector Machines — Academic Site)</em></li>
<li><a href="http://videolectures.net/Top/Computer_Science/Machine_Learning/Kernel_Methods/Support_Vector_Machines/">videolectures.net</a> <em>(SVM-related video lectures)</em></li>
<li>Karatzoglou, Alexandros et al.; <a href="http://www.jstatsoft.org/v15/i09/paper">Support Vector Machines in R</a>, Journal of Statistical Software April 2006, Volume 15, Issue 9.</li>
<li><a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">libsvm</a> <a class="uri" href="LIBSVM" title="wikilink">LIBSVM</a> is a popular library of SVM learners</li>
<li><a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/">liblinear</a> liblinear is a library for large linear classification including some SVMs</li>
<li><a href="http://shark-project.sourceforge.net">Shark</a> Shark is a C++ machine learning library implementing various types of SVMs</li>
<li><a href="http://dlib.net/ml.html">dlib</a> dlib is a C++ library for working with kernel methods and SVMs</li>
<li><a href="http://svmlight.joachims.org">SVM light</a> is a collection of software tools for learning and classification using SVM.</li>
<li><a href="http://cs.stanford.edu/people/karpathy/svmjs/demo/">SVMJS live demo</a> is a GUI demo for Javascript implementation of SVMs</li>
<li><a href="https://github.com/nickgillian/grt">Gesture Recognition Toolkit</a> contains an easy to use wrapper for <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">libsvm</a></li>
</ul>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>Theodoridis, Sergios; and Koutroumbas, Konstantinos; "Pattern Recognition", 4th Edition, Academic Press, 2009, ISBN 978-1-59749-272-0</li>
<li>Cristianini, Nello; and Shawe-Taylor, John; <em>An Introduction to Support Vector Machines and other kernel-based learning methods</em>, Cambridge University Press, 2000. ISBN 0-521-78019-5 <em>(<a href="http://www.support-vector.net">1</a> SVM Book)</em></li>
<li>Huang, Te-Ming; Kecman, Vojislav; and Kopriva, Ivica (2006); <em>Kernel Based Algorithms for Mining Huge Data Sets</em>, in <em>Supervised, Semi-supervised, and Unsupervised Learning</em>, Springer-Verlag, Berlin, Heidelberg, 260 pp. 96 illus., Hardcover, ISBN 3-540-31681-7 <a href="http://learning-from-data.com">2</a></li>
<li>Kecman, Vojislav; <em>Learning and Soft Computing — Support Vector Machines, Neural Networks, Fuzzy Logic Systems</em>, The MIT Press, Cambridge, MA, 2001.<a href="http://www.support-vector.ws">3</a></li>
<li>Schölkopf, Bernhard; and Smola, Alexander J.; <em>Learning with Kernels</em>, MIT Press, Cambridge, MA, 2002. ISBN 0-262-19475-9</li>
<li>Schölkopf, Bernhard; Burges, Christopher J. C.; and Smola, Alexander J. (editors); <em>Advances in Kernel Methods: Support Vector Learning</em>, MIT Press, Cambridge, MA, 1999. ISBN 0-262-19416-3. <a href="http://www.kernel-machines.org/nips97/book.html">4</a></li>
<li>Shawe-Taylor, John; and Cristianini, Nello; <em>Kernel Methods for Pattern Analysis</em>, Cambridge University Press, 2004. ISBN 0-521-81397-2 <em>(<a href="http://www.kernel-methods.net">5</a> Kernel Methods Book)</em></li>
<li>Steinwart, Ingo; and Christmann, Andreas; <em>Support Vector Machines</em>, Springer-Verlag, New York, 2008. ISBN 978-0-387-77241-7 <em>(<a href="http://www.staff.uni-bayreuth.de/~btms01/svm.html">6</a> SVM Book)</em></li>
<li>Tan, Peter Jing; and <a href="http://www.csse.monash.edu.au/~dld">Dowe, David L.</a> (2004); <a href="http://www.csse.monash.edu.au/~dld/David.Dowe.publications.html#TanDowe2004"><em>MML Inference of Oblique Decision Trees</em></a>, Lecture Notes in Artificial Intelligence (LNAI) 3339, Springer-Verlag, <a href="http://www.csse.monash.edu.au/~dld/Publications/2004/Tan+DoweAI2004.pdf">pp1082-1088</a>. (This paper uses <a href="minimum_message_length" title="wikilink">minimum message length</a> (<a href="Minimum_Message_Length" title="wikilink">MML</a>) and actually incorporates probabilistic support vector machines in the leaves of <a href="Decision_tree_learning" title="wikilink">decision trees</a>.)</li>
<li>Vapnik, Vladimir N.; <em>The Nature of Statistical Learning Theory</em>, Springer-Verlag, 1995. ISBN 0-387-98780-0</li>
<li>Vapnik, Vladimir N.; and Kotz, Samuel; <em>Estimation of Dependences Based on Empirical Data</em>, Springer, 2006. ISBN 0-387-30865-2, 510 pages [this is a reprint of Vapnik's early book describing philosophy behind SVM approach. The 2006 Appendix describes recent development].</li>
<li>Fradkin, Dmitriy; and Muchnik, Ilya; <em>Support Vector Machines for Classification</em> in Abello, J.; and Carmode, G. (Eds); <em>Discrete Methods in Epidemiology</em>, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, volume 70, pp. 13–20, 2006. <a href="http://paul.rutgers.edu/~dfradkin/papers/svm.pdf">7</a>. Succinctly describes theoretical ideas behind SVM.</li>
<li>Bennett, Kristin P.; and Campbell, Colin; <em>Support Vector Machines: Hype or Hallelujah?</em>, SIGKDD Explorations, 2, 2, 2000, 1–13. <a href="http://www.acm.org/sigs/sigkdd/explorations/issue2-2/bennett.pdf">8</a>. Excellent introduction to SVMs with helpful figures.</li>
<li>Ivanciuc, Ovidiu; <em>Applications of Support Vector Machines in Chemistry</em>, in <em>Reviews in Computational Chemistry</em>, Volume 23, 2007, pp. 291–400. Reprint available: <a href="http://www.ivanciuc.org/Files/Reprint/Ivanciuc_SVM_CCR_2007_23_291.pdf">9</a></li>
<li>Catanzaro, Bryan; Sundaram, Narayanan; and Keutzer, Kurt; <em>Fast Support Vector Machine Training and Classification on Graphics Processors</em>, in <em>International Conference on Machine Learning</em>, 2008 <a href="http://www.eecs.berkeley.edu/~catanzar/icml2008.pdf">10</a></li>
<li>Campbell, Colin; and Ying, Yiming; <em>Learning with Support Vector Machines</em>, 2011, Morgan and Claypool. ISBN 978-1-60845-616-1. <em><a href="http://www.morganclaypool.com/doi/abs/10.2200/S00324ED1V01Y201102AIM010">11</a></em></li>
</ul>

<p>"</p>

<p><a href="Category:Support_vector_machines" title="wikilink"> </a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Statistical_classification" title="wikilink">Category:Statistical classification</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2">*<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">ACM Website, Press release of March 17th 2009. <a class="uri" href="http://www.acm.org/press-room/news-releases/awards-08-groupa">http://www.acm.org/press-room/news-releases/awards-08-groupa</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20">Joachims, Thorsten; "Transductive Inference for Text Classification using Support Vector Machines", Proceedings of the 1999 International Conference on Machine Learning (ICML 1999), pp. 200-209.<a href="#fnref20">↩</a></li>
<li id="fn21">Drucker, Harris; Burges, Christopher J. C.; Kaufman, Linda; Smola, Alexander J.; and Vapnik, Vladimir N. (1997); "Support Vector Regression Machines", in <em>Advances in Neural Information Processing Systems 9, NIPS 1996</em>, 155–161, MIT Press.<a href="#fnref21">↩</a></li>
<li id="fn22">Suykens, Johan A. K.; Vandewalle, Joos P. L.; <em>Least squares support vector machine classifiers</em>, Neural Processing Letters, vol. 9, no. 3, Jun. 1999, pp. 293–300.<a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24">Bilwaj Gaonkar, Christos Davatzikos Analytic estimation of statistical significance maps for support vector machine based multi-variate image analysis and classification<a href="#fnref24">↩</a></li>
<li id="fn25">R. Cuingnet, C. Rosso, M. Chupin, S. Lehéricy, D. Dormont, H. Benali, Y. Samson and O. Colliot, Spatial regularization of SVM for the detection of diffusion alterations associated with stroke outcome, Medical Image Analysis, 2011, 15 (5): 729-737<a href="#fnref25">↩</a></li>
<li id="fn26">Statnikov, A., Hardin, D., &amp; Aliferis, C. (2006). Using SVM weight-based methods to identify causally relevant and non-causally relevant variables. sign, 1, 4.<a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
</ol>
</section>
</body>
</html>
