<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1420">Linear programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear programming</h1>
<hr/>

<p> </p>

<p><strong>Linear programming</strong> (<strong>LP</strong>; also called <strong>linear optimization</strong>) is a method to achieve the best outcome (such as maximum profit or lowest cost) in a <a href="mathematical_model" title="wikilink">mathematical model</a> whose requirements are represented by linear relationships. Linear programming is a special case of mathematical programming (<a href="mathematical_optimization" title="wikilink">mathematical optimization</a>).</p>

<p>More formally, linear programming is a technique for the <a href="mathematical_optimization" title="wikilink">optimization</a> of a <a class="uri" href="linear" title="wikilink">linear</a> <a href="objective_function" title="wikilink">objective function</a>, subject to <a href="linear_equality" title="wikilink">linear equality</a> and <a href="linear_inequality" title="wikilink">linear inequality</a> <a href="Constraint_(mathematics)" title="wikilink">constraints</a>. Its <a href="feasible_region" title="wikilink">feasible region</a> is a <a href="convex_polytope" title="wikilink">convex polytope</a>, which is a set defined as the <a href="intersection_(mathematics)" title="wikilink">intersection</a> of finitely many <a href="Half-space_(geometry)" title="wikilink">half spaces</a>, each of which is defined by a linear inequality. Its objective function is a <a href="real_number" title="wikilink">real</a>-valued <a href="affine_function" title="wikilink">affine function</a> defined on this polyhedron. A linear programming <a class="uri" href="algorithm" title="wikilink">algorithm</a> finds a point in the polyhedron where this function has the smallest (or largest) value if such a point exists.</p>

<p>Linear programs are problems that can be expressed in <a href="canonical_form" title="wikilink">canonical form</a>:</p>

<p>

<math display="inline" id="Linear_programming:0">
 <semantics>
  <mrow>
   <msup>
    <mi>ùêú</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
   <mi>ùê±</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêú</ci>
     <ci>normal-T</ci>
    </apply>
    <ci>ùê±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{c}^{\mathrm{T}}\mathbf{x}
  </annotation>
 </semantics>
</math>


 where <strong>x</strong> represents the vector of variables (to be determined), <strong>c</strong> and <strong>b</strong> are <a href="vector_space" title="wikilink">vectors</a> of (known) coefficients, <em>A</em> is a (known) <a href="Matrix_(mathematics)" title="wikilink">matrix</a> of coefficients, and 

<math display="inline" id="Linear_programming:1">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚ãÖ</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-‚ãÖ</ci>
    <ci>normal-T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\cdot)^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

 is the <a href="matrix_transpose" title="wikilink">matrix transpose</a>. The expression to be maximized or minimized is called the <em>objective function</em> (<strong>c</strong><sup>T</sup><strong>x</strong> in this case). The inequalities <em>A</em><strong>x</strong>¬†‚â§¬†<strong>b</strong> and <strong>x</strong> ‚â• <strong>0</strong> are the constraints which specify a <a href="convex_polytope" title="wikilink">convex polytope</a> over which the objective function is to be optimized. In this context, two vectors are <a href="Comparability" title="wikilink">comparable</a> when they have the same dimensions. If every entry in the first is less-than or equal-to the corresponding entry in the second then we can say the first vector is less-than or equal-to the second vector.</p>

<p>Linear programming can be applied to various fields of study. It is used in business and <a class="uri" href="economics" title="wikilink">economics</a>, but can also be utilized for some engineering problems. Industries that use linear programming models include transportation, energy, telecommunications, and manufacturing. It has proved useful in modeling diverse types of problems in planning, <a class="uri" href="routing" title="wikilink">routing</a>, <a href="scheduling_(production_processes)" title="wikilink">scheduling</a>, <a href="assignment_problem" title="wikilink">assignment</a>, and design.</p>
<h2 id="history">History</h2>

<p> The problem of solving a system of linear inequalities dates back at least as far as <a href="Joseph_Fourier" title="wikilink">Fourier</a>, who in 1827 published a method for solving them,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and after whom the method of <a href="Fourier‚ÄìMotzkin_elimination" title="wikilink">Fourier‚ÄìMotzkin elimination</a> is named.</p>

<p>The first linear programming formulation of a problem that is equivalent to the general linear programming problem was given by <a href="Leonid_Kantorovich" title="wikilink">Leonid Kantorovich</a> in 1939, who also proposed a method for solving it.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> He developed it during <a href="World_War_II" title="wikilink">World War II</a> as a way to plan expenditures and returns so as to reduce costs to the army and increase losses incurred by the enemy. About the same time as Kantorovich, the Dutch-American economist <a href="Tjalling_Koopmans" title="wikilink">T. C. Koopmans</a> formulated classical economic problems as linear programs. Kantorovich and Koopmans later shared the 1975 <a href="Nobel_prize_in_economics" title="wikilink">Nobel prize in economics</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In 1941, <a href="Frank_Lauren_Hitchcock" title="wikilink">Frank Lauren Hitchcock</a> also formulated transportation problems as linear programs and gave a solution very similar to the later Simplex method;<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Hitchcock had died in 1957 and the Nobel prize is not awarded posthumously.</p>

<p>During 1946-1947, <a href="George_Dantzig" title="wikilink">George B. Dantzig</a> independently developed general linear programming formulation to use for planning problems in US Air Force. In 1947, Dantzig also invented the <a href="Simplex_algorithm" title="wikilink">simplex method</a> that for the first time efficiently tackled the linear programming problem in most cases. When Dantzig arranged meeting with <a href="John_von_Neumann" title="wikilink">John von Neumann</a> to discuss his Simplex method, Neumann immediately conjectured the theory of <a href="#Duality" title="wikilink">duality</a> by realizing that the problem he had been working in <a href="game_theory" title="wikilink">game theory</a> was equivalent. Dantzig provided formal proof in an unpublished report "A Theorem on Linear Inequalities" on January 5, 1948.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Postwar, many industries found its use in their daily planning.</p>

<p>Dantzig's original example was to find the best assignment of 70 people to 70 jobs. The computing power required to test all the permutations to select the best assignment is vast; the number of possible configurations exceeds the number of particles in the observable universe. However, it takes only a moment to find the optimum solution by posing the problem as a linear program and applying the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a>. The theory behind linear programming drastically reduces the number of possible solutions that must be checked.</p>

<p>The linear-programming problem was first shown to be solvable in polynomial time by <a href="Leonid_Khachiyan" title="wikilink">Leonid Khachiyan</a> in 1979, but a larger theoretical and practical breakthrough in the field came in 1984 when <a href="Narendra_Karmarkar" title="wikilink">Narendra Karmarkar</a> introduced a new <a href="interior-point_method" title="wikilink">interior-point method</a> for solving linear-programming problems.</p>
<h2 id="uses">Uses</h2>

<p>Linear programming is a considerable field of optimization for several reasons. Many practical problems in <a href="operations_research" title="wikilink">operations research</a> can be expressed as linear programming problems. Certain special cases of linear programming, such as <em>network flow</em> problems and <em>multicommodity flow</em> problems are considered important enough to have generated much research on specialized algorithms for their solution. A number of algorithms for other types of optimization problems work by solving LP problems as sub-problems. Historically, ideas from linear programming have inspired many of the central concepts of optimization theory, such as <em>duality,</em> <em>decomposition,</em> and the importance of <em>convexity</em> and its generalizations. Likewise, linear programming is heavily used in <a class="uri" href="microeconomics" title="wikilink">microeconomics</a> and company management, such as planning, production, transportation, technology and other issues. Although the modern management issues are ever-changing, most companies would like to maximize profits or minimize costs with limited resources. Therefore, many issues can be characterized as linear programming problems.</p>
<h2 id="standard-form">Standard form</h2>

<p><em>Standard form</em> is the usual and most intuitive form of describing a linear programming problem. It consists of the following three parts:</p>
<ul>
<li>A <strong>linear function to be maximized</strong></li>
</ul>
<dl>
<dd>e.g. 

<math display="inline" id="Linear_programming:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},x_{2})=c_{1}x_{1}+c_{2}x_{2}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li><strong>Problem constraints</strong> of the following form</li>
</ul>
<dl>
<dd>e.g.

<p>:<math>\begin{matrix}</math></p>
</dd>
</dl>

<p><code>¬†a_{11}¬†x_1¬†+¬†a_{12}¬†x_2¬†&amp;\leq¬†b_1¬†\\</code><br/>
<code>¬†a_{21}¬†x_1¬†+¬†a_{22}¬†x_2¬†&amp;\leq¬†b_2¬†\\</code><br/>
<code>¬†a_{31}¬†x_1¬†+¬†a_{32}¬†x_2¬†&amp;\leq¬†b_3¬†\\</code></p>

<p>\end{matrix}</p>
<ul>
<li><strong>Non-negative variables</strong></li>
</ul>
<dl>
<dd>e.g.

<p>:<math>\begin{matrix}</math></p>
</dd>
</dl>

<p><code>x_1¬†\geq¬†0¬†\\</code><br/>
<code>x_2¬†\geq¬†0</code></p>

<p>\end{matrix}</p>

<p>The problem is usually expressed in <em><a href="Matrix_(mathematics)" title="wikilink">matrix</a> form</em>, and then becomes:</p>

<p>

<math display="block" id="Linear_programming:3">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>c</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <mpadded width="+2.8pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt" stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>‚â§</mo>
     <mrow>
      <mi>b</mi>
      <mi mathvariant="italic">and</mi>
      <mi>x</mi>
     </mrow>
     <mo>‚â•</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>normal-T</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>italic- and</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\{c^{\mathrm{T}}x\;|\;Ax\leq b\and x\geq 0\}
  </annotation>
 </semantics>
</math>

</p>

<p>Other forms, such as minimization problems, problems with constraints on alternative forms, as well as problems involving negative <a href="variable_(programming)" title="wikilink">variables</a> can always be rewritten into an equivalent problem in standard form.</p>
<h3 id="example">Example</h3>

<p>Suppose that a farmer has a piece of farm land, say <em>L</em> km<sup>2</sup>, to be planted with either wheat or barley or some combination of the two. The farmer has a limited amount of fertilizer, <em>F</em> kilograms, and insecticide, <em>P</em> kilograms. Every square kilometer of wheat requires <em>F</em><sub>1</sub> kilograms of fertilizer and <em>P</em><sub>1</sub> kilograms of insecticide, while every square kilometer of barley requires <em>F</em><sub>2</sub> kilograms of fertilizer and <em>P</em><sub>2</sub> kilograms of insecticide. Let S<sub>1</sub> be the selling price of wheat per square kilometer, and S<sub>2</sub> be the selling price of barley. If we denote the area of land planted with wheat and barley by <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub> respectively, then profit can be maximized by choosing optimal values for <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub>. This problem can be expressed with the following linear programming problem in the standard form:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Maximize

<math display="block" id="Linear_programming:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}\cdot x_{1}+S_{2}\cdot x_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>(maximize the revenue‚Äîrevenue is the "objective function")</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Subject to:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>‚â§</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}+x_{2}\leq L
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>1</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>2</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}\cdot x_{1}+F_{2}\cdot x_{2}\leq F
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}\cdot x_{1}+P_{2}\cdot x_{2}\leq P
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\geq 0,x_{2}\geq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Which in matrix form becomes:</p>
<dl>
<dd>maximize 

<math display="inline" id="Linear_programming:9">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>S</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>S</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}S_{1}&S_{2}\end{bmatrix}\begin{bmatrix}x_{1}\\
x_{2}\end{bmatrix}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Linear_programming:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>F</mi>
           <mn>1</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>F</mi>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>P</mi>
           <mn>1</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>P</mi>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mrow>
       <mo>[</mo>
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo>‚â§</mo>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mi>L</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>F</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>P</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mo>‚â•</mo>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <matrix>
      <matrixrow>
       <ci>L</ci>
      </matrixrow>
      <matrixrow>
       <ci>F</ci>
      </matrixrow>
      <matrixrow>
       <ci>P</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <geq></geq>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&1\\
F_{1}&F_{2}\\
P_{1}&P_{2}\end{bmatrix}\begin{bmatrix}x_{1}\\
x_{2}\end{bmatrix}\leq\begin{bmatrix}L\\
F\\
P\end{bmatrix},\,\begin{bmatrix}x_{1}\\
x_{2}\end{bmatrix}\geq\begin{bmatrix}0\\
0\end{bmatrix}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h2 id="augmented-form-slack-form">Augmented form (slack form)</h2>

<p>Linear programming problems can be converted into an <em>augmented form</em> in order to apply the common form of the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a>. This form introduces non-negative <em><a href="slack_variable" title="wikilink">slack variables</a></em> to replace inequalities with equalities in the constraints. The problems can then be written in the following <a href="block_matrix" title="wikilink">block matrix</a> form:</p>
<dl>
<dd>Maximize <em>Z</em>:
</dd>
<dd><math>
</math></dd>
</dl>

<p><code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†1¬†&amp;¬†-\mathbf{c}^T¬†&amp;¬†0¬†\\</code><br/>
<code>¬†¬†¬†0¬†&amp;¬†\mathbf{A}¬†&amp;¬†\mathbf{I}</code><br/>
<code>¬†\end{bmatrix}</code><br/>
<code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†Z¬†\\¬†\mathbf{x}¬†\\¬†\mathbf{x}_s</code><br/>
<code>¬†\end{bmatrix}¬†=</code><br/>
<code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†0¬†\\¬†\mathbf{b}</code><br/>
<code>¬†\end{bmatrix}</code></p>

<p></p>
<dl>
<dd><big><strong>x</strong>, <strong>x</strong><sub>s</sub> ‚â• 0</big>
</dd>
</dl>

<p>where <strong>x</strong><sub>s</sub> are the newly introduced slack variables, and <em>Z</em> is the variable to be maximized.</p>
<h3 id="example-1">Example</h3>

<p>The example above is converted into the following augmented form:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Maximize

<math display="block" id="Linear_programming:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}\cdot x_{1}+S_{2}\cdot x_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>(objective function)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Subject to:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}+x_{2}+x_{3}=L
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>1</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>2</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mn>4</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}\cdot x_{1}+F_{2}\cdot x_{2}+x_{4}=F
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mn>5</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}\cdot x_{1}+P_{2}\cdot x_{2}+x_{5}=P
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>5</mn>
    </msub>
   </mrow>
   <mo>‚â•</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2},x_{3},x_{4},x_{5}\geq 0
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
</tbody>
</table>

<p>where 

<math display="inline" id="Linear_programming:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>4</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>5</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3},x_{4},x_{5}
  </annotation>
 </semantics>
</math>

 are (non-negative) slack variables, representing in this example the unused area, the amount of unused fertilizer, and the amount of unused insecticide.</p>

<p>In matrix form this becomes:</p>
<dl>
<dd>Maximize <em>Z</em>:
</dd>
<dd><math>
</math></dd>
</dl>

<p><code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†1¬†&amp;¬†-S_1¬†&amp;¬†-S_2¬†&amp;¬†0¬†&amp;¬†0¬†&amp;¬†0¬†\\</code><br/>
<code>¬†¬†¬†0¬†&amp;¬†¬†¬†1¬†¬†¬†¬†&amp;¬†¬†¬†1¬†¬†¬†¬†&amp;¬†1¬†&amp;¬†0¬†&amp;¬†0¬†\\</code><br/>
<code>¬†¬†¬†0¬†&amp;¬†¬†F_1¬†¬†&amp;¬†¬†F_2¬†¬†&amp;¬†0¬†&amp;¬†1¬†&amp;¬†0¬†\\</code><br/>
<code>¬†¬†¬†0¬†&amp;¬†¬†P_1¬†¬†¬†¬†&amp;¬†P_2¬†&amp;¬†0¬†&amp;¬†0¬†&amp;¬†1¬†\\</code><br/>
<code>¬†\end{bmatrix}</code><br/>
<code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†Z¬†\\¬†x_1¬†\\¬†x_2¬†\\¬†x_3¬†\\¬†x_4¬†\\¬†x_5</code><br/>
<code>¬†\end{bmatrix}¬†=</code><br/>
<code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†0¬†\\¬†L¬†\\¬†F¬†\\¬†P</code><br/>
<code>¬†\end{bmatrix},¬†\,</code><br/>
<code>¬†\begin{bmatrix}</code><br/>
<code>¬†¬†¬†x_1¬†\\¬†x_2¬†\\¬†x_3¬†\\¬†x_4¬†\\¬†x_5</code><br/>
<code>¬†\end{bmatrix}¬†\ge¬†0.</code></p>

<p></p>
<h2 id="duality">Duality</h2>

<p>Every linear programming problem, referred to as a <em>primal</em> problem, can be converted into a <a href="dual_problem" title="wikilink">dual problem</a>, which provides an upper bound to the optimal value of the primal problem. In matrix form, we can express the <em>primal</em> problem as:</p>
<dl>
<dd>Maximize <strong>c</strong><sup>T</sup><strong>x</strong> subject to <em>A</em><strong>x</strong> ‚â§ <strong>b</strong>, <strong>x</strong> ‚â• 0;
<dl>
<dd>with the corresponding <strong>symmetric</strong> dual problem,
</dd>
</dl>
</dd>
<dd>Minimize <strong>b</strong><sup>T</sup><strong>y</strong> subject to <em>A</em><sup>T</sup><strong>y</strong> ‚â• <strong>c</strong>, <strong>y</strong> ‚â• 0.
</dd>
</dl>

<p>An alternative primal formulation is:</p>
<dl>
<dd>Maximize <strong>c</strong><sup>T</sup><strong>x</strong> subject to <em>A</em><strong>x</strong> ‚â§ <strong>b</strong>;
<dl>
<dd>with the corresponding <strong>asymmetric</strong> dual problem,
</dd>
</dl>
</dd>
<dd>Minimize <strong>b</strong><sup>T</sup><strong>y</strong> subject to <em>A</em><sup>T</sup><strong>y</strong> = <strong>c</strong>, <strong>y</strong> ‚â• 0.
</dd>
</dl>

<p>There are two ideas fundamental to duality theory. One is the fact that (for the symmetric dual) the dual of a dual linear program is the original primal linear program. Additionally, every feasible solution for a linear program gives a bound on the optimal value of the objective function of its dual. The <a href="weak_duality" title="wikilink">weak duality</a> theorem states that the objective function value of the dual at any feasible solution is always greater than or equal to the objective function value of the primal at any feasible solution. The <a href="strong_duality" title="wikilink">strong duality</a> theorem states that if the primal has an optimal solution, <strong>x</strong><sup>*</sup>, then the dual also has an optimal solution, <strong>y</strong><sup>*</sup>, and <strong>c</strong><sup>T</sup><strong>x</strong><sup>*</sup>=<strong>b</strong><sup>T</sup><strong>y</strong><sup>*</sup>.</p>

<p>A linear program can also be unbounded or infeasible. Duality theory tells us that if the primal is unbounded then the dual is infeasible by the weak duality theorem. Likewise, if the dual is unbounded, then the primal must be infeasible. However, it is possible for both the dual and the primal to be infeasible. As an example, consider the linear program:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Maximize

<math display="block" id="Linear_programming:17">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>-</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2x_{1}-x_{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Subject to:</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="example-2">Example</h3>

<p>Revisit the above example of the farmer who may grow wheat and barley with the set provision of some <em>L</em> land, <em>F</em> fertilizer and <em>P</em> pesticide. Assume now that <em>y</em> unit prices for each of these means of production (inputs) are set by a planning board. The planning board's job is to minimize the total cost of procuring the set amounts of inputs while providing the farmer with a floor on the unit price of each of his crops (outputs), <em>S</em><sub>1</sub> for wheat and <em>S</em><sub>2</sub> for barley. This corresponds to the following linear programming problem:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Minimize

<math display="block" id="Linear_programming:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>y</mi>
     <mi>L</mi>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>F</mi>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>y</mi>
     <mi>F</mi>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>P</mi>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>y</mi>
     <mi>P</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\cdot y_{L}+F\cdot y_{F}+P\cdot y_{P}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>(minimize the total cost of the means of production as the "objective function")</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Subject to:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>L</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>1</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>y</mi>
      <mi>F</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>y</mi>
      <mi>P</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{L}+F_{1}\cdot y_{F}+P_{1}\cdot y_{P}\geq S_{1}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:20">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>L</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>2</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>y</mi>
      <mi>F</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>y</mi>
      <mi>P</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <msub>
    <mi>S</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{L}+F_{2}\cdot y_{F}+P_{2}\cdot y_{P}\geq S_{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>L</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>F</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>P</mi>
    </msub>
   </mrow>
   <mo>‚â•</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>F</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>P</ci>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{L},y_{F},y_{P}\geq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Which in matrix form becomes:</p>
<dl>
<dd>Minimize

<math display="block" id="Linear_programming:22">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>L</mi>
      </mtd>
      <mtd columnalign="center">
       <mi>F</mi>
      </mtd>
      <mtd columnalign="center">
       <mi>P</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>y</mi>
        <mi>L</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>y</mi>
        <mi>F</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>y</mi>
        <mi>P</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <matrix>
     <matrixrow>
      <ci>L</ci>
      <ci>F</ci>
      <ci>P</ci>
     </matrixrow>
    </matrix>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>L</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>F</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>P</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}L&F&P\end{bmatrix}\begin{bmatrix}y_{L}\\
y_{F}\\
y_{P}\end{bmatrix}
  </annotation>
 </semantics>
</math>


</dd>
<dd>Subject to

<math display="block" id="Linear_programming:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>F</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>P</mi>
          <mn>1</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>F</mi>
          <mn>2</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>P</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <mi>L</mi>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <mi>F</mi>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <mi>P</mi>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>‚â•</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mi>L</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mi>F</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mi>P</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>‚â•</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>L</ci>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>F</ci>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>P</ci>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <geq></geq>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>L</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>F</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>P</ci>
       </apply>
      </matrixrow>
     </matrix>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&F_{1}&P_{1}\\
1&F_{2}&P_{2}\end{bmatrix}\begin{bmatrix}y_{L}\\
y_{F}\\
y_{P}\end{bmatrix}\geq\begin{bmatrix}S_{1}\\
S_{2}\end{bmatrix},\,\begin{bmatrix}y_{L}\\
y_{F}\\
y_{P}\end{bmatrix}\geq 0.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The primal problem deals with physical quantities. With all inputs available in limited quantities, and assuming the unit prices of all outputs is known, what quantities of outputs to produce so as to maximize total revenue? The dual problem deals with economic values. With floor guarantees on all output unit prices, and assuming the available quantity of all inputs is known, what input unit pricing scheme to set so as to minimize total expenditure?</p>

<p>To each variable in the primal space corresponds an inequality to satisfy in the dual space, both indexed by output type. To each inequality to satisfy in the primal space corresponds a variable in the dual space, both indexed by input type.</p>

<p>The coefficients that bound the inequalities in the primal space are used to compute the objective in the dual space, input quantities in this example. The coefficients used to compute the objective in the primal space bound the inequalities in the dual space, output unit prices in this example.</p>

<p>Both the primal and the dual problems make use of the same matrix. In the primal space, this matrix expresses the consumption of physical quantities of inputs necessary to produce set quantities of outputs. In the dual space, it expresses the creation of the economic values associated with the outputs from set input unit prices.</p>

<p>Since each inequality can be replaced by an equality and a slack variable, this means each primal variable corresponds to a dual slack variable, and each dual variable corresponds to a primal slack variable. This relation allows us to speak about complementary slackness.</p>
<h3 id="another-example">Another example</h3>

<p>Sometimes, one may find it more intuitive to obtain the dual program without looking at the program matrix. Consider the following linear program:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>minimize</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:24">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>d</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>t</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}{c_{i}x_{i}}+\sum_{j=1}^{n}{d_{j}t_{j}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>t</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <msub>
    <mi>g</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}{a_{ij}x_{i}}+e_{j}t_{j}\geq g_{j}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>t</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <msub>
    <mi>h</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}x_{i}+\sum_{j=1}^{n}{b_{ij}t_{j}}\geq h_{i}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>j</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\geq 0,\,t_{j}\geq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>We have <em>m</em>¬†+¬†<em>n</em> conditions and all variables are non-negative. We shall define <em>m</em>¬†+¬†<em>n</em> dual variables: <strong>y</strong><sub>j</sub> and <strong>s</strong><sub>i</sub>. We get:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>minimize</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:28">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>d</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>t</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}{c_{i}x_{i}}+\sum_{j=1}^{n}{d_{j}t_{j}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mrow>
      <mrow>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>‚ãÖ</mo>
      <msub>
       <mi>y</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>t</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>j</mi>
    </msub>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <ci>normal-‚ãÖ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}{a_{ij}x_{i}}\cdot y_{j}+e_{j}t_{j}\cdot y_{j}\geq g_{j}\cdot y_%
{j}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>‚ãÖ</mo>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mrow>
       <msub>
        <mi>b</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>t</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo>‚ãÖ</mo>
      <msub>
       <mi>s</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mo>‚ãÖ</mo>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-‚ãÖ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}x_{i}\cdot s_{i}+\sum_{j=1}^{n}{b_{ij}t_{j}}\cdot s_{i}\geq h_{i}\cdot s_%
{i}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>j</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\geq 0,\,t_{j}\geq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}\geq 0,\,s_{i}\geq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Since this is a minimization problem, we would like to obtain a dual program that is a lower bound of the primal. In other words, we would like the sum of all right hand side of the constraints to be the maximal under the condition that for each primal variable the sum of its <a href="coefficient" title="wikilink">coefficients</a> do not exceed its coefficient in the linear function. For example, <strong>x</strong><sub>1</sub> appears in <em>n</em>¬†+¬†1 constraints. If we sum its constraints' coefficients we get <em>a</em><sub>1,1</sub><strong>y</strong><sub>1</sub>¬†+¬†<em>a</em><sub>1,2</sub><strong>y</strong><sub>2</sub>¬†+¬†...¬†+¬†<em>a</em><sub>1,n</sub><strong>y</strong><sub><em>n</em></sub>¬†+¬†<em>f</em><sub>1</sub><strong>s</strong><sub>1</sub>. This sum must be at most <strong>c</strong><sub>1</sub>. As a result we get:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>maximize</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:33">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=1}^{n}{g_{j}y_{j}}+\sum_{i=1}^{m}{h_{i}s_{i}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>y</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <msub>
    <mi>c</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=1}^{n}{a_{ij}y_{j}}+f_{i}s_{i}\leq c_{i}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>s</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <msub>
    <mi>d</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{j}y_{j}+\sum_{i=1}^{m}{b_{ij}s_{i}}\leq d_{j}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_programming:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}\geq 0,\,s_{i}\geq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Note that we assume in our calculations steps that the program is in standard form. However, any linear program may be transformed to standard form and it is therefore not a limiting factor.</p>
<h2 id="coveringpacking-dualities">Covering/packing dualities</h2>

<p>A <a href="Covering_problem" title="wikilink">covering LP</a> is a linear program of the form:</p>
<dl>
<dd>Minimize: <big><strong>b</strong><sup>T</sup><strong>y</strong></big>,
</dd>
<dd>Subject to: <big><em>A</em><sup>T</sup><strong>y</strong> ‚â• <strong>c</strong>, <strong>y</strong> ‚â• 0</big>,
</dd>
</dl>

<p>such that the matrix <em>A</em> and the vectors <strong>b</strong> and <strong>c</strong> are non-negative.</p>

<p>The dual of a covering LP is a <a href="Packing_problem" title="wikilink">packing LP</a>, a linear program of the form:</p>
<dl>
<dd>Maximize: <big><strong>c</strong><sup>T</sup><strong>x</strong></big>,
</dd>
<dd>Subject to: <big><em>A</em><strong>x</strong> ‚â§ <strong>b</strong>, <strong>x</strong> ‚â• 0</big>,
</dd>
</dl>

<p>such that the matrix <em>A</em> and the vectors <strong>b</strong> and <strong>c</strong> are non-negative.</p>
<h3 id="examples">Examples</h3>

<p>Covering and packing LPs commonly arise as a <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a> of a combinatorial problem and are important in the study of <a href="approximation_algorithms" title="wikilink">approximation algorithms</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> For example, the LP relaxations of the <a href="Set_packing" title="wikilink">set packing problem</a>, the <a href="independent_set_problem" title="wikilink">independent set problem</a>, and the <a href="Matching_(graph_theory)" title="wikilink">matching problem</a> are packing LPs. The LP relaxations of the <a href="set_cover_problem" title="wikilink">set cover problem</a>, the <a href="vertex_cover_problem" title="wikilink">vertex cover problem</a>, and the <a href="dominating_set_problem" title="wikilink">dominating set problem</a> are also covering LPs.</p>

<p>Finding a <a href="fractional_coloring" title="wikilink">fractional coloring</a> of a <a href="Graph_(mathematics)" title="wikilink">graph</a> is another example of a covering LP. In this case, there is one constraint for each vertex of the graph and one variable for each <a href="Independent_set_(graph_theory)" title="wikilink">independent set</a> of the graph.</p>
<h2 id="complementary-slackness">Complementary slackness</h2>

<p>It is possible to obtain an optimal solution to the dual when only an optimal solution to the primal is known using the complementary slackness theorem. The theorem states:</p>

<p>Suppose that <strong>x</strong>¬†=¬†(<strong>x</strong><sub>1</sub>,¬†<strong>x</strong><sub>2</sub>,¬†...¬†,¬†<strong>x</strong><sub><em>n</em></sub>) is primal feasible and that <strong>y</strong>¬†=¬†(<strong>y</strong><sub>1</sub>,¬†<strong>y</strong><sub>2</sub>,¬†...¬†,¬†<strong>y</strong><sub><em>m</em></sub>) is dual feasible. Let (<strong>w</strong><sub>1</sub>,¬†<strong>w</strong><sub>2</sub>,¬†...,¬†<strong>w</strong><sub><em>m</em></sub>) denote the corresponding primal slack variables, and let (<strong>z</strong><sub>1</sub>,¬†<strong>z</strong><sub>2</sub>,¬†...¬†,¬†<strong>z</strong><sub><em>n</em></sub>) denote the corresponding dual slack variables. Then <strong>x</strong> and <strong>y</strong> are optimal for their respective problems if and only if</p>
<ul>
<li><strong>x</strong><sub><em>j</em></sub> <strong>z</strong><sub><em>j</em></sub>¬†=¬†0, for <em>j</em>¬†=¬†1,¬†2,¬†...¬†,¬†<em>n</em>, and</li>
<li><strong>w</strong><sub><em>i</em></sub> <strong>y</strong><sub><em>i</em></sub>¬†=¬†0, for <em>i</em>¬†=¬†1,¬†2,¬†...¬†,¬†<em>m</em>.</li>
</ul>

<p>So if the <em>i</em>-th slack variable of the primal is not zero, then the <em>i</em>-th variable of the dual is equal to zero. Likewise, if the <em>j</em>-th slack variable of the dual is not zero, then the <em>j</em>-th variable of the primal is equal to zero.</p>

<p>This necessary condition for optimality conveys a fairly simple economic principle. In standard form (when maximizing), if there is slack in a constrained primal resource (i.e., there are "leftovers"), then additional quantities of that resource must have no value. Likewise, if there is slack in the dual (shadow) price non-negativity constraint requirement, i.e., the price is not zero, then there must be scarce supplies (no "leftovers").</p>
<h2 id="theory">Theory</h2>
<h3 id="existence-of-optimal-solutions">Existence of optimal solutions</h3>

<p>Geometrically, the linear constraints define the <a href="feasible_region" title="wikilink">feasible region</a>, which is a <a href="convex_set" title="wikilink">convex</a> <a class="uri" href="polyhedron" title="wikilink">polyhedron</a>. A <a href="linear_functional" title="wikilink">linear function</a> is a <a href="convex_function" title="wikilink">convex function</a>, which implies that every <a href="local_minimum" title="wikilink">local minimum</a> is a <a href="global_minimum" title="wikilink">global minimum</a>; similarly, a linear function is a <a href="concave_function" title="wikilink">concave function</a>, which implies that every <a href="local_maximum" title="wikilink">local maximum</a> is a <a href="global_maximum" title="wikilink">global maximum</a>.</p>

<p>An optimal solution need not exist, for two reasons. First, if two constraints are inconsistent, then no feasible solution exists: For instance, the constraints <strong>x</strong>¬†‚â•¬†2 and <strong>x</strong>¬†‚â§¬†1 cannot be satisfied jointly; in this case, we say that the LP is <em>infeasible</em>. Second, when the <a class="uri" href="polytope" title="wikilink">polytope</a> is unbounded in the direction of the gradient of the objective function (where the gradient of the objective function is the vector of the coefficients of the objective function), then no optimal value is attained.</p>
<h3 id="optimal-vertices-and-rays-of-polyhedra">Optimal vertices (and rays) of polyhedra</h3>

<p>Otherwise, if a feasible solution exists and if the (linear) objective function is bounded, then the optimum value is always attained on the boundary of optimal level-set, by the <em><a href="maximum_principle" title="wikilink">maximum principle</a></em> for <em><a href="convex_function" title="wikilink">convex functions</a></em> (alternatively, by the <em>minimum</em> principle for <em><a href="concave_function" title="wikilink">concave functions</a></em>): Recall that linear functions are both convex and concave. However, some problems have distinct optimal solutions: For example, the problem of finding a feasible solution to a system of linear inequalities is a linear programming problem in which the objective function is the zero function (that is, the constant function taking the value zero everywhere): For this feasibility problem with the zero-function for its objective-function, if there are two distinct solutions, then every convex combination of the solutions is a solution.</p>

<p>The vertices of the polytope are also called <em>basic feasible solutions</em>. The reason for this choice of name is as follows. Let <em>d</em> denote the number of variables. Then the fundamental theorem of linear inequalities implies (for feasible problems) that for every vertex <strong>x</strong><sup>*</sup> of the LP feasible region, there exists a set of <em>d</em> (or fewer) inequality constraints from the LP such that, when we treat those <em>d</em> constraints as equalities, the unique solution is <strong>x</strong><sup>*</sup>. Thereby we can study these vertices by means of looking at certain subsets of the set of all constraints (a discrete set), rather than the continuum of LP solutions. This principle underlies the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a> for solving linear programs.</p>
<h2 id="algorithms">Algorithms</h2>
<figure><b>(Figure)</b>
<figcaption>In a linear programming problem, a series of linear constraints produces a <a href="Convex_set" title="wikilink">convex</a> <a href="feasible_region" title="wikilink">feasible region</a> of possible values for those variables. In the two-variable case this region is in the shape of a convex <a href="simple_polygon" title="wikilink">simple polygon</a>.</figcaption>
</figure>
<h3 id="basis-exchange-algorithms">Basis exchange algorithms</h3>
<h4 id="simplex-algorithm-of-dantzig">Simplex algorithm of Dantzig</h4>

<p>The <a href="simplex_algorithm" title="wikilink">simplex algorithm</a>, developed by <a href="George_Dantzig" title="wikilink">George Dantzig</a> in 1947, solves LP problems by constructing a feasible solution at a vertex of the <a class="uri" href="polytope" title="wikilink">polytope</a> and then walking along a path on the edges of the polytope to vertices with non-decreasing values of the objective function until an optimum is reached for sure. In many practical problems, "<a href="Simplex_algorithm#Degeneracy:_Stalling_and_cycling" title="wikilink">stalling</a>" occurs: Many pivots are made with no increase in the objective function.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In rare practical problems, the usual versions of the simplex algorithm may actually "cycle".<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> To avoid cycles, researchers developed new pivoting rules.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>In practice, the simplex <a class="uri" href="algorithm" title="wikilink">algorithm</a> is quite efficient and can be guaranteed to find the global optimum if certain precautions against <em>cycling</em> are taken. The simplex algorithm has been proved to solve "random" problems efficiently, i.e. in a cubic number of steps,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> which is similar to its behavior on practical problems.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>However, the simplex algorithm has poor worst-case behavior: Klee and Minty constructed a family of linear programming problems for which the simplex method takes a number of steps exponential in the problem size.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> In fact, for some time it was not known whether the linear programming problem was solvable in <a href="polynomial_time" title="wikilink">polynomial time</a>, i.e. of <a href="P_(complexity)" title="wikilink">complexity class P</a>.</p>
<h4 id="criss-cross-algorithm">Criss-cross algorithm</h4>

<p>Like the simplex algorithm of Dantzig, the <a href="criss-cross_algorithm" title="wikilink">criss-cross algorithm</a> is a basis-exchange algorithm that pivots between bases. However, the criss-cross algorithm need not maintain feasibility, but can pivot rather from a feasible basis to an infeasible basis. The criss-cross algorithm does not have <a href="time_complexity" title="wikilink">polynomial time-complexity</a> for linear programming. Both algorithms visit all¬†2<sup><em>D</em></sup>¬†corners of a (perturbed) <a href="unit_cube" title="wikilink">cube</a> in dimension¬†<em>D</em>, the <a href="Klee‚ÄìMinty_cube" title="wikilink">Klee‚ÄìMinty cube</a>, in the <a href="worst-case_complexity" title="wikilink">worst case</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h3 id="interior-point">Interior point</h3>
<h4 id="ellipsoid-algorithm-following-khachiyan">Ellipsoid algorithm, following Khachiyan</h4>

<p>This is the first <a href="worst-case_complexity" title="wikilink">worst-case</a> <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> algorithm for linear programming. To solve a problem which has <em>n</em> variables and can be encoded in <em>L</em> input bits, this algorithm uses <em>O(n<sup>4</sup>L)</em> pseudo-arithmetic operations on numbers with <em>O(L)</em> digits. Khachiyan's <a class="uri" href="algorithm" title="wikilink">algorithm</a> and his long standing issue was resolved by <a href="Leonid_Khachiyan" title="wikilink">Leonid Khachiyan</a> in 1979 with the introduction of the <a href="ellipsoid_method" title="wikilink">ellipsoid method</a>. The convergence analysis have (real-number) predecessors, notably the <a href="iterative_method" title="wikilink">iterative methods</a> developed by <a href="Naum_Z._Shor" title="wikilink">Naum Z. Shor</a> and the <a href="approximation_algorithm" title="wikilink">approximation algorithms</a> by Arkadi Nemirovski and D. Yudin.</p>
<h4 id="projective-algorithm-of-karmarkar">Projective algorithm of Karmarkar</h4>

<p>Khachiyan's algorithm was of landmark importance for establishing the polynomial-time solvability of linear programs. The algorithm was not a computational break-through, as the simplex method is more efficient for all but specially constructed families of linear programs.</p>

<p>However, Khachiyan's algorithm inspired new lines of research in linear programming. In 1984, <a href="Narendra_Karmarkar" title="wikilink">N. Karmarkar</a> proposed a <a href="projective_method" title="wikilink">projective method</a> for linear programming. <a href="Karmarkar's_algorithm" title="wikilink">Karmarkar's algorithm</a> improved on Khachiyan's worst-case polynomial bound (giving 

<math display="inline" id="Linear_programming:37">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>3.5</mn>
     </msup>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="float">3.5</cn>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3.5}L)
  </annotation>
 </semantics>
</math>

). Karmarkar claimed that his algorithm was much faster in practical LP than the simplex method, a claim that created great interest in interior-point methods.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h4 id="path-following-algorithms">Path-following algorithms</h4>

<p>In contrast to the simplex algorithm, which finds an optimal solution by traversing the edges between vertices on a polyhedral set, interior-point methods move through the interior of the feasible region. Since then, many interior-point methods have been proposed and analyzed. Early successful implementations were based on <em>affine scaling</em> variants of the method. For both theoretical and practical purposes, <a href="barrier_function" title="wikilink">barrier function</a> or <a class="uri" href="path-following" title="wikilink">path-following</a> methods have been the most popular since the 1990s.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="comparison-of-interior-point-methods-versus-simplex-algorithms">Comparison of interior-point methods versus simplex algorithms</h3>

<p>The current opinion is that the efficiency of good implementations of simplex-based methods and interior point methods are similar for routine applications of linear programming.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> However, for specific types of LP problems, it may be that one type of solver is better than another (sometimes much better), and that the structure of the solutions generated by interior point methods versus simplex-based methods are significantly different with the support set of active variables being typically smaller for the later one.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>LP solvers are in widespread use for optimization of various problems in industry, such as optimization of flow in transportation networks.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h3 id="approximate-algorithms-for-coveringpacking-lps">Approximate Algorithms for Covering/Packing LPs</h3>

<p>Covering and packing LPs can be solved approximately in nearly-linear time. That is, if matrix <em>A</em> is of dimension <em>n√óm</em> and has <em>N</em> non-zero entries, then there exist algorithms that run in time <em>O(N¬∑(log N)<sup>O(1)</sup>/Œµ<sup>O(1)</sup>)</em> and produce <em>O(1¬±Œµ)</em> approximate solutions to given covering and packing LPs. The best known sequential algorithm of this kind runs in time <em>O(N + (log N)¬∑(n+m)/Œµ<sup>2</sup>)</em>,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> and the best known parallel algorithm of this kind runs in <em>O((log N)<sup>2</sup>/Œµ<sup>3</sup>)</em> iterations, each requiring only a matrix-vector multiplication which is highly parallelizable.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h2 id="open-problems-and-recent-work">Open problems and recent work</h2>

<p>There are several open problems in the theory of linear programming, the solution of which would represent fundamental breakthroughs in mathematics and potentially major advances in our ability to solve large-scale linear programs.</p>
<ul>
<li>Does LP admit a <a href="Time_complexity#Strongly_and_weakly_polynomial_time" title="wikilink">strongly polynomial</a>-time algorithm?</li>
<li>Does LP admit a strongly polynomial algorithm to find a strictly complementary solution?</li>
<li>Does LP admit a polynomial algorithm in the real number (unit cost) model of computation?</li>
</ul>

<p>This closely related set of problems has been cited by <a href="Stephen_Smale" title="wikilink">Stephen Smale</a> as among the <a href="Smale's_problems" title="wikilink">18 greatest unsolved problems</a> of the 21st century. In Smale's words, the third version of the problem "is the main unsolved problem of linear programming theory." While algorithms exist to solve linear programming in weakly polynomial time, such as the <a href="ellipsoid_method" title="wikilink">ellipsoid methods</a> and <a href="interior_point_method" title="wikilink">interior-point techniques</a>, no algorithms have yet been found that allow strongly polynomial-time performance in the number of constraints and the number of variables. The development of such algorithms would be of great theoretical interest, and perhaps allow practical gains in solving large LPs as well.</p>

<p>Although the <a href="Hirsch_conjecture" title="wikilink">Hirsch conjecture</a> was recently disproved for higher dimensions, it still leaves the following questions open.</p>
<ul>
<li>Are there pivot rules which lead to polynomial-time Simplex variants?</li>
<li>Do all polytopal graphs have polynomially bounded diameter?</li>
</ul>

<p>These questions relate to the performance analysis and development of Simplex-like methods. The immense efficiency of the Simplex algorithm in practice despite its exponential-time theoretical performance hints that there may be variations of Simplex that run in polynomial or even strongly polynomial time. It would be of great practical and theoretical significance to know whether any such variants exist, particularly as an approach to deciding if LP can be solved in strongly polynomial time.</p>

<p>The Simplex algorithm and its variants fall in the family of edge-following algorithms, so named because they solve linear programming problems by moving from vertex to vertex along edges of a polytope. This means that their theoretical performance is limited by the maximum number of edges between any two vertices on the LP polytope. As a result, we are interested in knowing the maximum <a href="Graph_diameter" title="wikilink">graph-theoretical diameter</a> of polytopal <a href="Graph_(mathematics)" title="wikilink">graphs</a>. It has been proved that all polytopes have subexponential diameter. The recent disproof of the Hirsch conjecture is the first step to prove whether any polytope has superpolynomial diameter. If any such polytopes exist, then no edge-following variant can run in polynomial time. Questions about polytope diameter are of independent mathematical interest.</p>

<p>Simplex pivot methods preserve primal (or dual) feasibility. On the other hand, criss-cross pivot methods do not preserve (primal or dual) feasibility‚Äîthey may visit primal feasible, dual feasible or primal-and-dual infeasible bases in any order. Pivot methods of this type have been studied since the 1970s. Essentially, these methods attempt to find the shortest pivot path on the <a href="arrangement_polytope" title="wikilink">arrangement polytope</a> under the linear programming problem. In contrast to polytopal graphs, graphs of arrangement polytopes are known to have small diameter, allowing the possibility of strongly polynomial-time criss-cross pivot algorithm without resolving questions about the diameter of general polytopes.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h2 id="integer-unknowns">Integer unknowns</h2>

<p>If all of the unknown variables are required to be integers, then the problem is called an <a href="integer_programming" title="wikilink">integer programming</a> (IP) or <strong>integer linear programming</strong> (ILP) problem. In contrast to linear programming, which can be solved efficiently in the worst case, integer programming problems are in many practical situations (those with bounded variables) <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. <strong>0-1 integer programming</strong> or <strong>binary integer programming</strong> (BIP) is the special case of integer programming where variables are required to be 0 or 1 (rather than arbitrary integers). This problem is also classified as NP-hard, and in fact the decision version was one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>.</p>

<p>If only some of the unknown variables are required to be integers, then the problem is called a <strong>mixed integer programming</strong> (MIP) problem. These are generally also NP-hard because they are even more general than ILP programs.</p>

<p>There are however some important subclasses of IP and MIP problems that are efficiently solvable, most notably problems where the constraint matrix is <a href="totally_unimodular" title="wikilink">totally unimodular</a> and the right-hand sides of the constraints are integers or - more general - where the system has the <a href="total_dual_integrality" title="wikilink">total dual integrality</a> (TDI) property.</p>

<p>Advanced algorithms for solving integer linear programs include:</p>
<ul>
<li><a href="cutting-plane_method" title="wikilink">cutting-plane method</a></li>
<li><a href="branch_and_bound" title="wikilink">branch and bound</a></li>
<li><a href="branch_and_cut" title="wikilink">branch and cut</a></li>
<li><a href="branch_and_price" title="wikilink">branch and price</a></li>
<li>if the problem has some extra structure, it may be possible to apply <a href="delayed_column_generation" title="wikilink">delayed column generation</a>.</li>
</ul>

<p>Such integer-programming algorithms are discussed by Padberg and in Beasley.</p>
<h2 id="integral-linear-programs">Integral linear programs</h2>

<p>A linear program in real variables is said to be <strong>integral</strong> if it has at least one optimal solution which is integral. Likewise, a polyhedron 

<math display="inline" id="Linear_programming:38">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>‚à£</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>‚â•</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <geq></geq>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\{x\mid Ax\geq 0\}
  </annotation>
 </semantics>
</math>

 is said to be <strong>integral</strong> if for all bounded feasible objective functions <em>c</em>, the linear program 

<math display="inline" id="Linear_programming:39">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mi>c</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>‚à£</mo>
   <mrow>
    <mi>x</mi>
    <mo>‚àà</mo>
    <mi>P</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\max cx\mid x\in P\}
  </annotation>
 </semantics>
</math>

 has an optimum 

<math display="inline" id="Linear_programming:40">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 with integer coordinates. As observed by Edmonds and Giles in 1977, one can equivalently say that the polyhedron 

<math display="inline" id="Linear_programming:41">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is integral if for every bounded feasible integral objective function <em>c</em>, the optimal <em>value</em> of the linear program 

<math display="inline" id="Linear_programming:42">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mi>c</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>‚à£</mo>
   <mrow>
    <mi>x</mi>
    <mo>‚àà</mo>
    <mi>P</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\max cx\mid x\in P\}
  </annotation>
 </semantics>
</math>

 is an integer.</p>

<p>Integral linear programs are of central importance in the polyhedral aspect of <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a> since they provide an alternate characterization of a problem. Specifically, for any problem, the convex hull of the solutions is an integral polyhedron; if this polyhedron has a nice/compact description, then we can efficiently find the optimal feasible solution under any linear objective. Conversely, if we can prove that a <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a> is integral, then it is the desired description of the convex hull of feasible (integral) solutions.</p>

<p>Note that terminology is not consistent throughout the literature, so one should be careful to distinguish the following two concepts,</p>
<ul>
<li>in an <em>integer linear program,</em> described in the previous section, variables are forcibly constrained to be integers, and this problem is NP-hard in general,</li>
<li>in an <em>integral linear program,</em> described in this section, variables are not constrained to be integers but rather one has proven somehow that the continuous problem always has an integral optimal value (assuming <em>c</em> is integral), and this optimal value may be found efficiently since all polynomial-size linear programs can be solved in polynomial time.</li>
</ul>

<p>One common way of proving that a polyhedron is integral is to show that it is <a href="Totally_unimodular_matrix" title="wikilink">totally unimodular</a>. There are other general methods including the <a href="integer_decomposition_property" title="wikilink">integer decomposition property</a> and <a href="total_dual_integrality" title="wikilink">total dual integrality</a>. Other specific well-known integral LPs include the matching polytope, lattice polyhedra, <a class="uri" href="submodular" title="wikilink">submodular</a> flow polyhedra, and the intersection of 2 generalized polymatroids/<em>g</em>-polymatroids --- e.g. see Schrijver 2003.</p>

<p>A bounded integral polyhedron is sometimes called a <a href="convex_lattice_polytope" title="wikilink">convex lattice polytope</a>, particularly in two dimensions.</p>
<h2 id="solvers-and-scripting-programming-languages">Solvers and scripting (programming) languages</h2>

<p><strong>Free open-source <a href="Permissive_free_software_licence" title="wikilink">permissive</a> licenses:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>License</p></th>
<th style="text-align: left;">
<p>Brief info</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>JOptimizer</p></td>
<td style="text-align: left;">
<p><a href="Apache_License" title="wikilink">Apache License</a></p></td>
<td style="text-align: left;">
<p>Java library for convex optimization (open source)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="OpenOpt" title="wikilink">OpenOpt</a></p></td>
<td style="text-align: left;">
<p><a href="BSD_licenses" title="wikilink">BSD</a></p></td>
<td style="text-align: left;">
<p>Universal cross-platform numerical optimization framework,<br/>
 see its <a href="http://openopt.org/LP">LP</a> page and <a href="http://openopt.org/Problems">other problems</a> involved</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Coopr" title="wikilink">Coopr</a></p></td>
<td style="text-align: left;">
<p><a href="BSD_licenses" title="wikilink">BSD</a></p></td>
<td style="text-align: left;">
<p>An open-source modeling language for large-scale linear, mixed integer and nonlinear optimization</p></td>
</tr>
</tbody>
</table>

<p><strong>Free open-source <a href="Copyleft" title="wikilink"> copyleft (reciprocal)</a> licenses:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>License</p></th>
<th style="text-align: left;">
<p>Brief info</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Cassowary_constraint_solver" title="wikilink">Cassowary constraint solver</a></p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="COIN-OR_CLP" title="wikilink">CLP</a></p></td>
<td style="text-align: left;">
<p>CPL</p></td>
<td style="text-align: left;">
<p>an LP solver from COIN-OR</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="GNU_Linear_Programming_Kit" title="wikilink">glpk</a></p></td>
<td style="text-align: left;">
<p>GPL</p></td>
<td style="text-align: left;">
<p>GNU Linear Programming Kit, an LP/MILP solver with a native C <a class="uri" href="API" title="wikilink">API</a> and numerous (15) third-party wrappers for other languages. Specialist support for <a href="flow_network" title="wikilink">flow networks</a>. Bundles the <a class="uri" href="AMPL" title="wikilink">AMPL</a>-like <a href="GNU_MathProg" title="wikilink">GNU MathProg</a> modelling language and translator.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="LpSolve" title="wikilink">LpSolve</a></p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>lp_solve is a free (see LGPL for the GNU lesser general public license) linear (integer) programming solver based on the revised simplex method and the Branch-and-bound method for the integers. LpSolve has an IDE, a native C <a class="uri" href="API" title="wikilink">API</a>, and many external language interfaces, for <a href="Java_(programming_language)" title="wikilink">JAVA</a>, <a class="uri" href="AMPL" title="wikilink">AMPL</a>, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, <a class="uri" href="O-Matrix" title="wikilink">O-Matrix</a>, <a class="uri" href="Sysquake" title="wikilink">Sysquake</a>, <a class="uri" href="Scilab" title="wikilink">Scilab</a>, <a class="uri" href="Octave" title="wikilink">Octave</a>, <a class="uri" href="FreeMat" title="wikilink">FreeMat</a>, <a class="uri" href="Euler" title="wikilink">Euler</a>, <a href="Python_(programming_language)" title="wikilink">Python</a>, <a href="Sage_(mathematics_software)" title="wikilink">Sage</a>, <a class="uri" href="PHP" title="wikilink">PHP</a>, <a class="uri" href="R" title="wikilink">R</a> and the <a href="Microsoft_Solver_Foundation" title="wikilink">Microsoft Solver Foundation</a>. It is compatible with <a href="http://zimpl.zib.de/">Zimpl</a> modelling language.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Qoca" title="wikilink">Qoca</a></p></td>
<td style="text-align: left;">
<p>GPL</p></td>
<td style="text-align: left;">
<p>a library for incrementally solving systems of linear equations with various goal functions</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="R-Project" title="wikilink">R-Project</a></p></td>
<td style="text-align: left;">
<p>GPL</p></td>
<td style="text-align: left;">
<p>a programming language and software environment for statistical computing and graphics</p></td>
</tr>
</tbody>
</table>

<p><a class="uri" href="MINTO" title="wikilink">MINTO</a> (Mixed Integer Optimizer, an <a href="integer_programming" title="wikilink">integer programming</a> solver which uses branch and bound algorithm) has publicly available source code<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> but is not open source.</p>

<p><strong><a href="Proprietary_software" title="wikilink">Proprietary:</a></strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Brief info</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="AIMMS" title="wikilink">AIMMS</a></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="AMPL" title="wikilink">AMPL</a></p></td>
<td style="text-align: left;">
<p>A popular modeling language for large-scale linear, mixed integer and nonlinear optimisation with a free student limited version available (500 variables and 500 constraints).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="APMonitor" title="wikilink">APMonitor</a></p></td>
<td style="text-align: left;">
<p>API to MATLAB and Python. Solve example <a href="http://apmonitor.com/me575/index.php/Main/LinearProgramming">Linear Programming (LP) problems</a> through MATLAB, Python, or a web-interface.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="CPLEX" title="wikilink">CPLEX</a></p></td>
<td style="text-align: left;">
<p>Popular solver with an API for several programming languages, and also has a modelling language and works with AIMMS, AMPL, <a href="General_Algebraic_Modeling_System" title="wikilink">GAMS</a>, MPL, OpenOpt, OPL Development Studio, and <a class="uri" href="TOMLAB" title="wikilink">TOMLAB</a>. Free for academic use.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Microsoft_Excel" title="wikilink">Excel</a> Solver Function</p></td>
<td style="text-align: left;">
<p>A nonlinear solver adjusted to spreadsheets in which function evaluations are based on the recalculating cells. Basic version available as a standard add-on for Excel.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="FortMP" title="wikilink">FortMP</a></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="General_Algebraic_Modeling_System" title="wikilink">GAMS</a></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Gurobi" title="wikilink">Gurobi</a></p></td>
<td style="text-align: left;">
<p>Solver with parallel algorithms for large-scale linear programs, quadratic programs and mixed-integer programs. Free for academic use.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="IMSL_Numerical_Libraries" title="wikilink">IMSL Numerical Libraries</a></p></td>
<td style="text-align: left;">
<p>Collections of math and statistical algorithms available in C/C++, Fortran, Java and C#/.NET. Optimization routines in the IMSL Libraries include unconstrained, linearly and nonlinearly constrained minimizations, and linear programming algorithms.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="LINDO" title="wikilink">LINDO</a></p></td>
<td style="text-align: left;">
<p>Solver with an API for large scale optimization of linear, integer, quadratic, conic and general nonlinear programs with stochastic programming extensions. It offers a global optimization procedure for finding guaranteed globally optimal solution to general nonlinear programs with continuous and discrete variables. It also has a statistical sampling API to integrate Monte-Carlo simulations into an optimization framework. It has an algebraic modeling language (<a href="Lingo_(programming_language)" title="wikilink">LINGO</a>) and allows modeling within a spreadsheet (<a class="uri" href="What'sBest" title="wikilink">What'sBest</a>).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Maple_(software)" title="wikilink">Maple</a></p></td>
<td style="text-align: left;">
<p>A general-purpose programming-language for symbolic and numerical computing.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="MATLAB" title="wikilink">MATLAB</a></p></td>
<td style="text-align: left;">
<p>A general-purpose and matrix-oriented programming-language for numerical computing. Linear programming in MATLAB requires the <a href="Optimization_Toolbox" title="wikilink">Optimization Toolbox</a> in addition to the base MATLAB product; available routines include INTLINPROG and LINPROG</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Mathcad" title="wikilink">Mathcad</a></p></td>
<td style="text-align: left;">
<p>A WYSIWYG math editor. It has functions for solving both linear and nonlinear optimization problems.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Mathematica" title="wikilink">Mathematica</a></p></td>
<td style="text-align: left;">
<p>A general-purpose programming-language for mathematics, including symbolic and numerical capabilities.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="MOSEK" title="wikilink">MOSEK</a></p></td>
<td style="text-align: left;">
<p>A solver for large scale optimization with API for several languages (C++,java,.net, Matlab and python).</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="NAG_Numerical_Library" title="wikilink">NAG Numerical Library</a></p></td>
<td style="text-align: left;">
<p>A collection of mathematical and statistical routines developed by the <a href="Numerical_Algorithms_Group" title="wikilink">Numerical Algorithms Group</a> for multiple programming languages (C, C++, Fortran, Visual Basic, Java and C#) and packages (MATLAB, Excel, R, LabVIEW). The Optimization chapter of the NAG Library includes routines for linear programming problems with both sparse and non-sparse linear constraint matrices, together with routines for the optimization of quadratic, nonlinear, sums of squares of linear or nonlinear functions with nonlinear, bounded or no constraints. The NAG Library has routines for both local and global optimization, and for continuous or integer problems.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="NMath_Stats" title="wikilink">NMath Stats</a></p></td>
<td style="text-align: left;">
<p>A general-purpose <a href=".NET_Framework" title="wikilink">.NET</a> statistical library containing a simplex solver.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="OptimJ" title="wikilink">OptimJ</a></p></td>
<td style="text-align: left;">
<p>A Java-based modeling language for optimization with a free version available.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="SAS_System" title="wikilink">SAS</a>/OR</p></td>
<td style="text-align: left;">
<p>A suite of solvers for Linear, Integer, Nonlinear, Derivative-Free, Network, Combinatorial and Constraint Optimization; the <a href="Algebraic_modeling_language" title="wikilink">Algebraic modeling language</a> <a href="http://support.sas.com/documentation/cdl/en/ormpug/63975/HTML/default/ormpug_optmodel_sect005.htm">OPTMODEL</a>; and a variety of vertical solutions aimed at specific problems/markets, all of which are fully integrated with the <a href="SAS_System" title="wikilink">SAS System</a>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="SCIP_(optimization_software)" title="wikilink">SCIP</a></p></td>
<td style="text-align: left;">
<p>A general-purpose constraint integer programming solver with an emphasis on MIP. Compatible with <a href="http://zimpl.zib.de/">Zimpl</a> modelling language. Free for academic use and available in source code.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="XPRESS_Solver_Engine" title="wikilink">XPRESS Solver Engine</a></p></td>
<td style="text-align: left;">
<p>Solver for large-scale linear programs, quadratic programs, general nonlinear and mixed-integer programs. Has API for several programming languages, also has a modelling language Mosel and works with AMPL, <a href="General_Algebraic_Modeling_System" title="wikilink">GAMS</a>. Free for academic use.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="VisSim" title="wikilink">VisSim</a></p></td>
<td style="text-align: left;">
<p>A visual <a href="block_diagram" title="wikilink">block diagram</a> language for simulation of <a href="dynamical_system" title="wikilink">dynamical systems</a>.</p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Convex_programming" title="wikilink">Convex programming</a></li>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a></li>
<li><a href="Linear-fractional_programming_(LFP)" title="wikilink">Linear-fractional programming (LFP)</a></li>
<li><a href="LP-type_problem" title="wikilink">LP-type problem</a></li>
<li><a href="Mathematical_programming" title="wikilink">Mathematical programming</a></li>
<li><a href="Job_shop_scheduling" title="wikilink">Job shop scheduling</a></li>
<li><a href="Nonlinear_programming" title="wikilink">Nonlinear programming</a></li>
<li><a href="Oriented_matroid" title="wikilink">Oriented matroid</a></li>
<li><a href="Quadratic_programming" title="wikilink">Quadratic programming</a>, a superset of linear programming</li>
<li><a href="Shadow_price" title="wikilink">Shadow price</a></li>
<li><a href="Simplex_algorithm" title="wikilink">Simplex algorithm</a>, used to solve LP problems</li>
<li><a href="Semidefinite_programming" title="wikilink">Semidefinite programming</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>F. L. Hitchcock: <em>The distribution of a product from several sources to numerous localities</em>, Journal of Mathematics and Physics, 20, 1941, 224-230.</li>
<li>G.B Dantzig: <em>Maximization of a linear function of variables subject to linear inequalities</em>, 1947. Published pp.¬†339‚Äì347 in T.C. Koopmans (ed.):<em>Activity Analysis of Production and Allocation</em>, New York-London 1951 (Wiley &amp; Chapman-Hall)</li>
<li>J. E. Beasley, editor. <em>Advances in Linear and Integer Programming</em>. Oxford Science, 1996. (Collection of surveys)</li>
<li>R. G. Bland, New finite pivoting rules for the simplex method, <em>Math. Oper. Res.</em> 2 (1977) 103‚Äì107.</li>
<li>Karl-Heinz Borgwardt, <em>The Simplex Algorithm: A Probabilistic Analysis</em>, Algorithms and Combinatorics, Volume 1, Springer-Verlag, 1987. (Average behavior on random problems)</li>
<li>Richard W. Cottle, ed. <em>The Basic George B. Dantzig</em>. Stanford Business Books, Stanford University Press, Stanford, California, 2003. (Selected papers by <a href="George_B._Dantzig" title="wikilink">George B. Dantzig</a>)</li>
<li>George B. Dantzig and Mukund N. Thapa. 1997. <em>Linear programming 1: Introduction</em>. Springer-Verlag.</li>
<li>George B. Dantzig and Mukund N. Thapa. 2003. <em>Linear Programming 2: Theory and Extensions</em>. Springer-Verlag. (Comprehensive, covering e.g. <a href="simplex_algorithm" title="wikilink">pivoting</a> and interior-point algorithms, large-scale problems, <a href="Dantzig-Wolfe_decomposition" title="wikilink">decomposition following Dantzig-Wolfe</a> and <a href="Benders'_decomposition" title="wikilink">Benders</a>, and introducing <a href="stochastic_programming" title="wikilink">stochastic programming</a>.)</li>
<li>Edmonds, J. and Giles, R., "A min-max relation for submodular functions on graphs," Ann. Discrete Math., v1, pp.¬†185‚Äì204, 1977</li>
<li></li>
<li></li>
<li></li>
<li>Evar D. Nering and <a href="Albert_W._Tucker" title="wikilink">Albert W. Tucker</a>, 1993, <em>Linear Programs and Related Problems</em>, Academic Press. (elementary)</li>
<li>M. Padberg, <em>Linear Optimization and Extensions</em>, Second Edition, Springer-Verlag, 1999. (carefully written account of primal and dual simplex algorithms and projective algorithms, with an introduction to integer linear programming --- featuring the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a> for <a class="uri" href="Odysseus" title="wikilink">Odysseus</a>.)</li>
<li><a href="Christos_H._Papadimitriou" title="wikilink">Christos H. Papadimitriou</a> and Kenneth Steiglitz, <em>Combinatorial Optimization: Algorithms and Complexity</em>, Corrected republication with a new preface, Dover. (computer science)</li>
<li>

<p>(Invited survey, from the International Symposium on Mathematical Programming.)</p></li>
<li>

<p>(Computer science)</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>

<p>A reader may consider beginning with Nering and Tucker, with the first volume of Dantzig and Thapa, or with Williams.</p>
<ul>
<li>Dmitris Alevras and Manfred W. Padberg, <em>Linear Optimization and Extensions: Problems and Solutions</em>, Universitext, Springer-Verlag, 2001. (Problems from Padberg with solutions.)</li>
</ul>
<ul>
<li>

<p>Chapter 4: Linear Programming: pp.¬†63‚Äì94. Describes a randomized half-plane intersection algorithm for linear programming.</p></li>
<li>

<p>A6: MP1: INTEGER PROGRAMMING, pg.245. (computer science, complexity theory)</p></li>
<li>Bernd G√§rtner, <a href="Ji≈ô√≠_Matou≈°ek_(mathematician)" title="wikilink">Ji≈ô√≠ Matou≈°ek</a> (2006). <em>Understanding and Using Linear Programming</em>, Berlin: Springer. ISBN 3-540-30697-8 (elementary introduction for mathematicians and computer scientists)</li>
<li>Cornelis Roos, Tam√°s Terlaky, Jean-Philippe Vial, <em>Interior Point Methods for Linear Optimization</em>, Second Edition, Springer-Verlag, 2006. (Graduate level)</li>
<li></li>
<li>Alexander Schrijver, <em>Theory of Linear and Integer Programming</em>. John Wiley &amp; sons, 1998, ISBN 0-471-98232-6 (mathematical)</li>
<li><a href="Robert_J._Vanderbei" title="wikilink">Robert J. Vanderbei</a>, <a href="http://www.princeton.edu/~rvdb/LPbook/"><em>Linear Programming: Foundations and Extensions</em></a>, 3rd ed., International Series in Operations Research &amp; Management Science, Vol. 114, Springer Verlag, 2008. ISBN 978-0-387-74387-5. (An on-line second edition was formerly available. Vanderbei's site still contains extensive materials.)</li>
<li>H. P. Williams, <em>Model Building in Mathematical Programming</em>, Third revised Edition, 1990. (Modeling)</li>
<li>Stephen J. Wright, 1997, <em>Primal-Dual Interior-Point Methods</em>, SIAM. (Graduate level)</li>
<li><a href="Yinyu_Ye" title="wikilink">Yinyu Ye</a>, 1997, <em>Interior Point Algorithms: Theory and Analysis</em>, Wiley. (Advanced graduate-level)</li>
<li><a href="G√ºnter_M._Ziegler" title="wikilink">Ziegler, G√ºnter M.</a>, Chapters 1‚Äì3 and 6‚Äì7 in <em>Lectures on Polytopes</em>, Springer-Verlag, New York, 1994. (Geometry)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://people.brunel.ac.uk/~mastjjb/jeb/or/lp.html">Guidance On Formulating LP Problems</a></li>
<li><a href="http://glossary.computing.society.informs.org/">Mathematical Programming Glossary</a></li>
<li><a href="http://lpsolve.sourceforge.net/4.0/LinearProgrammingFAQ.htm">The Linear Programming FAQ</a></li>
<li><a href="http://plato.asu.edu/bench.html">Benchmarks For Optimisation Software</a></li>
<li><a href="http://www.lionhrtpub.com/orms/surveys/LP/LP-survey.html">2013 Linear Programming Software Survey</a> - <em><a href="OR/MS_Today" title="wikilink">OR/MS Today</a></em></li>
<li><a href="http://www.stanford.edu/group/SOL/dantzig.html">George Dantzig</a></li>
<li><a href="http://www.linearprogramming.info/">Linear Programming (LP) and Operations Research (OR) resources for students</a></li>
</ul>

<p>"</p>

<p><a href="Category:Linear_programming" title="wikilink"> </a> <a href="Category:Convex_optimization" title="wikilink">Category:Convex optimization</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Geometric_algorithms" title="wikilink">Category:Geometric algorithms</a> <a href="Category:P-complete_problems" title="wikilink">Category:P-complete problems</a> <a href="Category:Mathematical_and_quantitative_methods_(economics)" title="wikilink">Category:Mathematical and quantitative methods (economics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22">: <a href="#fnref22">‚Ü©</a></li>
<li id="fn23">: <a href="#fnref23">‚Ü©</a></li>
<li id="fn24"><a href="#fnref24">‚Ü©</a></li>
<li id="fn25"><a href="#fnref25">‚Ü©</a></li>
<li id="fn26"></li>
<li id="fn27">Tibor Ill√©s, Tam√°s Terlaky, Pivot versus interior point methods: Pros and cons, European Journal of Operational Research, 01/2002<a href="#fnref27">‚Ü©</a></li>
<li id="fn28">For solving network-flow problems in transportation networks, specialized implementations of the simplex algorithm can dramatically improve its efficiency. <a href="#fnref28">‚Ü©</a></li>
<li id="fn29"><a href="#fnref29">‚Ü©</a></li>
<li id="fn30"><a href="#fnref30">‚Ü©</a></li>
<li id="fn31"></li>
<li id="fn32"><a class="uri" href="http://coral.ie.lehigh.edu/~minto/download.html">http://coral.ie.lehigh.edu/~minto/download.html</a><a href="#fnref32">‚Ü©</a></li>
<li id="fn33"><a href="http://www.centerspace.net/landing.php?id=lp">Linear programming page at CenterSpace Software</a><a href="#fnref33">‚Ü©</a></li>
<li id="fn34"><a class="uri" href="http://www.in-ter-trans.eu/resources/Zesch_Hellingrath_2010_Integrated+Production-Distribution+Planning.pdf">http://www.in-ter-trans.eu/resources/Zesch_Hellingrath_2010_Integrated+Production-Distribution+Planning.pdf</a> OptimJ used in an optimization model for mixed-model assembly lines, University of M√ºnster<a href="#fnref34">‚Ü©</a></li>
<li id="fn35"><a class="uri" href="http://www.aaai.org/ocs/index.php/AAAI/AAAI10/paper/viewFile/1769/2076">http://www.aaai.org/ocs/index.php/AAAI/AAAI10/paper/viewFile/1769/2076</a> OptimJ used in an Approximate Subgame-Perfect Equilibrium Computation Technique for Repeated Games<a href="#fnref35">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
