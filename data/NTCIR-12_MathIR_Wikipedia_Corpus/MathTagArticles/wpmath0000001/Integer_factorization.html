<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="550">Integer factorization</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Integer factorization</h1>
<hr/>
<p>In <a href="number_theory" title="wikilink">number theory</a>, <strong>integer factorization</strong> is the decomposition of a <a href="composite_number" title="wikilink">composite number</a> into a product of smaller integers. If these integers are further restricted to <a href="prime_number" title="wikilink">prime numbers</a>, the process is called <strong>prime factorization</strong>.</p>
<p>When the numbers are very large, no efficient, non-quantum integer <a class="uri" href="factorization" title="wikilink">factorization</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> is known; an effort by several researchers concluded in 2009, factoring a 232-digit number (<a class="uri" href="RSA-768" title="wikilink">RSA-768</a>), utilizing hundreds of machines over a span of two years.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However, it has not been proven that no efficient algorithm exists. The presumed difficulty of this problem is at the heart of widely used algorithms in <a class="uri" href="cryptography" title="wikilink">cryptography</a> such as <a href="RSA_(algorithm)" title="wikilink">RSA</a>. Many areas of <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computer_science" title="wikilink">computer science</a> have been brought to bear on the problem, including <a href="elliptic_curve" title="wikilink">elliptic curves</a>, <a href="algebraic_number_theory" title="wikilink">algebraic number theory</a>, and <a href="quantum_computer" title="wikilink">quantum computing</a>.</p>
<p>Not all numbers of a given length are equally hard to factor. The hardest instances of these problems (for currently known techniques) are <a href="semiprime" title="wikilink">semiprimes</a>, the product of two <a href="prime_number" title="wikilink">prime numbers</a>. When they are both large, for instance more than two thousand <a href="bit" title="wikilink">bits</a> long, randomly chosen, and about the same size (but not too close, e.g., to avoid efficient factorization by <a href="Fermat's_factorization_method" title="wikilink">Fermat's factorization method</a>), even the fastest prime factorization algorithms on the fastest computers can take enough time to make the search impractical; that is, as the number of digits of the primes being factored increases, the number of operations required to perform the factorization on any computer increases drastically.</p>
<p>Many cryptographic protocols are based on the difficulty of factoring large composite integers or a related problem—for example, the <a href="RSA_problem" title="wikilink">RSA problem</a>. An algorithm that efficiently factors an arbitrary integer would render <a href="RSA_(algorithm)" title="wikilink">RSA</a>-based <a class="uri" href="public-key" title="wikilink">public-key</a> cryptography insecure.</p>
<h2 id="prime-decomposition">Prime decomposition</h2>
<p> By the <a href="fundamental_theorem_of_arithmetic" title="wikilink">fundamental theorem of arithmetic</a>, every positive integer greater than one has a unique prime factorization. A special case for one can be avoided using an appropriate notion of the <a href="empty_product" title="wikilink">empty product</a>. However, the fundamental theorem of arithmetic gives no insight into how to obtain an integer's prime factorization; it only guarantees its existence.</p>
<p>Given a general algorithm for integer factorization, one can factor any integer down to its constituent <a href="prime_factor" title="wikilink">prime factors</a> by repeated application of this algorithm. However, this is not the case with a special-purpose factorization algorithm, since it may not apply to the smaller factors that occur during decomposition, or may execute very slowly on these values. For example, if <em>N</em> is the number (2<sup>521</sup> − 1) × (2<sup>607</sup> − 1), then <a href="trial_division" title="wikilink">trial division</a> will quickly factor 10 × <em>N</em> as 2 × 5 × <em>N</em>, but will not quickly factor <em>N</em> into its factors.</p>
<h2 id="current-state-of-the-art">Current state of the art</h2>
<p>Among the <em>b</em>-<a class="uri" href="bit" title="wikilink">bit</a> numbers, the most difficult to factor in practice using existing algorithms are those that are products of two primes of similar size. For this reason, these are the integers used in cryptographic applications. The largest such semiprime yet factored was <a class="uri" href="RSA-768" title="wikilink">RSA-768</a>, a 768-bit number with 232 decimal digits, on December 12, 2009.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This factorization was a collaboration of several research institutions, spanning two years and taking the equivalent of almost 2000 years of computing on a single-core 2.2 GHz <a href="Advanced_Micro_Devices" title="wikilink">AMD</a> <a class="uri" href="Opteron" title="wikilink">Opteron</a>. Like all recent factorization records, this factorization was completed with a highly optimized implementation of the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a> run on hundreds of machines.</p>
<h3 id="difficulty-and-complexity">Difficulty and complexity</h3>
<p>No <a class="uri" href="algorithm" title="wikilink">algorithm</a> has been published that can factor all integers in <a href="polynomial_time" title="wikilink">polynomial time</a>, i.e., that can factor <em>b</em>-bit numbers in time <a href="Big_O_notation" title="wikilink">O</a>(<em>b</em><sup><em>k</em></sup>) for some constant <em>k</em>. There are published algorithms that are faster than <a href="Big_O_notation" title="wikilink">O</a>((1+ε)<sup><em>b</em></sup>) for all positive ε, i.e., sub-exponential.</p>
<p>The best published asymptotic running time is for the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a> (GNFS) algorithm, which, for a <em>b</em>-bit number <em>n</em>, is:</p>
<p><span class="LaTeX">$$O\left(\exp\left(\left(\begin{matrix}\frac{64}{9}\end{matrix} b\right)^{1\over3} (\log b)^{2\over3}\right)\right).$$</span></p>
<p>For current computers, GNFS is the best published algorithm for large <em>n</em> (more than about 100 digits). For a <a href="quantum_computer" title="wikilink">quantum computer</a>, however, <a href="Peter_Shor" title="wikilink">Peter Shor</a> discovered an algorithm in 1994 that solves it in polynomial time. This will have significant implications for cryptography if quantum computation is possible. <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> takes only <mtpl></mtpl> time and O(<em>b</em>) space on <em>b</em>-bit number inputs. In 2001, the first seven-qubit quantum computer became the first to run Shor's algorithm. It factored the number 15.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<p>When discussing what <a href="complexity_class" title="wikilink">complexity classes</a> the integer factorization problem falls into, it's necessary to distinguish two slightly different versions of the problem:</p>
<ul>
<li>The <a href="function_problem" title="wikilink">function problem</a> version: given an integer <em>N</em>, find an integer <em>d</em> with 1 < <em>d</em> < <em>N</em> that divides <em>N</em> (or conclude that <em>N</em> is prime). This problem is trivially in <a href="FNP_(complexity)" title="wikilink">FNP</a> and it's not known whether it lies in <a href="FP_(complexity)" title="wikilink">FP</a> or not. This is the version solved by practical implementations.</li>
<li>The <a href="decision_problem" title="wikilink">decision problem</a> version: given an integer <em>N</em> and an integer <em>M</em> with 1 < <em>M</em> < <em>N</em>, does <em>N</em> have a factor <em>d</em> with 1 < <em>d</em> ≤ <em>M</em>? This version is useful because most well-studied complexity classes are defined as classes of decision problems, not function problems.</li>
</ul>
<p>For <span class="LaTeX">$M=\sqrt{N}$</span>, the decision problem is equivalent to asking if <em>N</em> is prime.</p>
<p>An algorithm for either version provides one for the other. Repeated application of the function problem (applied to <em>d</em> and <em>N</em>/<em>d</em>, and their factors, if needed) will eventually provide either a factor of <em>N</em> no larger than <em>M</em> or a factorization into primes all greater than <em>M</em>. All known algorithms for the decision problem work in this way. Hence it is only of theoretical interest that, with at most <span class="LaTeX">$\log{N}$</span> queries using an algorithm for the decision problem, one would isolate a factor of <em>N</em> (or prove it prime) by <a href="binary_search" title="wikilink">binary search</a>.</p>
<p>It is not known exactly which <a href="computational_complexity_theory" title="wikilink">complexity classes</a> contain the decision version of the integer factorization problem. It is known to be in both <a href="NP_(complexity)" title="wikilink">NP</a> and <a class="uri" href="co-NP" title="wikilink">co-NP</a>. This is because both YES and NO answers can be verified in polynomial time. An answer of YES can be certified by exhibiting a factorization <em>N</em> = <em>d</em>(<em>N</em>/<em>d</em>) with <em>d</em> ≤ <em>M</em>. An answer of NO can be certified by exhibiting the factorization of <em>N</em> into distinct primes, all larger than <em>M</em>. We can verify their primality using the <a href="AKS_primality_test" title="wikilink">AKS primality test</a>, and that their product is <em>N</em> by multiplication. The <a href="fundamental_theorem_of_arithmetic" title="wikilink">fundamental theorem of arithmetic</a> guarantees that there is only one possible string that will be accepted (providing the factors are required to be listed in order), which shows that the problem is in both <strong><a href="UP_(complexity)" title="wikilink">UP</a></strong> and <strong>co-UP</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It is known to be in <a class="uri" href="BQP" title="wikilink">BQP</a> because of <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>. It is suspected to be outside of all three of the complexity classes <a href="P_(complexity)" title="wikilink">P</a>, <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, and <a class="uri" href="co-NP-complete" title="wikilink">co-NP-complete</a>. It is therefore a candidate for the <a class="uri" href="NP-intermediate" title="wikilink">NP-intermediate</a> complexity class. If it could be proved that it is in either NP-Complete or co-NP-Complete, that would imply NP = co-NP. That would be a very surprising result, and therefore integer factorization is widely suspected to be outside both of those classes. Many people have tried to find classical polynomial-time algorithms for it and failed, and therefore it is widely suspected to be outside P.</p>
<p>In contrast, the decision problem "is <em>N</em> a <a href="composite_number" title="wikilink">composite number</a>?" (or equivalently: "is <em>N</em> a <a href="prime_number" title="wikilink">prime number</a>?") appears to be much easier than the problem of actually finding the factors of <em>N</em>. Specifically, the former can be solved in polynomial time (in the number <em>n</em> of digits of <em>N</em>) with the <a href="AKS_primality_test" title="wikilink">AKS primality test</a>. In addition, there are a number of <a href="randomized_algorithm" title="wikilink">probabilistic algorithms</a> that can test primality very quickly in practice if one is willing to accept the vanishingly small possibility of error. The ease of <a href="primality_test" title="wikilink">primality testing</a> is a crucial part of the <a href="RSA_(algorithm)" title="wikilink">RSA</a> algorithm, as it is necessary to find large prime numbers to start with.</p>
<h2 id="factoring-algorithms">Factoring algorithms</h2>
<h3 id="special-purpose">Special-purpose</h3>
<p>A special-purpose factoring algorithm's running time depends on the properties of the number to be factored or on one of its unknown factors: size, special form, etc. Exactly what the running time depends on varies between algorithms.</p>
<p>An important subclass of special-purpose factoring algorithms is the <em>Category 1</em> or <em>First Category</em> algorithms, whose running time depends on the size of smallest prime factor. Given an integer of unknown form, these methods are usually applied before general-purpose methods to remove small factors.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> For example, <a href="trial_division" title="wikilink">trial division</a> is a Category 1 algorithm.</p>
<ul>
<li><a href="Trial_division" title="wikilink">Trial division</a></li>
<li><a href="Wheel_factorization" title="wikilink">Wheel factorization</a></li>
<li><a href="Pollard's_rho_algorithm" title="wikilink">Pollard's rho algorithm</a></li>
<li><a href="Algebraic-group_factorisation_algorithms" title="wikilink">Algebraic-group factorisation algorithms</a>, among which are <a href="Pollard's_p_−_1_algorithm" title="wikilink">Pollard's <em>p</em> − 1 algorithm</a>, <a href="Williams'_p_+_1_algorithm" title="wikilink">Williams' <em>p</em> + 1 algorithm</a>, and <a href="Lenstra_elliptic_curve_factorization" title="wikilink">Lenstra elliptic curve factorization</a></li>
<li><a href="Fermat's_factorization_method" title="wikilink">Fermat's factorization method</a></li>
<li><a href="Euler's_factorization_method" title="wikilink">Euler's factorization method</a></li>
<li><a href="Special_number_field_sieve" title="wikilink">Special number field sieve</a></li>
</ul>
<h3 id="general-purpose">General-purpose</h3>
<p>A general-purpose factoring algorithm, also known as a <em>Category 2</em>, <em>Second Category</em>, or <em>Kraitchik family</em> algorithm (after <a href="Maurice_Kraitchik" title="wikilink">Maurice Kraitchik</a>),<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> has a running time which depends solely on the size of the integer to be factored. This is the type of algorithm used to factor <a href="RSA_number" title="wikilink">RSA numbers</a>. Most general-purpose factoring algorithms are based on the <a href="congruence_of_squares" title="wikilink">congruence of squares</a> method.</p>
<ul>
<li><a href="Dixon's_algorithm" title="wikilink">Dixon's algorithm</a></li>
<li><a href="Continued_fraction_factorization" title="wikilink">Continued fraction factorization</a> (CFRAC)</li>
<li><a href="Quadratic_sieve" title="wikilink">Quadratic sieve</a></li>
<li><a href="Rational_sieve" title="wikilink">Rational sieve</a></li>
<li><a href="General_number_field_sieve" title="wikilink">General number field sieve</a></li>
<li><a href="Shanks'_square_forms_factorization" title="wikilink">Shanks' square forms factorization</a> (SQUFOF)</li>
</ul>
<h3 id="other-notable-algorithms">Other notable algorithms</h3>
<ul>
<li><a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>, for <a href="quantum_computer" title="wikilink">quantum computers</a></li>
</ul>
<h2 id="heuristic-running-time">Heuristic running time</h2>
<p>In <a href="number_theory" title="wikilink">number theory</a>, there are many integer factoring algorithms that heuristically have expected <a href="Time_complexity" title="wikilink">running time</a></p>
<p><span class="LaTeX">$$L_n\left[1/2,1+o(1)\right]=e^{(1+o(1))(\log n)^{\frac{1}{2}}(\log \log n)^{\frac{1}{2}}}$$</span></p>
<p>in <a href="Big_O_notation" title="wikilink">o</a> and <a class="uri" href="L-notation" title="wikilink">L-notation</a>. Some examples of those algorithms are the <a href="elliptic_curve_method" title="wikilink">elliptic curve method</a> and the <a href="quadratic_sieve" title="wikilink">quadratic sieve</a>. Another such algorithm is the <strong>class group relations method</strong> proposed by Schnorr,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Seysen,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and Lenstra,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> that is proved under the assumption of the <a href="Generalized_Riemann_hypothesis" title="wikilink">Generalized Riemann Hypothesis (GRH)</a>.</p>
<h2 id="rigorous-running-time">Rigorous running time</h2>
<p>The Schnorr-Seysen-Lenstra probabilistic algorithm has been rigorously proven by Lenstra and Pomerance<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> to have expected running time <span class="LaTeX">$L_n\left[1/2,1+o(1)\right]$</span> by replacing the GRH assumption with the use of multipliers. The algorithm uses the <a href="Ideal_class_group" title="wikilink">class group</a> of positive binary <a href="quadratic_form" title="wikilink">quadratic forms</a> of <a href="Discriminant_of_a_quadratic_form" title="wikilink">discriminant</a> Δ denoted by <em>G</em><sub>Δ</sub>. <em>G</em><sub>Δ</sub> is the set of triples of integers (<em>a</em>, <em>b</em>, <em>c</em>) in which those integers are relative prime.</p>
<h3 id="schnorr-seysen-lenstra-algorithm">Schnorr-Seysen-Lenstra Algorithm</h3>
<p>Given is an integer <em>n</em> that will be factored, where <em>n</em> is an odd positive integer greater than a certain constant. In this factoring algorithm the discriminant Δ is chosen as a multiple of <em>n</em>, Δ= -<em>dn</em>, where <em>d</em> is some positive multiplier. The algorithm expects that for one <em>d</em> there exist enough <a href="smooth_number" title="wikilink">smooth</a> forms in <em>G</em><sub>Δ</sub>. Lenstra and Pomerance show that the choice of <em>d</em> can be restricted to a small set to guarantee the smoothness result.</p>
<p>Denote by <em>P</em><sub>Δ</sub> the set of all primes <em>q</em> with <a href="Kronecker_symbol" title="wikilink">Kronecker symbol</a> <span class="LaTeX">$\left(\tfrac{\Delta}{q}\right)=1$</span>. By constructing a set of <a href="Generating_set_of_a_group" title="wikilink">generators</a> of <em>G</em><sub>Δ</sub> and prime forms <em>f</em><sub>q</sub> of <em>G</em><sub>Δ</sub> with <em>q</em> in <em>P</em><sub>Δ</sub> a sequence of relations between the set of generators and <em>f</em><sub>q</sub> are produced. The size of <em>q</em> can be bounded by <span class="LaTeX">$c_0(\log|\Delta|)^2$</span> for some constant <span class="LaTeX">$c_0$</span>.</p>
<p>The relation that will be used is a relation between the product of powers that is equal to the <a href="group_(mathematics)" title="wikilink">neutral element</a> of <em>G</em><sub>Δ</sub>. These relations will be used to construct a so-called ambiguous form of <em>G</em><sub>Δ</sub>, which is an element of <em>G</em><sub>Δ</sub> of order dividing 2. By calculating the corresponding factorization of Δ and by taking a <a href="Greatest_common_divisor" title="wikilink">gcd</a>, this ambiguous form provides the complete prime factorization of <em>n</em>. This algorithm has these main steps:</p>
<p>Let <em>n</em> be the number to be factored.</p>
<ol>
<li>Let Δ be a negative integer with Δ = -<em>dn</em>, where <em>d</em> is a multiplier and Δ is the negative discriminant of some quadratic form.</li>
<li>Take the <em>t</em> first primes <span class="LaTeX">$p_1=2,p_2=3,p_3=5, \dots ,p_t$</span>, for some <span class="LaTeX">$t\in{\mathbb N}$</span>.</li>
<li>Let <span class="LaTeX">$f_q$</span> be a random prime form of <em>G</em><sub>Δ</sub> with <span class="LaTeX">$\left(\tfrac{\Delta}{q}\right)=1$</span>.</li>
<li>Find a generating set <em>X</em> of <em>G</em><sub>Δ</sub></li>
<li>Collect a sequence of relations between set <em>X</em> and {<em>f<sub>q</sub> : q</em> ∈ <em>P</em><sub>Δ</sub>} satisfying<span class="LaTeX">$$\left(\prod_{x \in X_{}} x^{r(x)}\right).\left(\prod_{q \in P_\Delta} f^{t(q)}_{q}\right) = 1$$</span></li>
<li>Construct an ambiguous form <em>(a, b, c)</em> that is an element <em>f</em> ∈ <em>G</em><sub>Δ</sub> of order dividing 2 to obtain a coprime factorization of the largest odd divisor of Δ in which Δ = <em>-4a.c</em> or <em>a(a - 4c)</em> or <em>(b - 2a).(b + 2a)</em></li>
<li>If the ambiguous form provides a factorization of <em>n</em> then stop, otherwise find another ambiguous form until the factorization of <em>n</em> is found. In order to prevent useless ambiguous forms from generating, build up the <a href="Sylow_theorems" title="wikilink">2-Sylow</a> group ''S<sub>2</sub>(Δ) of G(Δ).</li>
</ol>
<p>To obtain an algorithm for factoring any positive integer, it is necessary to add a few steps to this algorithm such as <a href="trial_division" title="wikilink">trial division</a>, and the <a href="Adleman–Pomerance–Rumely_primality_test" title="wikilink">Jacobi sum test</a>.</p>
<h3 id="expected-running-time">Expected running time</h3>
<p>The algorithm as stated is a <a href="probabilistic_algorithm" title="wikilink">probabilistic algorithm</a> as it makes random choices. Its expected running time is at most <span class="LaTeX">$L_n\left[1/2,1+o(1)\right]$</span>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="applications">Applications</h2>
<h3 id="fast-fourier-transforms">Fast Fourier Transforms</h3>
<p>The best-known <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> algorithms depend upon integer factorization.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Canonical_representation_of_a_positive_integer" title="wikilink">Canonical representation of a positive integer</a></li>
<li><a class="uri" href="Factorization" title="wikilink">Factorization</a></li>
<li><a href="Multiplicative_partition" title="wikilink">Multiplicative partition</a></li>
<li><a href="Partition_(number_theory)" title="wikilink">Partition (number theory)</a> - A way of writing a number as a sum of positive integers.</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>
<p>Chapter 5: Exponential Factoring Algorithms, pp. 191–226. Chapter 6: Subexponential Factoring Algorithms, pp. 227–284. Section 7.4: Elliptic curve method, pp. 301–313.</p></li>
<li><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em><a href="The_Art_of_Computer_Programming" title="wikilink">The Art of Computer Programming</a></em>, Volume 2: <em>Seminumerical Algorithms</em>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89684-2. Section 4.5.4: Factoring into Primes, pp. 379–417.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://sourceforge.net/projects/msieve/">msieve</a> - SIQS and NFS - has helped complete some of the largest public factorizations known</li>
<li>
<p>explaining uniqueness of prime factorization using a lock analogy.</p></li>
<li><a href="http://www.mersenneforum.org/showthread.php?t=3255">A collection of links to factoring programs</a></li>
<li>Richard P. Brent, "Recent Progress and Prospects for Integer Factorisation Algorithms", <em>Computing and Combinatorics"</em>, 2000, pp. 3–22. <a href="http://citeseer.ist.psu.edu/327036.html">download</a></li>
<li><a href="Manindra_Agrawal" title="wikilink">Manindra Agrawal</a>, Neeraj Kayal, Nitin Saxena, "PRIMES is in P." Annals of Mathematics 160(2): 781-793 (2004). <a href="http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf">August 2005 version PDF</a></li>
<li><a href="ftp://ftp.computing.dcu.ie/pub/crypto/factor.exe">1</a> is a public-domain integer factorization program for Windows. It claims to handle 80-digit numbers. See also the web site for this program <a href="http://www.shamus.ie/"></a></li>
<li>Eric W. Weisstein, <a href="http://mathworld.wolfram.com/news/2005-11-08/rsa-640/">“RSA-640 Factored” <em>MathWorld Headline News</em>, November 8, 2005</a></li>
</ul>
<p>"</p>
<p><a href="Category:Integer_factorization_algorithms" title="wikilink"> </a> <a href="Category:Computational_hardness_assumptions" title="wikilink">Category:Computational hardness assumptions</a> <a href="Category:Unsolved_problems_in_computer_science" title="wikilink">Category:Unsolved problems in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
