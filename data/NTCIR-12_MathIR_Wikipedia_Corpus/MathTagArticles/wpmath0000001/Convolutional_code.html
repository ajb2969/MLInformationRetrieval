<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1267">Convolutional code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Convolutional code</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a class="uri" href="telecommunication" title="wikilink">telecommunication</a>, a <strong>convolutional code</strong> is a type of <a href="Forward_error_correction" title="wikilink">error-correcting code</a> that generates parity symbols via the sliding application of a boolean polynomial function to a data stream. The sliding application represents the 'convolution' of the encoder over the data, which gives rise to the term 'convolutional coding.'</p>

<p>The sliding nature of the convolutional codes facilities <a href="Trellis_(graph)" title="wikilink">trellis</a> decoding using a time invariant trellis. Time invariant trellis decoding allows convolutional codes to be maximum likelihood soft decision decoded with reasonable complexity.</p>

<p>The ability to perform economical maximum likelihood soft decision decoding is one of the major benefits of convolutional codes. This is in contrast to classic block codes which are generally represented by a time variant trellis and therefore are typically hard decision decoded.</p>

<p>Convolutional codes are often characterized by the base code rate and the depth (or memory) of the encoder [n,k,K]. The base code rate is typically given as n/k, where n is the input data rate and k is the output symbol rate. The depth is often called the "constraint length" 'K', where the output is a function of the previous K-1 inputs. The depth may also be given as the number of memory elements 'v' in the polynomial or the maximum possible number of states of the encoder (typically 2^v).</p>

<p>Convolutional codes are often described as continuous. However, it may also be said that convolutional codes have arbitrary block length, rather than that they are continuous, since most real world convolutional encoding is performed on blocks of data. Convolutionally encoded block codes typically employ termination.</p>

<p>The arbitrary block length of convolutional codes can also be contrasted to classic block codes, which generally have fixed block lengths that are determined by algebraic properties.</p>

<p>The code rate of a convolutional code is commonly modified via symbol puncturing. For example, a convolutional code with a 'mother' code rate n/k=1/2 may be punctured to a higher rate of, for example, 7/8 simply by not transmitting a portion of code symbols. The performance of a punctured convolutional code generally scales well with the amount of parity transmitted.</p>

<p>The ability to perform economical soft decision decoding on convolutional codes, as well as the block length and code rate flexibility of convolutional codes, makes them very popular for digital communications.</p>
<h2 id="history">History</h2>

<p>Convolutional codes were introduced in 1965 by <a href="Peter_Elias" title="wikilink">Peter Elias</a>. It was thought that convolutional codes could be decoded with arbitrary quality at the expense of computation and delay. In 1967 <a href="Andrew_Viterbi" title="wikilink">Andrew Viterbi</a> determined that convolutional codes could be maximum likelihood decoded with reasonable complexity using time invariant trellis based decoders -- the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a>. Other trellis based decoder algorithms were later developed including the <a class="uri" href="BCJR" title="wikilink">BCJR</a> decoding algorithm.</p>

<p>Recursive systematic convolutional codes were invented by <a href="Claude_Berrou" title="wikilink">Claude Berrou</a> around 1991. These codes proved especially useful for iterative processing including the processing of concatenated codes such as <a href="turbo_codes" title="wikilink">turbo codes</a>.</p>

<p>Using the "convolutional" terminology, a classic convolutional code might be considered a <a href="Finite_impulse_response" title="wikilink">Finite impulse response</a> (FIR) filter, while a recursive convolutional code might be considered an <a href="Infinite_impulse_response" title="wikilink">Infinite impulse response</a> (IIR) filter.</p>
<h2 id="where-convolutional-codes-are-used">Where convolutional codes are used</h2>

<p>Convolutional codes are used extensively in numerous applications in order to achieve reliable data transfer, including <a href="digital_video" title="wikilink">digital video</a>, radio, <a href="mobile_communication" title="wikilink">mobile communication</a>, and <a href="satellite_communication" title="wikilink">satellite communication</a>. These codes are often implemented in <a href="concatenated_code" title="wikilink">concatenation</a> with a hard-decision code, particularly <a href="Reed_Solomon" title="wikilink">Reed Solomon</a>. Prior to <a href="turbo_codes" title="wikilink">turbo codes</a>, such constructions were the most efficient, coming closest to the <a href="Shannon-Hartley_theorem" title="wikilink">Shannon limit</a>.</p>
<h2 id="convolutional-encoding">Convolutional encoding</h2>

<p>To convolutionally encode data, start with <em>k</em> <a href="memory_register" title="wikilink">memory registers</a>, each holding 1 input bit. Unless otherwise specified, all memory registers start with a value of 0. The encoder has <em>n</em> modulo-2 <a href="Adder_(electronics)" title="wikilink">adders</a> (a modulo 2 adder can be implemented with a single <a href="Boolean_logic" title="wikilink">Boolean</a> <a href="XOR_gate" title="wikilink">XOR gate</a>, where the logic is: 0+0 = 0, 0+1 = 1, 1+0 = 1, 1+1 = 0), and <em>n</em> <a href="generator_polynomial" title="wikilink">generator polynomials</a> — one for each adder (see figure below). An input bit <em>m</em><sub>1</sub> is fed into the leftmost register. Using the generator polynomials and the existing values in the remaining registers, the encoder outputs <em>n</em> symbols. These symbols may be transmitted or punctured depending on the desired code rate. Now <a href="bit_shift" title="wikilink">bit shift</a> all register values to the right (<em>m</em><sub>1</sub> moves to <em>m</em><sub>0</sub>, <em>m</em><sub>0</sub> moves to <em>m</em><sub>-1</sub>) and wait for the next input bit. If there are no remaining input bits, the encoder continues shifting until all registers have returned to the zero state (flush bit termination).</p>

<p>The figure below is a rate 1/3 (<em>m</em>/<em>n</em>) encoder with constraint length (<em>k</em>) of 3. Generator polynomials are <em>G</em><sub>1</sub> = (1,1,1), <em>G</em><sub>2</sub> = (0,1,1), and <em>G</em><sub>3</sub> = (1,0,1). Therefore, output bits are calculated (modulo 2) as follows:</p>
<dl>
<dd><em>n</em><sub>1</sub> = <em>m</em><sub>1</sub> + <em>m</em><sub>0</sub> + <em>m<sub>-1</sub></em>
</dd>
<dd><em>n</em><sub>2</sub> = <em>m</em><sub>0</sub> + <em>m</em><sub>-1</sub>
</dd>
<dd><em>n</em><sub>3</sub> = <em>m</em><sub>1</sub> + <em>m</em><sub>-1</sub>.
</dd>
</dl>
<figure><b>(Figure)</b>
<figcaption>Img.1. Rate 1/3 non-recursive, non-systematic convolutional encoder with constraint length 3</figcaption>
</figure>
<h2 id="recursive-and-non-recursive-codes">Recursive and non-recursive codes</h2>

<p>The encoder on the picture above is a <em>non-recursive</em> encoder. Here's an example of a recursive one and as such it admits a feedback structure:</p>
<figure><b>(Figure)</b>
<figcaption>Img.2. Rate 1/2 8-state recursive systematic convolutional encoder. Used as constituent code in 3GPP 25.212 Turbo Code.</figcaption>
</figure>

<p>The example encoder is <em><a href="Systematic_code" title="wikilink">systematic</a></em> because the input data is also used in the output symbols (Output 2). Codes with output symbols that do not include the input data are called <em>non-systematic.</em></p>

<p>Recursive codes are typically systematic and, conversely, non-recursive codes are typically non-systematic. It isn't a strict requirement, but a common practice.</p>

<p>The example encoder in Img. 2. is an 8-state encoder because the 3 registers will create 8 possible encoder states (2<sup>3</sup>). A corresponding decoder trellis will typically use 8 states as well.</p>

<p>Recursive systematic convolutional (RSC) codes have become more popular due to their use in Turbo Codes. Recursive systematic codes are also referred to as pseudo-systematic codes.</p>

<p>Other RSC codes and example applications include:</p>
<figure><b>(Figure)</b>
<figcaption>Img. 3. Two-state recursive systematic convolutional (RSC) code. Also called an 'accumulator.' </figcaption>
</figure>

<p>Useful for LDPC code implementation and as inner constituent code for <a href="serial_concatenated_convolutional_codes" title="wikilink">serial concatenated convolutional codes</a> (SCCC's).</p>
<figure><b>(Figure)</b>
<figcaption>Img. 4. Four-state recursive systematic convolutional (RSC) code.</figcaption>
</figure>

<p>Useful for SCCC's and multidimensional turbo codes.</p>
<figure><b>(Figure)</b>
<figcaption>Img. 5. Sixteen-state recursive systematic convolutional (RSC) code. </figcaption>
</figure>

<p>Useful as constituent code in low error rate turbo codes for applications such as satellite links. Also suitable as SCCC outer code.</p>
<h2 id="impulse-response-transfer-function-and-constraint-length">Impulse response, transfer function, and constraint length</h2>

<p>A convolutional encoder is called so because it performs a <em><a class="uri" href="convolution" title="wikilink">convolution</a></em> of the input stream with the encoder's <em>impulse responses</em>:</p>

<p>

<math display="block" id="Convolutional_code:0">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>y</mi>
     <mi>i</mi>
     <mi>j</mi>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msubsup>
       <mi>h</mi>
       <mi>k</mi>
       <mi>j</mi>
      </msubsup>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{j}=\sum_{k=0}^{\infty}h^{j}_{k}x_{i-k},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Convolutional_code:1">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>x</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,
  </annotation>
 </semantics>
</math>

 is an input sequence, 

<math display="inline" id="Convolutional_code:2">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>y</mi>
    <mi>j</mi>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{j}\,
  </annotation>
 </semantics>
</math>

 is a sequence from output 

<math display="inline" id="Convolutional_code:3">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>j</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\,
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Convolutional_code:4">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>h</mi>
    <mi>j</mi>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{j}\,
  </annotation>
 </semantics>
</math>

 is an impulse response for output 

<math display="inline" id="Convolutional_code:5">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>j</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\,
  </annotation>
 </semantics>
</math>

.</p>

<p>A convolutional encoder is a discrete <a href="LTI_system" title="wikilink">linear time-invariant system</a>. Every output of an encoder can be described by its own <a href="transfer_function" title="wikilink">transfer function</a>, which is closely related to the generator polynomial. An impulse response is connected with a transfer function through <a class="uri" href="Z-transform" title="wikilink">Z-transform</a>.</p>

<p>Transfer functions for the first (non-recursive) encoder are:</p>
<ul>
<li>

<math display="inline" id="Convolutional_code:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(z)=1+z^{-1}+z^{-2},\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Convolutional_code:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}(z)=z^{-1}+z^{-2},\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Convolutional_code:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>3</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{3}(z)=1+z^{-2}.\,
  </annotation>
 </semantics>
</math>


</li>
</ul>

<p>Transfer functions for the second (recursive) encoder are:</p>
<ul>
<li>

<math display="inline" id="Convolutional_code:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </msup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(z)=\frac{1+z^{-1}+z^{-3}}{1-z^{-2}-z^{-3}},\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Convolutional_code:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>1.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}(z)=1.\,
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Define 

<math display="inline" id="Convolutional_code:11">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\,
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Convolutional_code:12">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>i</mi>
     </munder>
     <mrow>
      <mi>p</mi>
      <mi>o</mi>
      <mi>l</mi>
      <mi>y</mi>
      <mi>d</mi>
      <mi>e</mi>
      <mi>g</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mi>z</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>o</ci>
       <ci>l</ci>
       <ci>y</ci>
       <ci>d</ci>
       <ci>e</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\max_{i}polydeg(H_{i}(1/z))\,
  </annotation>
 </semantics>
</math>

</p>

<p>where, for any <a href="rational_function" title="wikilink">rational function</a> 

<math display="inline" id="Convolutional_code:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>Q</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>z</ci>
      </apply>
      <ci>Q</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=P(z)/Q(z)\,
  </annotation>
 </semantics>
</math>


,</p>

<p>

<math display="block" id="Convolutional_code:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>y</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>y</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>g</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>g</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>g</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   polydeg(f)=\max(deg(P),deg(Q))\,
  </annotation>
 </semantics>
</math>

.</p>

<p>Then 

<math display="inline" id="Convolutional_code:15">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\,
  </annotation>
 </semantics>
</math>

 is the maximum of the <a href="degree_of_a_polynomial" title="wikilink">polynomial degrees</a> of the 

<math display="inline" id="Convolutional_code:16">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>z</mi>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}(1/z)\,
  </annotation>
 </semantics>
</math>

, and the <em>constraint length</em> is defined as 

<math display="inline" id="Convolutional_code:17">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=m+1\,
  </annotation>
 </semantics>
</math>

. For instance, in the first example the constraint length is 3, and in the second the constraint length is 4.</p>
<h2 id="trellis-diagram">Trellis diagram</h2>

<p>A convolutional encoder is a <a href="finite_state_machine" title="wikilink">finite state machine</a>. An encoder with <em>n</em> binary cells will have 2<sup><em>n</em></sup> states.</p>

<p>Imagine that the encoder (shown on Img.1, above) has '1' in the left memory cell (<em>m</em><sub>0</sub>), and '0' in the right one (<em>m</em><sub>-1</sub>). (<em>m</em><sub>1</sub> is not really a memory cell because it represents a current value). We will designate such a state as "10". According to an input bit the encoder at the next turn can convert either to the "01" state or the "11" state. One can see that not all transitions are possible for (e.g., a decoder can't convert from "10" state to "00" or even stay in "10" state).</p>

<p>All possible transitions can be shown as below:</p>
<figure><b>(Figure)</b>
<figcaption>Img.3. A trellis diagram for the encoder on Img.1. A path through the trellis is shown as a red line. The solid lines indicate transitions where a "0" is input and the dashed lines where a "1" is input.</figcaption>
</figure>

<p>An actual encoded sequence can be represented as a path on this graph. One valid path is shown in red as an example.</p>

<p>This diagram gives us an idea about <em>decoding</em>: if a received sequence doesn't fit this graph, then it was received with errors, and we must choose the nearest <em>correct</em> (fitting the graph) sequence. The real decoding algorithms exploit this idea.</p>
<h2 id="free-distance-and-error-distribution">Free distance and error distribution</h2>

<p>The <strong>free distance</strong> (<em>d</em>) is the minimal <a href="Hamming_distance" title="wikilink">Hamming distance</a> between different encoded sequences. The <em>correcting capability</em> (<em>t</em>) of a convolutional code is the number of errors that can be corrected by the code. It can be calculated as</p>

<p>

<math display="block" id="Convolutional_code:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mrow>
     <mo>⌊</mo>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </mfrac>
     <mo>⌋</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=\left\lfloor\frac{d-1}{2}\right\rfloor.
  </annotation>
 </semantics>
</math>

</p>

<p>Since a convolutional code doesn't use blocks, processing instead a continuous bitstream, the value of <em>t</em> applies to a quantity of errors located relatively near to each other. That is, multiple groups of <em>t</em> errors can usually be fixed when they are relatively far apart.</p>

<p>Free distance can be interpreted as the minimal length of an erroneous "burst" at the output of a convolutional decoder. The fact that errors appear as "bursts" should be accounted for when designing a <a href="concatenated_code" title="wikilink">concatenated code</a> with an inner convolutional code. The popular solution for this problem is to <a href="forward_error_correction#Interleaving" title="wikilink">interleave</a> data before convolutional encoding, so that the outer block (usually <a class="uri" href="Reed-Solomon" title="wikilink">Reed-Solomon</a>) code can correct most of the errors.</p>
<h2 id="decoding-convolutional-codes">Decoding convolutional codes</h2>

<p>Several <a href="algorithm" title="wikilink">algorithms</a> exist for decoding convolutional codes. For relatively small values of <em>k</em>, the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> is universally used as it provides <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> performance and is highly parallelizable. Viterbi decoders are thus easy to implement in <a class="uri" href="VLSI" title="wikilink">VLSI</a> hardware and in software on CPUs with <a class="uri" href="SIMD" title="wikilink">SIMD</a> instruction sets.</p>

<p>Longer constraint length codes are more practically decoded with any of several <a href="sequential_decoding" title="wikilink">sequential decoding</a> algorithms, of which the <a href="Robert_Fano" title="wikilink">Fano</a> algorithm is the best known. Unlike Viterbi decoding, sequential decoding is not maximum likelihood but its complexity increases only slightly with constraint length, allowing the use of strong, long-constraint-length codes. Such codes were used in the <a href="Pioneer_program" title="wikilink">Pioneer program</a> of the early 1970s to Jupiter and Saturn, but gave way to shorter, Viterbi-decoded codes, usually concatenated with large <a href="Reed-Solomon_error_correction" title="wikilink">Reed-Solomon error correction</a> codes that steepen the overall bit-error-rate curve and produce extremely low residual undetected error rates.</p>

<p>Both Viterbi and sequential decoding algorithms return hard decisions: the bits that form the most likely codeword. An approximate confidence measure can be added to each bit by use of the <a href="Soft_output_Viterbi_algorithm" title="wikilink">Soft output Viterbi algorithm</a>. <a href="Maximum_a_posteriori" title="wikilink">Maximum a posteriori</a> (MAP) soft decisions for each bit can be obtained by use of the <a href="BCJR_algorithm" title="wikilink">BCJR algorithm</a>.</p>
<h2 id="popular-convolutional-codes">Popular convolutional codes</h2>

<p>An especially popular Viterbi-decoded convolutional code, used at least since the <a href="Voyager_program" title="wikilink">Voyager program</a> has a constraint length <em>k</em> of 7 and a rate <em>r</em> of 1/2.</p>
<ul>
<li>Longer constraint lengths produce more powerful codes, but the <a class="uri" href="complexity" title="wikilink">complexity</a> of the Viterbi algorithm <a href="exponential_growth" title="wikilink">increases exponentially</a> with constraint lengths, limiting these more powerful codes to deep space missions where the extra performance is easily worth the increased decoder complexity.</li>
</ul>
<ul>
<li><a href="Mars_Pathfinder" title="wikilink">Mars Pathfinder</a>, <a href="Mars_Exploration_Rover" title="wikilink">Mars Exploration Rover</a> and the <a href="Cassini_probe" title="wikilink">Cassini probe</a> to Saturn use a <em>k</em> of 15 and a rate of 1/6; this code performs about 2 dB better than the simpler <em>k</em>=7 code at a cost of 256× in decoding complexity (compared to Voyager mission codes).</li>
</ul>
<h2 id="punctured-convolutional-codes">Punctured convolutional codes</h2>

<p><a class="uri" href="Puncturing" title="wikilink">Puncturing</a> is a technique used to make a <em>m</em>/<em>n</em> rate code from a "basic" low-rate (e.g., 1/<em>n</em>) code. It is reached by deletion of some bits in the encoder output. Bits are deleted according to a <em>puncturing matrix</em>. The following puncturing matrices are the most frequently used:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Code rate</p></th>
<th style="text-align: left;">
<p>Puncturing matrix</p></th>
<th style="text-align: left;">
<p>Free distance (for NASA standard K=7 convolutional code)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1/2<br/>
(No perf.)</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>10</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2/3</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3/4</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5/6</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7/8</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
</tbody>
</table>

<p>For example, if we want to make a code with rate 2/3 using the appropriate matrix from the above table, we should take a basic encoder output and transmit every second bit from the first branch and every bit from the second one. The specific order of transmission is defined by the respective communication standard.</p>

<p>Punctured convolutional codes are widely used in the <a href="satellite_communications" title="wikilink">satellite communications</a>, for example, in <a class="uri" href="INTELSAT" title="wikilink">INTELSAT</a> systems and <a href="Digital_Video_Broadcasting" title="wikilink">Digital Video Broadcasting</a>.</p>

<p>Punctured convolutional codes are also called "perforated".</p>
<h2 id="turbo-codes-replacing-convolutional-codes">Turbo codes: replacing convolutional codes</h2>

<p>Simple Viterbi-decoded convolutional codes are now giving way to <a href="turbo_code" title="wikilink">turbo codes</a>, a new class of iterated short convolutional codes that closely approach the theoretical limits imposed by <a href="Shannon's_theorem" title="wikilink">Shannon's theorem</a> with much less decoding complexity than the Viterbi algorithm on the long convolutional codes that would be required for the same performance. <a href="Concatenated_code" title="wikilink">Concatenation</a> with an outer algebraic code (e.g., <a class="uri" href="Reed-Solomon" title="wikilink">Reed-Solomon</a>) addresses the issue of <a href="error_floor" title="wikilink">error floors</a> inherent to turbo code designs.</p>
<h2 id="matlab-implementation">MATLAB implementation</h2>

<p>MATLAB supports convolutional codes. For example the encoder shown on Img. 1 can be implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">    G1 = <span class="fl">7</span>;<span class="co">% octal 7 corresponds to binary 111 n1 = m1 + m0 + m-1 </span>
    G2 = <span class="fl">3</span>;<span class="co">% octal 3 corresponds to binary 011 n1 = m0  + m-1 </span>
    G3 = <span class="fl">5</span>;<span class="co">% octal 5 corresponds to binary 101 n1 = m1  + m-1 </span>
    constLen = <span class="fl">3</span>;   <span class="co">% Constraint length </span>
    
    <span class="co">% Create the trellis that represents the convolutional code</span>
    convCodeTrellis = poly2trellis(constLen, [ G1 G2 G3 ]);
    uncodedWord = [<span class="fl">1</span> ];
    codedWord1 = convenc(uncodedWord, convCodeTrellis) 
    uncodedWord = [<span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span>];
    codedWord2 = convenc(uncodedWord, convCodeTrellis) </code></pre></div>

<p>The output is the following:</p>

<p>codedWord1 =</p>

<p><code>    1     0     1</code></p>

<p>codedWord2 =</p>

<p><code>    1     0     1     1     1     0     1     1     1     0     0     0</code></p>

<p>The bits of the first output stream are at positions 1,4,7,...,3k+1,... in output vector <em>codedWord</em>, respectively second stream at positions 2,5,...,3k+2,... and the third 3,6,...,3k,...</p>

<p>Initial state is by default initialized by all zeros.</p>

<p>Convolution code can also be implemented using Verilog HDL language,by making use of corresponding state diagrams and state tables.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quantum_convolutional_code" title="wikilink">Quantum convolutional code</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.inference.phy.cam.ac.uk/mackay/itila/">The on-line textbook: Information Theory, Inference, and Learning Algorithms</a>, by <a href="David_J.C._MacKay" title="wikilink">David J.C. MacKay</a>, discusses convolutional codes in Chapter 48.</li>
<li><a href="http://www.eccpage.com/">The Error Correcting Codes (ECC) Page</a></li>
<li><a href="http://www.mathworks.fr/fr/help/comm/convolutional-coding.html">Matlab explanations</a></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Articles_with_example_MATLAB/Octave_code" title="wikilink">Category:Articles with example MATLAB/Octave code</a></p>
</body>

