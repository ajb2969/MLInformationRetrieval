<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="192">Computable number</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computable number</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>computable numbers</strong> are the <a href="real_numbers" title="wikilink">real numbers</a> that can be computed to within any desired precision by a finite, terminating <a class="uri" href="algorithm" title="wikilink">algorithm</a>. They are also known as the <strong>recursive numbers</strong> or the <strong>computable reals</strong> or <strong>recursive reals</strong>.</p>

<p>Equivalent definitions can be given using <a href="μ-recursive_function" title="wikilink">μ-recursive functions</a>, <a href="Turing_machines" title="wikilink">Turing machines</a>, or <a href="lambda_calculus" title="wikilink">λ-calculus</a> as the formal representation of algorithms. The computable numbers form a <a href="real_closed_field" title="wikilink">real closed field</a> and can be used in the place of real numbers for many, but not all, mathematical purposes.</p>
<h2 id="informal-definition-using-a-turing-machine-as-example">Informal definition using a Turing machine as example</h2>

<p>In the following, <a href="Marvin_Minsky" title="wikilink">Marvin Minsky</a> defines the numbers to be computed in a manner similar to those defined by <a href="Alan_Turing" title="wikilink">Alan Turing</a> in 1936; i.e., as "sequences of digits interpreted as decimal fractions" between 0 and 1:</p>
<dl>
<dd>"A computable number [is] one for which there is a Turing machine which, given <em>n</em> on its initial tape, terminates with the <em>nth</em> digit of that number [encoded on its tape]." (Minsky 1967:159)
</dd>
</dl>

<p>The key notions in the definition are (1) that some <em>n</em> is specified at the start, (2) for any <em>n</em> the computation only takes a finite number of steps, after which the machine produces the desired output and terminates.</p>

<p>An alternate form of (2) – the machine successively prints all n of the digits on its tape, halting after printing the n<sup>th</sup> – emphasizes Minsky's observation: (3) That by use of a Turing machine, a <em>finite</em> definition – in the form of the machine's table – is being used to define what is a potentially-<em>infinite</em> string of decimal digits.</p>

<p>This is however not the modern definition which only requires the result be accurate to within any given accuracy. The informal definition above is subject to a rounding problem called the <a href="table-maker's_dilemma" title="wikilink">table-maker's dilemma</a> whereas the modern definition is not.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A <a href="real_number" title="wikilink">real number</a> <em>a</em> is <strong>computable</strong> if it can be approximated by some <a href="computable_function" title="wikilink">computable function</a> 

<math display="inline" id="Computable_number:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <mi>ℤ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}\to\mathbb{Z}
  </annotation>
 </semantics>
</math>


 in the following manner: given any positive <a class="uri" href="integer" title="wikilink">integer</a> <em>n</em>, the function produces an integer <em>f(n)</em> such that:</p>

<p>

<math display="block" id="Computable_number:1">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </mfrac>
    <mo>≤</mo>
    <mi>a</mi>
    <mo>≤</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f(n)-1\over n}\leq a\leq{f(n)+1\over n}.
  </annotation>
 </semantics>
</math>

</p>

<p>There are two similar definitions that are equivalent:</p>
<ul>
<li>There exists a computable function which, given any positive rational <a href="error_bound" title="wikilink">error bound</a> 

<math display="inline" id="Computable_number:2">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

, produces a <a href="rational_number" title="wikilink">rational number</a> <em>r</em> such that 

<math display="inline" id="Computable_number:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>r</mi>
      <mo>-</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mi>ε</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>r</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |r-a|\leq\varepsilon.
  </annotation>
 </semantics>
</math>

</li>
<li>There is a computable sequence of rational numbers 

<math display="inline" id="Computable_number:4">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 converging to 

<math display="inline" id="Computable_number:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Computable_number:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>q</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |q_{i}-q_{i+1}|<2^{-i}\,
  </annotation>
 </semantics>
</math>

 for each <em>i</em>.</li>
</ul>

<p>There is another equivalent definition of computable numbers via computable <a href="Dedekind_cut" title="wikilink">Dedekind cuts</a>. A <strong>computable Dedekind cut</strong> is a computable function 

<math display="inline" id="Computable_number:7">
 <semantics>
  <mpadded width="+2.8pt">
   <mi>D</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\;
  </annotation>
 </semantics>
</math>

 which when provided with a rational number 

<math display="inline" id="Computable_number:8">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 as input returns 

<math display="inline" id="Computable_number:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mi>true</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>r</ci>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(r)=\mathrm{true}\;
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Computable_number:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mi>false</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>r</ci>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(r)=\mathrm{false}\;
  </annotation>
 </semantics>
</math>


, satisfying the following conditions:</p>

<p>

<math display="block" id="Computable_number:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>r</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mi>true</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>D</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists rD(r)=\mathrm{true}\;
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Computable_number:12">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>r</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mi>false</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>D</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists rD(r)=\mathrm{false}\;
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Computable_number:13">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>></mo>
   <mpadded width="+2.8pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q>0\;
  </annotation>
 </semantics>
</math>

 An example is given by a program <em>D</em> that defines the <a href="cube_root" title="wikilink">cube root</a> of 3. Assuming 

<math display="block" id="Computable_number:14">
 <semantics>
  <mrow>
   <msup>
    <mi>p</mi>
    <mn>3</mn>
   </msup>
   <mo><</mo>
   <mrow>
    <mn>3</mn>
    <msup>
     <mi>q</mi>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mi>true</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <divide></divide>
       <ci>p</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>true</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{3}<3q^{3}\Rightarrow D(p/q)=\mathrm{true}\;
  </annotation>
 </semantics>
</math>

 this is defined by:</p>

<p>

<math display="block" id="Computable_number:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>p</mi>
     <mn>3</mn>
    </msup>
    <mo>></mo>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>q</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>⇒</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mo>/</mo>
       <mi>q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>false</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <divide></divide>
       <ci>p</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>false</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{3}>3q^{3}\Rightarrow D(p/q)=\mathrm{false}.\;
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Computable_number:16">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

</p>

<p>A real number is computable if and only if there is a computable Dedekind cut <em>D</em> converging to it. The function <em>D</em> is unique for each irrational computable number (although of course two different programs may provide the same function).</p>

<p>A <a href="complex_number" title="wikilink">complex number</a> is called computable if its real and imaginary parts are computable.</p>
<h2 id="properties">Properties</h2>
<h3 id="countable-but-not-computably-enumerable">Countable but not computably enumerable</h3>

<p>While the set of real numbers is <a class="uri" href="uncountable" title="wikilink">uncountable</a>, the set of computable numbers is only <a class="uri" href="countable" title="wikilink">countable</a> and thus <a href="almost_all" title="wikilink">almost all</a> real numbers are not computable. That the computable numbers are <a href="countable" title="wikilink">at most countable</a> intuitively comes from the fact that they are produced by Turing machines, of which there are only countably many. More precisely, assigning a <a href="Gödel_number" title="wikilink">Gödel number</a> to each Turing machine definition produces a subset 

<math display="inline" id="Computable_number:17">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of the <a href="natural_numbers" title="wikilink">natural numbers</a> corresponding to the computable numbers and identifies a <a class="uri" href="surjection" title="wikilink">surjection</a> from 

<math display="inline" id="Computable_number:18">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,
  </annotation>
 </semantics>
</math>

 to the computable numbers, which shows that the computable numbers are <a class="uri" href="subcountable" title="wikilink">subcountable</a>. Moreover for any computable number 

<math display="inline" id="Computable_number:19">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 the <a href="well_ordering_principle" title="wikilink">well ordering principle</a> provides that there is a minimal element in 

<math display="inline" id="Computable_number:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 which corresponds to 

<math display="inline" id="Computable_number:21">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>⊂</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}\subset S
  </annotation>
 </semantics>
</math>

, and therefore there exists a subset 

<math display="inline" id="Computable_number:22">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 consisting of the minimal elements, on which the map is a <a class="uri" href="bijection" title="wikilink">bijection</a>. The inverse of this bijection is an <a class="uri" href="injection" title="wikilink">injection</a> into the natural numbers of the computable numbers, proving that they are countable.</p>

<p>The set 

<math display="inline" id="Computable_number:23">
 <semantics>
  <msup>
   <mi>S</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}
  </annotation>
 </semantics>
</math>

 of Gödel numbers, however, is not <a href="computably_enumerable" title="wikilink">computably enumerable</a> (nor consequently is 

<math display="inline" id="Computable_number:24">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

), even though the computable reals are themselves ordered. This is because there is no algorithm to determine which Gödel numbers correspond to Turing machines that produce computable reals. In order to produce a computable real, a Turing machine must compute a <a href="total_function" title="wikilink">total function</a>, but the corresponding <a href="decision_problem" title="wikilink">decision problem</a> is in <a href="Turing_degree" title="wikilink">Turing degree</a> <strong>0′′</strong>. Consequently there is no surjective <a href="computable_function" title="wikilink">computable function</a> from the natural numbers to the computable reals, and <a href="Cantor's_diagonal_argument" title="wikilink">Cantor's diagonal argument</a> cannot be used <a href="Constructivism_(mathematics)" title="wikilink">constructively</a> to demonstrate uncountably many of them.</p>
<h3 id="properties-as-a-field">Properties as a field</h3>

<p>The arithmetical operations on computable numbers are themselves computable in the sense that whenever real numbers <em>a</em> and <em>b</em> are computable then the following real numbers are also computable: <em>a + b</em>, <em>a - b</em>, <em>ab</em>, and <em>a/b</em> if <em>b</em> is nonzero. These operations are actually <em>uniformly computable</em>; for example, there is a Turing machine which on input (<em>A</em>,<em>B</em>,

<math display="inline" id="Computable_number:25">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>


) produces output <em>r</em>, where <em>A</em> is the description of a Turing machine approximating <em>a</em>, <em>B</em> is the description of a Turing machine approximating <em>b</em>, and <em>r</em> is an 

<math display="inline" id="Computable_number:26">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 approximation of <em>a</em>+<em>b</em>.</p>

<p>The fact that computable real numbers form a field was first proved by <a href="Henry_Gordon_Rice" title="wikilink">Henry Gordon Rice</a> (1954).</p>

<p>Computable reals do not form however a <a href="computable_algebra" title="wikilink">computable field</a>, because the definition of the latter notion requires effective equality.</p>
<h3 id="non-computability-of-the-ordering">Non-computability of the ordering</h3>

<p>The order relation on the computable numbers is not computable. Let <em>A</em> be the description of a Turing machine approximating the number 

<math display="inline" id="Computable_number:27">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>0
  </annotation>
 </semantics>
</math>

. Then there is no Turing machine which on input <em>A</em> outputs "YES" if 

<math display="inline" id="Computable_number:28">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\leq 0
  </annotation>
 </semantics>
</math>

 and "NO" if 

<math display="inline" id="Computable_number:29">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. The reason: suppose the machine described by <em>A</em> keeps outputting 0 as 

<math display="inline" id="Computable_number:30">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo><</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<b
  </annotation>
 </semantics>
</math>


 approximations. It is not clear how long to wait before deciding that the machine will <em>never</em> output an approximation which forces <em>a</em> to be positive. Thus the machine will eventually have to guess that the number will equal 0, in order to produce an output; the sequence may later become different from 0. This idea can be used to show that the machine is incorrect on some sequences if it computes a total function. A similar problem occurs when the computable reals are represented as <a href="Dedekind_cut" title="wikilink">Dedekind cuts</a>. The same holds for the equality relation : the equality test is not computable.</p>

<p>While the full order relation is not computable, the restriction of it to pairs of unequal numbers is computable. That is, there is a program that takes as input two Turing machines <em>A</em> and <em>B</em> approximating numbers <em>a</em> and <em>b</em>, where <em>a</em> ≠ <em>b</em>, and outputs whether 

<math display="inline" id="Computable_number:31">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Computable_number:32">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>b</mi>
      <mo>-</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<|b-a|/2
  </annotation>
 </semantics>
</math>

. It is sufficient to use ε-approximations where 

<math display="inline" id="Computable_number:33">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo><</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<b
  </annotation>
 </semantics>
</math>

 so by taking increasingly small ε (with a limit to 0), one eventually can decide whether 

<math display="inline" id="Computable_number:34">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Computable_number:35">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="other-properties">Other properties</h3>

<p>The computable real numbers do not share all the properties of the real numbers used in analysis. For example, the least upper bound of a bounded increasing computable sequence of computable real numbers need not be a computable real number (Bridges and Richman, 1987:58). A sequence with this property is known as a <a href="Specker_sequence" title="wikilink">Specker sequence</a>, as the first construction is due to E. Specker (1949). Despite the existence of counterexamples such as these, parts of calculus and real analysis can be developed in the field of computable numbers, leading to the study of <a href="computable_analysis" title="wikilink">computable analysis</a>.</p>

<p>Every computable number is <a href="definable_number" title="wikilink">definable</a>, but not vice versa. There are many definable, noncomputable real numbers, including:</p>
<ul>
<li>The binary representation of the <a href="halting_problem" title="wikilink">halting problem</a> (or any other uncomputable set of natural numbers).</li>
<li><a href="Chaitin's_constant" title="wikilink">Chaitin's constant</a>, 

<math display="inline" id="Computable_number:36">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq 1
  </annotation>
 </semantics>
</math>

, which is a type of real number that is <a href="Turing_degree" title="wikilink">Turing equivalent</a> to the halting problem.</li>
</ul>

<p>Both of these examples in fact define an infinite set of definable, uncomputable numbers, one for each <a href="Universal_Turing_machine" title="wikilink">Universal Turing machine</a>. A real number is computable if and only if the set of natural numbers it represents (when written in binary and viewed as a characteristic function) is computable.</p>

<p>Every computable number is <a href="arithmetical_number" title="wikilink">arithmetical</a>.</p>

<p>The set of computable real numbers (as well as every countable, <a href="densely_ordered" title="wikilink">densely ordered</a> subset of computable reals without ends) is <a class="uri" href="order-isomorphic" title="wikilink">order-isomorphic</a> to the set of rational numbers.</p>
<h2 id="digit-strings-and-the-cantor-and-baire-spaces">Digit strings and the Cantor and Baire spaces</h2>

<p>Turing's original paper defined computable numbers as follows:</p>
<dl>
<dd>A real number is computable if its digit sequence can be produced by some algorithm or Turing machine. The algorithm takes an integer 

<math display="inline" id="Computable_number:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 as input and produces the 

<math display="inline" id="Computable_number:38">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-th digit of the real number's decimal expansion as output.
</dd>
</dl>

<p>(Note that the decimal expansion of <em>a</em> only refers to the digits following the decimal point.)</p>

<p>Turing was aware that this definition is equivalent to the 

<math display="inline" id="Computable_number:39">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-approximation definition given above. The argument proceeds as follows: if a number is computable in the Turing sense, then it is also computable in the 

<math display="inline" id="Computable_number:40">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>10</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">10</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>\log_{10}(1/\epsilon)
  </annotation>
 </semantics>
</math>


 sense: if 

<math display="inline" id="Computable_number:41">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, then the first <em>n</em> digits of the decimal expansion for <em>a</em> provide an 

<math display="inline" id="Computable_number:42">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 approximation of <em>a</em>. For the converse, we pick an 

<math display="inline" id="Computable_number:43">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>

 computable real number <em>a</em> and generate increasingly precisce approximations until the <em>n</em>th digit after the decimal point is certain. This always generates a decimal expansion equal to <em>a</em> but it may improperly end in an infinite sequence of 9's in which case it must have a finite (and thus computable) proper decimal expansion.</p>

<p>Unless certain topological properties of the real numbers are relevant it is often more convenient to deal with elements of 

<math display="inline" id="Computable_number:44">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

 (total 0,1 valued functions) instead of reals numbers in 

<math display="inline" id="Computable_number:45">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>


. The members of 

<math display="inline" id="Computable_number:46">
 <semantics>
  <mrow>
   <mo>.</mo>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>d</mi>
    <mi>n</mi>
   </msub>
   <mn>0111</mn>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0111</cn>
    <ci>normal-…</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .d_{1}d_{2}\ldots d_{n}0111\ldots
  </annotation>
 </semantics>
</math>

 can be identified with binary decimal expansions but since the decimal expansions 

<math display="inline" id="Computable_number:47">
 <semantics>
  <mrow>
   <mo>.</mo>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>d</mi>
    <mi>n</mi>
   </msub>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">10</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .d_{1}d_{2}\ldots d_{n}10
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Computable_number:48">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

 denote the same real number the interval 

<math display="inline" id="Computable_number:49">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>

 can only be bijectively (and homeomorphically under the subset topology) identified with the subset of 

<math display="inline" id="Computable_number:50">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>


 not ending in all 1's.</p>

<p>Note that this property of decimal expansions means it's impossible to effectively identify computable real numbers defined in terms of a decimal expansion and those defined in the 

<math display="inline" id="Computable_number:51">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 approximation sense. Hirst has shown there is no algorithm which takes as input the description of a Turing machine which produces 

<math display="inline" id="Computable_number:52">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 approximations for the computable number <em>a</em>, and produces as output a Turing machine which enumerates the digits of <em>a</em> in the sense of Turing's definition (see Hirst 2007). Similarly it means that the arithmetic operations on the computable reals are not effective on their decimal representations as when adding decimal numbers, in order to produce one digit it may be necessary to look arbitrarily far to the right to determine if there is a carry to the current location. This lack of uniformity is one reason that the contemporary definition of computable numbers uses 

<math display="inline" id="Computable_number:53">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>

 approximations rather than decimal expansions.</p>

<p>However, from a computational or measure theoretic perspective the two structures 

<math display="inline" id="Computable_number:54">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Computable_number:55">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>


 are essentially identical. and computability theorists often refer to members of 

<math display="inline" id="Computable_number:56">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

 as reals. While 

<math display="inline" id="Computable_number:57">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Computable_number:58">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 is <a href="totally_disconnected_space" title="wikilink">totally disconnected</a> for questions about 

<math display="inline" id="Computable_number:59">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>

 classes or randomness it's much less messy to work in 

<math display="inline" id="Computable_number:60">
 <semantics>
  <msup>
   <mi>ω</mi>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega}
  </annotation>
 </semantics>
</math>


.</p>

<p>Elements of 

<math display="inline" id="Computable_number:61">
 <semantics>
  <mi>ℝ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℝ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}
  </annotation>
 </semantics>
</math>

 are sometimes called reals as well and though containing a homeomorphic image of 

<math display="inline" id="Computable_number:62">
 <semantics>
  <msup>
   <mi>ω</mi>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Computable_number:63">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{R}
  </annotation>
 </semantics>
</math>

 in addition to being totally disconnected isn't even locally compact. This leads to genuine differences in the computational properties. For instance the 

<math display="inline" id="Computable_number:64">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <in></in>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall(n\in\omega)\phi(x,n)
  </annotation>
 </semantics>
</math>

 satisfying 

<math display="inline" id="Computable_number:65">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x,n)
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Computable_number:66">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>ω</mi>
    <mi>ω</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\omega^{\omega}
  </annotation>
 </semantics>
</math>

 quantifier free must be computable while the unique 

<math display="inline" id="Computable_number:67">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 satisfying a universal formula can be arbitrarily high in the hyperarithmetic hierarchy.</p>
<h2 id="can-computable-numbers-be-used-instead-of-the-reals">Can computable numbers be used instead of the reals?</h2>

<p>The computable numbers include many of the specific real numbers which appear in practice, including all real <a href="algebraic_number" title="wikilink">algebraic numbers</a>, as well as <em>e</em>, <span class="LaTeX">$\pi$</span>, and many other <a href="transcendental_number" title="wikilink">transcendental numbers</a>. Though the computable reals exhaust those reals we can calculate or approximate, the assumption that all reals are computable leads to substantially different conclusions about the real numbers. The question naturally arises of whether it is possible to dispose of the full set of reals and use computable numbers for all of mathematics. This idea is appealing from a <a href="constructivism_(mathematics)" title="wikilink">constructivist</a> point of view, and has been pursued by what <a href="Errett_Bishop" title="wikilink">Bishop</a> and Richman call the <em>Russian school</em> of constructive mathematics.</p>

<p>To actually develop analysis over computable numbers, some care must be taken. For example, if one uses the classical definition of a sequence, the set of computable numbers is not closed under the basic operation of taking the <a class="uri" href="supremum" title="wikilink">supremum</a> of a <a href="bounded_sequence" title="wikilink">bounded sequence</a> (for example, consider a <a href="Specker_sequence" title="wikilink">Specker sequence</a>). This difficulty is addressed by considering only sequences which have a computable <a href="modulus_of_convergence" title="wikilink">modulus of convergence</a>. The resulting mathematical theory is called <a href="computable_analysis" title="wikilink">computable analysis</a>.</p>
<h2 id="implementation">Implementation</h2>

<p>There are some computer packages that work with computable real numbers, representing the real numbers as programs computing approximations. One example is the <a class="uri" href="RealLib" title="wikilink">RealLib</a> package (<a href="http://daimi.au.dk/~barnie/RealLib/">reallib home page</a>).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Definable_number" title="wikilink">Definable number</a></li>
<li><a href="Semicomputable_function" title="wikilink">Semicomputable function</a></li>
<li><a href="Transcomputational_problem" title="wikilink">Transcomputational problem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Oliver Aberth 1968, <em>Analysis in the Computable Number Field</em>, Journal of the Association for Computing Machinery (JACM), vol 15, iss 2, pp 276–299. This paper describes the development of the calculus over the computable number field.</li>
<li>Errett Bishop and Douglas Bridges, <em>Constructive Analysis</em>, Springer, 1985, ISBN 0-387-15066-8</li>
<li>Douglas Bridges and Fred Richman. <em>Varieties of Constructive Mathematics</em>, Oxford, 1987.</li>
<li>Jeffry L. Hirst, Representations of reals in reverse mathematics, Bulletin of the Polish Academy of Sciences, Mathematics, 55, (2007) 303–316.</li>
<li><a href="Marvin_Minsky" title="wikilink">Marvin Minsky</a> 1967, <em>Computation: Finite and Infinite Machines</em>, Prentice-Hall, Inc. Englewood Cliffs, NJ. No ISBN. Library of Congress Card Catalog No. 67-12342. His chapter §9 "The Computable Real Numbers" expands on the topics of this article.</li>
<li>E. Specker, "Nicht konstruktiv beweisbare Sätze der Analysis" J. Symbol. Logic, 14 (1949) pp. 145–158</li>
<li>

<p>(and ). Computable numbers (and Turing's a-machines) were introduced in this paper; the definition of computable numbers uses infinite decimal sequences.</p></li>
<li>Klaus Weihrauch 2000, <em>Computable analysis</em>, Texts in theoretical computer science, <a href="Springer_Science+Business_Media" title="wikilink">Springer</a>, ISBN 3-540-66817-9. §1.3.2 introduces the definition by <a href="nested_sequences_of_intervals" title="wikilink">nested sequences of intervals</a> converging to the singleton real. Other representations are discussed in §4.1.</li>
<li>Klaus Weihrauch, <em><a href="http://eccc.uni-trier.de/static/books/A_Simple_Introduction_to_Computable_Analysis_Fragments_of_a_Book/">A simple introduction to computable analysis</a></em></li>
<li>H. Gordon Rice. "Recursive real numbers." Proceedings of the American Mathematical Society 5.5 (1954): 784-791.</li>
<li>V. Stoltenberg-Hansen, J. V. Tucker "Computable Rings and Fields" in <em>Handbook of computability theory</em> edited by E.R. Griffor. Elsevier 1999</li>
</ul>

<p>Computable numbers were defined independently by Turing, Post and Church. See <em>The Undecidable</em>, ed. Martin Davis, for further original papers.</p>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
</body>
</html>
