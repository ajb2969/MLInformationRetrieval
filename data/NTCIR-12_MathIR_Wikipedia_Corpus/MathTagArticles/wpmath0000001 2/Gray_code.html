<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1617">Gray code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gray code</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The <strong>reflected binary code</strong>, also known as <strong>Gray code</strong> after <a href="Frank_Gray_(researcher)" title="wikilink">Frank Gray</a>, is a <a href="binary_numeral_system" title="wikilink">binary numeral system</a> where two successive values differ in only one <a class="uri" href="bit" title="wikilink">bit</a> (binary digit). The reflected binary code was originally designed to prevent spurious output from <a class="uri" href="electromechanical" title="wikilink">electromechanical</a> <a href="switch" title="wikilink">switches</a>. Today, Gray codes are widely used to facilitate <a href="error_correction" title="wikilink">error correction</a> in digital communications such as <a href="digital_terrestrial_television" title="wikilink">digital terrestrial television</a> and some <a href="DOCSIS" title="wikilink">cable TV</a> systems.</p>
<h2 id="name">Name</h2>

<p> <a href="Bell_Labs" title="wikilink">Bell Labs</a> researcher <a href="Frank_Gray_(researcher)" title="wikilink">Frank Gray</a> introduced the term <em>reflected binary code</em> in his 1947 patent application, remarking that the code had "as yet no recognized name".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> He derived the name from the fact that it "may be built up from the conventional binary code by a sort of reflection process".</p>

<p>The code was later named after Gray by others who used it. Two different 1953 patent applications use "Gray code" as an alternative name for the "reflected binary code";<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> one of those also lists "minimum error code" and "cyclic permutation code" among the names.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A 1954 patent application refers to "the Bell Telephone Gray code".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="motivation">Motivation</h2>

<p>Many devices indicate position by closing and opening switches. If that device uses <a href="binary_numeral_system" title="wikilink">natural binary codes</a>, positions 3 and 4 are next to each other but all three bits of the binary representation differ:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Decimal</p></th>
<th style="text-align: left;">

<p>Binary</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>...</p></td>
<td style="text-align: left;">

<p>...</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>011</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>4</p></td>
<td style="text-align: left;">

<p>100</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>...</p></td>
<td style="text-align: left;">

<p>...</p></td>
</tr>
</tbody>
</table>

<p>The problem with <a href="binary_numeral_system" title="wikilink">natural binary codes</a> is that, with physical, mechanical switches, it is very unlikely that switches will change states exactly in synchrony. In the transition between the two states shown above, all three switches change state. In the brief period while all are changing, the switches will read some spurious position. Even without <a class="uri" href="keybounce" title="wikilink">keybounce</a>, the transition might look like 011 — 001 — 101 — 100. When the switches appear to be in position 001, the observer cannot tell if that is the "real" position 001, or a transitional state between two other positions. If the output feeds into a <a href="sequential_logic" title="wikilink">sequential</a> system, possibly via <a href="combinational_logic" title="wikilink">combinational logic</a>, then the sequential system may store a false value.</p>

<p>The reflected binary code solves this problem by changing only one switch at a time, so there is never any ambiguity of position,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Decimal</p></th>
<th style="text-align: left;">

<p>Binary</p></th>
<th style="text-align: left;">

<p>Gray</p></th>
<th style="text-align: left;">

<p>Gray/Decimal</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>000</p></td>
<td style="text-align: left;">

<p>000</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>001</p></td>
<td style="text-align: left;">

<p>001</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>010</p></td>
<td style="text-align: left;">

<p>011</p></td>
<td style="text-align: left;">

<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>011</p></td>
<td style="text-align: left;">

<p>010</p></td>
<td style="text-align: left;">

<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>4</p></td>
<td style="text-align: left;">

<p>100</p></td>
<td style="text-align: left;">

<p>110</p></td>
<td style="text-align: left;">

<p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>5</p></td>
<td style="text-align: left;">

<p>101</p></td>
<td style="text-align: left;">

<p>111</p></td>
<td style="text-align: left;">

<p>7</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>6</p></td>
<td style="text-align: left;">

<p>110</p></td>
<td style="text-align: left;">

<p>101</p></td>
<td style="text-align: left;">

<p>5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>7</p></td>
<td style="text-align: left;">

<p>111</p></td>
<td style="text-align: left;">

<p>100</p></td>
<td style="text-align: left;">

<p>4</p></td>
</tr>
</tbody>
</table>

<p>Notice that state 7 can roll over to state 0 with only one switch change. This is called the "cyclic" property of a Gray code. In the standard Gray coding the least significant bit follows a repetitive pattern of 2 on, 2 off  the next digit a pattern of 4 on, 4 off; and so forth.</p>

<p>More formally, a <strong>Gray code</strong> is a code assigning to each of a contiguous set of <a href="integer" title="wikilink">integers</a>, or to each member of a circular list, a word of symbols such that each two adjacent code words differ by one symbol. These codes are also known as <em>single-distance codes</em>, reflecting the <a href="Hamming_distance" title="wikilink">Hamming distance</a> of 1 between adjacent codes. There can be more than one Gray code for a given word length, but the term was first applied to a particular <a href="binary_numeral_system" title="wikilink">binary</a> code for the non-negative integers, the <em>binary-reflected Gray code</em>, or <strong>BRGC</strong>, the three-bit version of which is shown above.</p>
<h2 id="history-and-practical-application">History and practical application</h2>

<p>Reflected binary codes were applied to mathematical puzzles before they became known to engineers. The French engineer <a href="Émile_Baudot" title="wikilink">Émile Baudot</a> used Gray codes in <a class="uri" href="telegraphy" title="wikilink">telegraphy</a> in 1878.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> He received the French <a href="Légion_d'honneur" title="wikilink">Legion of Honor</a> medal for his work. The Gray code is sometimes attributed, incorrectly,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> to <a href="Elisha_Gray" title="wikilink">Elisha Gray</a> (in <em>Principles of Pulse Code Modulation</em>, K. W. Cattermole,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> for example).</p>

<p><a href="Frank_Gray_(researcher)" title="wikilink">Frank Gray</a>, who became famous for inventing the signaling method that came to be used for compatible color television, invented a method to convert analog signals to reflected binary code groups using <a href="vacuum_tube" title="wikilink">vacuum tube</a>-based apparatus. The method and apparatus were patented in 1953 and the name of Gray stuck to the codes. The "<a href="Pulse_code_modulation#History" title="wikilink">PCM tube</a>" apparatus that Gray patented was made by Raymond W. Sears of Bell Labs, working with Gray and William M. Goodall, who credited Gray for the idea of the reflected binary code.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Part of front page of Gray's patent, showing PCM tube (10) with reflected binary code in plate (15)</figcaption>
</figure>

<p>The use of his eponymous codes that Gray was most interested in was to minimize the effect of error in the conversion of analog signals to digital; his codes are still used today for this purpose, and others.</p>
<h3 id="position-encoders">Position encoders</h3>

<p> </p>

<p>Gray codes are used in position encoders (<a href="linear_encoder" title="wikilink">linear encoders</a> and <a href="rotary_encoder" title="wikilink">rotary encoders</a>), in preference to straightforward binary encoding. This avoids the possibility that, when several bits change in the binary representation of an angle, a misread will result from some of the bits changing before others. Originally, the code pattern was electrically conductive, supported (in a rotary encoder) by an insulating disk. Each track had its own stationary metal spring contact; one more contact made the connection to the pattern. That common contact was connected by the pattern to whichever of the track contacts were resting on the conductive pattern. However, sliding contacts wear out and need maintenance, which favors optical encoders.</p>

<p>Regardless of the care in aligning the contacts, and accuracy of the pattern, a natural-binary code would have errors at specific disk positions, because it is impossible to make all bits change at exactly the same time as the disk rotates. The same is true of an optical encoder; transitions between opaque and transparent cannot be made to happen simultaneously for certain exact positions. Rotary encoders benefit from the cyclic nature of Gray codes, because consecutive positions of the sequence differ by only one bit. This means that, for a transition from state A to state B, timing mismatches can only affect when the A → B transition occurs, rather than inserting one or more (up to <em>N</em> − 1 for an <em>N</em>-bit codeword) false intermediate states, as would occur if a standard binary code were used.</p>
<h3 id="towers-of-hanoi">Towers of Hanoi</h3>

<p>The binary-reflected Gray code can also be used to serve as a solution guide for the <a href="Tower_of_Hanoi" title="wikilink">Towers of Hanoi problem</a>, as well as the classical <a href="Chinese_rings_puzzle" title="wikilink">Chinese rings puzzle</a>, a sequential mechanical puzzle mechanism.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> It also forms a <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a> on a <a class="uri" href="hypercube" title="wikilink">hypercube</a>, where each bit is seen as one dimension.</p>
<h3 id="genetic-algorithms">Genetic algorithms</h3>

<p>Due to the <a href="Hamming_distance" title="wikilink">Hamming distance</a> properties of Gray codes, they are sometimes used in <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>. They are very useful in this field, since mutations in the code allow for mostly incremental changes, but occasionally a single bit-change can cause a big leap and lead to new properties.</p>
<h3 id="karnaugh-maps">Karnaugh maps</h3>

<p>Gray codes are also used in labelling the axes of <a href="Karnaugh_map" title="wikilink">Karnaugh maps</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="error-correction">Error correction</h3>

<p>In modern <a href="digital_communications" title="wikilink">digital communications</a>, Gray codes play an important role in <a href="error_correction" title="wikilink">error correction</a>. For example, in a <a href="digital_modulation" title="wikilink">digital modulation</a> scheme such as <a href="quadrature_amplitude_modulation" title="wikilink">QAM</a> where data is typically transmitted in <a href="symbol_rate" title="wikilink">symbols</a> of 4 bits or more, the signal's <a href="constellation_diagram" title="wikilink">constellation diagram</a> is arranged so that the bit patterns conveyed by adjacent constellation points differ by only one bit. By combining this with <a href="forward_error_correction" title="wikilink">forward error correction</a> capable of correcting single-bit errors, it is possible for a <a href="Receiver_(radio)" title="wikilink">receiver</a> to correct any transmission errors that cause a constellation point to deviate into the area of an adjacent point. This makes the transmission system less susceptible to <a class="uri" href="noise" title="wikilink">noise</a>.</p>
<h3 id="communication-between-clock-domains">Communication between clock domains</h3>

<p>Digital logic designers use Gray codes extensively for passing multi-bit count information between synchronous logic that operates at different clock frequencies. The logic is considered operating in different "clock domains". It is fundamental to the design of large chips that operate with many different clocking frequencies.</p>
<h4 id="gray-code-counters-and-arithmetic">Gray code counters and arithmetic</h4>

<p>A typical use of Gray code counters is building a <a href="FIFO_(computing_and_electronics)" title="wikilink">FIFO</a> (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a "wrong" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.</p>

<p>Sometimes digital buses in electronic systems are used to convey quantities that can only increase or decrease by one at a time, for example the output of an event counter which is being passed between clock domains or to a digital-to-analog converter. The advantage of Gray codes in these applications is that differences in the propagation delays of the many wires that represent the bits of the code cannot cause the received value to go through states that are out of the Gray code sequence. This is similar to the advantage of Gray codes in the construction of mechanical encoders, however the source of the Gray code is an electronic counter in this case. The counter itself must count in Gray code, or if the counter runs in binary then the output value from the counter must be reclocked after it has been converted to Gray code, because when a value is converted from binary to Gray code, it is possible that differences in the arrival times of the binary data bits into the binary-to-Gray conversion circuit will mean that the code could go briefly through states that are wildly out of sequence. Adding a clocked register after the circuit that converts the count value to Gray code may introduce a clock cycle of latency, so counting directly in Gray code may be advantageous. A Gray code counter was patented in 1962 , and there have been many others since. In recent times a Gray code counter can be implemented as a state machine in <a class="uri" href="Verilog" title="wikilink">Verilog</a>. In order to produce the next count value, it is necessary to have some combinational logic that will increment the current count value that is stored in Gray code. Probably the most obvious way to increment a Gray code number is to convert it into ordinary binary code, add one to it with a standard binary adder, and then convert the result back to Gray code. This approach was discussed in a paper in 1996 <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and then subsequently patented by someone else in 1998 . Other methods of counting in Gray code are discussed in a report by R. W. Doran, including taking the output from the first latches of the master-slave flip flops in a binary ripple counter.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Perhaps the most common electronic counter with the "only one bit changes at a time" property is the <a href="Johnson_counter" title="wikilink">Johnson counter</a>.</p>
<h2 id="constructing-an-n-bit-gray-code">Constructing an <em>n</em>-bit Gray code</h2>

<p> </p>

<p>The binary-reflected Gray code list for <em>n</em> bits can be generated <a href="recursion" title="wikilink">recursively</a> from the list for <em>n</em> − 1 bits by reflecting the list (i.e. listing the entries in reverse order), concatenating the original list with the reversed list, prefixing the entries in the original list with a binary 0, and then prefixing the entries in the reflected list with a binary 1.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> For example, generating the <em>n</em> = 3 list from the <em>n</em> = 2 list:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>2-bit list:</p></td>
<td style="text-align: left;">

<p>00, 01, 11, 10</p></td>
<td style="text-align: left;">

<p> </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>Reflected:</p></td>
<td style="text-align: left;">

<p> </p></td>
<td style="text-align: left;">

<p>10, 11, 01, 00</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Prefix old entries with <em>0</em>:</p></td>
<td style="text-align: left;">

<p>000, 001, 011, 010,</p></td>
<td style="text-align: left;">

<p> </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>Prefix new entries with <em>1</em>:</p></td>
<td style="text-align: left;">

<p> </p></td>
<td style="text-align: left;">

<p>110, 111, 101, 100</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Concatenated:</p></td>
<td style="text-align: left;">

<p>000, 001, 011, 010,</p></td>
<td style="text-align: left;">

<p>110, 111, 101, 100</p></td>
</tr>
</tbody>
</table>

<p>The one-bit Gray code is <em>G</em><sub>1</sub> = (0, 1). This can be thought of as built recursively as above from a zero-bit Gray code <em>G</em><sub>0</sub> = { Λ } consisting of a single entry of zero length. This iterative process of generating <em>G</em><sub><em>n</em>+1</sub> from <em>G</em><sub><em>n</em></sub> makes the following properties of the standard reflecting code clear:</p>
<ul>
<li><em>G</em><sub><em>n</em></sub> is a <a class="uri" href="permutation" title="wikilink">permutation</a> of the numbers 0, ..., 2<sup><em>n</em></sup>−1. (Each number appears exactly once in the list.)</li>
<li><em>G</em><sub><em>n</em></sub> is embedded as the first half of <em>G</em><sub><em>n</em>+1</sub>.</li>
<li>Therefore the coding is <em>stable</em>, in the sense that once a binary number appears in <em>G</em><sub><em>n</em></sub> it appears in the same position in all longer lists; so it makes sense to talk about <em>the</em> reflective Gray code value of a number: <em>G</em>(<em>m</em>) = the <em>m</em>-th reflecting Gray code, counting from 0.</li>
<li>Each entry in <em>G</em><sub><em>n</em></sub> differs by only one bit from the previous entry. (The Hamming distance is 1.)</li>
<li>The last entry in <em>G</em><sub><em>n</em></sub> differs by only one bit from the first entry. (The code is cyclic.)</li>
</ul>

<p>These characteristics suggest a simple and fast method of translating a binary value into the corresponding Gray code. Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: the <em>n</em>th Gray code is obtained by computing 

<math display="inline" id="Gray_code:0">
<semantics>
<mrow>
<mi>n</mi>
<mo>⊕</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mrow>
<mi>n</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">⌋</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>n</ci>
<apply>
<floor></floor>
<apply>
<divide></divide>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\oplus\lfloor n/2\rfloor
  </annotation>
</semantics>
</math>
</p>

<p>A similar method can be used to perform the reverse translation, but the computation of each bit depends on the computed value of the next higher bit so it cannot be performed in parallel. Assuming 

<math display="inline" id="Gray_code:1">
<semantics>
<msub>
<mi>g</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g_{i}
  </annotation>
</semantics>
</math>

 is the 

<math display="inline" id="Gray_code:2">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

th gray-coded bit (

<math display="inline" id="Gray_code:3">
<semantics>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g_{0}
  </annotation>
</semantics>
</math>

 being the most significant bit), and 

<math display="inline" id="Gray_code:4">
<semantics>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   b_{i}
  </annotation>
</semantics>
</math>

 is the 

<math display="inline" id="Gray_code:5">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

th binary-coded bit (

<math display="inline" id="Gray_code:6">
<semantics>
<msub>
<mi>b</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   b_{0}
  </annotation>
</semantics>
</math>

 being the most-significant bit), the reverse translation can be given recursively

<math display="block" id="Gray_code:7">
<semantics>
<mrow>
<msub>
<mi>b</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   b_{0}=g_{0}
  </annotation>
</semantics>
</math>

, and 

<math display="inline" id="Gray_code:8">
<semantics>
<mrow>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>g</mi>
<mi>i</mi>
</msub>
<mo>⊕</mo>
<msub>
<mi>b</mi>
<mrow>
<mi>i</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<apply>
<minus></minus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   b_{i}=g_{i}\oplus b_{i-1}
  </annotation>
</semantics>
</math>

. Alternatively, decoding a Gray code into a binary number can be described as a <a href="prefix_sum" title="wikilink">prefix sum</a> of the bits in the Gray code, where each individual summation operation in the prefix sum is performed modulo two.</p>

<p>To construct the binary-reflected Gray code iteratively, at step 0 start with the 

<math display="inline" id="Gray_code:9">
<semantics>
<mrow>
<mrow>
<mi>c</mi>
<mi>o</mi>
<mi>d</mi>
<msub>
<mi>e</mi>
<mn>0</mn>
</msub>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>c</ci>
<ci>o</ci>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   code_{0}=0
  </annotation>
</semantics>
</math>

, and at step 

<math display="inline" id="Gray_code:10">
<semantics>
<mrow>
<mi>i</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<ci>i</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i&gt;0
  </annotation>
</semantics>
</math>

 find the bit position of the least significant 1 in the binary representation of 

<math display="inline" id="Gray_code:11">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

 and flip the bit at that position in the previous code 

<math display="inline" id="Gray_code:12">
<semantics>
<msub>
<mi>code</mi>
<mrow>
<mi>i</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>code</ci>
<apply>
<minus></minus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{code}_{i-1}
  </annotation>
</semantics>
</math>

 to get the next code 

<math display="inline" id="Gray_code:13">
<semantics>
<mrow>
<mi>c</mi>
<mi>o</mi>
<mi>d</mi>
<msub>
<mi>e</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>c</ci>
<ci>o</ci>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   code_{i}
  </annotation>
</semantics>
</math>

. The bit positions start 0, 1, 0, 2, 0, 1, 0, 3, ... . See <a href="find_first_set" title="wikilink">find first set</a> for efficient algorithms to compute these values.</p>
<h2 id="converting-to-and-from-gray-code">Converting to and from Gray code</h2>

<p>The following functions in <a href="C_(programming_language)" title="wikilink">C</a> convert between binary numbers and their associated Gray codes. While it may seem that gray-to-binary conversion requires each bit to be handled one at a time, faster algorithms exist.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">        The purpose of this function is to convert an unsigned</span>
<span class="co">        binary number to reflected binary Gray code.</span>

<span class="co">        The operator &gt;&gt; is shift right. The operator ^ is exclusive or.</span>
<span class="co">*/</span>
<span class="dt">unsigned</span> <span class="dt">int</span> binaryToGray(<span class="dt">unsigned</span> <span class="dt">int</span> num)
{
        <span class="kw">return</span> (num &gt;&gt; <span class="dv">1</span>) ^ num;
}

<span class="co">/*</span>
<span class="co">        The purpose of this function is to convert a reflected binary</span>
<span class="co">        Gray code number to a binary number.</span>
<span class="co">*/</span>
<span class="dt">unsigned</span> <span class="dt">int</span> grayToBinary(<span class="dt">unsigned</span> <span class="dt">int</span> num)
{
    <span class="dt">unsigned</span> <span class="dt">int</span> mask;
    <span class="kw">for</span> (mask = num &gt;&gt; <span class="dv">1</span>; mask != <span class="dv">0</span>; mask = mask &gt;&gt; <span class="dv">1</span>)
    {
        num = num ^ mask;
    }
    <span class="kw">return</span> num;
}</code></pre></div>
<h2 id="special-types-of-gray-codes">Special types of Gray codes</h2>

<p>In practice, a "Gray code" almost always refers to a binary-reflected Gray code (BRGC). However, mathematicians have discovered other kinds of Gray codes. Like BRGCs, each consists of a lists of words, where each word differs from the next in only one digit (each word has a <a href="Hamming_distance" title="wikilink">Hamming distance</a> of 1 from the next word).</p>
<h3 id="n-ary-gray-code"><em>n</em>-ary Gray code</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p><em>Ternary number → ternary Gray code</em></p>

<p><code>  0 → 000</code><br/>
<code>  1 → 001</code><br/>
<code>  2 → 002</code><br/>
<code> 10 → 012</code><br/>
<code> 11 → 010</code><br/>
<code> 12 → 011</code><br/>
<code> 20 → 021</code><br/>
<code> 21 → 022</code><br/>
<code> 22 → 020</code><br/>
<code>100 → 120</code><br/>
<code>101 → 121</code><br/>
<code>102 → 122</code><br/>
<code>110 → 102</code><br/>
<code>111 → 100</code><br/>
<code>112 → 101</code><br/>
<code>120 → 111</code><br/>
<code>121 → 112</code><br/>
<code>122 → 110</code><br/>
<code>200 → 210</code><br/>
<code>201 → 211</code><br/>
<code>202 → 212</code><br/>
<code>210 → 222</code><br/>
<code>211 → 220</code><br/>
<code>212 → 221</code><br/>
<code>220 → 201</code><br/>
<code>221 → 202</code><br/>
<code>222 → 200</code></p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>There are many specialized types of Gray codes other than the binary-reflected Gray code. One such type of Gray code is the <strong><em>n</em>-ary Gray code</strong>, also known as a <strong>non-Boolean Gray code</strong>. As the name implies, this type of Gray code uses non-Boolean values in its encodings.</p>

<p>For example, a 3-ary (<a class="uri" href="ternary" title="wikilink">ternary</a>) Gray code would use the values {0, 1, 2}. The (<em>n</em>, <em>k</em>)-<em>Gray code</em> is the <em>n</em>-ary Gray code with <em>k</em> digits.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The sequence of elements in the (3, 2)-Gray code is: {00, 01, 02, 12, 10, 11, 21, 22, 20}. The (<em>n</em>, <em>k</em>)-Gray code may be constructed recursively, as the BRGC, or may be constructed <a href="iteration" title="wikilink">iteratively</a>. An <a class="uri" href="algorithm" title="wikilink">algorithm</a> to iteratively generate the (<em>N</em>, <em>k</em>)-Gray code is presented (in <a href="C_(programming_language)" title="wikilink">C</a>):</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="co">// inputs: base, digits, value</span>
<span class="co">// output: gray</span>
<span class="co">// Convert a value to a graycode with the given base and digits.</span>
<span class="co">// Iterating through a sequence of values would result in a sequence</span>
<span class="co">// of Gray codes in which only one digit changes at a time.</span>
<span class="dt">void</span> to_gray(<span class="dt">unsigned</span> base, <span class="dt">unsigned</span> digits, <span class="dt">unsigned</span> value, <span class="dt">unsigned</span> gray[digits])
{ 
    <span class="dt">unsigned</span> baseN[digits]; <span class="co">// Stores the ordinary base-N number, one digit per entry</span>
    <span class="dt">unsigned</span> i;     <span class="co">// The loop variable</span>
 
    <span class="co">// Put the normal baseN number into the baseN array. For base 10, 109 </span>
    <span class="co">// would be stored as [9,0,1]</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; digits; i++) {
        baseN[i] = value % base;
        value    = value / base;
    }
 
    <span class="co">// Convert the normal baseN number into the graycode equivalent. Note that</span>
    <span class="co">// the loop starts at the most significant digit and goes down.</span>
    <span class="dt">unsigned</span> shift = <span class="dv">0</span>;
    <span class="kw">while</span> (i--) {
        <span class="co">// The gray digit gets shifted down by the sum of the higher</span>
        <span class="co">// digits.</span>
        gray[i] = (baseN[i] + shift) % base;
        shift = shift + base - gray[i]; <span class="co">// Subtract from base so shift is positive</span>
    }
}
<span class="co">// EXAMPLES</span>
<span class="co">// input: value = 1899, base = 10, digits = 4</span>
<span class="co">// output: baseN[] = [9,9,8,1], gray[] = [0,1,7,1]</span>
<span class="co">// input: value = 1900, base = 10, digits = 4</span>
<span class="co">// output: baseN[] = [0,0,9,1], gray[] = [0,1,8,1]</span></code></pre></div>

<p>There are other graycode algorithms for (<em>n</em>,<em>k</em>)-Gray codes. The (<em>n</em>,<em>k</em>)-Gray code produced by the above algorithm is always cyclical; some algorithms, such as that by Guan,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> lack this property when k is odd. On the other hand, while only one digit at a time changes with this method, it can change by wrapping (looping from <em>n</em> − 1 to 0). In Guan's algorithm, the count alternately rises and falls, so that the numeric difference between two graycode digits is always one.</p>

<p>Gray codes are not uniquely defined, because a permutation of the columns of such a code is a Gray code too. The above procedure produces a code in which the lower the significance of a digit, the more often it changes, making it similar to normal counting methods.</p>
<h3 id="balanced-gray-code">Balanced Gray code</h3>

<p>Although the binary reflected Gray code is useful in many scenarios, it is not optimal in certain cases because of a lack of "uniformity".<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In <strong>balanced Gray codes</strong>, the number of changes in different coordinate positions are as close as possible. To make this more precise, let <em>G</em> be an <em>R</em>-ary complete Gray cycle having transition sequence 

<math display="inline" id="Gray_code:14">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>δ</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\delta_{k})
  </annotation>
</semantics>
</math>

; the <em>transition counts (spectrum)</em> of <em>G</em> are the collection of integers defined by</p>

<p>
<math display="block" id="Gray_code:15">
<semantics>
<mrow>
<mrow>
<msub>
<mi>λ</mi>
<mi>k</mi>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>j</mi>
<mo>∈</mo>
<msub>
<mi>ℤ</mi>
<msup>
<mi>R</mi>
<mi>n</mi>
</msup>
</msub>
</mrow>
<mo>:</mo>
<mrow>
<msub>
<mi>δ</mi>
<mi>j</mi>
</msub>
<mo>=</mo>
<mi>k</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<mo rspace="4.2pt" stretchy="false">|</mo>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<mrow>
<mtext>for</mtext>
<mi>k</mi>
</mrow>
<mo>∈</mo>
<msub>
<mi>ℤ</mi>
<mi>R</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>k</ci>
</apply>
<apply>
<abs></abs>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<apply>
<in></in>
<ci>j</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>j</ci>
</apply>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<in></in>
<apply>
<times></times>
<mtext>for</mtext>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<ci>R</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda_{k}=|\{j\in\mathbb{Z}_{R^{n}}:\delta_{j}=k\}|\,,\text{ for }k\in%
\mathbb{Z}_{R}
  </annotation>
</semantics>
</math>
</p>

<p>A Gray code is <em>uniform</em> or <em>uniformly balanced</em> if its transition counts are all equal, in which case we have 

<math display="inline" id="Gray_code:16">
<semantics>
<mrow>
<msub>
<mi>λ</mi>
<mi>k</mi>
</msub>
<mo>=</mo>
<mrow>
<msup>
<mi>R</mi>
<mi>n</mi>
</msup>
<mo>/</mo>
<mi>n</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>k</ci>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<ci>n</ci>
</apply>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda_{k}=R^{n}/n
  </annotation>
</semantics>
</math>

 for all <em>k</em>. Clearly, when 

<math display="inline" id="Gray_code:17">
<semantics>
<mrow>
<mi>R</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>R</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R=2
  </annotation>
</semantics>
</math>

, such codes exist only if <em>n</em> is a power of 2. Otherwise, if <em>n</em> does not divide 

<math display="inline" id="Gray_code:18">
<semantics>
<msup>
<mi>R</mi>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R^{n}
  </annotation>
</semantics>
</math>

 evenly, it is possible to construct <em>well-balanced</em> codes where every transition count is either 

<math display="inline" id="Gray_code:19">
<semantics>
<mrow>
<mo stretchy="false">⌊</mo>
<mrow>
<msup>
<mi>R</mi>
<mi>n</mi>
</msup>
<mo>/</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">⌋</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<floor></floor>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<ci>n</ci>
</apply>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lfloor R^{n}/n\rfloor
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Gray_code:20">
<semantics>
<mrow>
<mo stretchy="false">⌈</mo>
<mrow>
<msup>
<mi>R</mi>
<mi>n</mi>
</msup>
<mo>/</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">⌉</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ceiling></ceiling>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<ci>n</ci>
</apply>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lceil R^{n}/n\rceil
  </annotation>
</semantics>
</math>

. Gray codes can also be <em>exponentially balanced</em> if all of their transition counts are adjacent powers of two, and such codes exist for every power of two.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>For example, a balanced 4-bit Gray code has 16 transitions, which can be evenly distributed among all four positions (four transitions per position), making it uniformly balanced:<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p><code>0 </code><code> 1 1 1 1 1 </code><code> 0 0 0 0 0 </code><code> 1 </code><code> </code><br/>
<code>0 0 </code><code> 1 1 1 </code><code> 0 </code><code> 1 1 1 </code><code> 0 0 0 </code><br/>
<code>0 0 0 0 </code><code> 1 1 1 1 </code><code> 0 </code><code> 1 1 </code><code> 0 </code><br/>
<code> 0 0 </code><code> 1 </code><code> 0 0 0 0 </code><code> 1 1 1 1 1</code></p>

<p>whereas a balanced 5-bit Gray code has a total of 32 transitions, which cannot be evenly distributed among the positions. In this example, four positions have six transitions each, and one has eight:<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a>  1 1 1 1  0 0 0  1 1 1 1 1  0  1 1 1 1  0 0 0 0 0 0 0 0 0</p>

<p><code>0 0 0 </code><code> 1 1 1 1 1 1 1 </code><code> 0 0 0 0 0 0 </code><code> 1 1 1 1 1 </code><code> 0 0 </code><code> 1 </code><code> 0 0 </code><br/>
<code>1 1 </code><code> 0 </code><code> 1 1 </code><code> 0 0 0 0 0 </code><code> 1 1 </code><code> 0 0 </code><code> 1 1 1 1 1 </code><code> 0 0 0 0 </code><code> 1 </code><br/>
<code>1 </code><code> 0 0 0 0 0 0 </code><code> 1 1 1 1 1 </code><code> 0 0 0 0 0 </code><code> 1 1 1 1 1 1 1 </code><code> 0 0 </code><code> </code><br/>
<code>1 1 1 1 1 1 </code><code> 0 0 0 </code><code> 1 </code><code> 0 0 0 0 0 0 0 0 </code><code> 1 </code><code> 0 0 </code><code> 1 1 1 1 1</code></p>

<p>We will now show a construction for well-balanced binary Gray codes which allows us to generate an <em>n</em>-digit balanced Gray code for every <em>n</em>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> The main principle is to inductively construct an (<em>n</em> + 2)-digit Gray code 

<math display="inline" id="Gray_code:21">
<semantics>
<msup>
<mi>G</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
</semantics>
</math>

 given an <em>n</em>-digit Gray code <em>G</em> in such a way that the balanced property is preserved. To do this, we consider partitions of 

<math display="inline" id="Gray_code:22">
<semantics>
<mrow>
<mi>G</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>g</mi>
<mrow>
<msup>
<mn>2</mn>
<mi>n</mi>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>G</ci>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G=g_{0},\ldots,g_{2^{n}-1}
  </annotation>
</semantics>
</math>

 into an even number <em>L</em> of non-empty blocks of the form</p>

<p>
<math display="block" id="Gray_code:23">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>g</mi>
<mrow>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>3</mn>
</msub>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>g</mi>
<mrow>
<msub>
<mi>k</mi>
<mrow>
<mi>L</mi>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</set>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</set>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</set>
<ci>normal-…</ci>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<apply>
<minus></minus>
<ci>L</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
</set>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</set>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{g_{0}\},\{g_{1},\ldots,g_{k_{2}}\},\{g_{k_{2}+1},\ldots,g_{k_{3}}\},\ldots,%
\{g_{k_{L-2}+1},\ldots,g_{-2}\},\{g_{-1}\}
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Gray_code:24">
<semantics>
<mrow>
<mrow>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>k</mi>
<mrow>
<mi>L</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">0</cn>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<apply>
<minus></minus>
<ci>L</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k_{1}=0,k_{L-1}=-2
  </annotation>
</semantics>
</math>

, and 

<math display="inline" id="Gray_code:25">
<semantics>
<mrow>
<msub>
<mi>k</mi>
<mi>L</mi>
</msub>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<ci>L</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k_{L}=-1
  </annotation>
</semantics>
</math>

 (mod 

<math display="inline" id="Gray_code:26">
<semantics>
<msup>
<mn>2</mn>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{n}
  </annotation>
</semantics>
</math>

). This partition induces an 

<math display="inline" id="Gray_code:27">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (n+2)
  </annotation>
</semantics>
</math>

-digit Gray code given by</p>

<p>
<math display="block" id="Gray_code:28">
<semantics>
<mrow>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   00g_{0},
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Gray_code:29">
<semantics>
<mrow>
<mrow>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>01</mn>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>01</mn>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>11</mn>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>11</mn>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
</msub>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">01</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">01</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">11</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">11</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   00g_{1},\ldots,00g_{k_{2}},01g_{k_{2}},\ldots,01g_{1},11g_{1},\ldots,11g_{k_{2%
}},
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Gray_code:30">
<semantics>
<mrow>
<mrow>
<mrow>
<mn>11</mn>
<msub>
<mi>g</mi>
<mrow>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>11</mn>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>3</mn>
</msub>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>01</mn>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>3</mn>
</msub>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>01</mn>
<msub>
<mi>g</mi>
<mrow>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<mrow>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<msub>
<mi>k</mi>
<mn>3</mn>
</msub>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<cn type="integer">11</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">11</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">01</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">01</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
<ci>normal-…</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   11g_{k_{2}+1},\ldots,11g_{k_{3}},01g_{k_{3}},\ldots,01g_{k_{2}+1},00g_{k_{2}+1%
},\ldots,00g_{k_{3}},\ldots,
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Gray_code:31">
<semantics>
<mrow>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>00</mn>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>10</mn>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>10</mn>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mn>10</mn>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>11</mn>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>11</mn>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>01</mn>
<msub>
<mi>g</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mn>01</mn>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">00</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">10</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">10</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<cn type="integer">10</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">11</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">11</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">01</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">01</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   00g_{-2},00g_{-1},10g_{-1},10g_{-2},\ldots,10g_{0},11g_{0},11g_{-1},01g_{-1},0%
1g_{0}
  </annotation>
</semantics>
</math>
</p>

<p>If we define the <em>transition multiplicities</em>
<math display="inline" id="Gray_code:32">
<semantics>
<mrow>
<msub>
<mi>m</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>j</mi>
<mo>:</mo>
<mrow>
<mrow>
<msub>
<mi>δ</mi>
<msub>
<mi>k</mi>
<mi>j</mi>
</msub>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo>,</mo>
<mrow>
<mn>1</mn>
<mo>≤</mo>
<mi>j</mi>
<mo>≤</mo>
<mi>L</mi>
</mrow>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<ci>i</ci>
</apply>
<apply>
<abs></abs>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<ci>j</ci>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<ci>j</ci>
</apply>
</apply>
<ci>i</ci>
</apply>
<apply>
<and></and>
<apply>
<leq></leq>
<cn type="integer">1</cn>
<ci>j</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<ci>L</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m_{i}=|\{j:\delta_{k_{j}}=i,1\leq j\leq L\}|
  </annotation>
</semantics>
</math>

 to be the number of times the digit in position <em>i</em> changes between consecutive blocks in a partition, then for the (<em>n</em> + 2)-digit Gray code induced by this partition the transition spectrum 

<math display="inline" id="Gray_code:33">
<semantics>
<msubsup>
<mi>λ</mi>
<mi>k</mi>
<mo>′</mo>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>λ</ci>
<ci>normal-′</ci>
</apply>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda^{\prime}_{k}
  </annotation>
</semantics>
</math>

 is</p>

<p>
<math display="block" id="Gray_code:34">
<semantics>
<mrow>
<msubsup>
<mi>λ</mi>
<mi>k</mi>
<mo>′</mo>
</msubsup>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<mrow>
<mn>4</mn>
<msub>
<mi>λ</mi>
<mi>k</mi>
</msub>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<msub>
<mi>m</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mrow>
<mtext>if</mtext>
<mn>0</mn>
</mrow>
<mo>≤</mo>
<mi>k</mi>
<mo>&lt;</mo>
<mi>n</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mi>L</mi>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="left">
<mtext>otherwise</mtext>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>λ</ci>
<ci>normal-′</ci>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">4</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<times></times>
<mtext>if</mtext>
<cn type="integer">0</cn>
</apply>
<ci>k</ci>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<ci>n</ci>
</apply>
</apply>
<ci>L</ci>
<mtext>otherwise</mtext>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda^{\prime}_{k}=\begin{cases}4\lambda_{k}-2m_{k},&amp;\text{if }0\leq k<n\\ <="" annotation="" l,&\text{="" otherwise="" }\end{cases}="">
</n\\></annotation></semantics>
</math>
</p>

<p>The delicate part of this construction is to find an adequate partitioning of a balanced <em>n</em>-digit Gray code such that the code induced by it remains balanced. Uniform codes can be found when 

<math display="inline" id="Gray_code:35">
<semantics>
<mrow>
<mi>R</mi>
<mo>≡</mo>
<mrow>
<mn>0</mn>
<mo lspace="2.5pt" rspace="2.5pt">mod</mo>
<mn>4</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<ci>R</ci>
<apply>
<csymbol cd="latexml">modulo</csymbol>
<cn type="integer">0</cn>
<cn type="integer">4</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R\equiv 0\mod 4
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Gray_code:36">
<semantics>
<mrow>
<msup>
<mi>R</mi>
<mi>n</mi>
</msup>
<mo>≡</mo>
<mrow>
<mn>0</mn>
<mo lspace="2.5pt" rspace="2.5pt">mod</mo>
<mi>n</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="latexml">modulo</csymbol>
<cn type="integer">0</cn>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R^{n}\equiv 0\mod n
  </annotation>
</semantics>
</math>

, and this construction can be extended to the <em>R</em>-ary case as well.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h3 id="monotonic-gray-codes">Monotonic Gray codes</h3>

<p>Monotonic codes are useful in the theory of interconnection networks, especially for minimizing dilation for linear arrays of processors.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> If we define the <em>weight</em> of a binary string to be the number of 1s in the string, then although we clearly cannot have a Gray code with strictly increasing weight, we may want to approximate this by having the code run through two adjacent weights before reaching the next one.</p>

<p>We can formalize the concept of monotone Gray codes as follows: consider the partition of the hypercube 

<math display="inline" id="Gray_code:37">
<semantics>
<mrow>
<msub>
<mi>Q</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<mo>,</mo>
<msub>
<mi>E</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Q</ci>
<ci>n</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<ci>n</ci>
</apply>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q_{n}=(V_{n},E_{n})
  </annotation>
</semantics>
</math>

 into <em>levels</em> of vertices that have equal weight, i.e.</p>

<p>
<math display="block" id="Gray_code:38">
<semantics>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>v</mi>
<mo>∈</mo>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
</mrow>
<mo>:</mo>
<mrow>
<mi>v</mi>
<mtext>has weight</mtext>
<mi>i</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<apply>
<in></in>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>v</ci>
<mtext>has weight</mtext>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{n}(i)=\{v\in V_{n}:v\text{ has weight }i\}
  </annotation>
</semantics>
</math>
</p>

<p>for 

<math display="inline" id="Gray_code:39">
<semantics>
<mrow>
<mn>0</mn>
<mo>≤</mo>
<mi>i</mi>
<mo>≤</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<cn type="integer">0</cn>
<ci>i</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0\leq i\leq n
  </annotation>
</semantics>
</math>


. These levels satisfy 

<math display="inline" id="Gray_code:40">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>i</mi>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V_{n}(i)|={\left({{n}\atop{i}}\right)}
  </annotation>
</semantics>
</math>

. Let 

<math display="inline" id="Gray_code:41">
<semantics>
<mrow>
<msub>
<mi>Q</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Q</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q_{n}(i)
  </annotation>
</semantics>
</math>

 be the subgraph of 

<math display="inline" id="Gray_code:42">
<semantics>
<msub>
<mi>Q</mi>
<mi>n</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Q</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q_{n}
  </annotation>
</semantics>
</math>

 induced by 

<math display="inline" id="Gray_code:43">
<semantics>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∪</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<union></union>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>n</ci>
</apply>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{n}(i)\cup V_{n}(i+1)
  </annotation>
</semantics>
</math>

, and let 

<math display="inline" id="Gray_code:44">
<semantics>
<mrow>
<msub>
<mi>E</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   E_{n}(i)
  </annotation>
</semantics>
</math>


 be the edges in 

<math display="inline" id="Gray_code:45">
<semantics>
<mrow>
<msub>
<mi>Q</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Q</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q_{n}(i)
  </annotation>
</semantics>
</math>

. A monotonic Gray code is then a Hamiltonian path in 

<math display="inline" id="Gray_code:46">
<semantics>
<msub>
<mi>Q</mi>
<mi>n</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Q</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q_{n}
  </annotation>
</semantics>
</math>

 such that whenever 

<math display="inline" id="Gray_code:47">
<semantics>
<mrow>
<msub>
<mi>δ</mi>
<mn>1</mn>
</msub>
<mo>∈</mo>
<mrow>
<msub>
<mi>E</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta_{1}\in E_{n}(i)
  </annotation>
</semantics>
</math>

 comes before 

<math display="inline" id="Gray_code:48">
<semantics>
<mrow>
<msub>
<mi>δ</mi>
<mn>2</mn>
</msub>
<mo>∈</mo>
<mrow>
<msub>
<mi>E</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>j</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<ci>n</ci>
</apply>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta_{2}\in E_{n}(j)
  </annotation>
</semantics>
</math>

 in the path, then 

<math display="inline" id="Gray_code:49">
<semantics>
<mrow>
<mi>i</mi>
<mo>≤</mo>
<mi>j</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>i</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i\leq j
  </annotation>
</semantics>
</math>


.</p>

<p>An elegant construction of monotonic <em>n</em>-digit Gray codes for any <em>n</em> is based on the idea of recursively building subpaths 

<math display="inline" id="Gray_code:50">
<semantics>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<ci>j</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{n,j}
  </annotation>
</semantics>
</math>

 of length 

<math display="inline" id="Gray_code:51">
<semantics>
<mrow>
<mn>2</mn>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>j</mi>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>n</ci>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2{\left({{n}\atop{j}}\right)}
  </annotation>
</semantics>
</math>

 having edges in 

<math display="inline" id="Gray_code:52">
<semantics>
<mrow>
<msub>
<mi>E</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>j</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>E</ci>
<ci>n</ci>
</apply>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   E_{n}(j)
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> We define 

<math display="inline" id="Gray_code:53">
<semantics>
<mrow>
<msub>
<mi>P</mi>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mn>0</mn>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<cn type="integer">1</cn>
<cn type="integer">0</cn>
</list>
</apply>
<interval closure="open">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{1,0}=(0,1)
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Gray_code:54">
<semantics>
<mrow>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<mi mathvariant="normal">∅</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<ci>j</ci>
</list>
</apply>
<emptyset></emptyset>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{n,j}=\emptyset
  </annotation>
</semantics>
</math>


 whenever 

<math display="inline" id="Gray_code:55">
<semantics>
<mrow>
<mi>j</mi>
<mo>&lt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j&lt;0
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Gray_code:56">
<semantics>
<mrow>
<mi>j</mi>
<mo>≥</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<ci>j</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j\geq n
  </annotation>
</semantics>
</math>

, and</p>

<p>
<math display="block" id="Gray_code:57">
<semantics>
<mrow>
<msub>
<mi>P</mi>
<mrow>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mrow>
<mn>1</mn>
<msubsup>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mrow>
<msub>
<mi>π</mi>
<mi>n</mi>
</msub>
</msubsup>
</mrow>
<mo>,</mo>
<mrow>
<mn>0</mn>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<ci>j</ci>
</list>
</apply>
<list>
<apply>
<times></times>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>n</ci>
</apply>
</apply>
<list>
<ci>n</ci>
<apply>
<minus></minus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</list>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">0</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<ci>j</ci>
</list>
</apply>
</apply>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{n+1,j}=1P^{\pi_{n}}_{n,j-1},0P_{n,j}
  </annotation>
</semantics>
</math>
</p>

<p>otherwise. Here, 

<math display="inline" id="Gray_code:58">
<semantics>
<msub>
<mi>π</mi>
<mi>n</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{n}
  </annotation>
</semantics>
</math>

 is a suitably defined permutation and 

<math display="inline" id="Gray_code:59">
<semantics>
<msup>
<mi>P</mi>
<mi>π</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<ci>π</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P^{\pi}
  </annotation>
</semantics>
</math>


 refers to the path <em>P</em> with its coordinates permuted by 

<math display="inline" id="Gray_code:60">
<semantics>
<mi>π</mi>
<annotation-xml encoding="MathML-Content">
<ci>π</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi
  </annotation>
</semantics>
</math>

. These paths give rise to two monotonic <em>n</em>-digit Gray codes 

<math display="inline" id="Gray_code:61">
<semantics>
<msubsup>
<mi>G</mi>
<mi>n</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G_{n}^{(1)}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Gray_code:62">
<semantics>
<msubsup>
<mi>G</mi>
<mi>n</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>2</mn>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G_{n}^{(2)}
  </annotation>
</semantics>
</math>

 given by</p>

<p>
<math display="block" id="Gray_code:63">
<semantics>
<mrow>
<msubsup>
<mi>G</mi>
<mi>n</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<mo>=</mo>
<mrow>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>0</mn>
</mrow>
</msub>
<msubsup>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>1</mn>
</mrow>
<mi>R</mi>
</msubsup>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>2</mn>
</mrow>
</msub>
<msubsup>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>3</mn>
</mrow>
<mi>R</mi>
</msubsup>
<mi mathvariant="normal">⋯</mi>
<mtext>and</mtext>
<msubsup>
<mi>G</mi>
<mi>n</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>2</mn>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>0</mn>
</mrow>
<mi>R</mi>
</msubsup>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>1</mn>
</mrow>
</msub>
<msubsup>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>2</mn>
</mrow>
<mi>R</mi>
</msubsup>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>3</mn>
</mrow>
</msub>
<mi mathvariant="normal">⋯</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">0</cn>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">1</cn>
</list>
</apply>
<ci>R</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">2</cn>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">3</cn>
</list>
</apply>
<ci>R</ci>
</apply>
<ci>normal-⋯</ci>
<mtext>and</mtext>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">0</cn>
</list>
</apply>
<ci>R</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">1</cn>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">2</cn>
</list>
</apply>
<ci>R</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<cn type="integer">3</cn>
</list>
</apply>
<ci>normal-⋯</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G_{n}^{(1)}=P_{n,0}P_{n,1}^{R}P_{n,2}P_{n,3}^{R}\cdots\text{ and }G_{n}^{(2)}=%
P_{n,0}^{R}P_{n,1}P_{n,2}^{R}P_{n,3}\cdots
  </annotation>
</semantics>
</math>
</p>

<p>The choice of 

<math display="inline" id="Gray_code:64">
<semantics>
<msub>
<mi>π</mi>
<mi>n</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{n}
  </annotation>
</semantics>
</math>


 which ensures that these codes are indeed Gray codes turns out to be 

<math display="inline" id="Gray_code:65">
<semantics>
<mrow>
<msub>
<mi>π</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<msup>
<mi>E</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<msubsup>
<mi>π</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mn>2</mn>
</msubsup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>E</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{n}=E^{-1}(\pi_{n-1}^{2})
  </annotation>
</semantics>
</math>

. The first few values of 

<math display="inline" id="Gray_code:66">
<semantics>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<ci>j</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{n,j}
  </annotation>
</semantics>
</math>

 are shown in the table below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>Subpaths in the Savage–Winkler algorithm</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>
<math display="inline" id="Gray_code:67">
<semantics>
<msub>
<mi>P</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<list>
<ci>n</ci>
<ci>j</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{n,j}
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><em>n</em> = 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><em>n</em> = 2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><em>n</em> = 3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><em>n</em> = 4</p></td>
</tr>
</tbody>
</table>

<p>These monotonic Gray codes can be efficiently implemented in such a way that each subsequent element can be generated in <em>O</em>(<em>n</em>) time. The algorithm is most easily described using <a href="coroutine" title="wikilink">coroutines</a>.</p>

<p>Monotonic codes have an interesting connection to the <a href="Lovász_conjecture" title="wikilink">Lovász conjecture</a>, which states that every connected <a href="vertex-transitive_graph" title="wikilink">vertex-transitive graph</a> contains a Hamiltonian path. The "middle-level" subgraph 

<math display="inline" id="Gray_code:68">
<semantics>
<mrow>
<msub>
<mi>Q</mi>
<mrow>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Q</ci>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q_{2n+1}(n)
  </annotation>
</semantics>
</math>

 is <a href="vertex-transitive_graph" title="wikilink">vertex-transitive</a> (that is, its automorphism group is transitive, so that each vertex has the same "local environment"" and cannot be differentiated from the others, since we can relabel the coordinates as well as the binary digits to obtain an <a class="uri" href="automorphism" title="wikilink">automorphism</a>) and the problem of finding a Hamiltonian path in this subgraph is called the "middle-levels problem", which can provide insights into the more general conjecture. The question has been answered affirmatively for 

<math display="inline" id="Gray_code:69">
<semantics>
<mrow>
<mi>n</mi>
<mo>≤</mo>
<mn>15</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>n</ci>
<cn type="integer">15</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\leq 15
  </annotation>
</semantics>
</math>


, and the preceding construction for monotonic codes ensures a Hamiltonian path of length at least 0.839<em>N</em> where <em>N</em> is the number of vertices in the middle-level subgraph.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h3 id="beckettgray-code">Beckett–Gray code</h3>

<p>Another type of Gray code, the <strong>Beckett–Gray code</strong>, is named for Irish playwright <a href="Samuel_Beckett" title="wikilink">Samuel Beckett</a>, who was interested in <a class="uri" href="symmetry" title="wikilink">symmetry</a>. His play "<a href="Quad_(play)" title="wikilink">Quad</a>" features four actors and is divided into sixteen time periods. Each period ends with one of the four actors entering or leaving the stage. The play begins with an empty stage, and Beckett wanted each subset of actors to appear on stage exactly once.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Clearly the set of actors currently on stage can be represented by a 4-bit binary Gray code. Beckett, however, placed an additional restriction on the script: he wished the actors to enter and exit so that the actor who had been on stage the longest would always be the one to exit. The actors could then be represented by a <a href="FIFO_(computing_and_electronics)" title="wikilink">first in, first out</a> <a href="Queue_(data_structure)" title="wikilink">queue</a>, so that (of the actors onstage) the actor being dequeued is always the one who was enqueued first.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Beckett was unable to find a Beckett–Gray code for his play, and indeed, an exhaustive listing of all possible sequences reveals that no such code exists for <em>n</em> = 4. It is known today that such codes do exist for <em>n</em> = 2, 5, 6, 7, and 8, and do not exist for <em>n</em> = 3 or 4. An example of an 8-bit Beckett–Gray code can be found in Knuth's <em>Art of Computer Programming</em>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> According to Sawada and Wong, the search space for <em>n</em> = 6 can be explored in 15 hours, and more than 9,500 solutions for the case <em>n</em> = 7 have been found.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="snake-in-the-box-codes">Snake-in-the-box codes</h3>

<p><a class="uri" href="Snake-in-the-box" title="wikilink">Snake-in-the-box</a> codes, or <em>snakes</em>, are the sequences of nodes of <a href="induced_path" title="wikilink">induced paths</a> in an <em>n</em>-dimensional <a href="hypercube_graph" title="wikilink">hypercube graph</a>, and coil-in-the-box codes, or <em>coils</em>, are the sequences of nodes of induced <a href="cycle_(graph_theory)" title="wikilink">cycles</a> in a hypercube. Viewed as Gray codes, these sequences have the property of being able to detect any single-bit coding error. Codes of this type were first described by W. H. Kautz in the late 1950s;<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> since then, there has been much research on finding the code with the largest possible number of codewords for a given hypercube dimension.</p>
<h3 id="single-track-gray-code">Single-track Gray code</h3>

<p>Yet another kind of Gray code is the <strong>single-track Gray code</strong> (STGC) developed by N. B. Spedding<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> and refined by Hiltgen, Paterson and Brandestini in "Single-track Gray codes" (1996).<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> The STGC is a cyclical list of <em>P</em> unique binary encodings of length n such that two consecutive words differ in exactly one position, and when the list is examined as a <em>P</em> × <em>n</em> <a href="Matrix_(mathematics)" title="wikilink">matrix</a>, each column is a cyclic shift of the first column.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>The name comes from their use with <a href="rotary_encoder" title="wikilink">rotary encoders</a>, where a number of tracks are being sensed by contacts, resulting for each in an output of 0 or 1. To reduce noise due to different contacts not switching at exactly the same moment in time, one preferably sets up the tracks so that the data output by the contacts are in Gray code. To get high angular accuracy, one needs lots of contacts; in order to achieve at least 1 degree accuracy, one needs at least 360 distinct positions per revolution, which requires a minimum of 9 bits of data, and thus the same number of contacts.</p>

<p>If all contacts are placed at the same angular position, then 9 tracks are needed to get a standard BRGC with at least 1 degree accuracy. However, if the manufacturer moves a contact to a different angular position (but at the same distance from the center shaft), then the corresponding "ring pattern" needs to be rotated the same angle to give the same output. If the most significant bit (the inner ring in Figure 1) is rotated enough, it exactly matches the next ring out. Since both rings are then identical, the inner ring can be cut out, and the sensor for that ring moved to the remaining, identical ring (but offset at that angle from the other sensor on that ring). Those two sensors on a single ring make a quadrature encoder. That reduces the number of tracks for a "1 degree resolution" angular encoder to 8 tracks. Reducing the number of tracks still further can't be done with BRGC.</p>

<p>For many years, Torsten Sillke<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> and other mathematicians believed that it was impossible to encode position on a single track such that consecutive positions differed at only a single sensor, except for the 2-sensor, 1-track quadrature encoder. So for applications where 8 tracks were too bulky, people used single-track incremental encoders (quadrature encoders) or 2-track "quadrature encoder + reference notch" encoders.</p>

<p>N. B. Spedding, however, registered a patent in 1994 with several examples showing that it was possible.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Although it is not possible to distinguish 2<sup><em>n</em></sup> positions with <em>n</em> sensors on a single track, it <em>is</em> possible to distinguish close to that many. For example, when <em>n</em> is itself a power of 2, <em>n</em> sensors can distinguish 2<sup><em>n</em></sup> − 2<em>n</em> positions. Hiltgen and Paterson published a paper in 2001 exhibiting a single-track gray code with exactly 360 angular positions, constructed using 9 sensors.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> Since this number is larger than 2<sup>8</sup> = 256, more than 8 sensors are required by any code, although a BRGC could distinguish 512 positions with 9 sensors. An STGC for <em>P</em> = 30 and <em>n</em> = 5 is reproduced here: </p>

<p><code>10000</code><br/>
<code>10100</code><br/>
<code>11100</code><br/>
<code>11110</code><br/>
<code>11010</code><br/>
<code>11000</code><br/>
<code>01000</code><br/>
<code>01010</code><br/>
<code>01110</code><br/>
<code>01111</code><br/>
<code>01101</code><br/>
<code>01100</code><br/>
<code>00100</code><br/>
<code>00101</code><br/>
<code>00111</code><br/>
<code>10111</code><br/>
<code>10110</code><br/>
<code>00110</code><br/>
<code>00010</code><br/>
<code>10010</code><br/>
<code>10011</code><br/>
<code>11011</code><br/>
<code>01011</code><br/>
<code>00011</code><br/>
<code>00001</code><br/>
<code>01001</code><br/>
<code>11001</code><br/>
<code>11101</code><br/>
<code>10101</code><br/>
<code>10001</code></p>

<p>Each column is a cyclic shift of the first column, and from any row to the next row only one bit changes.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> The single-track nature (like a code chain) is useful in the fabrication of these wheels (compared to BRGC), as only one track is needed, thus reducing their cost and size. The Gray code nature is useful (compared to <a href="chain_code" title="wikilink">chain codes</a>, also called <a href="De_Bruijn_sequence" title="wikilink">De Bruijn sequences</a>), as only one sensor will change at any one time, so the uncertainty during a transition between two discrete states will only be plus or minus one unit of angular measurement the device is capable of resolving.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>
<h2 id="gray-isometry">Gray isometry</h2>

<p>The bijective mapping { 0 ↔ 00, 1 ↔ 01, 2 ↔ 11, 3 ↔ 10 } establishes an <a class="uri" href="isometry" title="wikilink">isometry</a> between the <a href="metric_space" title="wikilink">metric space</a> over the <a href="finite_field" title="wikilink">finite field</a>
<math display="inline" id="Gray_code:70">
<semantics>
<msubsup>
<mi>ℤ</mi>
<mn>2</mn>
<mn>2</mn>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}_{2}^{2}
  </annotation>
</semantics>
</math>

 with the metric given by the <a href="Hamming_distance" title="wikilink">Hamming distance</a> and the metric space over the <a href="finite_ring" title="wikilink">finite ring</a>
<math display="inline" id="Gray_code:71">
<semantics>
<msub>
<mi>ℤ</mi>
<mn>4</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}_{4}
  </annotation>
</semantics>
</math>

 (the usual <a href="modulo_arithmetic" title="wikilink">modulo arithmetic</a>) with the metric given by the <a href="Lee_distance" title="wikilink">Lee distance</a>. The mapping is suitably extended to an isometry of the <a href="Hamming_space" title="wikilink">Hamming spaces</a>
<math display="inline" id="Gray_code:72">
<semantics>
<msubsup>
<mi>ℤ</mi>
<mn>2</mn>
<mrow>
<mn>2</mn>
<mi>m</mi>
</mrow>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}_{2}^{2m}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Gray_code:73">
<semantics>
<msubsup>
<mi>ℤ</mi>
<mn>4</mn>
<mi>m</mi>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<cn type="integer">4</cn>
</apply>
<ci>m</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}_{4}^{m}
  </annotation>
</semantics>
</math>

. Its importance lies in establishing a correspondence between various "good" but not necessarily <a href="linear_code" title="wikilink">linear codes</a> as Gray-map images in 

<math display="inline" id="Gray_code:74">
<semantics>
<msubsup>
<mi>ℤ</mi>
<mn>2</mn>
<mn>2</mn>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}_{2}^{2}
  </annotation>
</semantics>
</math>


 of <a href="ring-linear_code" title="wikilink">ring-linear codes</a> from 

<math display="inline" id="Gray_code:75">
<semantics>
<msub>
<mi>ℤ</mi>
<mn>4</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℤ</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}_{4}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Linear_feedback_shift_register" title="wikilink">Linear feedback shift register</a></li>
<li><a href="De_Bruijn_sequence" title="wikilink">De Bruijn sequence</a></li>
<li><a href="Gillham_code" title="wikilink">Gillham code</a></li>
<li><a href="Steinhaus–Johnson–Trotter_algorithm" title="wikilink">Steinhaus–Johnson–Trotter algorithm</a>, an algorithm that generates Gray codes for the <a href="factorial_number_system" title="wikilink">factorial number system</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Black, Paul E. <a href="http://www.nist.gov/dads/HTML/graycode.html"><em>Gray code</em></a>. 25 February 2004. <a class="uri" href="NIST" title="wikilink">NIST</a>.</li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://demonstrations.wolfram.com/BinaryGrayCode/">"Gray Code" demonstration</a> by Michael Schreiber, <a href="Wolfram_Demonstrations_Project" title="wikilink">Wolfram Demonstrations Project</a> (with Mathematica implementation). 2007.</li>
<li><a href="http://www.nist.gov/dads/HTML/graycode.html">NIST Dictionary of Algorithms and Data Structures: Gray code</a></li>
<li><a href="http://www.aip.de/~ast/EvolCompFAQ/Q21.htm">Hitch Hiker's Guide to Evolutionary Computation, Q21: What are Gray codes, and why are they used?</a>, including <a href="C_(programming_language)" title="wikilink">C</a> code to convert between binary and BRGC</li>
<li><a href="http://www.theory.cs.uvic.ca/~cos/gen/comb.html">Subsets or Combinations</a> Can generate BRGC strings</li>
<li><a href="http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1998/CS/CS0937">"The Structure of Single-Track Gray Codes"</a> by Moshe Schwartz, Tuvi Etzion</li>
<li><a href="http://www.hpl.hp.com/techreports/2000/HPL-2000-81.html">Single-Track Circuit Codes</a> by Hiltgen, Alain P.; Paterson, Kenneth G.</li>
<li>Dragos A. Harabor uses <a href="http://www.ugcs.caltech.edu/~dragos/3DP/coord.html">Gray codes in a 3D digitizer</a>.</li>
<li>single-track gray codes, binary <a href="chain_code" title="wikilink">chain codes</a> (<a href="http://tinaja.com/text/chain01.html">Lancaster 1994</a>), and <a href="linear_feedback_shift_register" title="wikilink">linear feedback shift registers</a> are all useful in finding one's absolute position on a single-track rotary encoder (or other position sensor).</li>
<li>[<a class="uri" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?isnumber=4475352&amp;arnumber">http://ieeexplore.ieee.org/xpls/abs_all.jsp?isnumber=4475352&amp;arnumber;</a>;=4475394&amp;count;=44&amp;index;=39 Computing Binary Combinatorial Gray Codes Via Exhaustive Search With SAT Solvers] by Zinovik, I.; Kroening, D.; Chebiryak, Y.</li>
<li><a href="http://www.ams.org/featurecolumn/archive/gray.html">AMS Column: Gray codes</a></li>
<li><a href="http://www.bushytails.net/~randyg/encoder/encoderwheel.html">Optical Encoder Wheel Generator</a></li>
<li><a href="http://prototalk.net/forums/showthread.php?t=78">ProtoTalk.net – Understanding Quadrature Encoding</a> – Covers quadrature encoding in more detail with a focus on robotic applications</li>
</ul>

<p>"</p>

<p><a href="Category:Data_transmission" title="wikilink">Category:Data transmission</a> <a href="Category:Numeral_systems" title="wikilink">Category:Numeral systems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">F. Gray. <em>Pulse code communication</em>, March 17, 1953 (filed Nov. 1947). <a href="#fnref1">↩</a></li>
<li id="fn2">J. Breckman. <em>Encoding Circuit</em>, Jan 31, 1956 (filed Dec. 1953). <a href="#fnref2">↩</a></li>
<li id="fn3">E. A. Ragland et al. <em>Direction-Sensitive Binary Code Position Control System</em>, Feb. 11, 1958 (filed Oct. 1953). <a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">S. Reiner et al. <em>Automatic Rectification System</em>, Jun 24, 1958 (filed Jan. 1954). <a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Knuth, Donald E. "Generating all <em>n</em>-tuples." <em>The Art of Computer Programming, Volume 4A: Enumeration and Backtracking</em>, pre-fascicle 2a, October 15, 2004. <a href="http://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz">1</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"> Note that the two page sections taken together say that K-maps are labeled with Gray code. The first section says that they are labeled with a code that changes only one bit between entries and the second section says that such a code is called Gray code.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://www.stanford.edu/class/ee183/handouts_spr2003/synchronization_pres.pdf">"Synchronization in Digital Logic Circuits</a> by Ryan Donohue<a href="#fnref12">↩</a></li>
<li id="fn13">Mehta, H.; Owens, R.M. &amp; Irwin, M.J. (1996), [<a class="uri" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?tp">http://ieeexplore.ieee.org/xpls/abs_all.jsp?tp</a>=&amp;arnumber;=497616&amp;isnumber;=10625 Some issues in gray code addressing], in the Proceedings of the 6th Great Lakes Symposium on VLSI (GLSVLSI 96), IEEE Computer Society,pp. 178<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://www.cs.auckland.ac.nz/CDMTCS//researchreports/304bob.pdf">The Gray Code by R. W. Doran</a><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">Henry Gordon Dietz. <a href="http://aggregate.org/MAGIC/#Gray%20Code%20Conversion">"The Aggregate Magic Algorithms: Gray Code Conversion"</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"> A claim is at <a class="uri" href="http://www.winzurf.co.nz/Single_Track_Grey_Code_Patent/Single_track_Grey_code_encoder_patent.pdf">http://www.winzurf.co.nz/Single_Track_Grey_Code_Patent/Single_track_Grey_code_encoder_patent.pdf</a><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a class="uri" href="http://www.hpl.hp.com/techreports/2000/HPL-2000-81.pdf">http://www.hpl.hp.com/techreports/2000/HPL-2000-81.pdf</a> (no mention of Spedding)<a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37">Torsten Sillke. <a href="http://www.mathematik.uni-bielefeld.de/~sillke/PROBLEMS/gray">"Gray-Codes with few tracks"</a>.<a href="#fnref37">↩</a></li>
<li id="fn38"></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a class="uri" href="http://www.encyclopediaofmath.org/index.php/Kerdock_and_Preparata_codes">http://www.encyclopediaofmath.org/index.php/Kerdock_and_Preparata_codes</a><a href="#fnref43">↩</a></li>
</ol>
</section>
</body>
