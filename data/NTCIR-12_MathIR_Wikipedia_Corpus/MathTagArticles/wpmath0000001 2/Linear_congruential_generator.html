<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1476">Linear congruential generator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear congruential generator</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Visualisation of generation of pseudo-random numbers in [0, 8] using a linear congruential generator. The top two rows show a generator with m = 9, a = 2 and c = 0 outputting numbers from left to right until the output equals the seed, when the sequence repeats. A seed of 1 gives a cycle length of 6 but a seed of 3 gives a cycle length of only 2. Using a = 4 and c = 1 (bottom row) gives a full cycle length of 9 with any seed.</figcaption>
</figure>

<p>A <strong>linear congruential generator</strong> (<strong>LCG</strong>) is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that yields a sequence of pseudo-randomized numbers calculated with a discontinuous <a href="piecewise_linear_function" title="wikilink">piecewise linear equation</a>. The method represents one of the oldest and best-known <a href="pseudorandom_number_generator" title="wikilink">pseudorandom number generator</a> algorithms.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The theory behind them is relatively easy to understand, and they are easily implemented and fast, especially on computer hardware which can provide <a href="modulo_arithmetic" title="wikilink">modulo arithmetic</a> by storage-bit truncation.</p>

<p>The generator is defined by the <a href="recurrence_relation" title="wikilink">recurrence relation</a>:</p>

<p>

<math display="block" id="Linear_congruential_generator:0">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <msub>
        <mi>X</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mi>c</mi>
     </mrow>
     <mo rspace="9.1pt">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="9.1pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n+1}=\left(aX_{n}+c\right)~{}~{}\bmod~{}~{}m
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Linear_congruential_generator:1">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="sequence" title="wikilink">sequence</a> of pseudorandom values, and</p>

<p>

<math display="block" id="Linear_congruential_generator:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>,</mo>
    <mn>0</mn>
   </mrow>
   <mo>≤</mo>
   <mi>c</mi>
   <mo><</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <list>
      <ci>c</ci>
      <cn type="float">0</cn>
     </list>
     <ci>c</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c,\,0\leq c<m
  </annotation>
 </semantics>
</math>

 – the "multiplier"</p>

<p>

<math display="block" id="Linear_congruential_generator:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mn>0</mn>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo><</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="float">0</cn>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0},\,0\leq X_{0}<m
  </annotation>
 </semantics>
</math>

 – the "increment"</p>

<p>

<math display="inline" id="Linear_congruential_generator:4">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,c
  </annotation>
 </semantics>
</math>

 – the "seed" or "start value"</p>

<p>are <a class="uri" href="integer" title="wikilink">integer</a> constants that specify the generator. If <em>c</em> = 0, the generator is often called a <strong>multiplicative congruential generator</strong> (MCG), or <a href="Lehmer_RNG" title="wikilink">Lehmer RNG</a>. If <em>c</em> ≠ 0, the method is called a <em>mixed congruential generator</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="period-length">Period length</h2>

<p>The <a href="Periodic_function" title="wikilink">period</a> of a general LCG is at most <em>m</em>, and for some choices of factor <em>a</em> much less than that. Provided that the offset <em>c</em> is nonzero, the LCG will have a full period for all seed values <a href="if_and_only_if" title="wikilink">if and only if</a>:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ol>
<li>

<math display="inline" id="Linear_congruential_generator:5">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_congruential_generator:6">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>a</mi>
   </mpadded>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,a-1
  </annotation>
 </semantics>
</math>

 are <a href="relatively_prime" title="wikilink">relatively prime</a>,</li>
<li>

<math display="inline" id="Linear_congruential_generator:7">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,m
  </annotation>
 </semantics>
</math>

 is divisible by all <a href="prime_factor" title="wikilink">prime factors</a> of 

<math display="inline" id="Linear_congruential_generator:8">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>a</mi>
   </mpadded>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,a-1
  </annotation>
 </semantics>
</math>


,</li>
<li>

<math display="inline" id="Linear_congruential_generator:9">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,m
  </annotation>
 </semantics>
</math>

 is a multiple of 4 if <span class="LaTeX">$\,m$</span> is a multiple of 4.</li>
</ol>

<p>These three requirements are referred to as the Hull-Dobell Theorem.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> While LCGs are capable of producing <a href="pseudorandom_numbers" title="wikilink">pseudorandom numbers</a> which can pass formal <a href="tests_for_randomness" title="wikilink">tests for randomness</a>, this is extremely sensitive to the choice of the parameters <em>c</em>, <em>m</em>, and <em>a</em>.</p>

<p>Historically, poor choices had led to ineffective implementations of LCGs. A particularly illustrative example of this is <a class="uri" href="RANDU" title="wikilink">RANDU</a>, which was widely used in the early 1970s and led to many results which are currently being questioned because of the use of this poor LCG.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="parameters-in-common-use">Parameters in common use</h2>

<p>The most efficient LCGs have an <em>m</em> equal to a power of 2, most often <em>m</em> = 2<sup>32</sup> or <em>m</em> = 2<sup>64</sup>, because this allows the modulus operation to be computed by merely truncating all but the rightmost 32 or 64 bits. The following table lists the parameters of LCGs in common use, including built-in <em>rand()</em> functions in <a href="Runtime_library" title="wikilink">runtime libraries</a> of various <a href="compiler" title="wikilink">compilers</a>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Source</p></th>
<th style="text-align: left;">
<p><em>m</em></p></th>
<th style="text-align: left;">
<p>(multiplier) <em>a</em></p></th>
<th style="text-align: left;">
<p>(increment) <em>c</em></p></th>
<th style="text-align: left;">
<p>output bits of seed in <em>rand()</em> / <em>Random(L)</em></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em><a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a></em></p></td>
<td style="text-align: left;">
<p>2<sup>32</sup></p></td>
<td style="text-align: left;">
<p>1664525</p></td>
<td style="text-align: left;">
<p>1013904223</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Borland" title="wikilink">Borland</a> C/C++</p></td>
<td style="text-align: left;">
<p>2<sup>32</sup></p></td>
<td style="text-align: left;">
<p>22695477</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>bits 30..16 in <em>rand()</em>, 30..0 in <em>lrand()</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="glibc" title="wikilink">glibc</a> (used by <a href="GNU_Compiler_Collection" title="wikilink">GCC</a>)<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></td>
<td style="text-align: left;">
<p>| 2<sup>31</sup></p></td>
<td style="text-align: left;">
<p>1103515245</p></td>
<td style="text-align: left;">
<p>12345</p></td>
<td style="text-align: left;">
<p>bits 30..0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="ANSI_C" title="wikilink">ANSI C</a>: <a href="Watcom_C_compiler" title="wikilink">Watcom</a>, <a href="Digital_Mars" title="wikilink">Digital Mars</a>, <a class="uri" href="CodeWarrior" title="wikilink">CodeWarrior</a>, <a href="IBM_VisualAge" title="wikilink">IBM VisualAge</a> C/C++ <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>31</sup></p></td>
<td style="text-align: left;">
<p>1103515245</p></td>
<td style="text-align: left;">
<p>12345</p></td>
<td style="text-align: left;">
<p>bits 30..16</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="C99" title="wikilink">C99</a>, <a href="C11_(C_standard_revision)" title="wikilink">C11</a>: Suggestion in the ISO/IEC 9899 <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>32</sup></p></td>
<td style="text-align: left;">
<p>1103515245</p></td>
<td style="text-align: left;">
<p>12345</p></td>
<td style="text-align: left;">
<p>bits 30..16</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Borland_Delphi" title="wikilink">Borland Delphi</a>, <a href="Virtual_Pascal" title="wikilink">Virtual Pascal</a></p></td>
<td style="text-align: left;">
<p>2<sup>32</sup></p></td>
<td style="text-align: left;">
<p>134775813</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>bits 63..32 of <em>(seed * L)</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Visual_C++" title="wikilink">Microsoft Visual/Quick C/C++</a></p></td>
<td style="text-align: left;">
<p>2<sup>32</sup></p></td>
<td style="text-align: left;">
<p>214013 (343FD<sub>16</sub>)</p></td>
<td style="text-align: left;">
<p>2531011 (269EC3<sub>16</sub>)</p></td>
<td style="text-align: left;">
<p>bits 30..16</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Visual_Basic" title="wikilink">Microsoft Visual Basic</a> (6 and earlier)<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>24</sup></p></td>
<td style="text-align: left;">
<p>1140671485 (43FD43FD<sub>16</sub>)</p></td>
<td style="text-align: left;">
<p>12820163 (C39EC3<sub>16</sub>)</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>RtlUniform from <a href="Native_API" title="wikilink">Native API</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>31</sup> − 1</p></td>
<td style="text-align: left;">
<p>| 2147483629 (7FFFFFED<sub>16</sub>)</p></td>
<td style="text-align: left;">
<p>2147483587 (7FFFFFC3<sub>16</sub>)</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="CarbonLib" title="wikilink">Apple CarbonLib</a>, <a class="uri" href="C++11" title="wikilink">C++11</a>'s <code>minstd_rand0</code><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>31</sup> − 1</p></td>
<td style="text-align: left;">
<p>16807</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>see <a class="uri" href="MINSTD" title="wikilink">MINSTD</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="C++11" title="wikilink">C++11</a>'s <code>minstd_rand</code><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>31</sup> − 1</p></td>
<td style="text-align: left;">
<p>48271</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>see <a class="uri" href="MINSTD" title="wikilink">MINSTD</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="MMIX" title="wikilink">MMIX</a> by <a href="Donald_Knuth" title="wikilink">Donald Knuth</a></p></td>
<td style="text-align: left;">
<p>2<sup>64</sup></p></td>
<td style="text-align: left;">
<p>6364136223846793005</p></td>
<td style="text-align: left;">
<p>1442695040888963407</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Newlib" title="wikilink">Newlib</a>, <a class="uri" href="MUSL" title="wikilink">MUSL</a></p></td>
<td style="text-align: left;">
<p>2<sup>64</sup></p></td>
<td style="text-align: left;">
<p>6364136223846793005</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>bits 63...32</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="OpenVMS" title="wikilink">VMS</a>'s <strong>MTH$RANDOM</strong>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> old versions of <a class="uri" href="glibc" title="wikilink">glibc</a></p></td>
<td style="text-align: left;">
<p>2<sup>32</sup></p></td>
<td style="text-align: left;">
<p>69069</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Java_(programming_language)" title="wikilink">Java</a>'s java.utilRandom, glibc [ld]rand48[_r]()</p></td>
<td style="text-align: left;">
<p>2<sup>48</sup></p></td>
<td style="text-align: left;">
<p>25214903917 (5DEECE66D<sub>16</sub>)</p></td>
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>bits 47...16</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Formerly common:</em> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p></td>
<td style="text-align: left;">
<p>2<sup>31</sup></p></td>
<td style="text-align: left;">
<p>  65539</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>As shown above, LCGs do not always use all of the bits in the values they produce. For example, the <a href="Java_(programming_language)" title="wikilink">Java</a> implementation operates with 48-bit values at each iteration but returns only their 32 most significant bits. This is because the higher-order bits have longer periods than the lower-order bits (see below). LCGs that use this truncation technique produce statistically better values than those that do not.</p>

<p>The Knuth representation for 3 variables is as below: <em>X</em><sub><em>n</em>+1</sub> = (8121 <em>X</em><sub><em>n</em></sub> + 28411) mod 134456</p>

<p>Because there are only 134456 distinct possible values, according to the parameter definition, it tends to make it a bit more predictable. If <em>X</em><sub><em>n</em></sub> is even then <em>X</em><sub><em>n</em>+1</sub> will be odd, and vice versa, so the lowest order of bit oscillates at each step. This makes the generator to produce bits in each number that are usually not equally random.</p>
<h2 id="advantages-and-disadvantages-of-lcgs">Advantages and disadvantages of LCGs</h2>

<p>LCGs are fast and require minimal memory (typically 32 or 64 bits) to retain state. This makes them valuable for simulating multiple independent streams.</p>
<figure><b>(Figure)</b>
<figcaption><a href="Hyperplane" title="wikilink">Hyperplanes</a> of a linear congruential generator in three dimensions</figcaption>
</figure>

<p>LCGs should not be used for applications where high-quality <a class="uri" href="randomness" title="wikilink">randomness</a> is critical. For example, it is not suitable for a <a href="Monte_Carlo_simulation" title="wikilink">Monte Carlo simulation</a> because of the <a href="serial_correlation" title="wikilink">serial correlation</a> (among other things). They also must not be used for cryptographic applications; see <a href="cryptographically_secure_pseudo-random_number_generator" title="wikilink">cryptographically secure pseudo-random number generator</a> for more suitable generators. If a linear congruential generator is seeded with a character and then iterated once, the result is a simple classical cipher called an <a href="affine_cipher" title="wikilink">affine cipher</a>; this cipher is easily broken by standard <a href="frequency_analysis" title="wikilink">frequency analysis</a>.</p>

<p>LCGs tend to exhibit some severe defects. For instance, if an LCG is used to choose points in an n-dimensional space, the points will lie on, at most, (n!m)<sup>1/n</sup> <a class="uri" href="hyperplanes" title="wikilink">hyperplanes</a> (<a href="Marsaglia's_Theorem" title="wikilink">Marsaglia's Theorem</a>, developed by <a href="George_Marsaglia" title="wikilink">George Marsaglia</a>). This is due to serial correlation between successive values of the sequence <em>X</em><sub><em>n</em></sub>. The <a href="spectral_test" title="wikilink">spectral test</a>, which is a simple test of an LCG's quality, is based on this fact.</p>

<p>A further problem of LCGs is that the lower-order bits of the generated sequence have a far shorter period than the sequence as a whole if <em>m</em> is set to a <a href="power_of_two" title="wikilink">power of 2</a>. In general, the <em>n</em>th least significant digit in the base <em>b</em> representation of the output sequence, where <em>b</em><sup><em>k</em></sup> = <em>m</em> for some integer <em>k</em>, repeats with at most period <em>b</em><sup><em>n</em></sup>.</p>

<p>Yet another problem is that LCGs are not suitable for parallel programming. Multiple threads may access the currently stored state simultaneously causing a race condition. In implementations which use same initialization for different threads, equal sequences of random numbers may occur on simultaneously executing threads. Random number generators, particularly for parallel computers, should not be trusted.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> It is strongly recommended to check the results of simulation with more than one RNG to check if bias is introduced. Among the recommended generators for use on a parallel computer include combined linear congruential generators using sequence splitting and lagged Fibonacci generators using independent sequences.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Nevertheless, for some applications LCGs may be a good option. For instance, in an embedded system, the amount of memory available is often severely limited. Similarly, in an environment such as a <a href="video_game_console" title="wikilink">video game console</a> taking a small number of high-order bits of an LCG may well suffice. The low-order bits of LCGs when m is a power of 2 should never be relied on for any degree of randomness whatsoever. Indeed, simply substituting 2<sup><em>n</em></sup> for the modulus term reveals that the low order bits go through very short cycles. In particular, any full-cycle LCG when m is a power of 2 will produce alternately odd and even results.</p>

<p>The recent "PCG" algorithm uses several conditioning techniques which make a simple LCG competitive with more expensive and non-linear generators. The resulting generator retains the advantages of LCG's such as simplicity and very small state.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="comparison-with-other-prngs">Comparison with other PRNGs</h2>

<p>If higher-quality random numbers are needed, and sufficient memory is available (~ 2 <a href="kilobyte" title="wikilink">kilobytes</a>), then the <a href="Mersenne_twister" title="wikilink">Mersenne twister</a> algorithm provides a vastly longer period (2<sup>19937</sup> − 1) and variate uniformity.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> A common Mersenne twister implementation, interestingly enough, uses an LCG to generate seed data.</p>

<p>Linear congruential generators have the problem that all of the bits in each number are usually not equally random. A <a href="Linear_feedback_shift_register" title="wikilink">Linear Feedback Shift Register</a> PRNG produces a stream of pseudo-random bits, each of which are truly pseudo-random,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> and can be implemented with essentially the same amount of memory as a linear congruential generator, albeit with a bit more computation.</p>

<p>The <a href="linear_feedback_shift_register" title="wikilink">linear feedback shift register</a> has a strong relationship to linear congruential generators.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Given a few values in the sequence, some techniques can predict the following values in the sequence for not only linear congruent generators but any other polynomial congruent generator.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Full_cycle" title="wikilink">Full cycle</a></li>
<li><a href="Inversive_congruential_generator" title="wikilink">Inversive congruential generator</a></li>
<li><a class="uri" href="Multiply-with-carry" title="wikilink">Multiply-with-carry</a></li>
<li><a href="Lehmer_RNG" title="wikilink">Lehmer RNG</a> (sometimes called the Park-Miller RNG)</li>
<li><a href="Combined_Linear_Congruential_Generator" title="wikilink">Combined Linear Congruential Generator</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li></li>
<li><a href="Donald_Knuth" title="wikilink">D. E. Knuth</a>. <em>The Art of Computer Programming</em>, Volume 2: <em>Seminumerical Algorithms</em>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89684-2. Section 3.2.1: The Linear Congruential Method, pp. 10–26.</li>
<li></li>
<li></li>
<li>Gentle, James E., (2003). <em>Random Number Generation and Monte Carlo Methods</em>, 2nd edition, Springer, ISBN 0-387-00178-6.</li>
<li>

<p>(in this paper, efficient algorithms are given for inferring sequences produced by certain pseudo-random number generators).</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>The simulation <a href="http://www.vias.org/simulations/simusoft_lincong.html">Linear Congruential Generator</a> visualizes the correlations between the pseudo-random numbers when manipulating the parameters.</li>
<li><a href="http://www.cs.virginia.edu/~rjg7v/annotated.html">Security of Random Number Generation: An Annotated Bibliography</a></li>
<li><a href="http://www.math.niu.edu/~rusin/known-math/99/LCG">Linear Congruential Generators post to sci.math</a></li>
<li><a href="http://www.goldsteintech.com/art.php">The "Death of Art" computer art project at Goldstein Technologies LLC, uses an LCG to generate 33,554,432 images</a></li>
<li>P. L'Ecuyer and R. Simard, <a href="http://www.iro.umontreal.ca/~lecuyer/myftp/papers/testu01.pdf">"TestU01: A C Library for Empirical Testing of Random Number Generators"</a>, May 2006, revised November 2006, <em>ACM Transactions on Mathematical Software</em>, 33, 4, Article 22, August 2007.</li>
<li><a href="http://www.pcg-random.org/">PCG, A Family of Better Random Number Generators</a></li>
<li><a href="http://yurichev.com/blog/modulo/">Article about another way of cracking LCG</a></li>
</ul>

<p>"</p>

<p><a href="Category:Pseudorandom_number_generators" title="wikilink">Category:Pseudorandom number generators</a> <a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"<a href="http://demonstrations.wolfram.com/LinearCongruentialGenerators/">Linear Congruential Generators</a>" by Joe Bolte, <a href="Wolfram_Demonstrations_Project" title="wikilink">Wolfram Demonstrations Project</a>.<a href="#fnref1">↩</a></li>
<li id="fn2">Knuth 1997, Sec. 3.2.1<a href="#fnref2">↩</a></li>
<li id="fn3">Knuth 1997, pp. 17–19<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">The GNU C library's <em>rand()</em> in <a class="uri" href="stdlib.h" title="wikilink">stdlib.h</a> uses a simple (single state) linear congruential generator only in case that the state is declared as 8 bytes. If the state is larger (an array), the generator becomes an additive feedback generator and the period increases. See the <a href="http://www.mscs.dal.ca/~selinger/random/">simplified code</a> that reproduces the random sequence from this library.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">In spite of documentation on <a href="http://msdn.microsoft.com/en-us/library/bb432429(VS.85).aspx">MSDN</a>, RtlUniform uses LCG, and not Lehmer's algorithm, implementations before <a href="Windows_Vista" title="wikilink">Windows Vista</a> are flawed, because the result of multiplication is cut to 32 bits, before modulo is applied<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="http://www.gnu.org/software/gsl/manual/html_node/Other-random-number-generators.html">GNU Scientific Library: Other random number generators</a><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">Coddington, Paul D. "Random number generators for parallel computers." (1997).<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17">Melissa E. O'Neill "PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation." (2014).<a href="#fnref17">↩</a></li>
<li id="fn18">Matsumoto, Makoto, and Takuji Nishimura (1998) ACM Transactions on Modeling and Computer Simulation 8<a href="#fnref18">↩</a></li>
<li id="fn19">* <a href="Neil_Gershenfeld" title="wikilink">Neil Gershenfeld</a>. <em>The Nature of Mathematical Modeling</em>, First Edition. Cambridge University Press, 1999. ISBN 0-521-57095-6. Section 5.3.2: Linear Feedback, pg. 59.<a href="#fnref19">↩</a></li>
<li id="fn20">RFC 4086 section 6.1.3 "Traditional Pseudo-random Sequences"<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
</ol>
</section>
</body>
</html>
