<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="73">Ackermann function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ackermann function</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, the <strong>Ackermann function</strong>, named after <a href="Wilhelm_Ackermann" title="wikilink">Wilhelm Ackermann</a>, is one of the simplest<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and earliest-discovered examples of a <a href="total_function" title="wikilink">total</a> <a href="computable_function" title="wikilink">computable function</a> that is not <a href="Primitive_recursive_function" title="wikilink">primitive recursive</a>. All primitive recursive functions are total and computable, but the Ackermann function illustrates that not all total computable functions are primitive recursive.</p>

<p>After Ackermann's publication<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> of his function (which had three nonnegative integer arguments), many authors modified it to suit various purposes, so that today "the Ackermann function" may refer to any of numerous variants of the original function. One common version, the two-argument <strong>Ackermann–Péter function</strong>, is defined as follows for nonnegative integers <em>m</em> and <em>n</em>:</p>

<p>

<math display="block" id="Ackermann_function:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>m</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>m</mi>
        </mrow>
        <mo>></mo>
        <mrow>
         <mn>0</mn>
         <mtext>and</mtext>
         <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>A</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>m</mi>
           <mo>,</mo>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>m</mi>
        </mrow>
        <mo>></mo>
        <mrow>
         <mn>0</mn>
         <mtext>and</mtext>
         <mi>n</mi>
        </mrow>
        <mo>></mo>
        <mn>0.</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>m</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>and</mtext>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>A</ci>
        <interval closure="open">
         <ci>m</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
      </interval>
     </apply>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>and</mtext>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <gt></gt>
       <share href="#.cmml">
       </share>
       <cn type="float">0.</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(m,n)=\begin{cases}n+1&\mbox{if }m=0\\
A(m-1,1)&\mbox{if }m>0\mbox{ and }n=0\\
A(m-1,A(m,n-1))&\mbox{if }m>0\mbox{ and }n>0.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Its value grows rapidly, even for small inputs. For example <em>A</em>(4,2) is an integer of 19,729 decimal digits.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="history">History</h2>

<p>In the late 1920s, the mathematicians <a href="Gabriel_Sudan" title="wikilink">Gabriel Sudan</a> and <a href="Wilhelm_Ackermann" title="wikilink">Wilhelm Ackermann</a>, students of <a href="David_Hilbert" title="wikilink">David Hilbert</a>, were studying the foundations of computation. Both Sudan and Ackermann are credited<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> with discovering <a href="total_function" title="wikilink">total</a> <a href="computable_function" title="wikilink">computable functions</a> (termed simply "recursive" in some references) that are not <a href="primitive_recursive_function" title="wikilink">primitive recursive</a>. Sudan published the lesser-known <a href="Sudan_function" title="wikilink">Sudan function</a>, then shortly afterwards and independently, in 1928, Ackermann published his function 

<math display="inline" id="Ackermann_function:1">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\,\!
  </annotation>
 </semantics>
</math>

. Ackermann's three-argument function, 

<math display="inline" id="Ackermann_function:2">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <vector>
     <ci>m</ci>
     <ci>n</ci>
     <ci>p</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(m,n,p)\,\!
  </annotation>
 </semantics>
</math>

, is defined such that for <em>p</em> = 0, 1, 2, it reproduces the basic operations of <a class="uri" href="addition" title="wikilink">addition</a>, <a class="uri" href="multiplication" title="wikilink">multiplication</a>, and <a class="uri" href="exponentiation" title="wikilink">exponentiation</a> as</p>

<p>

<math display="block" id="Ackermann_function:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <vector>
      <ci>m</ci>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(m,n,0)=m+n,\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ackermann_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>m</mi>
     <mo>⋅</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <vector>
      <ci>m</ci>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </vector>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(m,n,1)=m\cdot n,\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ackermann_function:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>m</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <vector>
      <ci>m</ci>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </vector>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(m,n,2)=m^{n},\,\!
  </annotation>
 </semantics>
</math>

 and for <em>p</em> &gt; 2 it extends these basic operations in a way that can be compared to the <a href="hyperoperation" title="wikilink">hyperoperations</a>: (Aside from its historic role as a total-computable-but-not-primitive-recursive function, Ackermann's original function is seen to extend the basic arithmetic operations beyond exponentiation, although not as seamlessly as do variants of Ackermann's function that are specifically designed for that purpose—such as <a href="Reuben_Goodstein" title="wikilink">Goodstein's</a> <a class="uri" href="hyperoperation" title="wikilink">hyperoperation</a> sequence.)</p>

<p>In <em>On the Infinite</em>, David Hilbert hypothesized that the Ackermann function was not primitive recursive, but it was Ackermann, Hilbert’s personal secretary and former student, who actually proved the hypothesis in his paper <em>On Hilbert’s Construction of the Real Numbers</em>. <em>On the Infinite</em> was Hilbert’s most important paper on the foundations of mathematics, serving as the heart of <a href="Hilbert's_program" title="wikilink">Hilbert's program</a> to secure the foundation of <a href="transfinite_number" title="wikilink">transfinite numbers</a> by basing them on finite methods.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p><a href="Rózsa_Péter" title="wikilink">Rózsa Péter</a> and <a href="Raphael_Robinson" title="wikilink">Raphael Robinson</a> later developed a two-variable version of the Ackermann function that became preferred by many authors.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="definition-and-properties">Definition and properties</h2>

<p>Ackermann's original three-argument function 

<math display="inline" id="Ackermann_function:6">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <vector>
     <ci>m</ci>
     <ci>n</ci>
     <ci>p</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(m,n,p)\,\!
  </annotation>
 </semantics>
</math>

 is defined <a href="recursion" title="wikilink">recursively</a> as follows for nonnegative integers <em>m</em>, <em>n</em>, and <em>p</em>:</p>

<p>

<math display="block" id="Ackermann_function:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo>,</mo>
          <mi>n</mi>
          <mo>,</mo>
          <mn>0</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo>,</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo>,</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo>,</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mi>p</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mi>m</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>for</mtext>
         <mi>p</mi>
        </mrow>
        <mo>></mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo>,</mo>
          <mi>n</mi>
          <mo>,</mo>
          <mi>p</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo>,</mo>
          <mrow>
           <mi>φ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>m</mi>
            <mo>,</mo>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mi>p</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>p</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>for</mtext>
         <mi>n</mi>
        </mrow>
        <mo>></mo>
        <mrow>
         <mn>0</mn>
         <mtext>and</mtext>
         <mi>p</mi>
        </mrow>
        <mo>></mo>
        <mn>0.</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <vector>
      <ci>m</ci>
      <ci>n</ci>
      <ci>p</ci>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>φ</ci>
       <vector>
        <ci>m</ci>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </vector>
      </apply>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>φ</ci>
       <vector>
        <ci>m</ci>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </vector>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>φ</ci>
       <vector>
        <ci>m</ci>
        <cn type="integer">0</cn>
        <cn type="integer">2</cn>
       </vector>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>φ</ci>
       <vector>
        <ci>m</ci>
        <cn type="integer">0</cn>
        <ci>p</ci>
       </vector>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>for</mtext>
       <ci>p</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>φ</ci>
       <vector>
        <ci>m</ci>
        <ci>n</ci>
        <ci>p</ci>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>φ</ci>
       <vector>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>φ</ci>
         <vector>
          <ci>m</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>p</ci>
         </vector>
        </apply>
        <apply>
         <minus></minus>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </vector>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>for</mtext>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>and</mtext>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <gt></gt>
       <share href="#.cmml">
       </share>
       <cn type="float">0.</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(m,n,p)=\begin{cases}\varphi(m,n,0)=m+n\\
\varphi(m,0,1)=0\\
\varphi(m,0,2)=1\\
\varphi(m,0,p)=m&\text{ for }p>2\\
\varphi(m,n,p)=\varphi(m,\varphi(m,n-1,p),p-1)&\text{ for }n>0\text{ and }p>0.%
\end{cases}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Of the various two-argument versions, the one developed by Péter and Robinson (called "the" Ackermann function by some authors) is defined for nonnegative integers <em>m</em> and <em>n</em> as follows:</p>

<p>

<math display="block" id="Ackermann_function:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>m</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>m</mi>
        </mrow>
        <mo>></mo>
        <mrow>
         <mn>0</mn>
         <mtext>and</mtext>
         <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>A</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>m</mi>
           <mo>,</mo>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>m</mi>
        </mrow>
        <mo>></mo>
        <mrow>
         <mn>0</mn>
         <mtext>and</mtext>
         <mi>n</mi>
        </mrow>
        <mo>></mo>
        <mn>0.</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>m</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>and</mtext>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>A</ci>
        <interval closure="open">
         <ci>m</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
      </interval>
     </apply>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>and</mtext>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <gt></gt>
       <share href="#.cmml">
       </share>
       <cn type="float">0.</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(m,n)=\begin{cases}n+1&\mbox{if }m=0\\
A(m-1,1)&\mbox{if }m>0\mbox{ and }n=0\\
A(m-1,A(m,n-1))&\mbox{if }m>0\mbox{ and }n>0.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>It may not be immediately obvious that the evaluation of 

<math display="inline" id="Ackermann_function:9">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(m,n)
  </annotation>
 </semantics>
</math>


 always terminates. However, the recursion is bounded because in each recursive application either <em>m</em> decreases, or <em>m</em> remains the same and <em>n</em> decreases. Each time that <em>n</em> reaches zero, <em>m</em> decreases, so <em>m</em> eventually reaches zero as well. (Expressed more technically, in each case the pair (<em>m</em>, <em>n</em>) decreases in the <a href="lexicographic_order" title="wikilink">lexicographic order</a> on pairs, which is a <a href="well-order" title="wikilink">well-ordering</a>, just like the ordering of single non-negative integers; this means one cannot go down in the ordering infinitely many times in succession.) However, when <em>m</em> decreases there is no upper bound on how much <em>n</em> can increase—and it will often increase greatly.</p>

<p>The Péter-Ackermann function can also be expressed in terms of various other versions of the Ackermann function:</p>
<ul>
<li>the indexed version of <a href="Knuth's_up-arrow_notation" title="wikilink">Knuth's up-arrow notation</a> (extended to integer indices ≥ -2):</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Ackermann_function:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
   <msup>
    <mo>↑</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mn>3.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="open">
       <ci>m</ci>
       <ci>n</ci>
      </interval>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-↑</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="float">3.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(m,n)=2\uparrow^{m-2}(n+3)-3.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>The part of the definition <em>A</em>(<em>m</em>, 0) = A(<em>m</em>-1, 1) corresponds to 

<math display="inline" id="Ackermann_function:11">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mo>↑</mo>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mn>3</mn>
   <mo>=</mo>
   <mn>2</mn>
   <msup>
    <mo>↑</mo>
    <mi>m</mi>
   </msup>
   <mn>4.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-↑</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-↑</ci>
      <ci>m</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <cn type="float">4.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\uparrow^{m+1}3=2\uparrow^{m}4.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li><a href="hyper_operator" title="wikilink">hyper operators</a>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Ackermann_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(m,n)=2[m](n+3)-3
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>
<ul>
<li><a href="Conway_chained_arrow_notation" title="wikilink">Conway chained arrow notation</a>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Ackermann_function:13">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>+</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>-</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <plus></plus>
      <cn type="integer">3</cn>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">m</csymbol>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <cn type="integer">3</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(m,n)=(2\rightarrow(n+3)\rightarrow(m-2))-3
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Ackermann_function:14">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≥</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>m</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\geq 3
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
<dd>hence

<p>

<math display="block" id="Ackermann_function:15">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>→</mo>
   <mi>n</mi>
   <mo>→</mo>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">3</cn>
        </apply>
       </interval>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\rightarrow n\rightarrow m=A(m+2,n-3)+3
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Ackermann_function:16">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>2
  </annotation>
 </semantics>
</math>

.</p>
</dd>
<dd>(<em>n</em>=1 and <em>n</em>=2 would correspond with <em>A</em>(<em>m</em>,−2) = −1 and <em>A</em>(<em>m</em>,−1) = 1, which could logically be added.)
</dd>
</dl>

<p>For small values of <em>m</em> like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to <em>n</em> (at most <a href="exponential_growth" title="wikilink">exponentially</a>). For <em>m</em> ≥ 4, however, it grows much more quickly; even <em>A</em>(4, 2) is about 2

<math display="inline" id="Ackermann_function:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>×</mo>
   <mrow>
    <msup>
     <mn>10</mn>
     <mn>1</mn>
    </msup>
    <mn>9728</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">9728</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times 10^{1}9728
  </annotation>
 </semantics>
</math>

, and the decimal expansion of <em>A</em>(4, 3) is very large by any typical measure.</p>

<p>Logician <a href="Harvey_Friedman" title="wikilink">Harvey Friedman</a> defines a version of the Ackermann function as follows:</p>
<ul>
<li>For n = 0: A(m, n) = 1</li>
</ul>
<ul>
<li>For m = 1: A(m, n) = 2n</li>
<li>Else: A(m, n) = A(m - 1, A(m, n - 1))</li>
</ul>

<p>He also defines a single-argument version A(n) = A(n, n).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>A single-argument version A(k) = A(k, k) that increases both <em>m</em> and <em>n</em> at the same time dwarfs every primitive recursive function, including very fast-growing functions such as the <a href="exponential_function" title="wikilink">exponential function</a>, the factorial function, multi- and <a class="uri" href="superfactorial" title="wikilink">superfactorial</a> functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). It can be seen that A(n) is roughly comparable to f<sub>ω</sub>(n) in the fast-growing hierarchy.</p>

<p>This extreme growth can be exploited to show that <em>f</em>, which is obviously computable on a machine with infinite memory such as a <a href="Turing_machine" title="wikilink">Turing machine</a> and so is a <a href="computable_function" title="wikilink">computable function</a>, grows faster than any primitive recursive function and is therefore not primitive recursive. In a category with exponentials, using the isomorphism 

<math display="inline" id="Ackermann_function:18">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>×</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>≅</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <times></times>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <approx></approx>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B\rightarrow C\cong A\rightarrow(B\rightarrow C)
  </annotation>
 </semantics>
</math>

 (in computer science, this is called <a class="uri" href="currying" title="wikilink">currying</a>), the Ackermann function may be defined via primitive recursion over higher-order functionals as follows:</p>

<p>

<math display="block" id="Ackermann_function:19">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mo>Ack</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mo>Succ</mo>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mo>Ack</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>m</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>Iter</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>Ack</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>Ack</ci>
      <cn type="integer">0</cn>
     </apply>
     <eq></eq>
     <ci>Succ</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>Ack</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <ci>Iter</ci>
      <apply>
       <ci>Ack</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lcl}\operatorname{Ack}(0)&=&\operatorname{Succ}\\
\operatorname{Ack}(m+1)&=&\operatorname{Iter}(\operatorname{Ack}(m))\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>Succ</em> is the usual <a href="successor_function" title="wikilink">successor function</a> and <em>Iter</em> is defined by primitive recursion as well:</p>

<p>

<math display="block" id="Ackermann_function:20">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo>Iter</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo>Iter</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo>Iter</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>f</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <apply>
       <ci>Iter</ci>
       <ci>f</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <apply>
       <ci>Iter</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <apply>
        <ci>Iter</ci>
        <ci>f</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lcl}\operatorname{Iter}(f)(0)&=&f(1)\\
\operatorname{Iter}(f)(n+1)&=&f(\operatorname{Iter}(f)(n)).\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>One interesting aspect of the Ackermann function is that the only arithmetic operations it ever uses are addition and subtraction of 1. Its properties come solely from the power of unlimited recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see below.</p>
<h2 id="table-of-values">Table of values</h2>

<p>Computing the Ackermann function can be restated in terms of an infinite table. We place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left, then look up the required number in the previous row, at the position given by the number just taken. If there is no number to its left, simply look at the column headed "1" in the previous row. Here is a small upper-left portion of the table:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Values of <em>A</em>(<em>m</em>, <em>n</em>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>m</em>\<em>n</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6</p></td>
</tr>
</tbody>
</table>

<p>The numbers here which are only expressed with recursive exponentiation or <a href="Knuth's_up-arrow_notation" title="wikilink">Knuth arrows</a> are very large and would take up too much space to notate in plain decimal digits.</p>

<p>Despite the large values occurring in this early section of the table, some even larger numbers have been defined, such as <a href="Graham's_number" title="wikilink">Graham's number</a>, which cannot be written with any small number of Knuth arrows. This number is constructed with a technique similar to applying the Ackermann function to itself recursively.</p>

<p>This is a repeat of the above table, but with the values replaced by the relevant expression from the function definition to show the pattern clearly:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Values of <em>A</em>(<em>m</em>, <em>n</em>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>m</em>\<em>n</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6</p></td>
</tr>
</tbody>
</table>
<h2 id="expansion">Expansion</h2>

<p>To see how the Ackermann function grows so quickly, it helps to expand out some simple expressions using the rules in the original definition. For example, we can fully evaluate 

<math display="inline" id="Ackermann_function:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(1,2)
  </annotation>
 </semantics>
</math>

 in the following way:</p>

<p>

<math display="inline" id="Ackermann_function:22">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A(1,2)
  </annotation>
 </semantics>
</math>


</p>

<p>To demonstrate how 

<math display="inline" id="Ackermann_function:23">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(4,3)
  </annotation>
 </semantics>
</math>

's computation results in many steps and in a large number:</p>

<p>

<math display="inline" id="Ackermann_function:24">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A(4,3)
  </annotation>
 </semantics>
</math>


</p>

<p>Written as a power of 10, this is roughly equivalent to 10<sup>6.031

<math display="inline" id="Ackermann_function:25">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>×</mo>
   <mrow>
    <msup>
     <mn>10</mn>
     <mn>1</mn>
    </msup>
    <mn>9727</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">9727</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times 10^{1}9727
  </annotation>
 </semantics>
</math>

</sup>.</p>
<h2 id="inverse">Inverse</h2>

<p>Since the function  <em>f</em> (<em>n</em>) = <em>A</em>(<em>n</em>, <em>n</em>) considered above grows very rapidly, its <a href="inverse_function" title="wikilink">inverse function</a>, <em>f</em><sup>−1</sup>, grows very slowly. This <strong>inverse Ackermann function</strong> <em>f</em><sup>−1</sup> is usually denoted by <strong>α</strong>. In fact, α(n) is less than 5 for any practical input size <em>n</em>, since A(4, 4) is on the order of 

<math display="inline" id="Ackermann_function:26">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mn>2</mn>
    <msup>
     <mn>2</mn>
     <msup>
      <mn>2</mn>
      <mn>16</mn>
     </msup>
    </msup>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">16</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2^{2^{2^{16}}}}
  </annotation>
 </semantics>
</math>

.</p>

<p>This inverse appears in the time <a href="computational_complexity_theory" title="wikilink">complexity</a> of some <a href="algorithm" title="wikilink">algorithms</a>, such as the <a href="disjoint-set_data_structure" title="wikilink">disjoint-set data structure</a> and <a href="Bernard_Chazelle" title="wikilink">Chazelle</a>'s algorithm for <a href="minimum_spanning_tree" title="wikilink">minimum spanning trees</a>. Sometimes Ackermann's original function or other variations are used in these settings, but they all grow at similarly high rates. In particular, some modified functions simplify the expression by eliminating the <em>−3</em> and similar terms.</p>

<p>A two-parameter variation of the inverse Ackermann function can be defined as follows, where 

<math display="inline" id="Ackermann_function:27">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mi>x</mi>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor x\rfloor
  </annotation>
 </semantics>
</math>

 is the <a href="floor_function" title="wikilink">floor function</a>:</p>

<p>

<math display="block" id="Ackermann_function:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>≥</mo>
        <mn>1</mn>
       </mrow>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo>,</mo>
          <mrow>
           <mo stretchy="false">⌊</mo>
           <mrow>
            <mi>m</mi>
            <mo>/</mo>
            <mi>n</mi>
           </mrow>
           <mo stretchy="false">⌋</mo>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≥</mo>
        <mrow>
         <msub>
          <mi>log</mi>
          <mn>2</mn>
         </msub>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>α</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <min></min>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <geq></geq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <geq></geq>
       <apply>
        <times></times>
        <ci>A</ci>
        <interval closure="open">
         <ci>i</ci>
         <apply>
          <floor></floor>
          <apply>
           <divide></divide>
           <ci>m</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </interval>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(m,n)=\min\{i\geq 1:A(i,\lfloor m/n\rfloor)\geq\log_{2}n\}.
  </annotation>
 </semantics>
</math>

 This function arises in more precise analyses of the algorithms mentioned above, and gives a more refined time bound. In the disjoint-set data structure, <em>m</em> represents the number of operations while <em>n</em> represents the number of elements; in the minimum spanning tree algorithm, <em>m</em> represents the number of edges while <em>n</em> represents the number of vertices. Several slightly different definitions of α(<em>m</em>, <em>n</em>) exist; for example, log<sub>2</sub> <em>n</em> is sometimes replaced by <em>n</em>, and the floor function is sometimes replaced by a <a href="ceiling_function" title="wikilink">ceiling</a>.</p>

<p>Other studies might define an inverse function of one where m is set to a constant, such that the inverse applies to a particular row.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="use-as-benchmark">Use as benchmark</h2>

<p>The Ackermann function, due to its definition in terms of extremely deep recursion, can be used as a benchmark of a <a class="uri" href="compiler" title="wikilink">compiler</a>'s ability to optimize recursion. The first use of Ackermann's function in this way was by Yngve Sundblad, <em>The Ackermann function. A Theoretical, computational and formula manipulative study</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>This seminal paper was taken up by Brian Wichmann (co-author of the <a href="Whetstone_(benchmark)" title="wikilink">Whetstone benchmark</a>) in a trilogy of papers written between 1975 and 1982.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="ackermann-numbers">Ackermann numbers</h2>

<p>In <em>The Book of Numbers</em>, <a href="John_Horton_Conway" title="wikilink">John Horton Conway</a> and <a href="Richard_K._Guy" title="wikilink">Richard K. Guy</a> define the sequence of <strong>Ackermann numbers</strong> to be 0[0]0, 1[1]1, 2[2]2, 3[3]3, etc.;<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> that is, the <em>n</em>-th Ackermann number is defined to be <em>n</em>[<em>n</em>]<em>n</em> (<em>n</em> = 0, 1, 2, 3, ...), where <em>a</em>[<em>n</em>]<em>b</em> is the <a class="uri" href="hyperoperation" title="wikilink">hyperoperation</a>.</p>

<p>The first few Ackermann numbers are </p>

<p>:* 0[0]0 = 0 + 1 = 1</p>

<p>:* 1[1]1 = 1 + 1 = 2,</p>

<p>:* 2[2]2 = 2 · 2 = 4,</p>

<p>:* 3[3]3 = 3<sup>3</sup> = 27,</p>

<p>:* 4[4]4 = 4[3]4[3]4[3]4 = 4<sup>4<sup>4<sup>4</sup></sup></sup> = 4<sup>4<sup>256</sup></sup> = 4<sup>2<sup>512</sup></sup> = 2<sup>2<sup>513</sup></sup>,</p>

<p>:* 5[5]5 = 5[4]5[4]5[4]5[4]5 = 5[4]5[4]5[4](5[3]5[3]5[3]5[3]5) = 5[4]5[4]5[4](5<sup>5<sup>5<sup>5<sup>5</sup></sup></sup></sup>)</p>

<p>The sixth Ackermann number, 6[6]6, can be written in terms of <a class="uri" href="tetration" title="wikilink">tetration</a> towers as follows:</p>
<dl>
<dd>6[6]6 = 6[5]6[5]6[5]6[5]6[5]6 = 6[5]6[5]6[5]6[5](6[4]6[4]6[4]6[4]6[4]6)
</dd>
</dl>

<p>Alternatively, this can be written in terms of <a class="uri" href="exponentiation" title="wikilink">exponentiation</a> towers as</p>

<p>

<math display="block" id="Ackermann_function:29">
 <semantics>
  <mrow>
   <mrow>
    <mn>6</mn>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>6</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>6</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>6</mn>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>5</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>6</mn>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>5</mn>
       <mo stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>6</mn>
        <mrow>
         <mo stretchy="false">[</mo>
         <mn>5</mn>
         <mo stretchy="false">]</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>6</mn>
          <mrow>
           <mo stretchy="false">[</mo>
           <mn>5</mn>
           <mo stretchy="false">]</mo>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>6</mn>
            <mrow>
             <mo stretchy="false">[</mo>
             <mn>5</mn>
             <mo stretchy="false">]</mo>
            </mrow>
            <mn>6</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">6</cn>
      </apply>
      <cn type="integer">6</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">5</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">6</cn>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <cn type="integer">5</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">6</cn>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <cn type="integer">5</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">6</cn>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <cn type="integer">5</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">6</cn>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <cn type="integer">5</cn>
          </apply>
          <cn type="integer">6</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6[6]6=6[5](6[5](6[5](6[5](6[5]6))))=
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ackermann_function:30">
 <semantics>
  <mi></mi>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">absent</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ackermann_function:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msup>
         <mn>6</mn>
         <msup>
          <mn>6</mn>
          <msup>
           <mo>⋅</mo>
           <msup>
            <mo>⋅</mo>
            <msup>
             <mo>⋅</mo>
             <msup>
              <mo>⋅</mo>
              <mn>6</mn>
             </msup>
            </msup>
           </msup>
          </msup>
         </msup>
        </msup>
       </mtd>
      </mtr>
     </mtable>
     <mo>}</mo>
    </mrow>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msup>
        <mn>6</mn>
        <msup>
         <mn>6</mn>
         <msup>
          <mo>⋅</mo>
          <msup>
           <mo>⋅</mo>
           <msup>
            <mo>⋅</mo>
            <mn>6</mn>
           </msup>
          </msup>
         </msup>
        </msup>
       </msup>
      </mtd>
     </mtr>
    </mtable>
    <mo>}</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <msup>
       <mn>6</mn>
       <msup>
        <mn>6</mn>
        <msup>
         <mn>6</mn>
         <mn>6</mn>
        </msup>
       </msup>
      </msup>
     </mtd>
    </mtr>
   </mtable>
   <mo>}</mo>
   <mn>6</mn>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">6</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">6</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>normal-⋅</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>normal-⋅</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>normal-⋅</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>normal-⋅</ci>
              <cn type="integer">6</cn>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
      <ci>normal-}</ci>
     </cerror>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">6</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">6</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-⋅</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>normal-⋅</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>normal-⋅</ci>
            <cn type="integer">6</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-…</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">6</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">6</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">6</cn>
         <cn type="integer">6</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
    <ci>normal-}</ci>
    <cn type="integer">6</cn>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.\begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{\cdot^{6}}}}}}\end{matrix}%
\right\}\left.\begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix}%
\right\}\dots\left.\begin{matrix}6^{6^{6^{6}}}\end{matrix}\right\}6,
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where the number of towers on the previous line (including the rightmost "6") is
</dd>
<dd><math>
</math></dd>
</dl>

<p>\left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{\cdot^{6}}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \dots \left. \begin{matrix}6^{6^{6^6}}\end{matrix} \right \} 6, </p>
<dl>
<dd>where the number of towers on the previous line (including the rightmost "6") is
</dd>
<dd><math>
</math></dd>
</dl>

<p>\left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{6^6}}\end{matrix} \right \} 6, </p>
<dl>
<dd>where the number of towers on the previous line (including the rightmost "6") is
</dd>
<dd><math>
</math></dd>
</dl>

<p>\left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{6^6}}\end{matrix} \right \} 6, </p>
<dl>
<dd>where the number of towers on the previous line (including the rightmost "6") is
</dd>
<dd><math>
</math></dd>
</dl>

<p>\left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{\cdot^{\cdot^{\cdot^{6}}}}}\end{matrix} \right \} \left. \begin{matrix}6^{6^{6^6}}\end{matrix} \right \} 6, </p>

<p>where the number of 6s in each tower, on each of the lines above, is specified by the value of the next tower to its right (as indicated by a brace).</p>

<p>The above <em>three</em> lines of exponentiation towers correspond to the indicated three applications of</p>

<p>

<math display="inline" id="Ackermann_function:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>6</mn>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>5</mn>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <munder>
     <munder accentunder="true">
      <mrow>
       <mn>6</mn>
       <mrow>
        <mo movablelimits="false" stretchy="false">[</mo>
        <mn>4</mn>
        <mo movablelimits="false" stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mo movablelimits="false" stretchy="false">(</mo>
        <mrow>
         <mn>6</mn>
         <mrow>
          <mo movablelimits="false" stretchy="false">[</mo>
          <mn>4</mn>
          <mo movablelimits="false" stretchy="false">]</mo>
         </mrow>
         <mrow>
          <mo movablelimits="false" stretchy="false">(</mo>
          <mrow>
           <mn>6</mn>
           <mrow>
            <mo movablelimits="false" stretchy="false">[</mo>
            <mn>4</mn>
            <mo movablelimits="false" stretchy="false">]</mo>
           </mrow>
           <mrow>
            <mo movablelimits="false" stretchy="false">(</mo>
            <mrow>
             <mn>6</mn>
             <mrow>
              <mo movablelimits="false" stretchy="false">[</mo>
              <mn>4</mn>
              <mo movablelimits="false" stretchy="false">]</mo>
             </mrow>
             <mrow>
              <mo movablelimits="false" stretchy="false">(</mo>
              <mrow>
               <mn>6</mn>
               <mrow>
                <mo movablelimits="false" stretchy="false">[</mo>
                <mn>4</mn>
                <mo movablelimits="false" stretchy="false">]</mo>
               </mrow>
               <mn>6</mn>
              </mrow>
              <mo movablelimits="false" stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo movablelimits="false" stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo movablelimits="false" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo movablelimits="false" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo movablelimits="false">⏟</mo>
     </munder>
     <mrow>
      <mi>n</mi>
      <mn>6</mn>
      <mtext>s</mtext>
     </mrow>
    </munder>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">6</cn>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">5</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <times></times>
       <cn type="integer">6</cn>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">6</cn>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <cn type="integer">4</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">6</cn>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">6</cn>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <cn type="integer">4</cn>
          </apply>
          <apply>
           <times></times>
           <cn type="integer">6</cn>
           <apply>
            <csymbol cd="latexml">delimited-[]</csymbol>
            <cn type="integer">4</cn>
           </apply>
           <cn type="integer">6</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <cn type="float">6</cn>
      <mtext>s</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6[5]n=\underbrace{6[4](6[4](6[4](6[4](6[4]6))))}_{n\ 6\text{s}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Computability_theory" title="wikilink">Computability theory</a></li>
<li><a href="Double_recursion" title="wikilink">Double recursion</a></li>
<li><a href="Fast-growing_hierarchy" title="wikilink">Fast-growing hierarchy</a></li>
<li><a href="Goodstein_function" title="wikilink">Goodstein function</a></li>
<li><a href="Primitive_recursive_function" title="wikilink">Primitive recursive function</a></li>
<li><a href="Recursion_(computer_science)" title="wikilink">Recursion (computer science)</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li><a href="http://www.gfredericks.com/main/sandbox/arith/ackermann">An animated Ackermann function calculator</a></li>
<li><a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a>, <em><a href="http://www.scottaaronson.com/writings/bignumbers.html">Who can name the biggest number?</a></em> (1999)</li>
<li><a href="http://www-users.cs.york.ac.uk/~susan/cyc/a/ackermnn.htm">Ackermann function's</a>. Includes a table of some values.</li>
<li>[<a class="uri" href="http://forum.wolframscience.com/showthread.php?s">http://forum.wolframscience.com/showthread.php?s</a>=&amp;threadid;=579 Hyper-operations: Ackermann's Function and New Arithmetical Operation]</li>
<li><a href="http://www.mrob.com/pub/math/largenum.html">Robert Munafo's Large Numbers</a> describes several variations on the definition of <em>A</em>.</li>
<li>Gabriel Nivasch, <a href="http://www.yucs.org/~gnivasch/alpha/index.html">Inverse Ackermann without pain</a> on the inverse Ackermann function.</li>
<li>Raimund Seidel, <em><a href="http://cgi.di.uoa.gr/~ewcg06/invited/Seidel.pdf">Understanding the inverse Ackermann function</a></em> (PDF presentation).</li>
<li><a href="http://rosettacode.org/wiki/Ackermann_Function">The Ackermann function written in different programming languages</a>, (on <a href="Rosetta_Code" title="wikilink">Rosetta Code</a>)</li>
<li><a href="http://www.geocities.com/hjsmithh/Ackerman/index.html">Ackermann's Function</a> (<a href="http://www.webcitation.org/5km8K6GSP">Archived</a> 2009-10-24)—Some study and programming by Harry J. Smith.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Arithmetic" title="wikilink">Category:Arithmetic</a> <a href="Category:Large_integers" title="wikilink">Category:Large integers</a> <a href="Category:Special_functions" title="wikilink">Category:Special functions</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.kosara.net/thoughts/ackermann42.html">Decimal expansion of A(4,2)</a> <a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">von Heijenoort. <a href="http://mathgate.info/cebrown/notes/vonHeijenoort.php">From Frege To Gödel</a>, 1967.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a class="uri" href="http://www.math.osu.edu/~friedman.8/pdf/AckAlgGeom102100.pdf">http://www.math.osu.edu/~friedman.8/pdf/AckAlgGeom102100.pdf</a><a href="#fnref8">↩</a></li>
<li id="fn9">[<a class="uri" href="http://cat.inist.fr/?aModele=afficheN&amp;cpsidt">http://cat.inist.fr/?aModele=afficheN&amp;cpsidt;</a>;=15618233 An inverse-Ackermann style lower bound for the online minimum spanning tree verification problem] November 2002<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">John Horton Conway and Richard K. Guy. [<a class="uri" href="http://books.google.com/books?id=0--3rcO7dMYC&amp;lpg">http://books.google.com/books?id=0--3rcO7dMYC&amp;lpg;</a>;=PA60&amp;dq;=%22Ackermann%20number%22&amp;pg;=PA60#v=onepage&amp;q;=%22Ackermann%20number%22&amp;f;=false <em>The Book of Numbers</em>]. New York: Springer-Verlag, pp. 60-61, 1996. ISBN 978-0-387-97993-9<a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
