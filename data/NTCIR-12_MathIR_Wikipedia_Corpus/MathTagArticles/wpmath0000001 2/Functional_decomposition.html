<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="421">Functional decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Functional decomposition</h1>
<hr/>

<p><strong>Functional decomposition</strong> refers broadly to the process of resolving a <a href="Function_(mathematics)" title="wikilink">functional</a> relationship into its constituent parts in such a way that the original function can be reconstructed (i.e., recomposed) from those parts by <a href="function_composition" title="wikilink">function composition</a>. In general, this process of decomposition is undertaken either for the purpose of gaining insight into the identity of the constituent components (which may reflect individual physical processes of interest, for example), or for the purpose of obtaining a compressed representation of the global function, a task which is feasible only when the constituent processes possess a certain level of <em>modularity</em> (i.e., independence or non-interaction). Interactions between the components are critical to the function of the collection. All interactions may not be observable, but possibly deduced through repetitive perception, synthesis, validation and verification of composite behavior.</p>
<h2 id="basic-mathematical-definition">Basic mathematical definition</h2>

<p>For a multivariate function 

<math display="inline" id="Functional_decomposition:0">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x_{1},x_{2},\dots,x_{n})
  </annotation>
 </semantics>
</math>

, functional decomposition generally refers to a process of identifying a set of functions 

<math display="inline" id="Functional_decomposition:1">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>g</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{g_{1},g_{2},\dots g_{m}\}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Functional_decomposition:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>g</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>m</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},x_{2},\dots,x_{n})=\phi(g_{1}(x_{1},x_{2},\dots,x_{n}),g_{2}(x_{1},x_{%
2},\dots,x_{n}),\dots g_{m}(x_{1},x_{2},\dots,x_{n}))
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Functional_decomposition:3">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is some other function. Thus, we would say that the function 

<math display="inline" id="Functional_decomposition:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is decomposed into functions 

<math display="inline" id="Functional_decomposition:5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>g</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{g_{1},g_{2},\dots g_{m}\}
  </annotation>
 </semantics>
</math>

. This process is intrinsically hierarchical in the sense that we can (and often do) seek to further decompose the functions 

<math display="inline" id="Functional_decomposition:6">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

 into a collection of constituent functions 

<math display="inline" id="Functional_decomposition:7">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>h</mi>
     <mi>p</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{h_{1},h_{2},\dots h_{p}\}
  </annotation>
 </semantics>
</math>

such that</p>

<p>

<math display="block" id="Functional_decomposition:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>h</mi>
       <mi>p</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>p</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}(x_{1},x_{2},\dots,x_{n})=\gamma(h_{1}(x_{1},x_{2},\dots,x_{n}),h_{2}(x_{%
1},x_{2},\dots,x_{n}),\dots h_{p}(x_{1},x_{2},\dots,x_{n}))
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Functional_decomposition:9">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is some other function. Decompositions of this kind are interesting and important for a wide variety of reasons. In general, functional decompositions are worthwhile when there is a certain "sparseness" in the dependency structure; that is, when constituent functions are found to depend on approximately <a href="disjoint_sets" title="wikilink">disjoint sets</a> of variables. Thus, for example, if we can obtain a decomposition of 

<math display="inline" id="Functional_decomposition:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">6</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=f(x_{2},x_{3},\dots,x_{6})
  </annotation>
 </semantics>
</math>

 into a hierarchical composition of functions 

<math display="inline" id="Functional_decomposition:11">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>3</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">3</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{g_{1},g_{2},g_{3}\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Functional_decomposition:12">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=g_{1}(x_{2})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Functional_decomposition:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>4</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>5</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">5</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=g_{2}(x_{3},x_{4},x_{5})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Functional_decomposition:14">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>5</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">6</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{5}=g_{3}(x_{6})
  </annotation>
 </semantics>
</math>

, as shown in the figure at right, this would probably be considered a highly valuable decomposition.</p>
<h3 id="example-arithmetic">Example: Arithmetic</h3>

<p>A basic example of functional decomposition is expressing the four binary arithmetic operations of addition, subtraction, multiplication, and division in terms of the two binary operations of addition 

<math display="inline" id="Functional_decomposition:15">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b
  </annotation>
 </semantics>
</math>

 and multiplication 

<math display="inline" id="Functional_decomposition:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>×</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\times b,
  </annotation>
 </semantics>
</math>

 and the two unary operations of additive inversion 

<math display="inline" id="Functional_decomposition:17">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -a
  </annotation>
 </semantics>
</math>

 and multiplicative inversion 

<math display="inline" id="Functional_decomposition:18">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>a</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/a.
  </annotation>
 </semantics>
</math>

 Subtraction can then be realized as the composition of addition and additive inversion, 

<math display="inline" id="Functional_decomposition:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a-b=a+(-b),
  </annotation>
 </semantics>
</math>

 and division can be realized as the composition of multiplication and multiplicative inverse, 

<math display="inline" id="Functional_decomposition:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>÷</mo>
     <mi>b</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\div b=a\times(1/b).
  </annotation>
 </semantics>
</math>

 This simplifies the analysis of subtraction and division, and also makes it easier to axiomatize these operations in the notion of a <a href="Field_(mathematics)" title="wikilink">field</a>, as there are only two binary and two unary operations, rather than four binary operations.</p>
<h3 id="example-decomposition-of-continuous-functions">Example: Decomposition of continuous functions</h3>
<h2 id="motivation-for-decomposition">Motivation for decomposition</h2>

<p>As to <em>why</em> the decomposition is valuable, the reason is twofold. Firstly, decomposition of a function into non-interacting components generally permits more economical representations of the function. For example, on a set of quaternary (i.e., 4-ary) variables, representing the full function 

<math display="inline" id="Functional_decomposition:21">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">6</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=f(x_{2},x_{3},\dots,x_{6})
  </annotation>
 </semantics>
</math>

 requires storing 

<math display="inline" id="Functional_decomposition:22">
 <semantics>
  <mrow>
   <msup>
    <mn>4</mn>
    <mn>5</mn>
   </msup>
   <mo>=</mo>
   <mn>1024</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">4</cn>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">1024</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4^{5}=1024
  </annotation>
 </semantics>
</math>

 values, the value of the function for each element in the <a href="Cartesian_product" title="wikilink">Cartesian product</a> 

<math display="inline" id="Functional_decomposition:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>6</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">6</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{2},x_{3},\dots,x_{6}\}
  </annotation>
 </semantics>
</math>

, i.e., each of the 1024 possible combinations for 

<math display="inline" id="Functional_decomposition:24">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>6</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">6</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{2},x_{3},\dots,x_{6}\}
  </annotation>
 </semantics>
</math>

. However, if the decomposition into 

<math display="inline" id="Functional_decomposition:25">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>3</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">3</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{g_{1},g_{2},g_{3}\}
  </annotation>
 </semantics>
</math>

 given above is possible, then 

<math display="inline" id="Functional_decomposition:26">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1}=g_{1}(x_{2})
  </annotation>
 </semantics>
</math>

 requires storing 4 values, 

<math display="inline" id="Functional_decomposition:27">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>4</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>5</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">5</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{2}=g_{2}(x_{3},x_{4},x_{5})
  </annotation>
 </semantics>
</math>

 requires storing 

<math display="inline" id="Functional_decomposition:28">
 <semantics>
  <mrow>
   <msup>
    <mn>4</mn>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mn>64</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">64</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4^{3}=64
  </annotation>
 </semantics>
</math>

 values, and 

<math display="inline" id="Functional_decomposition:29">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">6</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{3}=g_{3}(x_{6})
  </annotation>
 </semantics>
</math>

 again requires storing just 4 values. So in virtue of the decomposition, we need store only 

<math display="inline" id="Functional_decomposition:30">
 <semantics>
  <mrow>
   <mrow>
    <mn>4</mn>
    <mo>+</mo>
    <mn>64</mn>
    <mo>+</mo>
    <mn>4</mn>
   </mrow>
   <mo>=</mo>
   <mn>72</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">4</cn>
     <cn type="integer">64</cn>
     <cn type="integer">4</cn>
    </apply>
    <cn type="integer">72</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4+64+4=72
  </annotation>
 </semantics>
</math>

 values rather than 1024 values, a dramatic savings.</p>

<p> Intuitively, this reduction in representation size is achieved simply because each variable depends only on a subset of the other variables. Thus, variable 

<math display="inline" id="Functional_decomposition:31">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 only depends directly on variable 

<math display="inline" id="Functional_decomposition:32">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

, rather than depending on the <em>entire set</em> of variables. We would say that variable 

<math display="inline" id="Functional_decomposition:33">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 <em>screens off</em> variable 

<math display="inline" id="Functional_decomposition:34">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 from the rest of the world. Practical examples of this phenomenon surround us, as discussed in the "Philosophical Considerations" below, but let's just consider the particular case of "northbound traffic on the <a href="West_Side_Highway" title="wikilink">West Side Highway</a>." Let us assume this variable (

<math display="inline" id="Functional_decomposition:35">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1}}
  </annotation>
 </semantics>
</math>

) takes on three possible values of {"moving slow", "moving deadly slow", "not moving at all"}. Now let's say variable 

<math display="inline" id="Functional_decomposition:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1}}
  </annotation>
 </semantics>
</math>

 depends on two other variables, "weather" with values of {"sun", "rain", "snow"}, and "<a href="GW_Bridge" title="wikilink">GW Bridge</a> traffic" with values {"10mph", "5mph", "1mph"}. The point here is that while there are certainly many secondary variables that affect the weather variable (e.g., low pressure system over Canada, <a href="Butterfly_Effect" title="wikilink">butterfly flapping</a> in Japan, etc.) and the Bridge traffic variable (e.g., an accident on <a href="Interstate_95_in_New_York" title="wikilink">I-95</a>, presidential motorcade, etc.) all these other secondary variables are not directly relevant to the West Side Highway traffic. All we need (hypothetically) in order to predict the West Side Highway traffic is the weather and the GW Bridge traffic, because these two variables <em>screen off</em> West Side Highway traffic from all other potential influences. That is, all other influences act <em>through</em> them.</p>

<p>Outside of purely mathematical considerations, perhaps the greatest value of functional decomposition is the insight it provides into the structure of the world. When a functional decomposition can be achieved, this provides ontological information about what structures actually exist in the world, and how they can be predicted and manipulated. For example, in the illustration above, if it is learned that 

<math display="inline" id="Functional_decomposition:37">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1}}
  </annotation>
 </semantics>
</math>

 depends directly only on 

<math display="inline" id="Functional_decomposition:38">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{2}}
  </annotation>
 </semantics>
</math>

, this means that for purposes of prediction of 

<math display="inline" id="Functional_decomposition:39">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1}}
  </annotation>
 </semantics>
</math>

, it suffices to know only 

<math display="inline" id="Functional_decomposition:40">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{2}}
  </annotation>
 </semantics>
</math>

. Moreover, interventions to influence 

<math display="inline" id="Functional_decomposition:41">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1}}
  </annotation>
 </semantics>
</math>

 can be taken directly on 

<math display="inline" id="Functional_decomposition:42">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{2}}
  </annotation>
 </semantics>
</math>

, and nothing additional can be gained by intervening on variables 

<math display="inline" id="Functional_decomposition:43">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>4</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>5</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{3},x_{4},x_{5}\}
  </annotation>
 </semantics>
</math>

, since these only act through 

<math display="inline" id="Functional_decomposition:44">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{2}}
  </annotation>
 </semantics>
</math>

 in any case.</p>
<h2 id="philosophical-considerations">Philosophical considerations</h2>

<p>The philosophical antecedents and ramifications of functional decomposition are quite broad, as functional decomposition in one guise or another underlies all of modern science. Here we review just a few of these philosophical considerations.</p>
<h3 id="reductionist-tradition">Reductionist tradition</h3>

<p>One of the major distinctions that is often drawn between <a href="Eastern_philosophy" title="wikilink">Eastern philosophy</a> and <a href="Western_Philosophy" title="wikilink">Western Philosophy</a> is that the Eastern philosophers tended to espouse ideas favoring <a class="uri" href="holism" title="wikilink">holism</a> while the Western thinkers tended to espouse ideas favoring <a class="uri" href="reductionism" title="wikilink">reductionism</a>. While this distinction between East and West — like other such philosophical distinctions that have been drawn (e.g., <a href="Philosophical_realism" title="wikilink">realism</a> vs. <a class="uri" href="anti-realism" title="wikilink">anti-realism</a>) — almost certainly simplifies matters too much, there is still a kernel of truth to be had. Some examples of the Eastern holistic spirit:</p>
<ul>
<li>"Open your mouth, increase your activities, start making distinctions between things, and you'll toil forever without hope." <small>— The <a href="Tao_Te_Ching" title="wikilink">Tao Te Ching</a> of <a href="Lao_Tzu" title="wikilink">Lao Tzu</a> (Brian Browne Walker, translator)</small></li>
<li>"It's a hard job for [people] to see the meaning of the fact that everything, including ourselves, depends on everything else and has no permanent self-existence." <small>— <a href="Majjhima_Nikaya" title="wikilink">Majjhima Nikaya</a> (Anne Bankroft, translator)</small></li>
<li>"A name is imposed on what is thought to be a thing or a state and this divides it from other things and other states. But when you pursue what lies behind the name, you find a greater and greater subtlety that has no divisions..." <small>— <a href="Visuddhi_Magga" title="wikilink">Visuddhi Magga</a> (Anne Bankroft, translator)</small></li>
</ul>

<p>The Western tradition, from its origins among the <a href="Greek_philosophers" title="wikilink">Greek philosophers</a>, preferred a position in which drawing correct distinctions, divisions, and contrasts was considered the very pinnacle of insight. In the <a href="Aristotelianism" title="wikilink">Aristotelian</a>/<a href="Porphyry_(philosopher)" title="wikilink">Porphyrian</a> worldview, to be able to distinguish (via strict proof) which qualities of a thing represent its <a class="uri" href="essence" title="wikilink">essence</a> vs. <a href="Property_(philosophy)" title="wikilink">property</a> vs. <a href="accident_(philosophy)" title="wikilink">accident</a> vs. <a href="Intensional_definition" title="wikilink">definition</a>, and by virtue of this formal description to segregate that entity into its proper place in the taxonomy of nature — this was to achieve the very height of wisdom.</p>
<h3 id="characteristics-of-hierarchy-and-modularity">Characteristics of hierarchy and modularity</h3>

<p>In natural or artificial systems that require components to be integrated in some fashion, but where the number of components exceeds what could reasonably be fully interconnected (due to exponential growth in number of connections), one often finds that some degree of hierarchicality must be employed in the solution. The general advantages of sparse hierarchical systems over densely connected systems—and quantitative estimates of these advantage—are presented by . In prosaic terms, a hierarchy is "a collection of elements that combine lawfully into complex wholes which depend for their properties upon those of their constituent parts," and wherein novelty is "fundamentally combinatorial, iterative, and transparent" .</p>

<p>An important notion that always arises in connection with hierarchies is modularity, which is effectively implied by the sparseness of connections in hierarchical topologies. In physical systems, a module is generally a set of interacting components that relates to the external world via a very limited interface, thus concealing most aspects of its internal structure. As a result, modifications that are made to the internals of a module (to improve efficiency for example) do not necessarily create a ripple effect through the rest of the system . This feature makes the effective use of modularity a centerpiece of all good software and hardware engineering, notably object oriented programming . Other examples of the use of hierarchy in the manufacture of artifacts, including computer software (,), are too obvious to bear mention.</p>
<h3 id="inevitability-of-hierarchy-and-modularity">Inevitability of hierarchy and modularity</h3>

<p>There are many compelling arguments regarding the prevalence and necessity of hierarchy/modularity in nature .  points out that among evolving systems, only those that can manage to obtain and then reuse stable subassemblies (modules) are likely to be able to search through the fitness landscape with a reasonably quick pace; thus, Simon submits that "among possible complex forms, hierarchies are the ones that have the time to evolve." This line of thinking has led to the even stronger claim that although "we do not know what forms of life have evolved on other planets in the universe, ... we can safely assume that 'wherever there is life, it must be hierarchically organized'" . This would be a fortunate state of affairs since the existence of simple and isolable subsystems is thought to be a precondition for successful science . In any case, experience certainly seems to indicate that much of the world possesses hierarchical structure.</p>

<p>It has been proposed that perception itself is a process of hierarchical decomposition , and that phenomena which are not essentially hierarchical in nature may not even be "theoretically intelligible" to the human mind (,). In Simon's words,</p>
<h2 id="applications">Applications</h2>

<p>Practical applications of functional decomposition are found in <a href="Bayesian_networks" title="wikilink">Bayesian networks</a>, <a href="structural_equation_modeling" title="wikilink">structural equation modeling</a>, <a href="linear_systems" title="wikilink">linear systems</a>, and <a href="database_systems" title="wikilink">database systems</a>.</p>
<h3 id="knowledge-representation">Knowledge representation</h3>

<p>Processes related to functional decomposition are prevalent throughout the fields of <a href="knowledge_representation" title="wikilink">knowledge representation</a> and <a href="machine_learning" title="wikilink">machine learning</a>. Hierarchical model induction techniques such as <a href="Logic_circuit_minimization" title="wikilink">Logic circuit minimization</a>, <a href="decision_trees" title="wikilink">decision trees</a>, <a href="grammatical_inference" title="wikilink">grammatical inference</a>, <a href="hierarchical_clustering" title="wikilink">hierarchical clustering</a>, and <a href="quadtree_decomposition" title="wikilink">quadtree decomposition</a> are all examples of function decomposition. A review of other applications and function decomposition can be found in , which also presents methods based on <a href="information_theory" title="wikilink">information theory</a> and <a href="graph_theory" title="wikilink">graph theory</a>.</p>

<p>Many statistical inference methods can be thought of as implementing a function decomposition process in the presence of noise; that is, where functional dependencies are only expected to hold <em>approximately</em>. Among such models are <a href="mixture_models" title="wikilink">mixture models</a> and the recently popular methods referred to as "causal decompositions" or <a href="Bayesian_networks" title="wikilink">Bayesian networks</a>.</p>
<h3 id="database-theory">Database theory</h3>

<p>See <a href="database_normalization" title="wikilink">database normalization</a>.</p>
<h3 id="machine-learning">Machine learning</h3>

<p>In practical scientific applications, it is almost never possible to achieve perfect functional decomposition because of the incredible complexity of the systems under study. This complexity is manifested in the presence of "noise," which is just a designation for all the unwanted and untraceable influences on our observations.</p>

<p>However, while perfect functional decomposition is usually impossible, the spirit lives on in a large number of statistical methods that are equipped to deal with noisy systems. When a natural or artificial system is intrinsically hierarchical, the <a href="joint_distribution" title="wikilink">joint distribution</a> on system variables should provide evidence of this hierarchical structure. The task of an observer who seeks to understand the system is then to infer the hierarchical structure from observations of these variables. This is the notion behind the hierarchical decomposition of a joint distribution, the attempt to recover something of the intrinsic hierarchical structure which generated that joint distribution.</p>

<p>As an example, <a href="Bayesian_network" title="wikilink">Bayesian network</a> methods attempt to decompose a joint distribution along its causal fault lines, thus "cutting nature at its seams". The essential motivation behind these methods is again that within most systems (natural or artificial), relatively few components/events interact with one another directly on equal footing . Rather, one observes pockets of dense connections (direct interactions) among small subsets of components, but only loose connections between these densely connected subsets. There is thus a notion of "causal proximity" in physical systems under which variables naturally precipitate into small clusters. Identifying these clusters and using them to represent the joint provides the basis for great efficiency of storage (relative to the full joint distribution) as well as for potent inference algorithms.</p>
<h3 id="software-architecture">Software architecture</h3>

<p>Functional Decomposition is a design method intending to produce a non-implementation, architectural description of a computer program. Rather than conjecturing Objects and adding methods to them (<a href="Object-oriented_programming" title="wikilink">OOP</a>), with each Object intending to capture some service of the program, the software architect first establishes a series of functions and types that accomplishes the main processing problem of the computer program, then derives Modules from this activity.</p>

<p>For example, the design of the editor <a class="uri" href="Emacs" title="wikilink">Emacs</a> can initially be thought about in terms of functions:</p>

<p>

<math display="inline" id="Functional_decomposition:45">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>e</mi>
   </mpadded>
   <mo>≡</mo>
   <mtext>state of the Emacs editor and running operating system</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>e</ci>
    <mtext>state of the Emacs editor and running operating system</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\,\equiv\text{state of the Emacs editor and running operating system}
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Functional_decomposition:46">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
   </mpadded>
   <mo>≡</mo>
   <mrow>
    <mi>e</mi>
    <mtext>with some component/part of its state changed</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <mtext>with some component/part of its state changed</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}\,\equiv e\text{ with some component/part of its state changed}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Functional_decomposition:47">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mrow>
      <mi>l</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mpadded width="+3.4pt">
       <mi>p</mi>
      </mpadded>
      <mi>e</mi>
      <mi>x</mi>
      <mi>p</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>s</mi>
      <mi>s</mi>
      <mi>i</mi>
      <mi>o</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <interval closure="open">
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>x</ci>
       <ci>p</ci>
       <ci>r</ci>
       <ci>e</ci>
       <ci>s</ci>
       <ci>s</ci>
       <ci>i</ci>
       <ci>o</ci>
       <ci>n</ci>
      </apply>
     </interval>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:(e,lisp\,\,expression)\rightarrow e^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>And a possible <strong>function decomposition</strong> of <em>f</em>:</p>

<p>

<math display="inline" id="Functional_decomposition:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mi>r</mi>
    <mi>o</mi>
    <mi>m</mi>
    <mi>E</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mi>r</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>l</mi>
     <mi>i</mi>
     <mi>s</mi>
     <mpadded width="+3.4pt">
      <mi>p</mi>
     </mpadded>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <mi>r</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mi>i</mi>
     <mi>o</mi>
     <mi>n</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>{</mo>
     <mtable>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mi>o</mi>
          <mi>b</mi>
          <mi>j</mi>
          <mi>e</mi>
          <mi>c</mi>
          <mi>t</mi>
         </mrow>
         <mo>,</mo>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mtext>if success</mtext>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mi>e</mi>
          <mi>r</mi>
          <mi>r</mi>
          <mi>o</mi>
          <mi>r</mi>
         </mrow>
         <mo>,</mo>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mtext>if failure</mtext>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
     <ci>o</ci>
     <ci>m</ci>
     <ci>E</ci>
     <ci>x</ci>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>i</ci>
      <ci>s</ci>
      <ci>p</ci>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <ci>r</ci>
      <ci>e</ci>
      <ci>s</ci>
      <ci>s</ci>
      <ci>i</ci>
      <ci>o</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">cases</csymbol>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>b</ci>
       <ci>j</ci>
       <ci>e</ci>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
      <mtext>if success</mtext>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>r</ci>
       <ci>r</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
      <mtext>if failure</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fromExpr:lisp\,\,expression\rightarrow\begin{cases}object,&\text{if success}\\
error,&\text{if failure}\end{cases}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Functional_decomposition:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <mi>b</mi>
      <mi>j</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>t</mi>
     </mrow>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>b</ci>
       <ci>j</ci>
       <ci>e</ci>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
      <ci>e</ci>
     </interval>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   evaluate:(object,e)\rightarrow e^{\prime}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Functional_decomposition:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>e</mi>
      <mi>r</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>r</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>r</ci>
       <ci>r</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
      <ci>e</ci>
     </interval>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   print:(error,e)\rightarrow e^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>This leads one to the plausible Module, Service, or Object, of an interpreter (containing the function <em>fromExpr</em>). Function Decomposition arguably yields insights about re-usability, such as if during the course of analysis, two functions produce the same type, it is likely that a common function/cross-cutting concern resides in both. To contrast, in <a href="Object-oriented_programming" title="wikilink">OOP</a>, it is a common practice to conjecture Modules prior to considering such a decomposition. This arguably results in costly <a class="uri" href="refactoring" title="wikilink">refactoring</a> later. FD mitigates that risk to some extent. Further, arguably, what separates FD from other design methods- is that it provides a concise high-level medium of architectural discourse that is end-to-end, revealing flaws in upstream <a class="uri" href="requirements" title="wikilink">requirements</a> and beneficially exposing more design decisions in advance. And lastly, FD is known to prioritize development. As arguably, if the FD is correct, the most re-usable and cost-determined parts of the program are identified far earlier in the development cycle.</p>
<h3 id="signal-processing">Signal processing</h3>

<p>Functional decomposition is used in the analysis of many <a href="signal_processing" title="wikilink">signal processing</a> systems, such as <a href="LTI_system_theory" title="wikilink">LTI systems</a>. The input signal to an LTI system can be expressed as a function, 

<math display="inline" id="Functional_decomposition:51">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Functional_decomposition:52">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)
  </annotation>
 </semantics>
</math>

 can be decomposed into a linear combination of other functions, called component signals:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Functional_decomposition:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>g</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>3</mn>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>g</mi>
       <mn>3</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>g</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)=a_{1}\cdot g_{1}(t)+a_{2}\cdot g_{2}(t)+a_{3}\cdot g_{3}(t)+\dots+a_{n}%
\cdot g_{n}(t)
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>Here, 

<math display="inline" id="Functional_decomposition:54">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{g_{1}(t),g_{2}(t),g_{3}(t),\dots,g_{n}(t)\}
  </annotation>
 </semantics>
</math>

 are the component signals. Note that 

<math display="inline" id="Functional_decomposition:55">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a_{1},a_{2},a_{3},\dots,a_{n}\}
  </annotation>
 </semantics>
</math>

 are constants. This decomposition aids in analysis, because now the output of the system can be expressed in terms of the components of the input. If we let 

<math display="inline" id="Functional_decomposition:56">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\{\}
  </annotation>
 </semantics>
</math>

 represent the effect of the system, then the output signal is 

<math display="inline" id="Functional_decomposition:57">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <set>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>t</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\{f(t)\}
  </annotation>
 </semantics>
</math>

, which can be expressed as:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Functional_decomposition:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mn>1</mn>
        </msub>
        <mo>⋅</mo>
        <msub>
         <mi>g</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mn>2</mn>
        </msub>
        <mo>⋅</mo>
        <msub>
         <mi>g</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mn>3</mn>
        </msub>
        <mo>⋅</mo>
        <msub>
         <mi>g</mi>
         <mn>3</mn>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">…</mi>
      <mo>+</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>n</mi>
        </msub>
        <mo>⋅</mo>
        <msub>
         <mi>g</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <set>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <set>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\{f(t)\}=T\{a_{1}\cdot g_{1}(t)+a_{2}\cdot g_{2}(t)+a_{3}\cdot g_{3}(t)+\dots%
+a_{n}\cdot g_{n}(t)\}
  </annotation>
 </semantics>
</math>



</dd>
<dd>

<math display="inline" id="Functional_decomposition:59">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>⋅</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <mo>⋅</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>3</mn>
      </msub>
      <mo>⋅</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mn>3</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <mo>⋅</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">3</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </set>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>n</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =a_{1}\cdot T\{g_{1}(t)\}+a_{2}\cdot T\{g_{2}(t)\}+a_{3}\cdot T\{g_{3}(t)\}+%
\dots+a_{n}\cdot T\{g_{n}(t)\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In other words, the system can be seen as acting separately on each of the components of the input signal. Commonly used examples of this type of decomposition are the <a href="Fourier_series" title="wikilink">Fourier series</a> and the <a href="Fourier_transform" title="wikilink">Fourier transform</a>.</p>
<h3 id="systems-engineering">Systems engineering</h3>

<p>Functional decomposition in <a href="systems_engineering" title="wikilink">systems engineering</a> refers to the process of defining a system in functional terms, then defining lower-level functions and sequencing relationships from these higher level systems functions.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The basic idea is to try to divide a system in such a way that each block of a <a href="Functional_flow_block_diagram" title="wikilink">block diagram</a> can be described without an "and" or "or" in the description.</p>

<p>This exercise forces each part of the system to have a pure <a href="role" title="wikilink">function</a>. When a system is designed as pure functions, they can be reused, or replaced. A usual side effect is that the interfaces between blocks become simple and generic. Since the interfaces usually become simple, it is easier to replace a pure function with a related, similar function.</p>

<p>For example, say that one needs to make a <a href="boombox" title="wikilink">stereo</a> system. One might functionally decompose this into <a href="loudspeaker" title="wikilink">speakers</a>, <a class="uri" href="amplifier" title="wikilink">amplifier</a>, a <a href="tape_deck" title="wikilink">tape deck</a> and a front panel. Later, when a different model needs an audio <a class="uri" href="CD" title="wikilink">CD</a>, it can probably fit the same interfaces.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bayesian_networks" title="wikilink">Bayesian networks</a></li>
<li><a href="Database_normalization" title="wikilink">Database normalization</a></li>
<li><a href="Function_composition" title="wikilink">Function composition</a></li>
<li><a href="Inductive_inference" title="wikilink">Inductive inference</a></li>
<li><a href="Knowledge_representation" title="wikilink">Knowledge representation</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Engineering" title="wikilink">Category:Engineering</a> <a href="Category:Functions_and_mappings" title="wikilink">Category:Functions and mappings</a> <a href="Category:Philosophy_of_mathematics" title="wikilink">Category:Philosophy of mathematics</a> <a href="Category:Philosophy_of_physics" title="wikilink">Category:Philosophy of physics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.dau.mil/pubscats/Pages/sys_eng_fund.aspx"><em>Systems Engineering Fundamentals.</em></a>, Defense Acquisition University Press, Fort Belvoir, VA, January 2001, p45<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
