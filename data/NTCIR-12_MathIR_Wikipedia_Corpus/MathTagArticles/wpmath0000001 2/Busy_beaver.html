<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1980">Busy beaver</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Busy beaver</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, a <strong>busy beaver</strong> is a <a href="Turing_machine" title="wikilink">Turing machine</a> that attains the maximum number of steps performed, or maximum number of nonblank symbols finally on the tape, among all Turing machines in a certain class. The Turing machines in this class must meet certain design specifications and are required to <a href="Halting_problem" title="wikilink">eventually halt</a> after being started with a blank tape.</p>

<p>A <strong>busy beaver function</strong> quantifies these upper limits on a given measure, and is a <a href="noncomputable_function" title="wikilink">noncomputable function</a>. In fact, a busy beaver function can be shown to grow faster <a href="asymptotic_analysis" title="wikilink">asymptotically</a> than does any computable function. The concept was first introduced by <a href="Tibor_Radó" title="wikilink">Tibor Radó</a> as the "busy beaver game" in his 1962 paper, "On Non-Computable Functions".</p>
<h2 id="the-busy-beaver-game">The busy beaver game</h2>

<p>The <strong><em>n</em>-state busy beaver game</strong> (or <strong>BB-<em>n</em> game</strong>), introduced in <a href="Tibor_Radó" title="wikilink">Tibor Radó</a>'s 1962 paper, involves a class of <a href="Turing_machine#Formal_definition" title="wikilink">Turing machines</a>, each member of which is required to meet the following design specifications:</p>
<ul>
<li>The machine has <em>n</em> "operational" states plus a Halt state, where <em>n</em> is a positive integer, and one of the <em>n</em> states is distinguished as the starting state.<br/>
(Typically, the states are labelled by 1, 2, ..., <em>n</em>, with state 1 as the starting state, or by <em>A</em>, <em>B</em>, <em>C</em>, ..., with state <em>A</em> as the starting state.)</li>
<li>The machine uses a single two-way infinite (or unbounded) tape.</li>
<li>The tape alphabet is {0, 1}, with 0 serving as the blank symbol.</li>
<li>The machine's <em>transition function</em> takes two inputs:</li>
</ul>

<p>:#the current non-Halt state,</p>

<p>:#the symbol in the current tape cell,</p>
<dl>
<dd>and produces three outputs:
<ol>
<li>a symbol to write over the one in the current tape cell (it may be the same symbol as the one overwritten),</li>
<li>a direction to move (left or right; that is, shift to the tape cell one place to the left or right of the current cell), and</li>
<li>a state to transition into (which may be the Halt state).</li>
</ol>
</dd>
<dd>The transition function may be seen as a finite table of 5-tuples, each of the form
</dd>
<dd>(current state, current symbol, symbol to write, direction of shift, next state).
</dd>
</dl>

<p>"Running" the machine consists of starting in the starting state, with the current tape cell being any cell of a blank (all-0) tape, and then iterating the transition function until the Halt state is entered (if ever). If, and only if, the machine eventually halts, then the number of 1s finally remaining on the tape is called the machine's <em>score</em>.</p>

<p>The <em>n</em>-state busy beaver (BB-<em>n</em>) game is a contest to find such an <em>n</em>-state Turing machine having the largest possible score — the largest number of 1s on its tape after halting. A machine that attains the largest possible score among all <em>n</em>-state Turing machines is called an <em>n</em>-state <strong>busy beaver</strong>, and a machine whose score is merely the highest so far attained (perhaps not the largest possible) is called a <em>champion</em> <em>n</em>-state machine.</p>

<p>Radó required that each machine entered in the contest be accompanied by a statement of the exact number of steps it takes to reach the Halt state, thus allowing the score of each entry to be verified (in principle) by running the machine for the stated number of steps. (If entries were to consist only of machine descriptions, then the problem of verifying every potential entry is undecidable, because it is equivalent to the well-known <a href="halting_problem" title="wikilink">halting problem</a> — there would be no effective way to decide whether an arbitrary machine eventually halts.)</p>
<h2 id="the-busy-beaver-function-σ">The busy beaver function Σ</h2>

<p>The busy beaver function, Σ: <em>N</em> → <em>N</em>, is defined such that Σ(<em>n</em>) is the maximum attainable score (the maximum number of 1s finally on the tape) among all halting 2-symbol <em>n</em>-state Turing machines of the above-described type, when started on a blank tape.</p>

<p>It is clear that Σ is a well-defined function: for every <em>n</em>, there are at most finitely many <em>n</em>-state Turing machines as above, <a href="up_to" title="wikilink">up to</a> isomorphism, hence at most finitely many possible running times.</p>

<p>This infinite sequence <strong>Σ</strong> is the <strong>busy beaver function</strong>, and any <em>n</em>-state 2-symbol Turing machine <em>M</em> for which σ(<em>M</em>) = Σ(<em>n</em>) (i.e., which attains the maximum score) is called a <strong>busy beaver</strong>. Note that for each <em>n</em>, there exist at least two <em>n</em>-state busy beavers (because, given any <em>n</em>-state busy beaver, another is obtained by merely changing the shift direction in a halting transition).</p>
<h2 id="non-computability-of-σ">Non-computability of Σ</h2>

<p>Radó's 1962 paper proved that if <em>f</em>: <a href="natural_number" title="wikilink">ℕ</a> → <a href="natural_number" title="wikilink">ℕ</a> is any <a href="computable_function" title="wikilink">computable function</a>, then Σ(<em>n</em>) &gt; <em>f(n)</em> for all sufficiently large <em>n</em>, and hence that Σ is not a computable function.</p>

<p>Moreover, this implies that it is <a href="Undecidable_problem" title="wikilink">undecidable</a> by a general <a class="uri" href="algorithm" title="wikilink">algorithm</a> whether an arbitrary Turing machine is a <a href="Busy_beaver#The_busy_beaver_game" title="wikilink">busy beaver</a>. (Such an algorithm cannot exist, because its existence would allow Σ to be computed, which is a proven impossibility. In particular, such an algorithm could be used to construct another algorithm that would compute Σ as follows: for any given <em>n</em>, each of the finitely many <em>n</em>-state 2-symbol Turing machines would be tested until an <em>n</em>-state busy beaver is found; this busy beaver machine would then be simulated to determine its score, which is by definition Σ(<em>n</em>).)</p>

<p>Even though Σ(<em>n</em>) is an uncomputable function, there are some small <em>n</em> for which it is possible to obtain its values and prove that they are correct. It is not hard to show that Σ(0) = 0, Σ(1) = 1, Σ(2) = 4, and with progressively more difficulty it can be shown that Σ(3) = 6 and Σ(4) = 13 . Σ(n) has not yet been determined for any instance of n &gt; 4, although lower bounds have been established (see the <a href="#Known_values" title="wikilink">Known Values</a> section below).</p>
<h2 id="σ-complexity-and-unprovability">Σ, complexity and unprovability</h2>

<p>A variant of <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a> is defined as follows [cf. Boolos, Burgess &amp; Jeffrey, 2007]: The <em>complexity</em> of a number <em>n</em> is the smallest number of states needed for a BB-class Turing machine that halts with a single block of <em>n</em> consecutive 1s on an initially blank tape. The corresponding variant of <a href="Chaitin's_incompleteness_theorem" title="wikilink">Chaitin's incompleteness theorem</a> states that, in the context of a given <a href="axiomatic_system" title="wikilink">axiomatic system</a> for the natural numbers, there exists a number <em>k</em> such that no specific number can be proved to have complexity greater than <em>k</em>, and hence that no specific upper bound can be proven for Σ(<em>k</em>) (the latter is because "the complexity of <em>n</em> is greater than <em>k</em>" would be proved if "<em>n</em> &gt; Σ(<em>k</em>)" were proved). As mentioned in the cited reference, for any axiomatic system of "ordinary mathematics" the least value <em>k</em> for which this is true is far less than <a href="Knuth's_up-arrow_notation" title="wikilink">10↑↑10</a>; consequently, <em>in the context of ordinary mathematics, neither the value nor any upper-bound of Σ(10↑↑10) can be proven</em>. (<a href="Gödel's_first_incompleteness_theorem" title="wikilink">Gödel's first incompleteness theorem</a> is illustrated by this result: in an axiomatic system of ordinary mathematics, there is a true-but-unprovable sentence of the form "Σ(10↑↑10) = <em>n</em>", and there are infinitely many true-but-unprovable sentences of the form "Σ(10↑↑10) s(M) = \,\!  the number of shifts <em>M</em> makes before halting, for any <em>M</em> in <em>E<sub>n</sub></em>,</p>
<ul>
<li>

<math display="inline" id="Busy_beaver:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>M</mi>
      <mo>∈</mo>
      <msub>
       <mi>E</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <max></max>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <in></in>
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)=\max\{s(M)|M\in E_{n}\}=\,\!
  </annotation>
 </semantics>
</math>

  the largest number of shifts made by any halting <em>n</em>-state 2-symbol Turing machine.</li>
</ul>

<p>Because these Turing machines are required to have a shift in each and every transition or "step" (including any transition to a Halt state), the max-shifts function is at the same time a max-steps function.</p>

<p>Radó showed that <em>S</em> is noncomputable for the same reason that Σ is noncomputable — it grows faster than any computable function. He proved this simply by noting that for each <em>n</em>, <em>S</em>(<em>n</em>) ≥ Σ(<em>n</em>), because a shift is required to write a 1 on the tape; consequently, <em>S</em> grows at least as fast as Σ, which had already been proved to grow faster than any computable function.</p>

<p>The following connection between Σ and <em>S</em> was used by Lin &amp; Radó [<em>Computer Studies of Turing Machine Problems</em>, 1965] to prove that Σ(3) = 6: For a given <em>n</em>, if <em>S</em>(<em>n</em>) is known then all <em>n</em>-state Turing machines can (in principle) be run for up to <em>S</em>(<em>n</em>) steps, at which point any machine that hasn't yet halted will never halt. At that point, by observing which machines have halted with the most 1s on the tape (i.e., the busy beavers), one obtains from their tapes the value of Σ(<em>n</em>). The approach used by Lin &amp; Radó for the case of <em>n</em> = 3 was to conjecture that <em>S</em>(3) = 21, then to simulate all the essentially different 3-state machines for up to 21 steps. By analyzing the behavior of the machines that had not halted within 21 steps, they succeeded in showing that none of those machines would ever halt, thus proving the conjecture that <em>S</em>(3) = 21, and determining that Σ(3) = 6 by the procedure just described.</p>

<p>Inequalities relating Σ and <em>S</em> include the following (from [Ben-Amram, et al., 1996]), which are valid for all <em>n</em> ≥ 1:</p>

<p>

<math display="block" id="Busy_beaver:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)\geq\Sigma(n)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Busy_beaver:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>3</mn>
       <mi>n</mi>
      </mrow>
      <mo>+</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-Σ</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)\leq(2n-1)\Sigma(3n+3)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Busy_beaver:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>3</mn>
        <mi>n</mi>
       </mrow>
       <mo>+</mo>
       <mn>6</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">6</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)<\Sigma(3n+6)\,\!;
  </annotation>
 </semantics>
</math>

</p>

<p>and an <a href="asymptotic_analysis" title="wikilink">asymptotically</a> improved bound (from [Ben-Amram, Petersen, 2002]): there exists a constant <em>c</em>, such that for all <em>n</em> ≥ 2,</p>

<p>

<math display="block" id="Busy_beaver:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">⌈</mo>
        <mrow>
         <mrow>
          <mn>8</mn>
          <mi>n</mi>
         </mrow>
         <mo>/</mo>
         <mrow>
          <msub>
           <mi>log</mi>
           <mn>2</mn>
          </msub>
          <mi>n</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">⌉</mo>
       </mrow>
       <mo>+</mo>
       <mi>c</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <apply>
       <ceiling></ceiling>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">8</cn>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)\leq\Sigma(n+\lceil 8n/\log_{2}n\rceil+c).\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="known-values">Known values</h2>

<p>The function values for Σ(<em>n</em>) and <em>S</em>(<em>n</em>) are only known exactly for <em>n</em> Skelet <a href="http://skelet.ludost.net/bb/nreg.html">lists 42 unproven machines</a>. However, other busy beaver hunters have different sets of machines. At the moment the record 6-state champion produces over 10<sup>18267</sup> 1s, using over 10<sup>36534</sup> steps (found by Pavel Kropitz in 2010). As noted above, these are 2-symbol Turing machines.</p>

<p>Milton Green, in his 1964 paper "A Lower Bound on Rado's Sigma Function for Binary Turing Machines", constructed a set of Turing machines demonstrating that</p>

<p>

<math display="block" id="Busy_beaver:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>3</mn>
   <msup>
    <mo>↑</mo>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mn>3</mn>
   <mo>></mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>-</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo>-</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>≥</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">3</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-↑</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">3</cn>
    <gt></gt>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">k</csymbol>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <geq></geq>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma(2k)>3\uparrow^{k-2}3>A(k-2,k-2)\quad(k\geq 2),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Busy_beaver:6">
 <semantics>
  <mo>↑</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \uparrow
  </annotation>
 </semantics>
</math>

 is <a href="Knuth_up-arrow_notation" title="wikilink">Knuth up-arrow notation</a> and <em>A</em> is <a href="Ackermann's_function" title="wikilink">Ackermann's function</a>.</p>

<p>Thus</p>

<p>

<math display="block" id="Busy_beaver:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>10</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>3</mn>
   <mo>↑</mo>
   <mo>↑</mo>
   <mo>↑</mo>
   <mn>3</mn>
   <mo>=</mo>
   <mn>3</mn>
   <mo>↑</mo>
   <mo>↑</mo>
   <msup>
    <mn>3</mn>
    <msup>
     <mn>3</mn>
     <mn>3</mn>
    </msup>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>3</mn>
    <msup>
     <mn>3</mn>
     <msup>
      <mn>3</mn>
      <msup>
       <mo>.</mo>
       <msup>
        <mo>.</mo>
        <msup>
         <mo>.</mo>
         <mn>3</mn>
        </msup>
       </msup>
      </msup>
     </msup>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">10</cn>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">3</cn>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <cn type="integer">3</cn>
    <eq></eq>
    <cn type="integer">3</cn>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-.</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-.</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-.</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma(10)>3\uparrow\uparrow\uparrow 3=3\uparrow\uparrow 3^{3^{3}}=3^{3^{3^{.^%
{.^{.^{3}}}}}}
  </annotation>
 </semantics>
</math>

</p>

<p>(with 3<sup>27</sup> = 7,625,597,484,987 terms in the exponential tower), and</p>

<p>

<math display="block" id="Busy_beaver:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>12</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>3</mn>
   <mo>↑</mo>
   <mo>↑</mo>
   <mo>↑</mo>
   <mo>↑</mo>
   <mn>3</mn>
   <mo>=</mo>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">12</cn>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">3</cn>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <cn type="integer">3</cn>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma(12)>3\uparrow\uparrow\uparrow\uparrow 3=g_{1},
  </annotation>
 </semantics>
</math>

</p>

<p>where <a href="Graham's_number#Magnitude" title="wikilink">the number <em>g</em><sub>1</sub></a> is the enormous starting value in the sequence that defines <a href="Graham's_number" title="wikilink">Graham's number</a>.</p>

<p>In contrast, the current bound on Σ(6) is 10<sup>18267</sup>, which is greater than the lower bound 3<sup>3</sup>=27 (which is tiny in comparison). In fact, it is much greater than the lower bound 

<math display="block" id="Busy_beaver:9">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mo>↑</mo>
   <mo>↑</mo>
   <mn>3</mn>
   <mo>=</mo>
   <msup>
    <mn>3</mn>
    <msup>
     <mn>3</mn>
     <mn>3</mn>
    </msup>
   </msup>
   <mo>=</mo>
   <mn>7</mn>
   <mo>,</mo>
   <mn>625</mn>
   <mo>,</mo>
   <mn>597</mn>
   <mo>,</mo>
   <mn>484</mn>
   <mo>,</mo>
   <mn>987</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">3</cn>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <cn type="integer">3</cn>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <eq></eq>
    <cn type="integer">7</cn>
    <ci>normal-,</ci>
    <cn type="integer">625</cn>
    <ci>normal-,</ci>
    <cn type="integer">597</cn>
    <ci>normal-,</ci>
    <cn type="integer">484</cn>
    <ci>normal-,</ci>
    <cn type="integer">987</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3\uparrow\uparrow 3=3^{3^{3}}=7,625,597,484,987
  </annotation>
 </semantics>
</math>

, which is Green's bound for 

<math display="inline" id="Busy_beaver:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>8</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma(8)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="generalizations">Generalizations</h2>

<p>For any <a href="model_of_computation" title="wikilink">model of computation</a> there exist simple analogs of the busy beaver. For example, the generalization to Turing machines with n states and m symbols defines the following <strong>generalized busy beaver functions</strong>:</p>
<ol>
<li>Σ(<em>n</em>, <em>m</em>): the largest number of non-zeros printable by an <em>n</em>-state, <em>m</em>-symbol machine started on an initially blank tape before halting, and</li>
<li><em>S</em>(<em>n</em>, <em>m</em>): the largest number of steps taken by an <em>n</em>-state, <em>m</em>-symbol machine started on an initially blank tape before halting.</li>
</ol>

<p>For example the longest running 3-state 3-symbol machine found so far runs 119,112,334,170,342,540 steps before halting. The longest running 6-state, 2-symbol machine which has the additional property of reversing the tape value at each step produces 6,147 1s after 47,339,970 steps. So <em>S</em><sub>RTM</sub>(6) ≥ 47,339,970 and Σ<sub>RTM</sub>(6) ≥ 6,147.</p>

<p>It is possible to further generalize the busy beaver function by extending to more than one dimension.</p>

<p>Likewise we could define an analog to the Σ function for <a href="register_machine" title="wikilink">register machines</a> as the largest number which can be present in any register on halting, for a given number of instructions.</p>
<h2 id="applications">Applications</h2>

<p>In addition to posing a rather challenging <a href="mathematical_game" title="wikilink">mathematical game</a>, the busy beaver functions offer an entirely new approach to solving pure mathematics problems. Many <a href="open_problem_in_mathematics" title="wikilink">open problems in mathematics</a> could in theory, but not in practice, be solved in a systematic way given the value of <em>S</em>(<em>n</em>) for a sufficiently large <em>n</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Consider any <a class="uri" href="conjecture" title="wikilink">conjecture</a> that could be <a href="mathematical_proof" title="wikilink">disproven</a> via a <a class="uri" href="counterexample" title="wikilink">counterexample</a> among a <a class="uri" href="countable" title="wikilink">countable</a> number of cases (e.g. <a href="Goldbach's_conjecture" title="wikilink">Goldbach's conjecture</a>). Write a computer program that sequentially tests this conjecture for increasing values. In the case of Goldbach's conjecture, we would consider every even number ≥ 4 sequentially and test whether or not it is the sum of two prime numbers. Suppose this program is simulated on an <em>n</em>-state Turing machine. If it finds a counterexample (an even number ≥ 4 that is not the sum of 2 primes in our example), it halts and notifies us. However, if the conjecture is true, then our program will never halt. (This program halts <em>only</em> if it finds a counterexample.)</p>

<p>Now, this program is simulated by an <em>n</em>-state Turing machine, so if we know <em>S</em>(<em>n</em>) we can decide (in a finite amount of time) whether or not it will ever halt by simply running the machine that many steps. And if, after <em>S</em>(<em>n</em>) steps, the machine does not halt, we know that it never will and thus that there are no counterexamples to the given conjecture (i.e., no even numbers that are not the sum of two primes). This would prove the conjecture to be true.</p>

<p>Thus specific values (or upper bounds) for <em>S</em>(<em>n</em>) could be used to systematically solve many open problems in mathematics (in theory). However, current results on the busy beaver problem suggest that this will not be practical for two reasons:</p>
<ul>
<li>It is extremely hard to prove values for the busy beaver function (and the max shift function). It has only been proven for extremely small machines with fewer than 5 states, while one would presumably need at least 20-50 states to make a useful machine. Furthermore, every known exact value of <em>S</em>(<em>n</em>) was proven by enumerating every <em>n</em>-state Turing machine and proving whether or not each halts. One would have to calculate <em>S</em>(<em>n</em>) by some less direct method for it to actually be useful.</li>
<li>But even if one did find a better way to calculate <em>S</em>(<em>n</em>), the values of the busy beaver function (and max shift function) get very large, very fast. <em>S</em>(6) &gt; 10<sup>36534</sup> already requires special pattern-based acceleration to be able to simulate to completion. Likewise, we know that 

<math display="inline" id="Busy_beaver:11">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>10</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>10</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>3</mn>
   <mo>↑</mo>
   <mo>↑</mo>
   <mo>↑</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">10</cn>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <csymbol cd="unknown">Σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">10</cn>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">3</cn>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <ci>normal-↑</ci>
    <cn type="integer">3</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(10)>\Sigma(10)>3\uparrow\uparrow\uparrow 3
  </annotation>
 </semantics>
</math>

 is a gigantic number. Thus, even if we knew, say, <em>S</em>(30), it is completely unreasonable to run any machine that number of steps. There is not enough computational capacity in the known universe to have performed even <em>S</em>(6) operations directly.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ul>
<h2 id="proof-for-uncomputability-of-sn-and-σn">Proof for uncomputability of <em>S</em>(<em>n</em>) and Σ(<em>n</em>)</h2>

<p>Suppose that <em>S</em>(<em>n</em>) is a computable function and let <em>EvalS</em> denote a TM, evaluating <em>S</em>(<em>n</em>). Given a tape with <em>n</em> 1s it will produce <em>S</em>(<em>n</em>) 1s on the tape and then halt. Let <em>Clean</em> denote a Turing machine cleaning the sequence of 1s initially written on the tape. Let <em>Double</em> denote a Turing machine evaluating function <em>n</em> + <em>n</em>. Given a tape with <em>n</em> 1s it will produce 2<em>n</em> 1s on the tape and then halt. Let us create the composition <em>Double</em> | <em>EvalS</em> | <em>Clean</em> and let <em>n</em><sub>0</sub> be the number of states of this machine. Let <em>Create_n<sub>0</sub></em> denote a Turing machine creating <em>n</em><sub>0</sub> 1s on an initially blank tape. This machine may be constructed in a trivial manner to have <em>n</em><sub>0</sub> states (the state <em>i</em> writes 1, moves the head right and switches to state <em>i</em> + 1, except the state <em>n</em><sub>0</sub>, which halts). Let <em>N</em> denote the sum <em>n</em><sub>0</sub> + <em>n</em><sub>0</sub>.</p>

<p>Let <em>BadS</em> denote the composition <em>Create_n<sub>0</sub></em> | <em>Double</em> | <em>EvalS</em> | <em>Clean</em>. Notice that this machine has <em>N</em> states. Starting with an initially blank tape it first creates a sequence of <em>n</em><sub>0</sub> 1s and then doubles it, producing a sequence of <em>N</em> 1s. Then <em>BadS</em> will produce <em>S</em>(<em>N</em>) 1s on tape, and at last it will clear all 1s and then halt. But the phase of cleaning will continue at least <em>S</em>(<em>N</em>) steps, so the time of working of <em>BadS</em> is strictly greater than <em>S</em>(<em>N</em>), which contradicts to the definition of the function <em>S</em>(<em>n</em>).</p>

<p>The uncomputability of Σ(<em>n</em>) may be proved in a similar way. In the above proof, one must exchange the machine <em>EvalS</em> with <em>EvalΣ</em> and <em>Clean</em> with <em>Increment</em> - a simple TM, searching for a first 0 on the tape and replacing it with 1.</p>

<p>The uncomputability of <em>S</em>(<em>n</em>) can also be established by reference to the blank tape halting problem. The blank tape halting problem is the problem of deciding for any Turing machine whether or not it will halt when started on an empty tape. The blank tape halting problem is equivalent to the standard <a href="halting_problem" title="wikilink">halting problem</a> and so it is also uncomputable. If <em>S</em>(<em>n</em>) was computable, then we could solve the blank tape halting problem simply by running any given Turing machine with <em>n</em> states for <em>S</em>(<em>n</em>) steps; if it has still not halted, it never will. So, since the blank tape halting problem is not computable, it follows that <em>S</em>(<em>n</em>) must likewise be uncomputable.</p>
<h2 id="examples">Examples</h2>

<p>These are tables of rules for the Turing machines that generate Σ(1) and <em>S</em>(1), Σ(2) and <em>S</em>(2), Σ(3) (but not <em>S</em>(3)), Σ(4) and <em>S</em>(4), and the best known lower bound for Σ(5) and <em>S</em>(5), and Σ(6) and <em>S</em>(6).</p>

<p>In the tables, columns represent the current state and rows represent the current symbol read from the tape. Each table entry is a string of three characters, indicating the symbol to write onto the tape, the direction to move, and the new state (in that order). The Halt state is shown as <span style="color:blue"><strong>H</strong></span></p>

<p>.</p>

<p>Each machine begins in state A with an infinite tape that contains all 0s. Thus, the initial symbol read from the tape is a 0.</p>

<p>Result Key: (starts at the position <u>underlined</u>, halts at the position <strong>in bold</strong>)</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1-state, 2-symbol busy beaver</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1R<span style="color:blue"><strong>H</strong></span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>(not used)</p></td>
</tr>
</tbody>
</table>

<p><strong>Result:</strong> 0 0 <u>1</u> <strong>0</strong> 0 (1 step, one "1" total)</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>2-state, 2-symbol busy beaver</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>A</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1L<strong>B</strong></p></td>
<td style="text-align: left;">
<p>1R<span style="color:blue"><strong>H</strong></span></p></td>
</tr>
</tbody>
</table>

<p><strong>Result:</strong> 0 0 1 1 <strong><u>1</u></strong> 1 0 0 (6 steps, four "1"s total)</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>3-state, 2-symbol busy beaver</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>0R<strong>C</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>C</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1R<span style="color:blue"><strong>H</strong></span></p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>A</strong></p></td>
</tr>
</tbody>
</table>

<p><strong>Result:</strong> 0 0 1 <u>1</u> 1 <strong>1</strong> 1 1 0 0 (14 steps, six "1"s total).</p>

<p>Unlike the previous machines, this one is a busy beaver only for Σ, but not for S. (S(3) = 21.)</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>4-state, 2-symbol busy beaver</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>D</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>A</strong></p></td>
<td style="text-align: left;">
<p>1R<span style="color:blue"><strong>H</strong></span></p></td>
<td style="text-align: left;">
<p>1R<strong>D</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1L<strong>B</strong></p></td>
<td style="text-align: left;">
<p>0L<strong>C</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>D</strong></p></td>
<td style="text-align: left;">
<p>0R<strong>A</strong></p></td>
</tr>
</tbody>
</table>

<p><strong>Result:</strong> 0 0 1 <strong>0</strong> 1 1 1 1 1 1 1 1 <u>1</u> 1 1 1 0 0 (107 steps, thirteen "1"s total)</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>current 5-state, 2-symbol best contender (possible busy beaver)</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>E</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>C</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>D</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>A</strong></p></td>
<td style="text-align: left;">
<p>1R<span style="color:blue"><strong>H</strong></span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1L<strong>C</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>0L<strong>E</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>D</strong></p></td>
<td style="text-align: left;">
<p>0L<strong>A</strong></p></td>
</tr>
</tbody>
</table>

<p><strong>Result:</strong> 4098 "1"s with 8191 "0"s interspersed in 47,176,870 steps.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>current 6-state, 2-symbol best contender</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>E</p></td>
<td style="text-align: left;">
<p>F</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>C</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>D</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>E</strong></p></td>
<td style="text-align: left;">
<p>1L<strong>A</strong></p></td>
<td style="text-align: left;">
<p>1L<span style="color:blue"><strong>H</strong></span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1L<strong>E</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>F</strong></p></td>
<td style="text-align: left;">
<p>0R<strong>B</strong></p></td>
<td style="text-align: left;">
<p>0L<strong>C</strong></p></td>
<td style="text-align: left;">
<p>0R<strong>D</strong></p></td>
<td style="text-align: left;">
<p>1R<strong>C</strong></p></td>
</tr>
</tbody>
</table>

<p><strong>Result:</strong> ≈3.515 × 10<sup>18267</sup> "1"s in ≈7.412 × 10<sup>36534</sup> steps.</p>
<h2 id="exact-values-and-lower-bounds-for-some-sn-m-and-σn-m">Exact values and lower bounds for some <em>S</em>(<em>n</em>, <em>m</em>) and Σ(<em>n</em>, <em>m</em>)</h2>

<p>The following table lists the exact values and some known lower bounds for <em>S</em>(<em>n</em>, <em>m</em>) and Σ(<em>n</em>, <em>m</em>) for the generalized busy beaver problems. Known exact values are shown as plain integers and known lower bounds are preceded by a greater than or equal to (≥) symbol. Note: entries listed as "???" are bounded from below by the maximum of all entries to left and above. These machines either haven't been investigated or were subsequently surpassed by a machine preceding them.</p>

<p>The Turing machines that achieve these values are available on both <a href="http://www.drb.insel.de/~heiner/BB/">Heiner Marxen's</a> and <a href="http://www.logique.jussieu.fr/~michel/ha.html">Pascal Michel's</a> webpages. Each of these websites also contains some analysis of the Turing machines and references to the proofs of the exact values.</p>

<p><strong>Values of S(<em>n</em>,<em>m</em>)</strong>:</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>2-state</p></th>
<th style="text-align: left;">
<p>3-state</p></th>
<th style="text-align: left;">
<p>4-state</p></th>
<th style="text-align: left;">
<p>5-state</p></th>
<th style="text-align: left;">
<p>6-state</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>2-symbol</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>21</p></td>
<td style="text-align: left;">
<p>107</p></td>
<td style="text-align: left;">
<p>≥ 47,176,870</p></td>
<td style="text-align: left;">
<p>&gt; 7.4 × 10<sup>36534</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3-symbol</p></td>
<td style="text-align: left;">
<p>38</p></td>
<td style="text-align: left;">
<p>≥ 119,112,334,170,342,540</p></td>
<td style="text-align: left;">
<p>&gt; 1.0 × 10<sup>14072</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4-symbol</p></td>
<td style="text-align: left;">
<p>≥ 3,932,964</p></td>
<td style="text-align: left;">
<p>&gt; 5.2 × 10<sup>13036</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5-symbol</p></td>
<td style="text-align: left;">
<p>&gt; 1.9 × 10<sup>704</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6-symbol</p></td>
<td style="text-align: left;">
<p>&gt; 2.4 × 10<sup>9866</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p><strong>Values of Σ(<em>n</em>,<em>m</em>)</strong>:</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>2-state</p></th>
<th style="text-align: left;">
<p>3-state</p></th>
<th style="text-align: left;">
<p>4-state</p></th>
<th style="text-align: left;">
<p>5-state</p></th>
<th style="text-align: left;">
<p>6-state</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>2-symbol</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>≥ 4,098</p></td>
<td style="text-align: left;">
<p>&gt; 3.5 × 10<sup>18267</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3-symbol</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>≥ 374,676,383</p></td>
<td style="text-align: left;">
<p>&gt; 1.3 × 10<sup>7036</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4-symbol</p></td>
<td style="text-align: left;">
<p>≥ 2,050</p></td>
<td style="text-align: left;">
<p>&gt; 3.7 × 10<sup>6518</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5-symbol</p></td>
<td style="text-align: left;">
<p>&gt; 1.7 × 10<sup>352</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6-symbol</p></td>
<td style="text-align: left;">
<p>&gt; 1.9 × 10<sup>4933</sup></p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
<td style="text-align: left;">
<p>???</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Turmite" title="wikilink">Turmite</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>
<dl>
<dd>This is where Radó first defined the busy beaver problem and proved that it was uncomputable and grew faster than any computable function.
</dd>
</dl></li>
<li>
<dl>
<dd>The results of this paper had already appeared in part in Lin's 1963 doctoral dissertation, under Radó's guidance. Lin &amp; Radó prove that Σ(3) = 6 and S(3) = 21 by proving that all 3-state 2-symbol Turing Machines which don't halt within 21 steps will never halt. (Most are proven automatically by a computer program, however 40 are proven by human inspection.)
</dd>
</dl></li>
<li>
<dl>
<dd>Brady proves that Σ(4) = 13 and S(4) = 107. Brady defines two new categories for non-halting 3-state 2-symbol Turing Machines: Christmas Trees and Counters. He uses a computer program to prove that all but 27 machines which run over 107 steps are variants of Christmas Trees and Counters which can be proven to run infinitely. The last 27 machines (referred to as holdouts) are proven by personal inspection by Brady himself not to halt.
</dd>
</dl></li>
<li>
<dl>
<dd>Machlin and Stout describe the busy beaver problem and many techniques used for finding busy beavers (which they apply to Turing Machines with 4-states and 2-symbols, thus verifying Brady's proof). They suggest how to estimate a variant of Chaitin's halting probability (Ω).
</dd>
</dl></li>
<li>
<dl>
<dd>Marxen and Buntrock demonstrate that Σ(5) ≥ 4098 and S(5) ≥ 47,176,870 and describe in detail the method they used to find these machines and prove many others will never halt.
</dd>
</dl></li>
<li>
<dl>
<dd>Green recursively constructs machines for any number of states and provides the recursive function that computes their score (computes σ), thus providing a lower bound for Σ. This function's growth is comparable to that of <a href="Ackermann's_function" title="wikilink">Ackermann's function</a>.
</dd>
</dl></li>
<li>
<dl>
<dd>Busy beaver programs are described by <a href="Alexander_Dewdney" title="wikilink">Alexander Dewdney</a> in <em>Scientific American</em>, August 1984, pages 19–23, also March 1985 p. 23 and <a href="http://grail.cba.csuohio.edu/~somos/busy.html#dewd">April 1985 p. 30</a>.
</dd>
</dl></li>
<li></li>
<li>
<dl>
<dd>Wherein Brady (of 4-state fame) describes some history of the beast and calls its pursuit "The Busy Beaver Game". He describes other games (e.g. <a href="cellular_automata" title="wikilink">cellular automata</a> and <a href="Conway's_Game_of_Life" title="wikilink">Conway's Game of Life</a>). Of particular interest is "The Busy Beaver Game in Two Dimensions" (p. 247). With 19 references.
</dd>
</dl></li>
<li>
<dl>
<dd>Cf Chapter 9, Turing Machines. A difficult book, meant for electrical engineers and technical specialists. Discusses recursion, partial-recursion with reference to Turing Machines, halting problem. A reference in Booth attributes busy beaver to Rado. Booth also defines Rado's busy beaver problem in "home problems" 3, 4, 5, 6 of Chapter 9, p. 396. Problem 3 is to "show that the busy beaver problem is unsolvable... for all values of n."
</dd>
</dl></li>
<li>
<dl>
<dd>Bounds between functions Σ and <em>S</em>.
</dd>
</dl></li>
<li>
<dl>
<dd>Improved bounds.
</dd>
</dl></li>
<li>
<dl>
<dd>This article contains a complete classification of the 2-state, 3-symbol Turing machines, and thus a proof for the (2, 3) busy beaver: Σ(2, 3) = 9 and S(2, 3) = 38.
</dd>
</dl></li>
<li></li>
<li>
<dl>
<dd>This is the description of ideas, of the algorithms and their implementation, with the description of the experiments examining 5-state and 6-state Turing machines by parallel run on 31 4-core computer and finally the best results for 6-state TM. Written in Slovak.
</dd>
</dl></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>The page of <a href="http://www.drb.insel.de/~heiner/BB/">Heiner Marxen</a>, who, with Jürgen Buntrock, found the above-mentioned records for a 5 and 6-state Turing machine.</li>
<li>Pascal Michel's <a href="http://www.logique.jussieu.fr/~michel/ha.html">Historical survey</a> of busy beaver results which also contains best results and some analysis.</li>
<li>Definition of the class <a href="http://skelet.ludost.net/bb/RTM.htm">RTM</a> - Reversal Turing Machines, simple and strong subclass of the TMs.</li>
<li>The "<a href="http://www.cogsci.rpi.edu/~heuveb/research/BB/">Millennium Attack</a>" at the Rensselaer RAIR Lab on the busy beaver Problem. This effort found several new records and established several values for the quadruple formalization.</li>
<li>Daniel Briggs' <a href="http://web.mit.edu/~dbriggs/www/">website</a> and <a href="http://dbriggs.scripts.mit.edu/forum/index.php">forum</a> for solving the 5-state, 2-symbol busy beaver problem, based on <a href="http://skelet.ludost.net/bb/nreg.html">Skelet</a> (Georgi Georgiev) nonregular machines list.</li>
<li>Aaronson, Scott (1999), <em><a href="http://www.scottaaronson.com/writings/bignumbers.html">Who can name the biggest number?</a></em></li>
<li></li>
<li><em><a href="http://demonstrations.wolfram.com/BusyBeaver/">Busy Beaver</a></em> by Hector Zenil, <a href="Wolfram_Demonstrations_Project" title="wikilink">Wolfram Demonstrations Project</a>.</li>
<li><a href="https://www.youtube.com/watch?v=CE8UhcyJS0I">Busy Beaver Turing Machines - Computerphile</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Large_integers" title="wikilink">Category:Large integers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Chaitin 1987<a href="#fnref1">↩</a></li>
<li id="fn2">Lloyd 2001. <a href="http://arxiv.org/abs/quant-ph/0110141">Computational Capacity of the Universe</a>.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
