<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1316">Sprague–Grundy theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sprague–Grundy theorem</h1>
<hr/>

<p> In <a href="combinatorial_game_theory" title="wikilink">combinatorial game theory</a>, the <strong>Sprague–Grundy theorem</strong> states that every <a href="impartial_game" title="wikilink">impartial game</a> under the <a href="normal_play_convention" title="wikilink">normal play convention</a> is equivalent to a <a class="uri" href="nimber" title="wikilink">nimber</a>. The <strong>Grundy value</strong> or <strong>nim-value</strong> of an impartial game is then defined as the unique nimber that the game is equivalent to. In the case of a game whose positions (or summands of positions) are indexed by the natural numbers (for example the possible heap sizes in nim-like games), the sequence of nimbers for successive heap sizes is called the <strong>nim-sequence</strong> of the game.</p>

<p>The theorem and its proof encapsulate the main results of a theory discovered independently by <a href="Roland_Sprague" title="wikilink">R. P. Sprague</a> (1935) and <a href="Patrick_Michael_Grundy" title="wikilink">P. M. Grundy</a> (1939).<sup><a href="#CITEREFSmith1960" title="wikilink">[1</a>]</sup></p>
<h2 id="definitions">Definitions</h2>

<p>For the purposes of the Sprague–Grundy theorem, a <em>game</em> is a two-player game of <a href="perfect_information" title="wikilink">perfect information</a> satisfying the <em>ending condition</em> (all games come to an end: there are no infinite lines of play) and the <em>normal play condition</em> (a player who cannot move loses).</p>

<p>An <em><a href="impartial_game" title="wikilink">impartial game</a></em> is one such as <a class="uri" href="nim" title="wikilink">nim</a>, in which each player has exactly the same available moves as the other player in any position. Note that games such as <a class="uri" href="tic-tac-toe" title="wikilink">tic-tac-toe</a>, <a class="uri" href="checkers" title="wikilink">checkers</a>, and <a class="uri" href="chess" title="wikilink">chess</a> are <em>not</em> impartial games. In the case of checkers and chess, for example, players can only move their own pieces, not their opponent's pieces. And in tic-tac-toe, one player puts down X's, while the other puts down O's. Positions in impartial games fall into two <em>outcome classes</em>: either the next player (the one whose turn it is) wins (an <em>N-position</em>) or the previous player wins (a <em>P-position</em>).</p>

<p>In this proof, a position is identified with the set of positions that can be reached in one move (these positions are called <em>options</em>). For example, the position 

<math display="inline" id="Sprague–Grundy_theorem:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\}
  </annotation>
 </semantics>
</math>

 is a P-position under normal play, because the current player has no moves and therefore loses. The position 

<math display="inline" id="Sprague–Grundy_theorem:1">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <list></list>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\{\}\}
  </annotation>
 </semantics>
</math>

, in contrast, is an N-position; the current player has only one option, and that option is a losing position for their opponent.</p>

<p>A <em><a class="uri" href="nimber" title="wikilink">nimber</a></em> is a special position denoted 

<math display="inline" id="Sprague–Grundy_theorem:2">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *n
  </annotation>
 </semantics>
</math>

 for some <a href="Ordinal_number" title="wikilink">ordinal</a> 

<math display="inline" id="Sprague–Grundy_theorem:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


. 

<math display="inline" id="Sprague–Grundy_theorem:4">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *0
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Sprague–Grundy_theorem:5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\}
  </annotation>
 </semantics>
</math>

, the P-position given as an example earlier. The other nimbers are defined inductively by 

<math display="inline" id="Sprague–Grundy_theorem:6">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>*</mo>
   <mi>n</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>*</mo>
    <mi>n</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <times></times>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <times></times>
    <csymbol cd="unknown">n</csymbol>
    <union></union>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <times></times>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *(n+1)=*n\cup\{*n\}
  </annotation>
 </semantics>
</math>

; in particular, 

<math display="inline" id="Sprague–Grundy_theorem:7">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mn>1</mn>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>*</mo>
    <mn>0</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <times></times>
    <cn type="integer">1</cn>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <times></times>
     <cn type="integer">0</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *1=\{*0\}
  </annotation>
 </semantics>
</math>

 (the example N-position from above), 

<math display="inline" id="Sprague–Grundy_theorem:8">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mn>2</mn>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>*</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mo>*</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <times></times>
    <cn type="integer">2</cn>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <times></times>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *2=\{*0,*1\}
  </annotation>
 </semantics>
</math>


 (a choice between the two example positions), etc. 

<math display="inline" id="Sprague–Grundy_theorem:9">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *n
  </annotation>
 </semantics>
</math>

 therefore corresponds to a heap of 

<math display="inline" id="Sprague–Grundy_theorem:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 counters in the game of <a class="uri" href="nim" title="wikilink">nim</a>, hence the name.</p>

<p>Two positions 

<math display="inline" id="Sprague–Grundy_theorem:11">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sprague–Grundy_theorem:12">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 can be <em>added</em> to make a new position 

<math display="inline" id="Sprague–Grundy_theorem:13">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>


 in a combined game where the current player can choose either to move in 

<math display="inline" id="Sprague–Grundy_theorem:14">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 or in 

<math display="inline" id="Sprague–Grundy_theorem:15">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. Explicit computation of the set 

<math display="inline" id="Sprague–Grundy_theorem:16">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 is by repeated application of the rule 

<math display="inline" id="Sprague–Grundy_theorem:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>+</mo>
    <mi>H</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>G</mi>
      <mo>+</mo>
      <mi>h</mi>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mi>h</mi>
      <mo>∈</mo>
      <mi>H</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>g</mi>
      <mo>+</mo>
      <mi>H</mi>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mi>g</mi>
      <mo>∈</mo>
      <mi>G</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>G</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <plus></plus>
       <ci>G</ci>
       <ci>h</ci>
      </apply>
      <apply>
       <in></in>
       <ci>h</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <plus></plus>
       <ci>g</ci>
       <ci>H</ci>
      </apply>
      <apply>
       <in></in>
       <ci>g</ci>
       <ci>G</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H=\{G+h\mid h\in H\}\cup\{g+H\mid g\in G\}
  </annotation>
 </semantics>
</math>

, which incidentally indicates that position addition is both commutative and associative as expected.</p>

<p>Two positions 

<math display="inline" id="Sprague–Grundy_theorem:18">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Sprague–Grundy_theorem:19">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 are defined to be <em>equivalent</em> if for every position 

<math display="inline" id="Sprague–Grundy_theorem:20">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, the position 

<math display="inline" id="Sprague–Grundy_theorem:21">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 is in the same outcome class as 

<math display="inline" id="Sprague–Grundy_theorem:22">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}+H
  </annotation>
 </semantics>
</math>

. Such an equivalence is written 

<math display="inline" id="Sprague–Grundy_theorem:23">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="first-lemma">First Lemma</h2>

<p>As an intermediate step to proving the main theorem, we show that, for every position 

<math display="inline" id="Sprague–Grundy_theorem:24">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and every P-position 

<math display="inline" id="Sprague–Grundy_theorem:25">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the equivalence 

<math display="inline" id="Sprague–Grundy_theorem:26">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx A+G
  </annotation>
 </semantics>
</math>

 holds. By the above definition of equivalence, this amounts to showing that 

<math display="inline" id="Sprague–Grundy_theorem:27">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sprague–Grundy_theorem:28">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+G+H
  </annotation>
 </semantics>
</math>


 share an outcome class for all 

<math display="inline" id="Sprague–Grundy_theorem:29">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</p>

<p>Suppose that 

<math display="inline" id="Sprague–Grundy_theorem:30">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 is a P-position. Then the previous player has a winning strategy for 

<math display="inline" id="Sprague–Grundy_theorem:31">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+G+H
  </annotation>
 </semantics>
</math>

: respond to moves in 

<math display="inline" id="Sprague–Grundy_theorem:32">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 according to their winning strategy for 

<math display="inline" id="Sprague–Grundy_theorem:33">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 (which exists by virtue of 

<math display="inline" id="Sprague–Grundy_theorem:34">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 being a P-position), and respond to moves in 

<math display="inline" id="Sprague–Grundy_theorem:35">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 according to their winning strategy for 

<math display="inline" id="Sprague–Grundy_theorem:36">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 (which exists for analogous reason). So 

<math display="inline" id="Sprague–Grundy_theorem:37">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+G+H
  </annotation>
 </semantics>
</math>

 must also be a P-position.</p>

<p>On the other hand, if 

<math display="inline" id="Sprague–Grundy_theorem:38">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>


 is an N-position, then the next player has a winning strategy: choose a P-position from among the 

<math display="inline" id="Sprague–Grundy_theorem:39">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

 options, putting their opponent in the case above. Thus, in this case, 

<math display="inline" id="Sprague–Grundy_theorem:40">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+G+H
  </annotation>
 </semantics>
</math>

 must be a N-position, just like 

<math display="inline" id="Sprague–Grundy_theorem:41">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>

.</p>

<p>As these are the only two cases, the lemma holds.</p>
<h2 id="second-lemma">Second Lemma</h2>

<p>As a further step, we show that 

<math display="inline" id="Sprague–Grundy_theorem:42">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Sprague–Grundy_theorem:43">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+G^{\prime}
  </annotation>
 </semantics>
</math>


 is a P-position.</p>

<p>In the forward direction, suppose that 

<math display="inline" id="Sprague–Grundy_theorem:44">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>

. Applying the definition of equivalence with 

<math display="inline" id="Sprague–Grundy_theorem:45">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=G
  </annotation>
 </semantics>
</math>

, we find that 

<math display="inline" id="Sprague–Grundy_theorem:46">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}+G
  </annotation>
 </semantics>
</math>

 (which is equal to 

<math display="inline" id="Sprague–Grundy_theorem:47">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+G^{\prime}
  </annotation>
 </semantics>
</math>

 by <a class="uri" href="commutativity" title="wikilink">commutativity</a> of addition) is in the same outcome class as 

<math display="inline" id="Sprague–Grundy_theorem:48">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+G
  </annotation>
 </semantics>
</math>


. But 

<math display="inline" id="Sprague–Grundy_theorem:49">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+G
  </annotation>
 </semantics>
</math>

 must be a P-position: for every move made in one copy of 

<math display="inline" id="Sprague–Grundy_theorem:50">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, the previous player can respond with the same move in the other copy, and so always make the last move.</p>

<p>In the reverse direction, we apply the first lemma with 

<math display="inline" id="Sprague–Grundy_theorem:51">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mo>+</mo>
    <msup>
     <mi>G</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=G+G^{\prime}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sprague–Grundy_theorem:52">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to get 

<math display="inline" id="Sprague–Grundy_theorem:53">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <mrow>
    <mi>G</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mo>+</mo>
      <msup>
       <mi>G</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <plus></plus>
     <ci>G</ci>
     <apply>
      <plus></plus>
      <ci>G</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>G</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G+(G+G^{\prime})
  </annotation>
 </semantics>
</math>


 and with 

<math display="inline" id="Sprague–Grundy_theorem:54">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mo>+</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <ci>G</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=G+G
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sprague–Grundy_theorem:55">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 to deduce 

<math display="inline" id="Sprague–Grundy_theorem:56">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>≈</mo>
   <mrow>
    <msup>
     <mi>G</mi>
     <mo>′</mo>
    </msup>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mo>+</mo>
      <mi>G</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>G</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}\approx G^{\prime}+(G+G)
  </annotation>
 </semantics>
</math>

. By <a class="uri" href="associativity" title="wikilink">associativity</a> and commutativity, the right-hand sides of these results are equal. Furthermore, 

<math display="inline" id="Sprague–Grundy_theorem:57">
 <semantics>
  <mo>≈</mo>
  <annotation-xml encoding="MathML-Content">
   <approx></approx>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx
  </annotation>
 </semantics>
</math>

 is an <a href="equivalence_relation" title="wikilink">equivalence relation</a> because equality is an equivalence relation on outcome classes. Via the <a href="Transitive_relation" title="wikilink">transitivity</a> of 

<math display="inline" id="Sprague–Grundy_theorem:58">
 <semantics>
  <mo>≈</mo>
  <annotation-xml encoding="MathML-Content">
   <approx></approx>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx
  </annotation>
 </semantics>
</math>


, we can conclude that 

<math display="inline" id="Sprague–Grundy_theorem:59">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="proof">Proof</h2>

<p>We prove that all positions are equivalent to a nimber by <a href="structural_induction" title="wikilink">structural induction</a>. The more specific result, that the given game's initial position must be equivalent to a nimber, shows that the game is itself equivalent to a nimber.</p>

<p>Consider a position 

<math display="inline" id="Sprague–Grundy_theorem:60">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>G</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>G</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>k</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\{G_{1},G_{2},\ldots,G_{k}\}
  </annotation>
 </semantics>
</math>

. By the induction hypothesis, all of the options are equivalent to nimbers, say 

<math display="inline" id="Sprague–Grundy_theorem:61">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>i</mi>
   </msub>
   <mo>≈</mo>
   <mo>*</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>i</ci>
    </apply>
    <approx></approx>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i}\approx*n_{i}
  </annotation>
 </semantics>
</math>

. So let 

<math display="inline" id="Sprague–Grundy_theorem:62">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>*</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo>*</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mo>*</mo>
    <msub>
     <mi>n</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}=\{*n_{1},*n_{2},\ldots,*n_{k}\}
  </annotation>
 </semantics>
</math>

. We will show that 

<math display="inline" id="Sprague–Grundy_theorem:63">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <approx></approx>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx*m
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Sprague–Grundy_theorem:64">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the <a href="mex_(mathematics)" title="wikilink">mex (minimum exclusion)</a> of the numbers 

<math display="inline" id="Sprague–Grundy_theorem:65">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>n</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>n</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1},n_{2},\ldots,n_{k}
  </annotation>
 </semantics>
</math>

, that is, the smallest non-negative integer not equal to some 

<math display="inline" id="Sprague–Grundy_theorem:66">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>The first thing we need to note is that 

<math display="inline" id="Sprague–Grundy_theorem:67">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>

, by way of the second lemma. If 

<math display="inline" id="Sprague–Grundy_theorem:68">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 is zero, the claim is trivially true. Otherwise, consider 

<math display="inline" id="Sprague–Grundy_theorem:69">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+G^{\prime}
  </annotation>
 </semantics>
</math>

. If the next player makes a move to 

<math display="inline" id="Sprague–Grundy_theorem:70">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Sprague–Grundy_theorem:71">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, then the previous player can move to 

<math display="inline" id="Sprague–Grundy_theorem:72">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *n_{i}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Sprague–Grundy_theorem:73">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>


, and conversely if the next player makes a move in 

<math display="inline" id="Sprague–Grundy_theorem:74">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

. After this, the position is a P-position by the lemma's forward implication. Therefore, 

<math display="inline" id="Sprague–Grundy_theorem:75">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+G^{\prime}
  </annotation>
 </semantics>
</math>

 is a P-position, and, citing the lemma's reverse implication, 

<math display="inline" id="Sprague–Grundy_theorem:76">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>Now let us show that 

<math display="inline" id="Sprague–Grundy_theorem:77">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <plus></plus>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}+*m
  </annotation>
 </semantics>
</math>

 is a P-position, which, using the second lemma once again, means that 

<math display="inline" id="Sprague–Grundy_theorem:78">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>≈</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <approx></approx>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}\approx*m
  </annotation>
 </semantics>
</math>


. We do so by giving an explicit strategy for the previous player.</p>

<p>Suppose that 

<math display="inline" id="Sprague–Grundy_theorem:79">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sprague–Grundy_theorem:80">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m
  </annotation>
 </semantics>
</math>

 are empty. Then 

<math display="inline" id="Sprague–Grundy_theorem:81">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <plus></plus>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}+*m
  </annotation>
 </semantics>
</math>

 is the null set, clearly a P-position.</p>

<p>Or consider the case that the next player moves in the component 

<math display="inline" id="Sprague–Grundy_theorem:82">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m
  </annotation>
 </semantics>
</math>

 to the option 

<math display="inline" id="Sprague–Grundy_theorem:83">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <msup>
    <mi>m</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m^{\prime}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Sprague–Grundy_theorem:84">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 was the <em>minimum</em> excluded number, the previous player can move in 

<math display="inline" id="Sprague–Grundy_theorem:85">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <msup>
    <mi>m</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m^{\prime}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sprague–Grundy_theorem:86">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

. And, as shown before, any position plus itself is a P-position.</p>

<p>Finally, suppose instead that the next player moves in the component 

<math display="inline" id="Sprague–Grundy_theorem:87">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *n_{i}
  </annotation>
 </semantics>
</math>

 to the option 

<math display="inline" id="Sprague–Grundy_theorem:88">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
   <mo><</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}<m
  </annotation>
 </semantics>
</math>


. If 

<math display="inline" id="Sprague–Grundy_theorem:89">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m
  </annotation>
 </semantics>
</math>

 then the previous player moves in 

<math display="inline" id="Sprague–Grundy_theorem:90">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *n_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sprague–Grundy_theorem:91">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}>m
  </annotation>
 </semantics>
</math>

; otherwise, if 

<math display="inline" id="Sprague–Grundy_theorem:92">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *n_{i}
  </annotation>
 </semantics>
</math>

, the previous player moves in 

<math display="inline" id="Sprague–Grundy_theorem:93">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Sprague–Grundy_theorem:94">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}=m
  </annotation>
 </semantics>
</math>

; in either case the result is a position plus itself. (It is not possible that 

<math display="inline" id="Sprague–Grundy_theorem:95">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Sprague–Grundy_theorem:96">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}
  </annotation>
 </semantics>
</math>

 was defined to be different from all the 

<math display="inline" id="Sprague–Grundy_theorem:97">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx G^{\prime}
  </annotation>
 </semantics>
</math>

.)</p>

<p>In summary, we have 

<math display="inline" id="Sprague–Grundy_theorem:98">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>≈</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <approx></approx>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}\approx*m
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Sprague–Grundy_theorem:99">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <approx></approx>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx*m
  </annotation>
 </semantics>
</math>

. By transitivity, we conclude that 

<math display="inline" id="Sprague–Grundy_theorem:100">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, as desired.</p>
<h2 id="development">Development</h2>

<p>If 

<math display="inline" id="Sprague–Grundy_theorem:101">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is a position of an impartial game, the unique integer 

<math display="inline" id="Sprague–Grundy_theorem:102">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≈</mo>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <approx></approx>
    <times></times>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\approx*m
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Sprague–Grundy_theorem:103">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 is called its Grundy value, or Grundy number, and the function which assigns this value to each such position is called the Sprague–Grundy function. R.L.Sprague and P.M.Grundy independently gave an explicit definition of this function, not based on any concept of equivalence to nim positions, and showed that it had the following properties:</p>
<ul>
<li>The Grundy value of a single nim pile of size 

<math display="inline" id="Sprague–Grundy_theorem:104">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m
  </annotation>
 </semantics>
</math>

 (i.e. of the position 

<math display="inline" id="Sprague–Grundy_theorem:105">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

) is 

<math display="inline" id="Sprague–Grundy_theorem:106">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

;</li>
<li>A position is a loss for the next player to move (i.e. a P-position) if and only if its Grundy value is zero; and</li>
<li>The Grundy value of the sum of a finite set of positions is just the <a class="uri" href="nim-sum" title="wikilink">nim-sum</a> of the Grundy values of its summands.</li>
</ul>

<p>It follows straightforwardly from these results that if a position 

<math display="inline" id="Sprague–Grundy_theorem:107">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 has a Grundy value of 

<math display="inline" id="Sprague–Grundy_theorem:108">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>+</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>G</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G+H
  </annotation>
 </semantics>
</math>


, then 

<math display="inline" id="Sprague–Grundy_theorem:109">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *m+H
  </annotation>
 </semantics>
</math>

 has the same Grundy value as 

<math display="inline" id="Sprague–Grundy_theorem:110">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, and therefore belongs to the same outcome class, for any position <span class="LaTeX">$H$</span>. Thus, although Sprague and Grundy never explicitly stated the theorem described in this article, it is nevertheless an almost trivial consequence of their results. These results have subsequently been developed into the field of <a href="combinatorial_game_theory" title="wikilink">combinatorial game theory</a>, notably by <a href="Richard_K._Guy" title="wikilink">Richard Guy</a>, <a href="E._R._Berlekamp" title="wikilink">Elwyn Berlekamp</a>, <a href="John_Horton_Conway" title="wikilink">John Horton Conway</a> and others, where they are now encapsulated in the Sprague–Grundy theorem and its proof in the form described here. The field is presented in the books <em><a href="Winning_Ways_for_your_Mathematical_Plays" title="wikilink">Winning Ways for your Mathematical Plays</a></em> and <em><a href="On_Numbers_and_Games" title="wikilink">On Numbers and Games</a></em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Genus_theory" title="wikilink">Genus theory</a></li>
<li><a href="Indistinguishability_quotient" title="wikilink">Indistinguishability quotient</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>Reprinted, 1964, <strong>27</strong>: 9–11.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cut-the-knot.org/Curriculum/Games/Grundy.shtml">Grundy's game</a> at <a class="uri" href="cut-the-knot" title="wikilink">cut-the-knot</a></li>
<li><a href="http://www.math.ucla.edu/~tom/Game_Theory/comb.pdf">Easily readable, introductory account from the UCLA Math Department</a></li>
<li><a href="http://sputsoft.com/blog/2009/04/the-game-of-nim.html">The Game of Nim</a> at <a href="http://sputsoft.com">sputsoft.com</a></li>
</ul>

<p>"</p>

<p><a href="Category:Combinatorial_game_theory" title="wikilink">Category:Combinatorial game theory</a> <a href="Category:Theorems_in_discrete_mathematics" title="wikilink">Category:Theorems in discrete mathematics</a></p>
</body>
</html>
