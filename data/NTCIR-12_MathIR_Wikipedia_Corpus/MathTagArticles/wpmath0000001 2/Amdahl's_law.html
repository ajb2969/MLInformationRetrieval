<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="58">Amdahl's law</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Amdahl's law</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The speedup of a program using multiple processors in parallel computing is limited by the sequential fraction of the program. For example, if 95% of the program can be parallelized, the theoretical maximum speedup using parallel computing would be 20× as shown in the diagram.</figcaption>
</figure>

<p><strong>Amdahl's law</strong>, also known as <strong>Amdahl's argument</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is used to find the maximum expected improvement to an overall system when only part of the system is improved. It is often used in <a href="parallel_computing" title="wikilink">parallel computing</a> to predict the theoretical maximum <a class="uri" href="speedup" title="wikilink">speedup</a> using multiple processors. The law is named after <a href="Computer_architecture" title="wikilink">computer architect</a> <a href="Gene_Amdahl" title="wikilink">Gene Amdahl</a>, and was presented at the <a href="American_Federation_of_Information_Processing_Societies" title="wikilink">AFIPS</a> Spring Joint Computer Conference in 1967.</p>

<p>The speedup of a program using multiple processors in parallel computing is limited by the time needed for the sequential fraction of the program. For example, if a program needs 20 hours using a single processor core, and a particular portion of the program which takes one hour to execute cannot be parallelized, while the remaining 19 hours (95%) of execution time can be parallelized, then regardless of how many processors are devoted to a parallelized execution of this program, the minimum execution time cannot be less than that critical one hour. Hence, the theoretical speedup is limited to at most 20×.</p>
<h2 id="definition">Definition</h2>

<p>Given:</p>
<ul>
<li>

<math display="inline" id="Amdahl's_law:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

, the number of <a href="thread_of_execution" title="wikilink">threads of execution</a>,</li>
<li>

<math display="inline" id="Amdahl's_law:1">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>B</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\in[0,1]
  </annotation>
 </semantics>
</math>

, the fraction of the algorithm that is strictly serial,</li>
</ul>

<p>The time 

<math display="inline" id="Amdahl's_law:2">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\left(n\right)
  </annotation>
 </semantics>
</math>

 an algorithm takes to finish when being executed on 

<math display="inline" id="Amdahl's_law:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 thread(s) of execution corresponds to:</p>

<p>

<math display="inline" id="Amdahl's_law:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>B</mi>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>n</mi>
       </mfrac>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>B</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=T(1)\left(B+\frac{1}{n}\left(1-B\right)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the theoretical speedup 

<math display="inline" id="Amdahl's_law:5">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)
  </annotation>
 </semantics>
</math>

 that can be had by executing a given algorithm on a system capable of executing 

<math display="inline" id="Amdahl's_law:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 threads of execution is:</p>

<p>

<math display="inline" id="Amdahl's_law:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo>(</mo>
      <mn>1</mn>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo>(</mo>
      <mi>n</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo>(</mo>
      <mn>1</mn>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo>(</mo>
      <mn>1</mn>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>B</mi>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>B</mi>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>B</mi>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>n</mi>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>B</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <ci>B</ci>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>B</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <ci>B</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(n)=\frac{T\left(1\right)}{T\left(n\right)}=\frac{T\left(1\right)}{T\left(1%
\right)\left(B+\frac{1}{n}\left(1-B\right)\right)}=\frac{1}{B+\frac{1}{n}\left%
(1-B\right)}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="description">Description</h2>

<p>Amdahl's law is a model for the expected speedup and the relationship between parallelized implementations of an algorithm and its sequential implementations, under the assumption that the problem size remains the same when parallelized. For example, if for a given problem size a parallelized implementation of an algorithm can run 12% of the algorithm's operations arbitrarily quickly (while the remaining 88% of the operations are not parallelizable), Amdahl's law states that the maximum speedup of the parallelized version is  times as fast as the non-parallelized implementation.</p>

<p>More technically, the law is concerned with the speedup achievable from an improvement to a computation that affects a proportion <em>P</em> of that computation where the improvement has a speedup of <em>S</em>. (For example, if 30% of the computation may be the subject of a speed up, <em>P</em> will be 0.3; if the improvement makes the portion affected twice as fast, <em>S</em> will be 2.) Amdahl's law states that the overall speedup of applying the improvement will be:</p>

<p>

<math display="block" id="Amdahl's_law:8">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mi>P</mi>
      <mi>S</mi>
     </mfrac>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mn>0.3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mn>0.3</mn>
      <mn>2</mn>
     </mfrac>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1.1765</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>P</ci>
       </apply>
       <apply>
        <divide></divide>
        <ci>P</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <cn type="float">0.3</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="float">0.3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.1765</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{(1-P)+\frac{P}{S}}=\frac{1}{(1-0.3)+\frac{0.3}{2}}=1.1765
  </annotation>
 </semantics>
</math>

</p>

<p>To see how this formula was derived, assume that the running time of the old computation was 1, for some unit of time. The running time of the new computation will be the length of time the unimproved fraction takes (which is 1 − <em>P</em>), plus the length of time the improved fraction takes. The length of time for the improved part of the computation is the length of the improved part's former running time divided by the speedup, making the length of time of the improved part <em>P</em>/<em>S</em>. The final speedup is computed by dividing the old running time by the new running time, which is what the above formula does.</p>

<p>Here's another example. We are given a sequential task which is split into four consecutive parts: P1, P2, P3 and P4 with the percentages of runtime being 11%, 18%, 23% and 48% respectively. Then we are told that P1 is not sped up, so S1 = 1, while P2 is sped up 5×, P3 is sped up 20×, and P4 is sped up 1.6×. By using the formula P1/S1 + P2/S2 + P3/S3 + P4/S4, we find the new sequential running time is:</p>

<p>

<math display="block" id="Amdahl's_law:9">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>0.11</mn>
     <mn>1</mn>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mn>0.18</mn>
     <mn>5</mn>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mn>0.23</mn>
     <mn>20</mn>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mn>0.48</mn>
     <mn>1.6</mn>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0.4575.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="float">0.11</cn>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="float">0.18</cn>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="float">0.23</cn>
      <cn type="integer">20</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="float">0.48</cn>
      <cn type="float">1.6</cn>
     </apply>
    </apply>
    <cn type="float">0.4575.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{0.11}{1}+\frac{0.18}{5}+\frac{0.23}{20}+\frac{0.48}{1.6}=0.4575.
  </annotation>
 </semantics>
</math>

</p>

<p>or a little less than 

<math display="inline" id="Amdahl's_law:10">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1}/{2}
  </annotation>
 </semantics>
</math>

 the original running time. Using the formula <mtpl></mtpl>, the overall speed boost is 1 / 0.4575 = 2.186, or a little more than double the original speed. Notice how the 20× and 5× speedup don't have much effect on the overall speed when P1 (11%) is not sped up, and P4 (48%) is sped up only 1.6 times.</p>
<h2 id="parallelization">Parallelization</h2>

<p>In the case of parallelization, Amdahl's law states that if <em>P</em> is the proportion of a program that can be made parallel (i.e., benefit from parallelization), and (1 − <em>P</em>) is the proportion that cannot be parallelized (remains serial), then the maximum speedup that can be achieved by using <em>N</em> processors is</p>

<p>

<math display="block" id="Amdahl's_law:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mi>P</mi>
      <mi>N</mi>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>P</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>P</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(N)=\frac{1}{(1-P)+\frac{P}{N}}
  </annotation>
 </semantics>
</math>

.</p>

<p>In the limit, as <em>N</em> tends to <a href="Extended_real_number_line" title="wikilink">infinity</a>, the maximum speedup tends to 1 / (1 − <em>P</em>). In practice, performance to price ratio falls rapidly as <em>N</em> is increased once there is even a small component of (1 − <em>P</em>).</p>

<p>As an example, if <em>P</em> is 90%, then (1 − <em>P</em>) is 10%, and the problem can be sped up by a maximum of a factor of 10, no matter how large the value of <em>N</em> used. For this reason, parallel computing is only useful for either small numbers of <a href="central_processing_unit" title="wikilink">processors</a>, or problems with very high values of <em>P</em>: so-called <a href="embarrassingly_parallel" title="wikilink">embarrassingly parallel</a> problems. A great part of the craft of <a href="parallel_programming" title="wikilink">parallel programming</a> consists of attempting to reduce the component (1 – <em>P</em>) to the smallest possible value.</p>

<p><em>P</em> can be estimated by using the measured speedup (<em>SU</em>) on a specific number of processors (<em>NP</em>) using</p>

<p>

<math display="block" id="Amdahl's_law:12">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mtext>estimated</mtext>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>S</mi>
       <mi>U</mi>
      </mrow>
     </mfrac>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>N</mi>
       <mi>P</mi>
      </mrow>
     </mfrac>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <mtext>estimated</mtext>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>U</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\text{estimated}}=\frac{\frac{1}{SU}-1}{\frac{1}{NP}-1}
  </annotation>
 </semantics>
</math>

.</p>

<p><em>P</em> estimated in this way can then be used in Amdahl's law to predict speedup for a different number of processors.</p>
<h2 id="relation-to-law-of-diminishing-returns">Relation to law of diminishing returns</h2>

<p>Amdahl's law is often conflated with the <a href="Diminishing_returns" title="wikilink">law of diminishing returns</a>, whereas only a special case of applying Amdahl's law demonstrates 'law of diminishing returns'. If one picks optimally (in terms of the achieved speed-up) what to improve, then one will see monotonically decreasing improvements as one improves. If, however, one picks non-optimally, after improving a sub-optimal component and moving on to improve a more optimal component, one can see an increase in return. Note that it is often rational to improve a system in an order that is "non-optimal" in this sense, given that some improvements are more difficult or consuming of development time than others.</p>

<p>Amdahl's law does represent the law of diminishing returns if you are considering what sort of return you get by adding more processors to a machine, if you are running a fixed-size computation that will use all available processors to their capacity. Each new processor you add to the system will add less usable power than the previous one. Each time you double the number of processors the speedup ratio will diminish, as the total throughput heads toward the limit of 

<math display="inline" id="Amdahl's_law:13">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>1</mn>
     </mpadded>
     <mo rspace="4.2pt">-</mo>
     <mi>P</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1/(1\,-\,P)
  </annotation>
 </semantics>
</math>

.</p>

<p>This analysis neglects other potential bottlenecks such as <a href="memory_bandwidth" title="wikilink">memory bandwidth</a> and I/O bandwidth, if they do not scale with the number of processors; however, taking into account such bottlenecks would tend to further demonstrate the diminishing returns of only adding processors.</p>
<h2 id="speedup-in-a-sequential-program">Speedup in a sequential program</h2>

<p> The maximum speedup in an improved sequential program, where some part was sped up 

<math display="inline" id="Amdahl's_law:14">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 times is limited by inequality</p>

<p>

<math display="block" id="Amdahl's_law:15">
 <semantics>
  <mrow>
   <mtext>maximum speedup</mtext>
   <mo>≤</mo>
   <mfrac>
    <mi>p</mi>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>f</mi>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <mtext>maximum speedup</mtext>
    <apply>
     <divide></divide>
     <ci>p</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-⋅</ci>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{maximum speedup }\leq\frac{p}{1+f\cdot(p-1)}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Amdahl's_law:16">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Amdahl's_law:17">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mn>0</mn>
   </mpadded>
   <mo rspace="5.3pt"><</mo>
   <mpadded width="+2.8pt">
    <mi>f</mi>
   </mpadded>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>f</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="float">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 0\;<\;f\;<\;1
  </annotation>
 </semantics>
</math>

) is the fraction of time (before the improvement) spent in the part that was not improved. For example (see picture on right):</p>
<ul>
<li>If part B is made five times faster (

<math display="inline" id="Amdahl's_law:18">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>p</mi>
   </mpadded>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="float">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle p\;=\;5
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Amdahl's_law:19">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi>t</mi>
     <mi>A</mi>
    </msub>
   </mpadded>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>A</ci>
    </apply>
    <cn type="float">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle t_{A}\;=\;3
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Amdahl's_law:20">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi>t</mi>
     <mi>B</mi>
    </msub>
   </mpadded>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>B</ci>
    </apply>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle t_{B}\;=\;1
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Amdahl's_law:21">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>f</mi>
   </mpadded>
   <mo rspace="5.3pt">=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>A</mi>
    </msub>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>t</mi>
        <mi>A</mi>
       </msub>
      </mpadded>
      <mo rspace="4.2pt">+</mo>
      <msub>
       <mi>t</mi>
       <mi>B</mi>
      </msub>
     </mrow>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.75</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.75</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f\;=\;t_{A}/(t_{A}\,+\,t_{B})\;=\;0.75
  </annotation>
 </semantics>
</math>

, then

<p>

<math display="block" id="Amdahl's_law:22">
 <semantics>
  <mrow>
   <mtext>maximum speedup</mtext>
   <mo>≤</mo>
   <mfrac>
    <mn>5</mn>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mn>0.75</mn>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>5</mn>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1.25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <mtext>maximum speedup</mtext>
     <apply>
      <divide></divide>
      <cn type="integer">5</cn>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="float">0.75</cn>
        <apply>
         <minus></minus>
         <cn type="integer">5</cn>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.25</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{maximum speedup }\leq\frac{5}{1+0.75\cdot(5-1)}=1.25
  </annotation>
 </semantics>
</math>

</p></li>
<li>If part A is made to run twice as fast (

<math display="inline" id="Amdahl's_law:23">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>p</mi>
   </mpadded>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="float">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle p\;=\;2
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Amdahl's_law:24">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi>t</mi>
     <mi>B</mi>
    </msub>
   </mpadded>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>B</ci>
    </apply>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle t_{B}\;=\;1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Amdahl's_law:25">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi>t</mi>
     <mi>A</mi>
    </msub>
   </mpadded>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>A</ci>
    </apply>
    <cn type="float">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle t_{A}\;=\;3
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Amdahl's_law:26">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>f</mi>
   </mpadded>
   <mo rspace="5.3pt">=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>B</mi>
    </msub>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>t</mi>
        <mi>A</mi>
       </msub>
      </mpadded>
      <mo rspace="4.2pt">+</mo>
      <msub>
       <mi>t</mi>
       <mi>B</mi>
      </msub>
     </mrow>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.25</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f\;=\;t_{B}/(t_{A}\,+\,t_{B})\;=\;0.25
  </annotation>
 </semantics>
</math>

, then

<p>

<math display="block" id="Amdahl's_law:27">
 <semantics>
  <mrow>
   <mtext>maximum speedup</mtext>
   <mo>≤</mo>
   <mfrac>
    <mn>2</mn>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mn>0.25</mn>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1.60</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <mtext>maximum speedup</mtext>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="float">0.25</cn>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.60</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{maximum speedup }\leq\frac{2}{1+0.25\cdot(2-1)}=1.60
  </annotation>
 </semantics>
</math>

</p></li>
</ul>

<p>Therefore, making A twice as fast is better than making B five times faster. The percentage improvement in speed can be calculated as</p>

<p>

<math display="block" id="Amdahl's_law:28">
 <semantics>
  <mrow>
   <mtext>percentage improvement</mtext>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mtext>speedup factor</mtext>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>⋅</mo>
    <mn>100</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>percentage improvement</mtext>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <mtext>speedup factor</mtext>
      </apply>
     </apply>
     <cn type="integer">100</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{percentage improvement}=\left(1-\frac{1}{\text{speedup factor}}\right)%
\cdot 100
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Improving part A by a factor of two will increase overall program speed by a factor of 1.6, which makes it 37.5% faster than the original computation.</li>
<li>However, improving part B by a factor of five, which presumably requires more effort, will only achieve an overall speedup factor of 1.25, which makes it 20% faster.</li>
</ul>
<h2 id="limitations">Limitations</h2>

<p>Amdahl's law only applies to cases where the problem size is fixed. In practice, as more computing resources become available, they tend to get used on larger problems (larger datasets), and the time spent in the parallelizable part often grows much faster than the inherently sequential work. In this case, <a href="Gustafson's_law" title="wikilink">Gustafson's law</a> gives a more realistic assessment of parallel performance.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Critical_path_method" title="wikilink">Critical path method</a></li>
<li><a href="Karp–Flatt_metric" title="wikilink">Karp–Flatt metric</a></li>
<li><a href="Moore's_law" title="wikilink">Moore's law</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.futurechips.org/thoughts-for-researchers/parallel-programming-gene-amdahl-said.html">Cases where Amdahl's law is inapplicable</a></li>
<li><a href="http://purl.umn.edu/104341">Oral history interview with Gene M. Amdahl</a> <a href="Charles_Babbage_Institute" title="wikilink">Charles Babbage Institute</a>, University of Minnesota. Amdahl discusses his graduate work at the University of Wisconsin and his design of <a href="Wisconsin_Integrally_Synchronized_Computer" title="wikilink">WISC</a>. Discusses his role in the design of several computers for IBM including the <a href="IBM_Stretch" title="wikilink">STRETCH</a>, <a href="IBM_701" title="wikilink">IBM 701</a>, and <a href="IBM_704" title="wikilink">IBM 704</a>. He discusses his work with <a href="Nathaniel_Rochester_(computer_scientist)" title="wikilink">Nathaniel Rochester</a> and IBM's management of the design process. Mentions work with <a href="TRW_Inc." title="wikilink">Ramo-Wooldridge</a>, <a class="uri" href="Aeronutronic" title="wikilink">Aeronutronic</a>, and <a href="Computer_Sciences_Corporation" title="wikilink">Computer Sciences Corporation</a></li>
<li><a href="http://www.julianbrowne.com/article/viewer/amdahls-law">A simple interactive Amdahl's Law calculator</a></li>
<li><a href="http://demonstrations.wolfram.com/AmdahlsLaw/">"Amdahl's Law"</a> by Joel F. Klein, <a href="Wolfram_Demonstrations_Project" title="wikilink">Wolfram Demonstrations Project</a>, 2007.</li>
<li><a href="http://www.cs.wisc.edu/multifacet/amdahl/">Amdahl's Law in the Multicore Era</a></li>
<li><a href="http://www.cilk.com/multicore-blog/bid/5365/What-the-is-Parallelism-Anyhow">Blog Post: "What the $#@! is Parallelism, Anyhow?"</a></li>
<li><a href="http://www.multicorepacketprocessing.com/how-should-amdahl-law-drive-the-redesigns-of-socket-system-calls-for-an-os-on-a-multicore-cpu">Amdahl's Law applied to OS system calls on multicore CPU</a></li>
<li><a href="https://www.cs.sfu.ca/~fedorova/papers/TurboBoostEvaluation.pdf">Evaluation of the Intel Core i7 Turbo Boost feature</a>, by James Charles, Preet Jassi, Ananth Narayan S, Abbas Sadat and Alexandra Fedorova</li>
<li><a href="http://www.researchgate.net/publication/228569958_Calculation_of_the_acceleration_of_parallel_programs_as_a_function_of_the_number_of_threads">Calculation of the acceleration of parallel programs as a function of the number of threads</a>, by George Popov, Valeri Mladenov and Nikos Mastorakis</li>
<li><a href="http://myarm.com/blog-measure-and-visualize-parallelism.html">Blog: measurement and visualization of parallelism</a>, by Stefan Ruppert</li>
</ul>

<p>"</p>

<p><a href="Category:Analysis_of_parallel_algorithms" title="wikilink">Category:Analysis of parallel algorithms</a> <a href="Category:Programming_rules_of_thumb" title="wikilink">Category:Programming rules of thumb</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
