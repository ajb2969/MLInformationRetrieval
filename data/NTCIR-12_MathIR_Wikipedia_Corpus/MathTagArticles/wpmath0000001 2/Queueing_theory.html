<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1618">Queueing theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Queueing theory</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption><a href="Queueing_theory#Queueing_networks" title="wikilink">Queue networks</a> are systems in which single queues are connected by a routing network. In this image servers are represented by circles, queues by a series of retangles and the routing network by arrows. In the study of queue networks one typically tries to obtain the <a href="equilibrium_distribution" title="wikilink">equilibrium distribution</a> of the network, although in many applications the study of the <a href="transient_state" title="wikilink">transient state</a> is fundamental.</figcaption>
</figure>

<p><strong>Queueing theory</strong> is the mathematical study of waiting lines, or <a href="wikt:queue" title="wikilink">queues</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In queueing theory a model is constructed so that queue lengths and waiting time can be predicted.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Queueing theory is generally considered a branch of <a href="operations_research" title="wikilink">operations research</a> because the results are often used when making business decisions about the resources needed to provide a service.</p>

<p>Queueing theory has its origins in research by <a href="Agner_Krarup_Erlang" title="wikilink">Agner Krarup Erlang</a> when he created models to describe the Copenhagen telephone exchange.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The ideas have since seen applications including <a class="uri" href="telecommunication" title="wikilink">telecommunication</a>, <a href="Traffic_engineering_(transportation)" title="wikilink">traffic engineering</a>, <a class="uri" href="computing" title="wikilink">computing</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and the design of factories, shops, offices and hospitals.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="single-queueing-nodes">Single queueing nodes</h2>

<p>Single queueing nodes are usually described using <a href="Kendall's_notation" title="wikilink">Kendall's notation</a> in the form <em>A</em>/<em>S</em>/<em>C</em> where <em>A</em> describes the time between arrivals to the queue, <em>S</em> the size of jobs and <em>C</em> the number of servers at the node.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Many theorems in queueing theory can be proved by reducing queues to mathematical systems known as <a href="Markov_chain" title="wikilink">Markov chains</a>, first described by <a href="Andrey_Markov" title="wikilink">Andrey Markov</a> in his 1906 paper.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p><a href="Agner_Krarup_Erlang" title="wikilink">Agner Krarup Erlang</a>, a <a href="Denmark" title="wikilink">Danish</a> engineer who worked for the Copenhagen Telephone Exchange, published the first paper on what would now be called queueing theory in 1909.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> He modeled the number of telephone calls arriving at an exchange by a <a href="Poisson_process" title="wikilink">Poisson process</a> and solved the <a href="M/D/1_queue" title="wikilink">M/D/1 queue</a> in 1917 and <a href="M/D/k_queue" title="wikilink">M/D/k queueing</a> model in 1920.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In Kendall's notation:</p>
<ul>
<li>M stands for Markov or memoryless and means arrivals occur according to a <a href="Poisson_process" title="wikilink">Poisson process</a></li>
<li>D stands for deterministic and means jobs arriving at the queue require a fixed amount of service</li>
<li><em>k</em> describes the number of servers at the queueing node (<em>k</em> = 1, 2,...). If there are more jobs at the node than there are servers then jobs will queue and wait for service</li>
</ul>

<p>The <a href="M/M/1_queue" title="wikilink">M/M/1 queue</a> is a simple model where a single server serves jobs that arrive according to a Poisson process and have <a href="exponentially_distributed" title="wikilink">exponentially distributed</a> service requirements. In an <a href="M/G/1_queue" title="wikilink">M/G/1 queue</a> the G stands for general and indicates an arbitrary <a href="probability_distribution" title="wikilink">probability distribution</a>. The M/G/1 model was solved by <a href="Felix_Pollaczek" title="wikilink">Felix Pollaczek</a> in 1930,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> a solution later recast in probabilistic terms by <a href="Aleksandr_Khinchin" title="wikilink">Aleksandr Khinchin</a> and now known as the <a href="Pollaczek–Khinchine_formula" title="wikilink">Pollaczek–Khinchine formula</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>After <a href="World_War_II" title="wikilink">World War II</a> queueing theory became an area of research interest to mathematicians.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> In 1953 <a href="David_George_Kendall" title="wikilink">David Kendall</a> solved the GI/M/k queue<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> and introduced the modern notation for queues, now known as <a href="Kendall's_notation" title="wikilink">Kendall's notation</a>. In 1957 Pollaczek studied the GI/G/1 using an <a href="integral_equation" title="wikilink">integral equation</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> <a href="John_Kingman" title="wikilink">John Kingman</a> gave a formula for the <a href="Mean_sojourn_time" title="wikilink">mean waiting time</a> in a <a href="G/G/1_queue" title="wikilink">G/G/1 queue</a>: <a href="Kingman's_formula" title="wikilink">Kingman's formula</a>.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>The <a href="matrix_geometric_method" title="wikilink">matrix geometric method</a> and <a href="matrix_analytic_method" title="wikilink">matrix analytic methods</a> have allowed queues with <a href="phase-type_distribution" title="wikilink">phase-type distributed</a> inter-arrival and service time distributions to be considered.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>Problems such as performance metrics for the <a href="M/G/k_queue" title="wikilink">M/G/k queue</a> remain an open problem.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="service-disciplines">Service disciplines</h2>

<p>Various scheduling policies can be used at queuing nodes:</p>
<dl>
<dt><a href="FIFO_(computing_and_electronics)" title="wikilink">First in first out</a> :This principle states that customers are served one at a time and that the customer that has been waiting the longest is served first.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><br/>
<a href="LIFO_(computing)" title="wikilink">Last in first out</a> :This principle also serves customers one at a time, but the customer with the shortest <a href="Mean_sojourn_time" title="wikilink">waiting time</a> will be served first.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Also known as a <a href="Stack_(data_structure)" title="wikilink">stack</a>.<br/>
<a href="Processor_sharing" title="wikilink">Processor sharing</a> :Service capacity is shared equally between customers.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><br/>
Priority :Customers with high priority are served first.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Priority queues can be of two types, non-preemptive (where a job in service cannot be interrupted) and preemptive (where a job in service can be interrupted by a higher priority job). No work is lost in either model.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><br/>
<a href="Shortest_job_first" title="wikilink">Shortest job first</a> : The next job to be served is the one with the smallest size<br/>
Preemptive shortest job first : The next job to be served is the one with the original smallest size<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><br/>
<a href="Shortest_remaining_processing_time" title="wikilink">Shortest remaining processing time</a> : The next job to serve is the one with the smallest remaining processing requirement.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></dt>
</dl>
<dl>
<dt>Service facility :</dt>
</dl>
<ul>
<li>Single server:customers line up and there is only one server</li>
<li>Parallel servers:customers line up and there are several servers</li>
<li>Tandem queue:there are many counters and customers can decide going where to queue</li>
</ul>
<dl>
<dt>Customer’s behavior of waiting:</dt>
</dl>
<ul>
<li>Balking:customers deciding not to join the queue if it is too long</li>
<li>Jockeying:customers switch between queues if they think they will get served faster by so doing</li>
<li>Reneging:customers leave the queue if they have waited too long for service</li>
</ul>
<h2 id="queueing-networks">Queueing networks</h2>

<p>Networks of queues are systems in which a number of queues are connected by customer routing. When a customer is serviced at one node it can join another node and queue for service, or leave the network. For a network of <em>m</em> the state of the system can be described by an <em>m</em>–dimensional vector (<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,...,<em>x</em><sub><em>m</em></sub>) where <em>x</em><sub><em>i</em></sub> represents the number of customers at each node.</p>

<p>The first significant results in this area were <a href="Jackson_network" title="wikilink">Jackson networks</a>,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> for which an efficient <a href="product-form_stationary_distribution" title="wikilink">product-form stationary distribution</a> exists and the <a href="mean_value_analysis" title="wikilink">mean value analysis</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> which allows average metrics such as throughput and sojourn times to be computed.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> If the total number of customers in the network remains constant the network is called a closed network and has also been shown to have a product–form stationary distribution in the <a href="Gordon–Newell_theorem" title="wikilink">Gordon–Newell theorem</a>.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> This result was extended to the <a href="BCMP_network" title="wikilink">BCMP network</a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> where a network with very general service time, regimes and customer routing is shown to also exhibit a product-form stationary distribution. The <a href="normalizing_constant" title="wikilink">normalizing constant</a> can be calculated with the <a href="Buzen's_algorithm" title="wikilink">Buzen's algorithm</a>, proposed in 1973.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Networks of customers have also been investigated, <a href="Kelly_network" title="wikilink">Kelly networks</a> where customers of different classes experience different priority levels at different service nodes.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> Another type of network are <a class="uri" href="G-networks" title="wikilink">G-networks</a> first proposed by <a href="Erol_Gelenbe" title="wikilink">Erol Gelenbe</a> in 1993:<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> these networks do not assume exponential time distributions like the classic Jackson Network.</p>
<h3 id="example-of-mm1">Example of M/M/1</h3>
<dl>
<dt>Birth and Death process</dt>
</dl>
<ul>
<li>A/B/C</li>
</ul>
<figure><b>(Figure)</b>
<figcaption>Birth and Death process.</figcaption>
</figure>
<dl>
<dd><dl>
<dd>A:distribution of arrival time
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>B:distribution of service time
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>C:the number of parallel servers
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>A system of inter-arrival time and service time showed exponential distribution, we denoted M.
</dd>
</dl>
<dl>
<dd><dl>
<dd>λ：the average arrival rate
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>µ：the average service rate of a single service
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>P : the probability of n customers in system
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>n :the number of people in system
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Let E represent the number of times of entering state n, and L represent the number of times of leaving state n. We have 

<math display="inline" id="Queueing_theory:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>E</mi>
     <mo>-</mo>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>E</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E-L|\in\{0,1\}
  </annotation>
 </semantics>
</math>

. When the system arrives at steady state, which means t, we have, therefore arrival rate=removed rate.</li>
</ul>
<ul>
<li>Balance equation</li>
</ul>
<dl>
<dd><dl>
<dd>situation 0

<math display="block" id="Queueing_theory:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>P</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{1}P_{1}=\lambda_{0}P_{0}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>situation 1

<math display="block" id="Queueing_theory:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mi>P</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>μ</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{0}P_{0}+\mu_{2}P_{2}=(\lambda_{1}+\mu_{1})P_{1}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>situation n

<math display="block" id="Queueing_theory:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>n</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>μ</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>P</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n-1}P_{n-1}+\mu_{n+1}P_{n+1}=(\lambda_{n}+\mu_{n})P_{n}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>By balance equation, <math>P_1=\frac{\lambda_0}{\mu_1}P_0\;\;\;P_2=\frac{\lambda_1}{\mu_2}P_1+\frac{1}{\mu_2}(\mu_1P_1-\lambda_0P_0)=\frac{\lambda_1}{\mu_2}P_1=\frac{\lambda_1\lambda_0}{\mu_2\mu_1}P_0
</math></dd>
</dl>
</dd>
</dl>

<p></p>
<dl>
<dd><dl>
<dd>By mathematical induction, <math>
</math></dd>
</dl>
</dd>
</dl>

<p>P_n=\frac{\lambda_{n-1}\lambda_{n-2}\cdots\lambda_0}{\mu_n\mu_{n-1}\cdots\mu_1}P_0=P_0\prod_{i=0}^{n-1}\frac{\lambda_i}{\mu_{i+1}} </p>
<dl>
<dd><dl>
<dd>Because <math>
</math></dd>
</dl>
</dd>
</dl>

<p>\sum_{n=0}^{\infty}P_n=P_0+P_0\sum_{n=1}^{\infty}\prod_{i=0}^ {n-1}\frac{\lambda_i}{\mu_{i+1}}=1 </p>
<dl>
<dd><dl>
<dd>we get <math>
</math></dd>
</dl>
</dd>
</dl>

<p>P_0=\frac{1}{1+\sum_{n=1}^{\infty}\prod_{i=0}^ {n-1}\frac{\lambda_i}{\mu_{i+1}}} </p>
<h3 id="routing-algorithms">Routing algorithms</h3>

<p>In discrete time networks where there is a constraint on which service nodes can be active at any time, the <a href="max-weight_scheduling" title="wikilink">max-weight scheduling</a> algorithm chooses a service policy to give optimal throughput in the case that each job visits only a single service node. In the more general case where jobs can visit more than one node, <a href="backpressure_routing" title="wikilink">backpressure routing</a> gives optimal throughput.</p>

<p>A <a href="network_scheduler" title="wikilink">network scheduler</a> must choose a queuing algorithm, which affects the characteristics of the larger network.</p>
<h2 id="mean-field-limits">Mean field limits</h2>

<p><a href="Mean_field_model" title="wikilink">Mean field models</a> consider the limiting behaviour of the <a href="empirical_measure" title="wikilink">empirical measure</a> (proportion of queues in different states) as the number of queues (<em>m</em> above) goes to infinity. The impact of other queues on any given queue in the network is approximated by a differential equation. The deterministic model converges to the same stationary distribution as the original model.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="fluid-limits">Fluid limits</h2>

<p>Fluid models are continuous deterministic analogs of queueing networks obtained by taking the limit when the process is scaled in time and space, allowing heterogeneous objects. This scaled trajectory converges to a deterministic equation which allows us stability of the system to be proven. It is known that a queueing network can be stable, but have an unstable fluid limit.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>
<h2 id="heavy-trafficdiffusion-approximations">Heavy traffic/diffusion approximations</h2>

<p>In a system with high occupancy rates (utilisation near 1) a heavy traffic approximation can be used to approximate the queueing length process by a <a href="reflected_Brownian_motion" title="wikilink">reflected Brownian motion</a>,<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> <a href="Ornstein–Uhlenbeck_process" title="wikilink">Ornstein–Uhlenbeck process</a> or more general <a href="diffusion_process" title="wikilink">diffusion process</a>.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> The number of dimensions of the RBM is equal to the number of queueing nodes and the diffusion is restricted to the non-negative <a class="uri" href="orthant" title="wikilink">orthant</a>.</p>
<h2 id="software-for-simulationanalysis">Software for simulation/analysis</h2>
<ul>
<li><a href="http://jmt.sourceforge.net">Java Modelling Tools</a>, a GPL suite of queueing theory tools written in <a href="Java_(programming_language)" title="wikilink">Java</a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></li>
<li><a href="http://octave.sourceforge.net/queueing/index.html">Queueing Package for GNU Octave</a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Ehrenfest_model" title="wikilink">Ehrenfest model</a></li>
<li><a href="Erlang_unit" title="wikilink">Erlang unit</a></li>
<li><a href="Industrial_engineering" title="wikilink">Industrial engineering</a></li>
<li><a href="Network_simulation" title="wikilink">Network simulation</a></li>
<li><a href="Queue_area" title="wikilink">Queue area</a></li>
<li><a href="Queueing_delay" title="wikilink">Queueing delay</a></li>
<li><a href="Queueing_Systems" title="wikilink">Queueing Systems</a> (a journal of queueing theory)</li>
<li><a href="Random_early_detection" title="wikilink">Random early detection</a></li>
<li><a href="Renewal_theory" title="wikilink">Renewal theory</a></li>
<li><a class="uri" href="Throughput" title="wikilink">Throughput</a></li>
<li><a href="Scheduling_(computing)" title="wikilink">Scheduling (computing)</a></li>
<li><a href="Traffic_jam" title="wikilink">Traffic jam</a></li>
<li><a href="Traffic_generation_model" title="wikilink">Traffic generation model</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p><a href="http://books.google.com.br/books/about/Fundamentals_of_Queueing_Theory.html?id=K3lQGeCtAJgC">Online</a></p></li>
<li>

<p>chap.15, pp. 380–412</p></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.supositorio.com/rcalc/rcalclite.htm">Queueing theory calculator</a></li>
<li><a href="http://people.revoledu.com/kardi/tutorial/Queuing/index.html">Teknomo's Queueing theory tutorial and calculators</a></li>
<li><a href="http://www.netlab.tkk.fi/opetus/s383143/kalvot/english.shtml">Virtamo's Queueing Theory Course</a></li>
<li><a href="http://web2.uwindsor.ca/math/hlynka/queue.html">Myron Hlynka's Queueing Theory Page</a></li>
<li><a href="http://www.eventhelix.com/RealtimeMantra/CongestionControl/queueing_theory.htm">Queueing Theory Basics</a></li>
<li><a href="http://queueing-systems.ens-lyon.fr/">A free online tool to solve some classical queueing systems</a></li>
</ul>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Production_and_manufacturing" title="wikilink">Category:Production and manufacturing</a> <a href="Category:Services_management_and_marketing" title="wikilink">Category:Services management and marketing</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Formal_sciences" title="wikilink">Category:Formal sciences</a> <a href="Category:Queueing_theory" title="wikilink">*</a> <a href="Category:Rationing_and_licensing" title="wikilink">Category:Rationing and licensing</a> <a href="Category:Network_performance" title="wikilink">Category:Network performance</a> <a href="Category:Markov_models" title="wikilink">Category:Markov models</a> <a href="Category:Markov_processes" title="wikilink">Category:Markov processes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Tijms, H.C, ''Algorithmic Analysis of Queues", Chapter 9 in A First Course in Stochastic Models, Wiley, Chichester, 2003<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">A.A. Markov, Extension of the law of large numbers to dependent quantities, Izvestiia Fiz.-Matem. Obsch. Kazan Univ., (2nd Ser.), 15(1906), pp. 135–156 [Also [37], pp. 339–361].<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">Pollaczek, F., Ueber eine Aufgabe der Wahrscheinlichkeitstheorie, Math. Z. 1930<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">Kendall, D.G.:Stochastic processes occurring in the theory of queues and their analysis by the method of the imbedded Markov chain, Ann. Math. Stat. 1953<a href="#fnref17">↩</a></li>
<li id="fn18">Pollaczek, F., Problèmes Stochastiques posés par le phénomène de formation d'une queue<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22">Penttinen A., <em>Chapter 8 – Queueing Systems</em>, Lecture Notes: S-38.145 - Introduction to Teletraffic Theory.<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
</ol>
</section>
</body>
</html>
