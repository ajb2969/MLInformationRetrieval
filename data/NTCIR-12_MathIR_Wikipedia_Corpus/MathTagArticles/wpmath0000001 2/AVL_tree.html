<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="50">AVL tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>AVL tree</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Example AVL tree</figcaption>
</figure>

<p>In <a href="computer_science" title="wikilink">computer science</a>, an <strong>AVL tree</strong> (Georgy Adelson-Velsky and Evgenii Landis' tree, named after the inventors) is a <a href="self-balancing_binary_search_tree" title="wikilink">self-balancing binary search tree</a>. It was the first such <a href="data_structure" title="wikilink">data structure</a> to be invented.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In an AVL tree, the <a href="tree_height" title="wikilink">heights</a> of the two <a href="child_node" title="wikilink">child</a> subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Lookup, insertion, and deletion all take <a href="big_O_notation" title="wikilink">O</a>(log <em>n</em>) time in both the average and worst cases, where <em>n</em> is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more <a href="tree_rotation" title="wikilink">tree rotations</a>.</p>

<p>The AVL tree is named after its two <a href="Soviet_Union" title="wikilink">Soviet</a> inventors, <a href="Georgy_Adelson-Velsky" title="wikilink">Georgy Adelson-Velsky</a> and <a href="Evgenii_Landis" title="wikilink">Evgenii Landis</a>, who published it in their 1962 paper "An algorithm for the organization of information".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>AVL trees are often compared with <a href="red-black_tree" title="wikilink">red-black trees</a> because both support the same set of operations and take <a href="big_O_notation" title="wikilink">O</a>(log <em>n</em>) time for the basic operations. For lookup-intensive applications, AVL trees are faster than red-black trees because they are more rigidly balanced.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Similar to red-black trees, AVL trees are height-balanced. Both are in general not <a href="Weight-balanced_tree" title="wikilink">weight-balanced</a> nor μ-balanced for any 

<math display="inline" id="AVL_tree:0">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>μ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mu\leq\tfrac{1}{2}
  </annotation>
 </semantics>
</math>

;<ref><a href="http://cs.stackexchange.com/questions/421/avl-trees-are-not-weight-balanced">AVL trees are not weight-balanced? (meaning: AVL trees are not μ-balanced?)</a><br/>
Thereby: A Binary Tree is called 

<math display="inline" id="AVL_tree:1">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

-balanced, with 

<math display="inline" id="AVL_tree:2">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>μ</mi>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>μ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\mu\leq\tfrac{1}{2}
  </annotation>
 </semantics>
</math>

, if for every node 

<math display="inline" id="AVL_tree:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, the inequality</ref></p>

<p>

<math display="block" id="AVL_tree:4">
 <semantics>
  <mrow>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mo>-</mo>
    <mi>μ</mi>
   </mrow>
   <mo>≤</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>N</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>N</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mfrac>
   </mstyle>
   <mo>≤</mo>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mo>+</mo>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>μ</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <abs></abs>
        <ci>N</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>μ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{2}-\mu\leq\tfrac{|N_{l}|}{|N|+1}\leq\tfrac{1}{2}+\mu
  </annotation>
 </semantics>
</math>

 holds and 

<math display="inline" id="AVL_tree:5">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is minimal with this property. 

<math display="inline" id="AVL_tree:6">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>N</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |N|
  </annotation>
 </semantics>
</math>

 is the number of nodes below the tree with 

<math display="inline" id="AVL_tree:7">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 as root (including the root) and 

<math display="inline" id="AVL_tree:8">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{l}
  </annotation>
 </semantics>
</math>

 is the left child node of 

<math display="inline" id="AVL_tree:9">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. that is, sibling nodes can have hugely differing numbers of descendants.</p>
<h2 id="operations">Operations</h2>

<p> Basic operations of an AVL tree involve carrying out the same actions as would be carried out on an unbalanced <a href="binary_search_tree" title="wikilink">binary search tree</a>, but modifications are followed by zero or more operations called <a href="tree_rotation" title="wikilink">tree rotations</a>, which help to restore the height balance of the subtrees.</p>
<h3 id="searching">Searching</h3>

<p>Searching for a specific key in an AVL tree can be done the same way as that of a normal unbalanced <a href="Binary_search_tree#Searching" title="wikilink">binary search tree</a>.</p>
<h3 id="traversal">Traversal</h3>

<p>Once a node has been found in a balanced tree, the <em>next</em> or <em>previous</em> nodes can be explored in <a href="amortized_complexity" title="wikilink">amortized</a> constant time. Some instances of exploring these "nearby" nodes require traversing up to log(<em>n</em>) links (particularly when moving from the rightmost leaf of the root's left subtree to the root or from the root to the leftmost leaf of the root's right subtree; in the example AVL tree, moving from node 14 to the <em>next but one</em> node 19 takes 4 steps). However, exploring all <em>n</em> nodes of the tree in this manner would use each link exactly twice: one traversal to enter the subtree rooted at that node, another to leave that node's subtree after having explored it. And since there are <em>n</em>−1 links in any tree, the amortized cost is found to be 2×(<em>n</em>−1)/<em>n</em>, or approximately 2.</p>
<h3 id="insertion">Insertion</h3>

<p>After inserting a node, it is necessary to check each of the node's ancestors for consistency with the <a href="Invariant_(computer_science)" title="wikilink">invariants</a> of AVL trees: this is called "retracing". This is achieved by considering the <strong>balance factor</strong> of each node, which is defined as follows:</p>

<p><code>balanceFactor = height(left subtree) - height(right subtree)</code></p>
<figure><b>(Figure)</b>
<figcaption>Pictorial description of how rotations rebalance a node in AVL tree. The numbered circles represent the nodes being rebalanced. The lettered triangles represent subtrees which are themselves balanced AVL trees. A blue number next to a node denotes possible balance factors (those in parentheses occurring only in case of deletion).</figcaption>
</figure>

<p>Thus the balance factor of any node of an AVL tree is in the integer range [-1,+1]. This <em>balance factor is stored in the node</em>, but may have to be corrected after an insertion or a deletion, which is also done during retracing. Since with a single insertion the height of an AVL subtree cannot increase by more than one, the temporarily recomputed balance factor of a node after an insertion will be in the range [−2,+2]. For each node checked, if the recomputed balance factor remains in the range from −1 to +1 then only corrections of the balance factor, but no rotations are necessary. However, if the recomputed balance factor becomes less than −1 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.</p>
<dl>
<dt>Description of the Rotations</dt>
</dl>

<p>Let us first assume the balance factor of a node P is 2 (as opposed to the other possible unbalanced value −2). This case is depicted in the left column of the illustration with P:=<strong>5</strong>. We then look at the left subtree (the higher one) with root N. If this subtree does not lean to the right - i.e. N has balance factor 1 (or, when deletion also 0) - we can rotate the whole tree to the right to get a balanced tree. This is labelled as the "Left Left Case" in the illustration with N:=<strong>4</strong>. If the subtree does lean to the right - i.e. N:=<strong>3</strong> has balance factor −1 - we first rotate the subtree to the left and end up the previous case. This second case is labelled as "Left Right Case" in the illustration.</p>

<p>If the balance factor of the node P is −2 (this case is depicted in the right column of the illustration P:=<strong>3</strong>) we can mirror the above algorithm. I.e. if the root N of the (higher) right subtree has balance factor −1 (or, when deletion also 0) we can rotate the whole tree to the left to get a balanced tree. This is labelled as the "Right Right Case" in the illustration with N:=<strong>4</strong>. If the root N:=<strong>5</strong> of the right subtree has balance factor 1 ("Right Left Case") we can rotate the subtree to the right to end up in the "Right Right Case".</p>

<p>The whole retracing loop for an insertion looks like this:</p>
<div class="sourceCode"><pre class="sourceCode d"><code class="sourceCode d"> <span class="co">// N is the child of P whose height increases by 1.</span>
 <span class="kw">do</span> {
   <span class="kw">if</span> (N == left_child(P)) {
     <span class="kw">if</span> (balance_factor(P) == <span class="dv">1</span>) { <span class="co">// The left column in the picture</span>
       <span class="co">// Temporary balance_factor(P) == 2 ==&gt; rebalancing is required.</span>
       <span class="kw">if</span> (balance_factor(N) == -<span class="dv">1</span>) { <span class="co">// Left Right Case</span>
          rotate_left(N); <span class="co">// Reduce to Left Left Case</span>
       }
       <span class="co">// Left Left Case</span>
       rotate_right(P);
       <span class="kw">break</span>; <span class="co">// Leave the loop</span>
     }
     <span class="kw">if</span> (balance_factor(P) == -<span class="dv">1</span>) {
       balance_factor(P) = <span class="dv">0</span>; <span class="co">// N’s height increase is absorbed at P.</span>
       <span class="kw">break</span>; <span class="co">// Leave the loop</span>
     }
     balance_factor(P) = <span class="dv">1</span>; <span class="co">// Height increases at P</span>
   } <span class="kw">else</span> { <span class="co">// N == right_child(P), the child whose height increases by 1.</span>
     <span class="kw">if</span> (balance_factor(P) == -<span class="dv">1</span>) { <span class="co">// The right column in the picture</span>
       <span class="co">// Temporary balance_factor(P) == -2 ==&gt; rebalancing is required.</span>
       <span class="kw">if</span> (balance_factor(N) == <span class="dv">1</span>) { <span class="co">// Right Left Case</span>
          rotate_right(N); <span class="co">// Reduce to Right Right Case</span>
       }
       <span class="co">// Right Right Case</span>
       rotate_left(P);
       <span class="kw">break</span>; <span class="co">// Leave the loop</span>
     }
     <span class="kw">if</span> (balance_factor(P) == <span class="dv">1</span>) {
       balance_factor(P) = <span class="dv">0</span>; <span class="co">// N’s height increase is absorbed at P.</span>
       <span class="kw">break</span>; <span class="co">// Leave the loop</span>
     }
     balance_factor(P) = -<span class="dv">1</span>; <span class="co">// Height increases at P</span>
   }
   N = P;
   P = parent(N);
 } <span class="kw">while</span> (P != <span class="kw">null</span>); <span class="co">// Possibly up to the root</span></code></pre></div>

<p>After a rotation a subtree has the same height as before, so retracing can stop. In order to restore the balance factors of all nodes, first observe that all nodes requiring correction lie along the path used during the initial insertion. If the above procedure is applied to nodes along this path, starting from the bottom (i.e. the inserted node), then every node in the tree will again have a balance factor of −1, 0, or 1.</p>

<p>The time required is 

<math display="inline" id="AVL_tree:10">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 for lookup, plus a maximum of 

<math display="inline" id="AVL_tree:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 retracing levels on the way back to the root, so the operation can be completed in 

<math display="inline" id="AVL_tree:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 time.</p>
<h3 id="deletion">Deletion</h3>

<p>Let node X be the node with the value we need to delete, and let node Y be a node in the tree we need to find to take node X's place, and let node Z be the actual node we take out of the tree.</p>

<p> Steps to consider when deleting a node in an AVL tree are the following:</p>
<ol>
<li>If node X is a leaf or has only one child, skip to step 5 with Z:=X.</li>
<li>Otherwise, determine node Y by finding the largest node in node X's left subtree (the in-order predecessor of X − it does not have a right child) or the smallest in its right subtree (the in-order successor of X − it does not have a left child).</li>
<li>Exchange all the child and parent links of node X with those of node Y. In this step, the in-order sequence between nodes X and Y is temporarily disturbed, but the tree structure doesn't change.</li>
<li>Choose node Z to be all the child and parent links of old node Y = those of new node X.</li>
<li>If node Z has a subtree (which then is a leaf), attach it to Z's parent.</li>
<li>If node Z was the root (its parent is null), update root.</li>
<li>Delete node Z.</li>
<li>Retrace the path back up the tree (starting with node Z's parent) to the root, adjusting the balance factors as needed.</li>
</ol>

<p>Since with a single deletion the height of an AVL subtree cannot decrease by more than one, the temporary balance factor of a node will be in the range from −2 to +2.</p>

<p>If the balance factor becomes ±2 then the subtree is unbalanced and needs to be rotated. The various cases of rotations are depicted in section <a href="#rotation_descr" title="wikilink">"Insertion"</a>.</p>

<p>The whole retracing loop for a deletion looks like this:</p>
<div class="sourceCode"><pre class="sourceCode d"><code class="sourceCode d"> <span class="co">// N is the child of P whose height decreases by 1.</span>
 <span class="kw">do</span> {
   <span class="kw">if</span> (N == right_child(P)) {
     <span class="kw">if</span> (balance_factor(P) == <span class="dv">1</span>) { <span class="co">// The left column in the picture</span>
       <span class="co">// Temporary balance_factor(P) == 2 ==&gt; rebalancing is required.</span>
       S = left_child(P); <span class="co">// Sibling of N</span>
       B = balance_factor(S);
       <span class="kw">if</span> (B == -<span class="dv">1</span>) { <span class="co">// Left Right Case</span>
          rotate_left(S); <span class="co">// Reduce to Left Left Case</span>
       }
       <span class="co">// Left Left Case</span>
       rotate_right(P);
       <span class="kw">if</span> (B == <span class="dv">0</span>) <span class="co">// (in the picture the small blue (0) at node 4)</span>
         <span class="kw">break</span>; <span class="co">// Height does not change: Leave the loop</span>
     }
     <span class="kw">if</span> (balance_factor(P) == <span class="dv">0</span>) {
       balance_factor(P) = <span class="dv">1</span>; <span class="co">// N’s height decrease is absorbed at P.</span>
       <span class="kw">break</span>; <span class="co">// Leave the loop</span>
     }
     balance_factor(P) = <span class="dv">0</span>; <span class="co">// Height decreases at P</span>
   } <span class="kw">else</span> { <span class="co">// N == left_child(P), the child whose height decreases by 1.</span>
     <span class="kw">if</span> (balance_factor(P) == -<span class="dv">1</span>) { <span class="co">// The right column in the picture</span>
       <span class="co">// Temporary balance_factor(P) == -2 ==&gt; rebalancing is required.</span>
       S = right_child(P); <span class="co">// Sibling of N</span>
       B = balance_factor(S);
       <span class="kw">if</span> (B == <span class="dv">1</span>) { <span class="co">// Right Left Case</span>
          rotate_right(S); <span class="co">// Reduce to Right Right Case</span>
       }
       <span class="co">// Right Right Case</span>
       rotate_left(P);
       <span class="kw">if</span> (B == <span class="dv">0</span>) <span class="co">// (in the picture the small blue (0) at node 4)</span>
         <span class="kw">break</span>; <span class="co">// Height does not change: Leave the loop</span>
     }
     <span class="kw">if</span> (balance_factor(P) == <span class="dv">0</span>) {
       balance_factor(P) = -<span class="dv">1</span>; <span class="co">// N’s height decrease is absorbed at P.</span>
       <span class="kw">break</span>; <span class="co">// Leave the loop</span>
     }
     balance_factor(P) = <span class="dv">0</span>; <span class="co">// Height decreases at P</span>
   }
   N = P;
   P = parent(N);
 } <span class="kw">while</span> (P != <span class="kw">null</span>); <span class="co">// Possibly up to the root</span></code></pre></div>

<p>The retracing can stop if the balance factor becomes ±1 indicating that the height of that subtree has remained unchanged. This can also result from a rotation when the higher child tree has a balance factor of 0.</p>

<p>If the balance factor becomes 0 then the height of the subtree has decreased by one and the retracing needs to continue. This can also result from a rotation.</p>

<p>The time required is 

<math display="inline" id="AVL_tree:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 for lookup, plus a maximum of 

<math display="inline" id="AVL_tree:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 retracing levels on the way back to the root, so the operation can be completed in 

<math display="inline" id="AVL_tree:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 time.</p>
<h2 id="comparison-to-other-structures">Comparison to other structures</h2>

<p>Both AVL trees and red-black trees are self-balancing binary search trees and they are very similar mathematically.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The operations to balance the trees are different, but both occur on the average in O(1) with maximum in O(log <em>n</em>). The real difference between the two is the limiting height. For a tree of size 

<math display="inline" id="AVL_tree:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>An AVL tree's height is strictly less than:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>

<p>

<math display="block" id="AVL_tree:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>log</mi>
      <mi>φ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msqrt>
        <mn>5</mn>
       </msqrt>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msqrt>
         <mn>5</mn>
        </msqrt>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>φ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>φ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msqrt>
         <mn>5</mn>
        </msqrt>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mn>1.44</mn>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>0.328</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>φ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <root></root>
         <cn type="integer">5</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <root></root>
          <cn type="integer">5</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <ci>φ</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>φ</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <root></root>
          <cn type="integer">5</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="float">1.44</cn>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <cn type="float">0.328</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{\varphi}(\sqrt{5}(n+2))-2={\log_{2}(\sqrt{5}(n+2))\over\log_{2}(\varphi)%
}-2=\log_{\varphi}(2)\cdot\log_{2}(\sqrt{5}(n+2))-2\approx 1.44\log_{2}(n+2)-0%
.328
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where 

<math display="inline" id="AVL_tree:18">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the <a href="golden_ratio" title="wikilink">golden ratio</a>.
</dd>
</dl></li>
<li>A red-black tree's height is at most 

<math display="inline" id="AVL_tree:19">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\log_{2}(n+1)
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>

<p>AVL trees are more rigidly balanced than red-black trees, leading to slower insertion and removal but faster retrieval.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="tree_data_structure" title="wikilink">Trees</a></li>
<li><a href="Tree_rotation" title="wikilink">Tree rotation</a></li>
<li><a href="Red-black_tree" title="wikilink">Red-black tree</a></li>
<li><a href="Splay_tree" title="wikilink">Splay tree</a></li>
<li><a href="Scapegoat_tree" title="wikilink">Scapegoat tree</a></li>
<li><a class="uri" href="B-tree" title="wikilink">B-tree</a></li>
<li><a class="uri" href="T-tree" title="wikilink">T-tree</a></li>
<li><a href="List_of_data_structures" title="wikilink">List of data structures</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em>The Art of Computer Programming</em>, Volume 3: <em>Sorting and Searching</em>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Pages 458–475 of section 6.2.3: Balanced Trees.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="https://github.com/vilkov/libxdg/wiki">xdg library</a> by Dmitriy Vilkov: Serializable straight C-implementation could easily be taken from this library under <a href="GNU_Lesser_General_Public_License" title="wikilink">GNU-LGPL</a> and <a href="Academic_Free_License" title="wikilink">AFL v2.0</a> licenses.</li>
<li><a href="http://www.nist.gov/dads/HTML/avltree.html">Description from the Dictionary of Algorithms and Data Structures</a></li>
<li><a href="http://github.com/pgrafov/python-avl-tree/">Python Implementation</a></li>
<li><a href="http://piumarta.com/software/tree/">Single C header file by Ian Piumarta</a></li>
<li><a href="http://www.strille.net/works/media_technology_projects/avl-tree_2001/">AVL Tree Demonstration</a></li>
<li><a href="http://www.qmatica.com/DataStructures/Trees/AVL/AVLTree.html">AVL tree applet – all operations</a></li>
<li><a href="http://github.com/fbuihuu/libtree">Fast and efficient implementation of AVL Trees</a></li>
<li><a href="https://github.com/mondrake/Rbppavl">PHP Implementation</a></li>
<li><a href="https://github.com/chdemko/php-sorted-collections">AVL Threaded Tree PHP Implementation</a></li>
<li><a href="http://www.codeproject.com/Articles/12347/AVL-Binary-Tree-for-C">C++ implementation which can be used as an array</a></li>
<li><a href="http://code.google.com/p/self-balancing-avl-tree/">Self balancing AVL tree with Concat and Split operations</a></li>
</ul>

<p>"</p>

<p><a href="Category:1962_in_computer_science" title="wikilink">Category:1962 in computer science</a> <a href="Category:Binary_trees" title="wikilink">Category:Binary trees</a> <a href="Category:Soviet_inventions" title="wikilink">Category:Soviet inventions</a> <a href="Category:Search_trees" title="wikilink">Category:Search trees</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Robert_Sedgewick_(computer_scientist)" title="wikilink">Robert Sedgewick</a>, <em>Algorithms</em>, Addison-Wesley, 1983, ISBN 0-201-06672-6, page 199, chapter 15: Balanced Trees.<a href="#fnref1">↩</a></li>
<li id="fn2"> English translation by Myron J. Ricci in <em>Soviet Math. Doklady</em>, 3:1259–1263, 1962.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">In fact, each AVL tree can be colored red-black.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="Red-black_tree#Proof_of_asymptotic_bounds" title="wikilink">Proof of asymptotic bounds</a><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>

