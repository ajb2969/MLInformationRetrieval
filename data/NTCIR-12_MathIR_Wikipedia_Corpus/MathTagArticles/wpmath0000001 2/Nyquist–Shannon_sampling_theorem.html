<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1163">Nyquist–Shannon sampling theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nyquist–Shannon sampling theorem</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Fig. 1: Magnitude of the Fourier transform of a bandlimited function|right</figcaption>
</figure>

<p>In the field of <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, the <strong>sampling theorem</strong> is a fundamental bridge between <a href="continuous-time_signal" title="wikilink">continuous-time signals</a> (often called "analog signals") and <a href="discrete-time_signal" title="wikilink">discrete-time signals</a> (often called "digital signals"). It establishes a sufficient condition for a <a href="sample_rate" title="wikilink">sample rate</a> that permits a discrete sequence of <em>samples</em> to capture all the information from a continuous-time signal of finite bandwidth.</p>

<p>Strictly speaking, the theorem only applies to a class of <a href="mathematical_function" title="wikilink">mathematical functions</a> having a <a href="continuous_Fourier_transform" title="wikilink">Fourier transform</a> that is zero outside of a finite region of frequencies (see Fig 1). Intuitively we expect that when one reduces a continuous function to a discrete sequence and <a class="uri" href="interpolates" title="wikilink">interpolates</a> back to a continuous function, the fidelity of the result depends on the density (or <a href="Sampling_(signal_processing)" title="wikilink">sample rate</a>) of the original samples. The sampling theorem introduces the concept of a sample rate that is sufficient for perfect fidelity for the class of functions that are <a class="uri" href="bandlimited" title="wikilink">bandlimited</a> to a given bandwidth, such that no actual information is lost in the sampling process. It expresses the sufficient sample rate in terms of the bandwidth for the class of functions. The theorem also leads to a formula for perfectly reconstructing the original continuous-time function from the samples.</p>

<p>Perfect reconstruction may still be possible when the sample-rate criterion is not satisfied, provided other constraints on the signal are known. (See  below, and <a href="Compressed_sensing" title="wikilink">Compressed sensing</a>.) In some cases (when the sample-rate criterion is not satisfied), utilizing additional constraints allows for approximate reconstructions. The fidelity of these reconstructions can be verified and quantified utilizing Bochner's theorem.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The name <em>Nyquist–Shannon sampling theorem</em> honors <a href="Harry_Nyquist" title="wikilink">Harry Nyquist</a> and <a href="Claude_Shannon" title="wikilink">Claude Shannon</a>. The theorem was also discovered independently by <a href="E._T._Whittaker" title="wikilink">E. T. Whittaker</a>, by <a href="Vladimir_Kotelnikov" title="wikilink">Vladimir Kotelnikov</a>, and by others. It is thus also known by the names <em>Nyquist–Shannon–Kotelnikov</em>, <em>Whittaker–Shannon–Kotelnikov</em>, <em>Whittaker–Nyquist–Kotelnikov–Shannon</em>, and <em>cardinal theorem of interpolation</em>.</p>
<h2 id="introduction">Introduction</h2>

<p><a href="Sampling_(signal_processing)" title="wikilink">Sampling</a> is the process of converting a signal (for example, a function of continuous time and/or space) into a numeric sequence (a function of discrete time and/or space). <a href="Claude_Shannon" title="wikilink">Shannon's</a> version of the theorem states:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>If a function x(t) contains no frequencies higher than <em>B</em> <a class="uri" href="hertz" title="wikilink">hertz</a>, it is completely determined by giving its ordinates at a series of points spaced 1/(2<em>B</em>) seconds apart.</p>

<p>A sufficient sample-rate is therefore 2<em>B</em> samples/second, or anything larger. Equivalently, for a given sample rate <em>f</em><sub>s</sub>, perfect reconstruction is guaranteed possible for a bandlimit <mtpl></mtpl>.</p>

<p>When the bandlimit is too high (or there is no bandlimit), the reconstruction exhibits imperfections known as <a class="uri" href="aliasing" title="wikilink">aliasing</a>. Modern statements of the theorem are sometimes careful to explicitly state that <em>x</em>(<em>t</em>) must contain no <a href="Sine_wave" title="wikilink">sinusoidal</a> component at exactly frequency <em>B</em>, or that <em>B</em> must be strictly less than ½ the sample rate. The two thresholds, 2<em>B</em> and <em>f</em><sub>s</sub>/2 are respectively called the <strong><a href="Nyquist_rate" title="wikilink">Nyquist rate</a></strong> and <strong><a href="Nyquist_frequency" title="wikilink">Nyquist frequency</a></strong>. And respectively, they are attributes of <em>x</em>(<em>t</em>) and of the sampling equipment. The condition described by these inequalities is called the <strong>Nyquist criterion</strong>, or sometimes the <em>Raabe condition</em>. The theorem is also applicable to functions of other domains, such as <em>space,</em> in the case of a digitized image. The only change, in the case of other domains, is the units of measure applied to <em>t</em>, <em>f</em><sub>s</sub>, and <em>B</em>.</p>
<figure><b>(Figure)</b>
<figcaption>Fig. 2: The normalized <a href="sinc_function" title="wikilink">sinc function</a>:  ... showing the central peak at , and zero-crossings at the other integer values of <em>x</em>.</figcaption>
</figure>

<p>The <mtpl></mtpl> is customarily used to represent the interval between samples and is called the <strong>sample period</strong> or <strong>sampling interval</strong>. And the samples of function <em>x</em>(<em>t</em>) are commonly denoted by  (alternatively "<em>x<sub>n</sub></em>" in older signal processing literature), for all integer values of <em>n</em>. The mathematically ideal way to interpolate the sequence involves the use of <a href="sinc_function" title="wikilink">sinc functions</a>, like those shown in Fig 2. Each sample in the sequence is replaced by a sinc function, centered on the time axis at the original location of the sample, <em>nT</em>, with the amplitude of the sinc function scaled to the sample value, <em>x</em>[<em>n</em>]. Subsequently, the sinc functions are summed into a continuous function. A mathematically equivalent method is to convolve one sinc function with a series of <a href="Dirac_delta" title="wikilink">Dirac delta</a> pulses, weighted by the sample values. Neither method is numerically practical. Instead, some type of approximation of the sinc functions, finite in length, is used. The imperfections attributable to the approximation are known as <em>interpolation error</em>.</p>

<p>Practical <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converters</a> produce neither scaled and delayed sinc functions, nor ideal Dirac pulses. Instead they produce a <a class="uri" href="piecewise-constant" title="wikilink">piecewise-constant</a> sequence of scaled and delayed <a href="rectangular_function" title="wikilink">rectangular pulses</a> (the <a href="zero-order_hold" title="wikilink">zero-order hold</a>), usually followed by an "anti-imaging filter" to clean up spurious high-frequency content.</p>
<h2 id="aliasing">Aliasing</h2>
<figure><b>(Figure)</b>
<figcaption>Fig. 3: The samples of two sine waves can be identical, when at least one of them is at a frequency above half the sample rate.</figcaption>
</figure>

<p>When <em>x</em>(<em>t</em>) is a function with a <a href="Fourier_transform" title="wikilink">Fourier transform</a>, <em>X</em>(<em>f</em>)<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mpadded width="+5pt">
     <mover>
      <mo movablelimits="false">=</mo>
      <mi>def</mi>
     </mover>
    </mpadded>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>i</mi>
          <mn>2</mn>
          <mi>π</mi>
          <mi>f</mi>
          <mi>t</mi>
         </mrow>
        </mrow>
       </msup>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>i</ci>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>f</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <ci>normal-d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(f)\ \stackrel{\mathrm{def}}{=}\ \int_{-\infty}^{\infty}x(t)\ e^{-i2\pi ft}\ %
{\rm d}t,
  </annotation>
 </semantics>
</math>

</p>

<p>the <a href="Poisson_summation_formula" title="wikilink">Poisson summation formula</a> indicates that the samples, <em>x</em>(<em>nT</em>), of <em>x</em>(<em>t</em>) are sufficient to create a <a href="periodic_summation" title="wikilink">periodic summation</a> of <em>X</em>(<em>f</em>). The result is<strong>:</strong></p>

<p>{=} \sum_{k=-\infty}^{\infty} X\left(f - k f_s\right) = \sum_{n=-\infty}^{\infty} T\cdot x(nT)\ e^{-i 2\pi n T f},|<mtpl><eqref>Eq.1<eqref></eqref></eqref></mtpl>}}</p>
<figure><b>(Figure)</b>
<figcaption>Fig. 4: <em>X</em>(<em>f</em>) (top blue) and <em>X</em><sub>A</sub>(<em>f</em>) (bottom blue) are continuous Fourier transforms of two <u>different</u> functions, <em>x</em>(<em>t</em>) and <em>x</em><sub>A</sub>(<em>t</em>) (not shown). When the functions are sampled at rate <em>f</em><sub>s</sub>, the images (green) are added to the original transforms (blue) when one examines the discrete-time Fourier transforms (DTFT) of the sequences. In this hypothetical example, the DTFTs are identical, which means <u>the sampled sequences are identical</u>, even though the original continuous pre-sampled functions are not. If these were audio signals, <em>x</em>(<em>t</em>) and <em>x</em><sub>A</sub>(<em>t</em>) might not sound the same. But their samples (taken at rate <em>f</em><sub>s</sub>) are identical and would lead to identical reproduced sounds; thus <em>x</em><sub>A</sub>(<em>t</em>) is an alias of <em>x</em>(<em>t</em>) at this sample rate.</figcaption>
</figure>

<p>which is a periodic function and its equivalent representation as a <a href="Fourier_series" title="wikilink">Fourier series</a>, whose coefficients are <em>T</em>•<em>x</em>(<em>nT</em>). This function is also known as the <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a> (DTFT) of the sequence <em>T</em>•<em>x</em>(<em>nT</em>), for integers n.</p>

<p>As depicted in Figure 4, copies of <em>X</em>(<em>f</em>) are shifted by multiples of <em>f<sub>s</sub></em> and combined by addition. For a band-limited function  (<em>X</em>(<em>f</em>) = <em>0</em> for all |<em>f</em>| ≥ <em>B</em>),  and sufficiently large <em>f<sub>s</sub></em>, it is possible for the copies to remain distinct from each other. But if the Nyquist criterion is not satisfied, adjacent copies overlap, and it is not possible in general to discern an unambiguous <em>X</em>(<em>f</em>). Any frequency component above <em>f<sub>s</sub></em>/2 is indistinguishable from a lower-frequency component, called an <em>alias</em>, associated with one of the copies. In such cases, the customary interpolation techniques produce the alias, rather than the original component. When the sample-rate is pre-determined by other considerations (such as an industry standard), <em>x</em>(<em>t</em>) is usually filtered to reduce its high frequencies to acceptable levels before it is sampled. The type of filter required is a <a href="lowpass_filter" title="wikilink">lowpass filter</a>, and in this application it is called an <a href="anti-aliasing_filter" title="wikilink">anti-aliasing filter</a>.</p>
<figure><b>(Figure)</b>
<figcaption>Fig. 5: Spectrum, <em>X<sub>s</sub></em>(<em>f</em>), of a properly sampled bandlimited signal (blue) and the adjacent DTFT images (green) that do not overlap. A <em>brick-wall</em> low-pass filter, <em>H</em>(<em>f</em>), removes the images, leaves the original spectrum, <em>X</em>(<em>f</em>), and recovers the original signal from its samples.</figcaption>
</figure>
<h2 id="derivation-as-a-special-case-of-poisson-summation">Derivation as a special case of Poisson summation</h2>

<p>From Figure 5, it is apparent that when there is no overlap of the copies (aka "images") of <em>X</em>(<em>f</em>), the <em>k</em> = 0 term of <em>X<sub>s</sub></em>(<em>f</em>) can be recovered by the product<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>H</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>X</mi>
       <mi>s</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(f)=H(f)\cdot X_{s}(f),\,
  </annotation>
 </semantics>
</math>

      where<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>f</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo><</mo>
        <mi>B</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>f</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>></mo>
         <mrow>
          <msub>
           <mi>f</mi>
           <mi>s</mi>
          </msub>
          <mo>-</mo>
          <mi>B</mi>
         </mrow>
        </mrow>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <lt></lt>
      <apply>
       <abs></abs>
       <ci>f</ci>
      </apply>
      <ci>B</ci>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <gt></gt>
      <apply>
       <abs></abs>
       <ci>f</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>s</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(f)\ \stackrel{\mathrm{def}}{=}\ \begin{cases}1&|f|<B\\
0&|f|>f_{s}-B.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>At this point, the sampling theorem is proved, since <em>X</em>(<em>f</em>) uniquely determines <em>x</em>(<em>t</em>).</p>

<p>All that remains is to derive the formula for reconstruction. <em>H</em>(<em>f</em>) need not be precisely defined in the region <mtpl></mtpl> because <em>X</em><sub>s</sub>(<em>f</em>) is zero in that region. However, the worst case is when <em>B</em> = <em>f<sub>s</sub></em>/2, the Nyquist frequency. A function that is sufficient for that and all less severe cases is<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>rect</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>f</mi>
      <msub>
       <mi>f</mi>
       <mi>s</mi>
      </msub>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>f</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo><</mo>
        <mstyle displaystyle="false">
         <mfrac>
          <msub>
           <mi>f</mi>
           <mi>s</mi>
          </msub>
          <mn>2</mn>
         </mfrac>
        </mstyle>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>f</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>></mo>
         <mstyle displaystyle="false">
          <mfrac>
           <msub>
            <mi>f</mi>
            <mi>s</mi>
           </msub>
           <mn>2</mn>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>rect</ci>
      <apply>
       <divide></divide>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">cases</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <lt></lt>
       <apply>
        <abs></abs>
        <ci>f</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>s</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <gt></gt>
       <apply>
        <abs></abs>
        <ci>f</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>s</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(f)=\mathrm{rect}\left(\frac{f}{f_{s}}\right)=\begin{cases}1&|f|<\frac{f_{s}}%
{2}\\
0&|f|>\frac{f_{s}}{2},\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where rect(•) is the <a href="rectangular_function" title="wikilink">rectangular function</a>.  Therefore<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>rect</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>f</mi>
        <msub>
         <mi>f</mi>
         <mi>s</mi>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>X</mi>
      <mi>s</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>rect</ci>
       <apply>
        <divide></divide>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(f)=\mathrm{rect}\left(\frac{f}{f_{s}}\right)\cdot X_{s}(f)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:5">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>rect</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mo>⋅</mo>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mi>T</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>i</mi>
         <mn>2</mn>
         <mi>π</mi>
         <mi>n</mi>
         <mi>T</mi>
         <mi>f</mi>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>rect</ci>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>i</ci>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>n</ci>
          <ci>T</ci>
          <ci>f</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\mathrm{rect}(Tf)\cdot\sum_{n=-\infty}^{\infty}T\cdot x(nT)\ e^{-i2\pi nTf}
  </annotation>
 </semantics>
</math>

      (from  , above).
</dd>
<dd><math> = \sum_{n=-\infty}^{\infty} x(nT)\cdot \underbrace{T\cdot \mathrm{rect} (Tf) \cdot e^{-i 2\pi n T f}}_{
</math></dd>
</dl>
</dd>
</dl>

<p>\mathcal{F}\left \{</p>

<p><code>\mathrm{sinc} \left( \frac{t - nT}{T} \right)</code></p>

<p>\right \} }.     <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The inverse transform of both sides produces the <a href="Whittaker–Shannon_interpolation_formula" title="wikilink">Whittaker–Shannon interpolation formula</a><strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mi>T</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>sinc</mi>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mrow>
          <mi>n</mi>
          <mi>T</mi>
         </mrow>
        </mrow>
        <mi>T</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>sinc</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=\sum_{n=-\infty}^{\infty}x(nT)\cdot\mathrm{sinc}\left(\frac{t-nT}{T}%
\right),
  </annotation>
 </semantics>
</math>

</p>

<p>which shows how the samples, <em>x</em>(<em>nT</em>), can be combined to reconstruct <em>x</em>(<em>t</em>).</p>
<ul>
<li>From Figure 5, it is clear that larger-than-necessary values of <em>f<sub>s</sub></em> (smaller values of <em>T</em>), called <em>oversampling</em>, have no effect on the outcome of the reconstruction and have the benefit of leaving room for a <em>transition band</em> in which <em>H</em>(<em>f</em>) is free to take intermediate values. <a class="uri" href="Undersampling" title="wikilink">Undersampling</a>, which causes aliasing, is not in general a reversible operation.</li>
<li>Theoretically, the interpolation formula can be implemented as a <a href="low_pass_filter" title="wikilink">low pass filter</a>, whose impulse response is sinc(<em>t</em>/<em>T</em>) and whose input is 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:7">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mi>T</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>δ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mrow>
        <mi>n</mi>
        <mi>T</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>δ</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\sum_{n=-\infty}^{\infty}x(nT)\cdot\delta(t-nT),
  </annotation>
 </semantics>
</math>

 which is a <a href="Dirac_comb" title="wikilink">Dirac comb</a> function modulated by the signal samples. Practical <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converters</a> (DAC) implement an approximation like the <a href="zero-order_hold" title="wikilink">zero-order hold</a>. In that case, oversampling can reduce the approximation error.</li>
</ul>
<h2 id="shannons-original-proof">Shannon's original proof</h2>

<p>Poisson shows that the Fourier series in  produces the periodic summation of <em>X</em>(<em>f</em>), regardless of <em>f<sub>s</sub></em> and <em>B</em>. Shannon, however, only derives the series coefficients for the case <em>f<sub>s</sub></em> = <em>2B</em>. Virtually quoting Shannon's original paper<strong>:</strong></p>
<dl>
<dd>Let 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:8">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega)
  </annotation>
 </semantics>
</math>

 be the spectrum of 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x(t).
  </annotation>
 </semantics>
</math>

  Then
</dd>
</dl>

<p>::{| |- |

<math display="inline" id="Nyquist–Shannon_sampling_theorem:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)\,
  </annotation>
 </semantics>
</math>

 |

<math display="inline" id="Nyquist–Shannon_sampling_theorem:11">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+2.8pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>i</mi>
         <mi>ω</mi>
         <mi>t</mi>
        </mrow>
       </msup>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>ω</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ={1\over 2\pi}\int_{-\infty}^{\infty}X(\omega)e^{i\omega t}\;{\rm d}\omega
  </annotation>
 </semantics>
</math>

 |- | |

<math display="inline" id="Nyquist–Shannon_sampling_theorem:12">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>B</mi>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>B</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+2.8pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>i</mi>
         <mi>ω</mi>
         <mi>t</mi>
        </mrow>
       </msup>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>ω</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>B</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ={1\over 2\pi}\int_{-2\pi B}^{2\pi B}X(\omega)e^{i\omega t}\;{\rm d}\omega
  </annotation>
 </semantics>
</math>

 |}</p>
<dl>
<dd>since 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:13">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega)
  </annotation>
 </semantics>
</math>

 is assumed to be zero outside the band 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mstyle scriptlevel="+1">
     <mfrac>
      <mi>ω</mi>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
    </mstyle>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <divide></divide>
      <ci>ω</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle|\frac{\omega}{2\pi}|<B
  </annotation>
 </semantics>
</math>

. If we let
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:15">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mi>n</mi>
     <mrow>
      <mn>2</mn>
      <mi>B</mi>
     </mrow>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t={n\over{2B}}\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where <em>n</em> is any positive or negative integer, we obtain
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>n</mi>
       <mrow>
        <mn>2</mn>
        <mi>B</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>B</mi>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>B</mi>
       </mrow>
      </msubsup>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mpadded width="+2.8pt">
        <msup>
         <mi>e</mi>
         <mrow>
          <mi>i</mi>
          <mi>ω</mi>
          <mfrac>
           <mi>n</mi>
           <mrow>
            <mn>2</mn>
            <mi>B</mi>
           </mrow>
          </mfrac>
         </mrow>
        </msup>
       </mpadded>
       <mi mathvariant="normal">d</mi>
       <mi>ω</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>B</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ω</ci>
         <apply>
          <divide></divide>
          <ci>n</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>B</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\left(\tfrac{n}{2B}\right)={1\over 2\pi}\int_{-2\pi B}^{2\pi B}X(\omega)e^{i%
\omega{n\over{2B}}}\;{\rm d}\omega.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>On the left are values of 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:17">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x(t)
  </annotation>
 </semantics>
</math>

 at the sampling points. The integral on the right will be recognized as essentially<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> the <em>n</em><sup>th</sup> coefficient in a Fourier-series expansion of the function 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega),
  </annotation>
 </semantics>
</math>

 taking the interval –<em>B</em> to <em>B</em> as a fundamental period. This means that the values of the samples 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x(n/2B)
  </annotation>
 </semantics>
</math>

 determine the Fourier coefficients in the series expansion of 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega).
  </annotation>
 </semantics>
</math>

  Thus they determine 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega),
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:22">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega)
  </annotation>
 </semantics>
</math>

 is zero for frequencies greater than <em>B</em>, and for lower frequencies 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:23">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega)
  </annotation>
 </semantics>
</math>

 is determined if its Fourier coefficients are determined. But 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:24">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X(\omega)
  </annotation>
 </semantics>
</math>

 determines the original function 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:25">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x(t)
  </annotation>
 </semantics>
</math>

 completely, since a function is determined if its spectrum is known. Therefore the original samples determine the function 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x(t)
  </annotation>
 </semantics>
</math>

 completely.
</dd>
</dl>

<p>Shannon's proof of the theorem is complete at that point, but he goes on to discuss reconstruction via <a href="sinc_function" title="wikilink">sinc functions</a>, what we now call the <a href="Whittaker–Shannon_interpolation_formula" title="wikilink">Whittaker–Shannon interpolation formula</a> as discussed above. He does not derive or prove the properties of the sinc function, but these would have been familiar to engineers reading his works at the time, since the Fourier pair relationship between <a href="rectangular_function" title="wikilink">rect</a> (the rectangular function) and sinc was well known.</p>
<dl>
<dd>Let 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:27">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x_{n}
  </annotation>
 </semantics>
</math>

 be the <em>n</em><sup>th</sup> sample. Then the function 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:28">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x(t)
  </annotation>
 </semantics>
</math>

 is represented by:
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mfrac>
       <mrow>
        <mrow>
         <mi>sin</mi>
         <mi>π</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mn>2</mn>
           <mi>B</mi>
           <mi>t</mi>
          </mrow>
          <mo>-</mo>
          <mi>n</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mn>2</mn>
           <mi>B</mi>
           <mi>t</mi>
          </mrow>
          <mo>-</mo>
          <mi>n</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <sin></sin>
         <ci>π</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>B</ci>
          <ci>t</ci>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>π</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>B</ci>
          <ci>t</ci>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=\sum_{n=-\infty}^{\infty}x_{n}{\sin\pi(2Bt-n)\over\pi(2Bt-n)}.\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>As in the other proof, the existence of the Fourier transform of the original signal is assumed, so the proof does not say whether the sampling theorem extends to bandlimited stationary random processes.</p>
<h3 id="notes">Notes</h3>
<h2 id="application-to-multivariable-signals-and-images">Application to multivariable signals and images</h2>
<figure><b>(Figure)</b>
<figcaption>Fig. 6: Subsampled image showing a <a href="Moiré_pattern" title="wikilink">Moiré pattern</a></figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Fig. 7: Properly sampled image</figcaption>
</figure>

<p>The sampling theorem is usually formulated for functions of a single variable. Consequently, the theorem is directly applicable to time-dependent signals and is normally formulated in that context. However, the sampling theorem can be extended in a straightforward way to functions of arbitrarily many variables. Grayscale images, for example, are often represented as two-dimensional arrays (or matrices) of real numbers representing the relative intensities of <a href="pixel" title="wikilink">pixels</a> (picture elements) located at the intersections of row and column sample locations. As a result, images require two independent variables, or indices, to specify each pixel uniquely — one for the row, and one for the column.</p>

<p>Color images typically consist of a composite of three separate grayscale images, one to represent each of the three primary colors — red, green, and blue, or <em>RGB</em> for short. Other colorspaces using 3-vectors for colors include HSV, CIELAB, XYZ, etc. Some colorspaces such as cyan, magenta, yellow, and black (CMYK) may represent color by four dimensions. All of these are treated as <a href="vector-valued_function" title="wikilink">vector-valued functions</a> over a two-dimensional sampled domain.</p>

<p>Similar to one-dimensional discrete-time signals, images can also suffer from aliasing if the sampling resolution, or pixel density, is inadequate. For example, a digital photograph of a striped shirt with high frequencies (in other words, the distance between the stripes is small), can cause aliasing of the shirt when it is sampled by the camera's <a href="image_sensor" title="wikilink">image sensor</a>. The aliasing appears as a <a href="moiré_pattern" title="wikilink">moiré pattern</a>. The "solution" to higher sampling in the spatial domain for this case would be to move closer to the shirt, use a higher resolution sensor, or to optically blur the image before acquiring it with the sensor.</p>

<p>Another example is shown to the right in the brick patterns. The top image shows the effects when the sampling theorem's condition is not satisfied. When software rescales an image (the same process that creates the thumbnail shown in the lower image) it, in effect, runs the image through a low-pass filter first and then <a href="downsampling" title="wikilink">downsamples</a> the image to result in a smaller image that does not exhibit the <a href="moiré_pattern" title="wikilink">moiré pattern</a>. The top image is what happens when the image is downsampled without low-pass filtering: aliasing results.</p>

<p>The application of the sampling theorem to images should be made with care. For example, the sampling process in any standard image sensor (CCD or CMOS camera) is relatively far from the ideal sampling which would measure the image intensity at a single point. Instead these devices have a relatively large sensor area at each sample point in order to obtain sufficient amount of light. In other words, any detector has a finite-width <a href="point_spread_function" title="wikilink">point spread function</a>. The analog optical image intensity function which is sampled by the sensor device is not in general bandlimited, and the non-ideal sampling is itself a useful type of low-pass filter, though not always sufficient to remove enough high frequencies to sufficiently reduce aliasing. When the area of the sampling spot (the size of the pixel sensor) is not large enough to provide sufficient <a href="spatial_anti-aliasing" title="wikilink">spatial anti-aliasing</a>, a separate anti-aliasing filter (optical low-pass filter) is typically included in a camera system to further blur the optical image. Despite images having these problems in relation to the sampling theorem, the theorem can be used to describe the basics of down and up sampling of images.</p>
<figure><b>(Figure)</b>
<figcaption>Fig. 8: A family of sinusoids at the critical frequency, all having the same sample sequences of alternating +1 and –1. That is, they all are aliases of each other, even though their frequency is not above half the sample rate.</figcaption>
</figure>
<h2 id="critical-frequency">Critical frequency</h2>

<p>To illustrate the necessity of <em>f<sub>s</sub></em> &gt; 2<em>B</em>, consider the family of sinusoids (depicted in Fig. 8) generated by different values of θ in this formula<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mfrac>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>π</mi>
          <mi>B</mi>
          <mi>t</mi>
         </mrow>
         <mo>+</mo>
         <mi>θ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mpadded>
    <mo rspace="7.5pt">=</mo>
    <mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>B</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi>sin</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>B</mi>
         <mi>t</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>tan</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>π</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi>θ</mi>
    <mo><</mo>
    <mrow>
     <mi>π</mi>
     <mo>/</mo>
     <mn>2.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <cos></cos>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>B</ci>
          <ci>t</ci>
         </apply>
         <ci>θ</ci>
        </apply>
       </apply>
       <apply>
        <cos></cos>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <minus></minus>
       <apply>
        <cos></cos>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>B</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <sin></sin>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>B</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <tan></tan>
         <ci>θ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <lt></lt>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <ci>π</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>θ</ci>
     </apply>
     <apply>
      <lt></lt>
      <share href="#.cmml">
      </share>
      <apply>
       <divide></divide>
       <ci>π</ci>
       <cn type="float">2.</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=\frac{\cos(2\pi Bt+\theta)}{\cos(\theta)}\ =\ \cos(2\pi Bt)-\sin(2\pi Bt)%
\tan(\theta),\quad-\pi/2<\theta<\pi/2.
  </annotation>
 </semantics>
</math>

</p>

<p>With <em>f<sub>s</sub></em> = 2<em>B</em> or equivalently <em>T</em> = 1/(2<em>B</em>), the samples are given by<strong>:</strong></p>

<p>

<math display="block" id="Nyquist–Shannon_sampling_theorem:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>π</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munder>
      <munder accentunder="true">
       <mrow>
        <mi>sin</mi>
        <mrow>
         <mo movablelimits="false" stretchy="false">(</mo>
         <mrow>
          <mi>π</mi>
          <mi>n</mi>
         </mrow>
         <mo movablelimits="false" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo movablelimits="false">⏟</mo>
      </munder>
      <mn>0</mn>
     </munder>
     <mrow>
      <mi>tan</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-⏟</ci>
         <apply>
          <sin></sin>
          <apply>
           <times></times>
           <ci>π</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <tan></tan>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(nT)=\cos(\pi n)-\underbrace{\sin(\pi n)}_{0}\tan(\theta)=(-1)^{n}
  </annotation>
 </semantics>
</math>

 <u>regardless of the value of θ</u>. That sort of ambiguity is the reason for the <em>strict</em> inequality of the sampling theorem's condition.</p>
<h2 id="sampling-of-non-baseband-signals">Sampling of non-baseband signals</h2>

<p>As discussed by Shannon:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<dl>
<dd><blockquote>

<p>A similar result is true if the band does not start at zero frequency but at some higher value, and can be proved by a linear translation (corresponding physically to <a href="single-sideband_modulation" title="wikilink">single-sideband modulation</a>) of the zero-frequency case. In this case the elementary pulse is obtained from sin(<em>x</em>)/<em>x</em> by single-side-band modulation.</p>
</blockquote>
</dd>
</dl>

<p>That is, a sufficient no-loss condition for sampling <a href="signal_(information_theory)" title="wikilink">signals</a> that do not have <a class="uri" href="baseband" title="wikilink">baseband</a> components exists that involves the <em>width</em> of the non-zero frequency interval as opposed to its highest frequency component. See <em><a href="Sampling_(signal_processing)" title="wikilink">Sampling (signal processing)</a></em> for more details and examples.</p>

<p>A bandpass condition is that <em>X</em>(<em>f</em>) = 0, for all nonnegative <em>f</em> outside the open band of frequencies:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:32">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mfrac>
      <mi>N</mi>
      <mn>2</mn>
     </mfrac>
     <msub>
      <mi>f</mi>
      <mi mathvariant="normal">s</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>N</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </mfrac>
     <msub>
      <mi>f</mi>
      <mi mathvariant="normal">s</mi>
     </msub>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>normal-s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>normal-s</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{N}{2}f_{\mathrm{s}},\frac{N+1}{2}f_{\mathrm{s}}\right),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>for some nonnegative integer <em>N</em>. This formulation includes the normal baseband condition as the case <em>N</em>=0.</p>

<p>The corresponding interpolation function is the impulse response of an ideal brick-wall <a href="bandpass_filter" title="wikilink">bandpass filter</a> (as opposed to the ideal <a href="brick-wall_filter" title="wikilink">brick-wall</a> <a href="lowpass_filter" title="wikilink">lowpass filter</a> used above) with cutoffs at the upper and lower edges of the specified band, which is the difference between a pair of lowpass impulse responses:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>sinc</mo>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>N</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>t</mi>
        </mrow>
        <mi>T</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>N</mi>
     </mpadded>
     <mrow>
      <mo>sinc</mo>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>N</mi>
         <mi>t</mi>
        </mrow>
        <mi>T</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>sinc</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <ci>sinc</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>t</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N+1)\,\operatorname{sinc}\left(\frac{(N+1)t}{T}\right)-N\,\operatorname{sinc}%
\left(\frac{Nt}{T}\right).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Other generalizations, for example to signals occupying multiple non-contiguous bands, are possible as well. Even the most generalized form of the sampling theorem does not have a provably true converse. That is, one cannot conclude that information is necessarily lost just because the conditions of the sampling theorem are not satisfied; from an engineering perspective, however, it is generally safe to assume that if the sampling theorem is not satisfied then information will most likely be lost.</p>
<h2 id="nonuniform-sampling">Nonuniform sampling</h2>

<p>The sampling theory of Shannon can be generalized for the case of <a href="nonuniform_sampling" title="wikilink">nonuniform sampling</a>, that is, samples not taken equally spaced in time. The Shannon sampling theory for non-uniform sampling states that a band-limited signal can be perfectly reconstructed from its samples if the average sampling rate satisfies the Nyquist condition.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Therefore, although uniformly spaced samples may result in easier reconstruction algorithms, it is not a necessary condition for perfect reconstruction.</p>

<p>The general theory for non-baseband and nonuniform samples was developed in 1967 by <a href="Henry_Landau" title="wikilink">Landau</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> He proved that, to paraphrase roughly, the average sampling rate (uniform or otherwise) must be twice the <em>occupied</em> bandwidth of the signal, assuming it is <em>a priori</em> known what portion of the spectrum was occupied. In the late 1990s, this work was partially extended to cover signals of when the amount of occupied bandwidth was known, but the actual occupied portion of the spectrum was unknown.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In the 2000s, a complete theory was developed (see the section <a href="Nyquist–Shannon_sampling_theorem#Beyond_Nyquist" title="wikilink">Beyond Nyquist</a> below) using <a href="compressed_sensing" title="wikilink">compressed sensing</a>. In particular, the theory, using signal processing language, is described in this 2009 paper.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> They show, among other things, that if the frequency locations are unknown, then it is necessary to sample at least at twice the Nyquist criteria; in other words, you must pay at least a factor of 2 for not knowing the location of the <a class="uri" href="spectrum" title="wikilink">spectrum</a>. Note that minimum sampling requirements do not necessarily guarantee <a href="Numerical_stability" title="wikilink">stability</a>.</p>
<h2 id="sampling-below-the-nyquist-rate-under-additional-restrictions">Sampling below the Nyquist rate under additional restrictions</h2>

<p>The Nyquist–Shannon sampling theorem provides a <a href="necessary_and_sufficient_condition" title="wikilink">sufficient condition</a> for the sampling and reconstruction of a band-limited signal. When reconstruction is done via the <a href="Whittaker–Shannon_interpolation_formula" title="wikilink">Whittaker–Shannon interpolation formula</a>, the Nyquist criterion is also a necessary condition to avoid aliasing, in the sense that if samples are taken at a slower rate than twice the band limit, then there are some signals that will not be correctly reconstructed. However, if further restrictions are imposed on the signal, then the Nyquist criterion may no longer be a <a href="necessary_and_sufficient_condition" title="wikilink">necessary condition</a>.</p>

<p>A non-trivial example of exploiting extra assumptions about the signal is given by the recent field of <a href="compressed_sensing" title="wikilink">compressed sensing</a>, which allows for full reconstruction with a sub-Nyquist sampling rate. Specifically, this applies to signals that are sparse (or compressible) in some domain. As an example, compressed sensing deals with signals that may have a low over-all bandwidth (say, the <em>effective</em> bandwidth <em>EB</em>), but the frequency locations are unknown, rather than all together in a single band, so that the <a href="Nyquist–Shannon_sampling_theorem#Sampling_of_non-baseband_signals" title="wikilink">passband technique</a> doesn't apply. In other words, the frequency spectrum is sparse. Traditionally, the necessary sampling rate is thus 2<em>B</em>. Using compressed sensing techniques, the signal could be perfectly reconstructed if it is sampled at a rate slightly lower than 2<em>EB</em>. The downside of this approach is that reconstruction is no longer given by a formula, but instead by the solution to a <a href="Convex_optimization" title="wikilink">convex optimization program</a> which requires well-studied but nonlinear methods.</p>
<h2 id="historical-background">Historical background</h2>

<p>The sampling theorem was implied by the work of <a href="Harry_Nyquist" title="wikilink">Harry Nyquist</a> in 1928 ("Certain topics in telegraph transmission theory"), in which he showed that up to 2<em>B</em> independent pulse samples could be sent through a system of bandwidth <em>B</em>; but he did not explicitly consider the problem of sampling and reconstruction of continuous signals. About the same time, <a href="Karl_Küpfmüller" title="wikilink">Karl Küpfmüller</a> showed a similar result,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and discussed the sinc-function impulse response of a band-limiting filter, via its integral, the step response <em><a href="sine_integral" title="wikilink">Integralsinus</a></em>; this bandlimiting and reconstruction filter that is so central to the sampling theorem is sometimes referred to as a <em>Küpfmüller filter</em> (but seldom so in English).</p>

<p>The sampling theorem, essentially a <a href="duality_(mathematics)" title="wikilink">dual</a> of Nyquist's result, was proved by <a href="Claude_E._Shannon" title="wikilink">Claude E. Shannon</a> in 1949 ("Communication in the presence of noise"). <a href="V._A._Kotelnikov" title="wikilink">V. A. Kotelnikov</a> published similar results in 1933 ("On the transmission capacity of the 'ether' and of cables in electrical communications", translation from the Russian), as did the mathematician <a href="E._T._Whittaker" title="wikilink">E. T. Whittaker</a> in 1915 ("Expansions of the Interpolation-Theory", "Theorie der Kardinalfunktionen"), J. M. Whittaker in 1935 ("Interpolatory function theory"), and <a href="Dennis_Gabor" title="wikilink">Gabor</a> in 1946 ("Theory of communication"). In 1999, the <a href="Eduard_Rhein_Foundation" title="wikilink">Eduard Rhein Foundation</a> awarded Kotelnikov their Basic Research Award "for the first theoretically exact formulation of the sampling theorem." <a href="http://www.eduard-rhein-foundation.de/html/1999/G99_e.html">1</a></p>
<h3 id="other-discoverers">Other discoverers</h3>

<p>Others who have independently discovered or played roles in the development of the sampling theorem have been discussed in several historical articles, for example by Jerri<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and by Lüke.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> For example, Lüke points out that H. Raabe, an assistant to Küpfmüller, proved the theorem in his 1939 Ph.D. dissertation; the term <em>Raabe condition</em> came to be associated with the criterion for unambiguous representation (sampling rate greater than twice the bandwidth).</p>

<p>Meijering<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> mentions several other discoverers and names in a paragraph and pair of footnotes:</p>
<blockquote>

<p>As pointed out by Higgins [135], the sampling theorem should really be considered in two parts, as done above: the first stating the fact that a bandlimited function is completely determined by its samples, the second describing how to reconstruct the function using its samples. Both parts of the sampling theorem were given in a somewhat different form by J. M. Whittaker [350, 351, 353] and before him also by Ogura [241, 242]. They were probably not aware of the fact that the first part of the theorem had been stated as early as 1897 by Borel [25].<sup>27</sup> As we have seen, Borel also used around that time what became known as the cardinal series. However, he appears not to have made the link [135]. In later years it became known that the sampling theorem had been presented before Shannon to the Russian communication community by Kotel'nikov [173]. In more implicit, verbal form, it had also been described in the German literature by Raabe [257]. Several authors [33, 205] have mentioned that Someya [296] introduced the theorem in the Japanese literature parallel to Shannon. In the English literature, Weston [347] introduced it independently of Shannon around the same time.<sup>28</sup></p>
</blockquote>
<blockquote>

<p><sup>27</sup> Several authors, following Black [16], have claimed that this first part of the sampling theorem was stated even earlier by Cauchy, in a paper [41] published in 1841. However, the paper of Cauchy does not contain such a statement, as has been pointed out by Higgins [135].</p>
</blockquote>
<blockquote>

<p><sup>28</sup> As a consequence of the discovery of the several independent introductions of the sampling theorem, people started to refer to the theorem by including the names of the aforementioned authors, resulting in such catchphrases as “the Whittaker–Kotel’nikov–Shannon (WKS) sampling theorem" [155] or even "the Whittaker–Kotel'nikov–Raabe–Shannon–Someya sampling theorem" [33]. To avoid confusion, perhaps the best thing to do is to refer to it as the sampling theorem, "rather than trying to find a title that does justice to all claimants" [136].</p>
</blockquote>
<h3 id="why-nyquist">Why Nyquist?</h3>

<p>Exactly how, when, or why <a href="Harry_Nyquist" title="wikilink">Harry Nyquist</a> had his name attached to the sampling theorem remains obscure. The term <em>Nyquist Sampling Theorem</em> (capitalized thus) appeared as early as 1959 in a book from his former employer, <a href="Bell_Labs" title="wikilink">Bell Labs</a>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and appeared again in 1963,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> and not capitalized in 1965.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> It had been called the <em>Shannon Sampling Theorem</em> as early as 1954,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> but also just <em>the sampling theorem</em> by several other books in the early 1950s.</p>

<p>In 1958, Blackman and Tukey cited Nyquist's 1928 paper as a reference for <em>the sampling theorem of information theory</em>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> even though that paper does not treat sampling and reconstruction of continuous signals as others did. Their glossary of terms includes these entries:</p>
<dl>
<dd><em>Sampling theorem</em> (<em>of information theory</em>)
</dd>
</dl>
<dl>
<dd>Nyquist's result that equi-spaced data, with two or more points per cycle of highest frequency, allows reconstruction of band-limited functions. (See <em>Cardinal theorem.</em>)
</dd>
</dl>
<dl>
<dd><em>Cardinal theorem</em> (<em>of interpolation theory</em>)
</dd>
</dl>
<dl>
<dd>A precise statement of the conditions under which values given at a doubly infinite set of equally spaced points can be interpolated to yield a continuous band-limited function with the aid of the function
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nyquist–Shannon_sampling_theorem:34">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>sin</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <sin></sin>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\sin(x-x_{i})}{x-x_{i}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Exactly what "Nyquist's result" they are referring to remains mysterious.</p>

<p>When Shannon stated and proved the sampling theorem in his 1949 paper, according to Meijering<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> "he referred to the critical sampling interval <em>T</em> = 1/(2<em>W</em>) as the <em>Nyquist interval</em> corresponding to the band <em>W</em>, in recognition of Nyquist’s discovery of the fundamental importance of this interval in connection with telegraphy." This explains Nyquist's name on the critical interval, but not on the theorem.</p>

<p>Similarly, Nyquist's name was attached to <em><a href="Nyquist_rate" title="wikilink">Nyquist rate</a></em> in 1953 by <a href="Harold_Stephen_Black" title="wikilink">Harold S. Black</a>:<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<dl>
<dd>"If the essential frequency range is limited to <em>B</em> cycles per second, 2<em>B</em> was given by Nyquist as the maximum number of code elements per second that could be unambiguously resolved, assuming the peak interference is less half a quantum step. This rate is generally referred to as <strong>signaling at the Nyquist rate</strong> and 1/(2<em>B</em>) has been termed a <em>Nyquist interval</em>." (bold added for emphasis; italics as in the original)
</dd>
</dl>

<p>According to the <a class="uri" href="OED" title="wikilink">OED</a>, this may be the origin of the term <em>Nyquist rate</em>. In Black's usage, it is not a sampling rate, but a signaling rate.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Balian–Low_theorem" title="wikilink">Balian–Low theorem</a>, a similar theoretical lower-bound on sampling rates, but which applies to <a href="Time–frequency_analysis" title="wikilink">time–frequency transforms</a>.</li>
<li>The <a href="Cheung–Marks_theorem" title="wikilink">Cheung–Marks theorem</a> specifies conditions where restoration of a signal by the sampling theorem can become ill-posed.</li>
<li><a href="Hartley's_law" title="wikilink">Hartley's law</a></li>
<li><a href="Nyquist_ISI_criterion" title="wikilink">Nyquist ISI criterion</a></li>
<li><a href="Reconstruction_from_zero_crossings" title="wikilink">Reconstruction from zero crossings</a></li>
<li><a href="Zero-order_hold" title="wikilink">Zero-order hold</a></li>
</ul>
<h2 id="notes-1">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>J. R. Higgins: <em>Five short stories about the cardinal series</em>, Bulletin of the AMS 12(1985)</li>
<li><a href="V._A._Kotelnikov" title="wikilink">V. A. Kotelnikov</a>, "On the carrying capacity of the ether and wire in telecommunications", Material for the First All-Union Conference on Questions of Communication, Izd. Red. Upr. Svyazi RKKA, Moscow, 1933 (Russian). <a href="http://ict.open.ac.uk/classics/1.pdf">(english translation, PDF)</a></li>
<li><a href="Karl_Küpfmüller" title="wikilink">Karl Küpfmüller</a>, "Utjämningsförlopp inom Telegraf- och Telefontekniken", ("Transients in telegraph and telephone engineering"), Teknisk Tidskrift, no. 9 pp. 153–160 and 10 pp. 178–182, 1931. <a href="http://runeberg.org/tektid/1931e/0157.html">2</a> <a href="http://runeberg.org/tektid/1931e/0182.html">3</a></li>
<li>R.J. Marks II: <em><a href="http://marksmannet.com/RobertMarks/REPRINTS/1999_IntroductionToShannonSamplingAndInterpolationTheory.pdf">Introduction to Shannon Sampling and Interpolation Theory</a></em>, Springer-Verlag, 1991.</li>
<li>R.J. Marks II, Editor: <a href="http://marksmannet.com/RobertMarks/REPRINTS/1993_AdvancedTopicsOnShannon.pdf">Advanced Topics in Shannon Sampling and Interpolation Theory</a>, Springer-Verlag, 1993.</li>
<li>R.J. Marks II, <em>Handbook of Fourier Analysis and Its Applications,</em> Oxford University Press, (2009), Chapters 5-8. <a href="http://books.google.com/books?id=Sp7O4bocjPAC">Google books</a>.</li>
<li><a href="Harry_Nyquist" title="wikilink">H. Nyquist</a>, "Certain topics in telegraph transmission theory", Trans. AIEE, vol. 47, pp. 617–644, Apr. 1928 <a href="http://www.ieee.org/publications_standards/publications/proceedings/nyquist.pdf">Reprint as classic paper in: ''Proc. IEEE, Vol. 90, No. 2, Feb 2002</a>.</li>
<li></li>
<li><a href="Claude_E._Shannon" title="wikilink">C. E. Shannon</a>, "Communication in the presence of noise", Proc. Institute of Radio Engineers, vol. 37, no.1, pp. 10–21, Jan. 1949. <a href="http://www.stanford.edu/class/ee104/shannonpaper.pdf">Reprint as classic paper in: <em>Proc. IEEE</em>, Vol. 86, No. 2, (Feb 1998)</a></li>
<li>Michael Unser: <em><a href="http://bigwww.epfl.ch/publications/unser0001.html">Sampling-50 Years after Shannon</a></em>, Proc. IEEE, vol. 88, no. 4, pp. 569–587, April 2000</li>
<li><a href="E._T._Whittaker" title="wikilink">E. T. Whittaker</a>, "On the Functions Which are Represented by the Expansions of the Interpolation Theory", Proc. Royal Soc. Edinburgh, Sec. A, vol.35, pp. 181–194, 1915</li>
<li><a href="J._M._Whittaker" title="wikilink">J. M. Whittaker</a>, <em>Interpolatory Function Theory</em>, Cambridge Univ. Press, Cambridge, England, 1935.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.vias.org/simulations/simusoft_nykvist.html">Learning by Simulations</a> Interactive simulation of the effects of inadequate sampling</li>
<li><a href="http://webdemo.inue.uni-stuttgart.de/webdemos/02_lectures/uebertragungstechnik_1/sampling_theorem/">Interactive presentation of the sampling and reconstruction in a web-demo</a> Institute of Telecommunications, University of Stuttgart</li>
<li><a href="http://spazioscuola.altervista.org/UndersamplingAR/UndersamplingARnv.htm">Undersampling and an application of it</a></li>
<li><a href="http://web.archive.org/web/20060614125302/http://www.lavryengineering.com/documents/Sampling_Theory.pdf">Sampling Theory For Digital Audio</a></li>
<li><a href="http://www.stsip.org/">Journal devoted to Sampling Theory</a></li>
<li>[<a class="uri" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp">http://ieeexplore.ieee.org/xpl/login.jsp?tp</a>=&amp;arnumber;=5699377&amp;url;=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5699377 Sampling Theorem with Constant Amplitude Variable Width Pulse]</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Theorems_in_Fourier_analysis" title="wikilink">Category:Theorems in Fourier analysis</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Mathematical_theorems_in_theoretical_computer_science" title="wikilink">Category:Mathematical theorems in theoretical computer science</a> <a href="Category:Claude_Shannon" title="wikilink">Category:Claude Shannon</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">, "Communication in the presence of noise", <a href="Proceedings_of_the_IRE" title="wikilink">Proc. Institute of Radio Engineers</a>, vol. 37, no. 1, pp. 10–21, Jan. 1949. <a href="http://www.stanford.edu/class/ee104/shannonpaper.pdf">Reprint as classic paper in: <em>Proc. IEEE</em>, vol. 86, no. 2, (Feb. 1998)</a><a href="#fnref2">↩</a></li>
<li id="fn3">The sinc function follows from rows 202 and 102 of the <a href="Table_of_Fourier_transforms" title="wikilink">transform tables</a><a href="#fnref3">↩</a></li>
<li id="fn4">The actual coefficient formula contains an additional factor of 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mi>B</mi>
    </mrow>
    <mo>=</mo>
    <mi>T</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <ci>B</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1/2B=T.
  </annotation>
 </semantics>
</math>

 So Shannon's coefficients are 

<math display="inline" id="Nyquist–Shannon_sampling_theorem:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mo>⋅</mo>
     <mi>x</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <ci>T</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle T\cdot x(nT),
  </annotation>
 </semantics>
</math>

 which agrees with .<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Nonuniform Sampling, Theory and Practice (ed. F. Marvasti), Kluwer Academic/Plenum Publishers, New York, 2000<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">see, e.g., <a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"> <a href="http://ict.open.ac.uk/classics/2.pdf">(English translation 2005)</a>.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="Abdul_Jerri" title="wikilink">Abdul Jerri</a>, <a href="http://web.archive.org/web/20080605171238/http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1455040">The Shannon Sampling Theorem—Its Various Extensions and Applications: A Tutorial Review</a>, <em>Proceedings of the IEEE</em>, 65:1565–1595, Nov. 1977. See also <a href="http://web.archive.org/web/20090120203809/http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1455576">Correction to "The Shannon sampling theorem—Its various extensions and applications: A tutorial review"</a>, Proceedings of the IEEE, 67:695, April 1979<a href="#fnref11">↩</a></li>
<li id="fn12">Hans Dieter Lüke, , <em>IEEE Communications Magazine,</em> pp.106–108, April 1999.<a href="#fnref12">↩</a></li>
<li id="fn13">Erik Meijering, , <em><a href="Proc._IEEE" title="wikilink">Proc. IEEE</a>,</em> 90, 2002.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
