<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="357">Linear filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear filter</h1>
<hr/>

<p><strong>Linear filters</strong> process time-varying input signals to produce output signals, subject to the constraint of <a class="uri" href="linearity" title="wikilink">linearity</a>. This results from systems composed solely of components (or digital algorithms) classified as having a linear response. Most filters implemented in <a href="analog_electronics" title="wikilink">analog electronics</a>, in <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, or in mechanical systems are classified as <a class="uri" href="causal" title="wikilink">causal</a>, <a href="time_invariant" title="wikilink">time invariant</a>, and linear <a href="signal_processing_filter" title="wikilink">signal processing filters</a>.</p>

<p>The general concept of linear filtering is also used in <a class="uri" href="statistics" title="wikilink">statistics</a>, <a href="data_analysis" title="wikilink">data analysis</a>, and <a href="mechanical_engineering" title="wikilink">mechanical engineering</a> among other fields and technologies. This includes non-causal filters and filters in more than one dimension such as those used in image processing; those filters are subject to different constraints leading to different design methods.</p>
<h2 id="impulse-response-and-transfer-function">Impulse response and transfer function</h2>

<p>A <a href="LTI_system_theory" title="wikilink">linear time-invariant</a> (LTI) filter can be uniquely specified by its <a href="impulse_response" title="wikilink">impulse response</a> <em>h</em>, and the output of any filter is mathematically expressed as the <a class="uri" href="convolution" title="wikilink">convolution</a> of the input with that impulse response. The <a href="frequency_response" title="wikilink">frequency response</a>, given by the filter's <a href="transfer_function" title="wikilink">transfer function</a> 

<math display="inline" id="Linear_filter:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\omega)
  </annotation>
 </semantics>
</math>

, is an alternative characterization of the filter. Typical filter design goals are to realize a particular frequency response, that is, the magnitude of the transfer function 

<math display="inline" id="Linear_filter:1">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |H(\omega)|
  </annotation>
 </semantics>
</math>

; the importance of the <a href="Phase_(waves)" title="wikilink">phase</a> of the transfer function varies according to the application, inasmuch as the shape of a waveform can be distorted to a greater or lesser extent in the process of achieving a desired (amplitude) response in the frequency domain. The frequency response may be tailored to, for instance, eliminate unwanted frequency components from an input <a href="Signal_(information_theory)" title="wikilink">signal</a>, or to limit an amplifier to signals within a particular band of frequencies.</p>

<p>The <a href="impulse_response" title="wikilink">impulse response</a> <em>h</em> of a linear time-invariant causal filter specifies the output that the filter would produce if it were to receive an input consisting of a single impulse at time 0. An "impulse" in a continuous time filter means a <a href="Dirac_delta_function" title="wikilink">Dirac delta function</a>; in a <a href="discrete_time" title="wikilink">discrete time</a> filter the <a href="Kronecker_delta_function" title="wikilink">Kronecker delta function</a> would apply. The impulse response completely characterizes the response of any such filter, inasmuch as any possible input signal can be expressed as a (possibly infinite) combination of weighted delta functions. Multiplying the impulse response shifted in time according to the arrival of each of these delta functions by the amplitude of each delta function, and summing these responses together (according to the <a href="superposition_principle" title="wikilink">superposition principle</a>, applicable to all linear systems) yields the output waveform.</p>

<p>Mathematically this is described as the <a class="uri" href="convolution" title="wikilink">convolution</a> of a time-varying input signal <em>x(t)</em> with the filter's <a href="impulse_response" title="wikilink">impulse response</a> <em>h</em>, defined as:</p>

<p>

<math display="block" id="Linear_filter:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>T</mi>
    </msubsup>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
      <ci>h</ci>
      <ci>τ</ci>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\int_{0}^{T}x(t-\tau)\,h(\tau)\,d\tau
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Linear_filter:3">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msub>
     </mpadded>
     <msub>
      <mi>h</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\sum_{i=0}^{N}x_{k-i}\,h_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>The first form is the continuous-time form, which describes mechanical and analog electronic systems, for instance. The second equation is a discrete-time version used, for example, by digital filters implemented in software, so-called <em><a href="digital_signal_processing" title="wikilink">digital signal processing</a></em>. The impulse response <em>h</em> completely characterizes any linear time-invariant (or shift-invariant in the discrete-time case) filter. The input <em>x</em> is said to be "<a class="uri" href="convolved" title="wikilink">convolved</a>" with the impulse response <em>h</em> having a (possibly infinite) duration of time <em>T</em> (or of <em>N</em> <a href="sampling_period" title="wikilink">sampling periods</a>).</p>

<p>Filter design consists of finding a possible transfer function that can be implemented within certain practical constraints dictated by the technology or desired complexity of the system, followed by a practical design that realizes that transfer function using the chosen technology. The complexity of a filter may be specified according to the <a href="degree_of_a_polynomial" title="wikilink">order</a> of the filter.</p>

<p>Among the time-domain filters we here consider, there are two general classes of filter transfer functions that can approximate a desired frequency response. Very different mathematical treatments apply to the design of filters termed <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR) filters, characteristic of mechanical and analog electronics systems, and <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filters, which can be implemented by <a href="discrete_time" title="wikilink">discrete time</a> systems such as computers (then termed <em><a href="digital_signal_processing" title="wikilink">digital signal processing</a></em>).</p>
<h3 id="infinite-impulse-response-filters">Infinite impulse response filters</h3>

<p>Consider a physical system that acts as a linear filter, such as a system of springs and masses, or an analog electronic circuit that includes <a href="capacitor" title="wikilink">capacitors</a> and/or <a href="inductor" title="wikilink">inductors</a> (along with other linear components such as <a href="resistor" title="wikilink">resistors</a> and <a href="amplifier" title="wikilink">amplifiers</a>). When such a system is subject to an impulse (or any signal of finite duration) it responds with an output waveform that lasts past the duration of the input, eventually decaying exponentially in one or another manner, but never completely settling to zero (mathematically speaking). Such a system is said to have an <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR). The convolution integral (or summation) above extends over all time: T (or N) must be set to infinity.</p>

<p>For instance, consider a damped harmonic oscillator such as a pendulum, or a resonant L-C <a href="tank_circuit" title="wikilink">tank circuit</a>. If the pendulum has been at rest and we were to strike it with a hammer (the "impulse"), setting it in motion, it would swing back and forth ("resonate"), say, with an amplitude of 10 cm. After 10 minutes, say, the pendulum would still be swinging but the amplitude would have decreased to 5 cm, half of its original amplitude. After another 10 minutes its amplitude would be only 2.5 cm, then 1.25 cm, etc. However it would never come to a complete rest, and we therefore call that response to the impulse (striking it with a hammer) "infinite" in duration.</p>

<p>The complexity of such a system is specified by its order <em>N</em>. N is often a constraint on the design of a transfer function since it specifies the number of reactive components in an analog circuit; in a digital IIR filter the number of computations required is proportional to N.</p>
<h3 id="finite-impulse-response-filters">Finite impulse response filters</h3>

<p>A filter implemented in a computer program (or a so-called <a href="digital_signal_processor" title="wikilink">digital signal processor</a>) is a discrete-time system; a different (but parallel) set of mathematical concepts defines the behavior of such systems. Although a <a href="digital_filter" title="wikilink">digital filter</a> can be an IIR filter if the algorithm implementing it includes <a class="uri" href="feedback" title="wikilink">feedback</a>, it is also possible to easily implement a filter whose impulse truly goes to zero after N time steps; this is called a <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filter.</p>

<p>For instance, suppose one has a filter that, when presented with an impulse in a time series:</p>
<dl>
<dd>0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ...
</dd>
</dl>

<p>outputs a series that responds to that impulse at time 0 until time 4, and has no further response, such as:</p>
<dl>
<dd>0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0.....
</dd>
</dl>

<p>Although the impulse response has lasted 4 time steps after the input, starting at time 5 it has truly gone to zero. The extent of the impulse response is <em>finite</em>, and this would be classified as a fourth-order FIR filter. The convolution integral (or summation) above need only extend to the full duration of the impulse response T, or the order N in a discrete time filter.</p>
<h3 id="implementation-issues">Implementation issues</h3>

<p>Classical analog filters are IIR filters, and classical filter theory centers on the determination of transfer functions given by low order <a href="rational_functions" title="wikilink">rational functions</a>, which can be synthesized using the same small number of reactive components.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Using digital computers, on the other hand, both FIR and IIR filters are straightforward to implement in software.</p>

<p>A digital IIR filter can generally approximate a desired filter response using less computing power than a FIR filter, however this advantage is more often unneeded given the increasing power of digital processors. The ease of designing and characterizing FIR filters makes them preferable to the filter designer (programmer) when ample computing power is available. Another advantage of FIR filters is that their impulse response can be made symmetric, which implies a response in the frequency domain that has <a href="linear_phase" title="wikilink"> zero phase at all frequencies</a> (not considering a finite delay), which is absolutely impossible with any IIR filter.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="frequency-response">Frequency response</h2>

<p>The frequency response or <a href="transfer_function" title="wikilink">transfer function</a> 

<math display="inline" id="Linear_filter:4">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |H(\omega)|
  </annotation>
 </semantics>
</math>

 of a filter can be obtained if the impulse response is known, or directly through analysis using <a href="Laplace_transform" title="wikilink">Laplace transforms</a>, or in discrete-time systems the <a class="uri" href="Z-transform" title="wikilink">Z-transform</a>. The frequency response also includes the phase as a function of frequency, however in many cases the phase response is of little or no interest. FIR filters can be made to have zero phase, but with IIR filters that is generally impossible. With most IIR transfer functions there are related transfer functions having a frequency response with the same magnitude but a different phase; in most cases the so-called <a href="minimum_phase" title="wikilink">minimum phase</a> transfer function is preferred.</p>

<p>Filters in the time domain are most often requested to follow a specified frequency response. Then, a mathematical procedure finds a filter transfer function that can be realized (within some constraints), and approximates the desired response to within some criterion. Common filter response specifications are described as follows:</p>
<ul>
<li>A <a href="low-pass_filter" title="wikilink">low-pass filter</a> passes low frequencies while blocking higher frequencies.</li>
<li>A <a href="high-pass_filter" title="wikilink">high-pass filter</a> passes high frequencies.</li>
<li>A <a href="band-pass_filter" title="wikilink">band-pass filter</a> passes a band (range) of frequencies.</li>
<li>A <a href="band-stop_filter" title="wikilink">band-stop filter</a> passes high and low frequencies outside of a specified band.</li>
<li>A <a href="notch_filter" title="wikilink">notch filter</a> has a null response at a particular frequency. This function may be combined with one of the above responses.</li>
<li>An <a href="all-pass_filter" title="wikilink">all-pass filter</a> passes all frequencies equally well, but alters the phase relationship among them.</li>
<li>An equalization filter is not designed to fully pass or block any frequency, but instead to gradually vary the amplitude response as a function of frequency: filters used as <a class="uri" href="pre-emphasis" title="wikilink">pre-emphasis</a> filters, <a href="Equalization_(audio)" title="wikilink">equalizers</a>, or <a href="tone_control" title="wikilink">tone controls</a> are good examples.</li>
</ul>
<h3 id="fir-transfer-functions">FIR transfer functions</h3>

<p>Meeting a frequency response requirement with an FIR filter uses relatively straightforward procedures. In the most basic form, the desired frequency response itself can be sampled with a resolution of 

<math display="inline" id="Linear_filter:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta f
  </annotation>
 </semantics>
</math>

 and fourier transformed to the time domain. This obtains the filter coefficients <em>h<sub>i</sub></em>, which implements a zero phase FIR filter that matches the frequency response at the sampled frequencies used. To better match a desired response, 

<math display="inline" id="Linear_filter:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta f
  </annotation>
 </semantics>
</math>

 must be reduced. However the duration of the filter's impulse response, and the number of terms that must be summed for each output value (according to the above discrete time convolution) is given by 

<math display="inline" id="Linear_filter:7">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mpadded width="+1.7pt">
       <mi>f</mi>
      </mpadded>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>f</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=1/(\Delta f\,T)
  </annotation>
 </semantics>
</math>

 where <em>T</em> is the <a href="sampling_period" title="wikilink">sampling period</a> of the discrete time system (N-1 is also termed the <em>order</em> of an FIR filter). Thus the complexity of a digital filter and the computing time involved, grows inversely with 

<math display="inline" id="Linear_filter:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta f
  </annotation>
 </semantics>
</math>

, placing a higher cost on filter functions that better approximate the desired behavior. For the same reason, filter functions whose critical response is at lower frequencies (compared to the <a href="sampling_frequency" title="wikilink">sampling frequency</a> <em>1/T</em>) require a higher order, more computationally intensive FIR filter. An IIR filter can thus be much more efficient in such cases.</p>

<p>Elsewhere the reader may find further discussion of design methods for <a href="FIR_filter#Filter_design" title="wikilink">practical FIR filter design</a>.</p>
<h3 id="iir-transfer-functions">IIR transfer functions</h3>

<p>Since classical analog filters are IIR filters, there has been a long history of studying the range of possible transfer functions implementing various of the above desired filter responses in continuous time systems. Using <a href="Bilinear_transform" title="wikilink">transforms</a> it is possible to convert these continuous time frequency responses to ones that are implemented in discrete time, for use in digital IIR filters. The complexity of any such filter is given by the <em>order</em> N, which describes the order of the <a href="rational_function" title="wikilink">rational function</a> describing the frequency response. The order N is of particular importance in analog filters, because an N<sup>th</sup> order electronic filter requires N reactive elements (capacitors and/or inductors) to implement. If a filter is implemented using, for instance, <a href="Active_filter" title="wikilink">biquad stages</a> using <a href="op-amp" title="wikilink">op-amps</a>, N/2 stages are needed. In a digital implementation, the number of computations performed per sample is proportional to N. Thus the mathematical problem is to obtain the best approximation (in some sense) to the desired response using a smaller N, as we shall now illustrate.</p>

<p>Below are the frequency responses of several standard filter functions that approximate a desired response, optimized according to some criterion. These are all fifth-order low-pass filters, designed for a cutoff frequency of .5 in normalized units. Frequency responses are shown for the <a href="Butterworth_filter" title="wikilink">Butterworth</a>, <a href="Chebyshev_filter" title="wikilink">Chebyshev</a>, <a href="chebyshev_filter#Type_II_Chebyshev_filters" title="wikilink">inverse Chebyshev</a>, and <a href="elliptic_filter" title="wikilink">elliptic filters</a>.</p>
<figure><b>(Figure)</b>
<figcaption>Electronic linear filters.svg</figcaption>
</figure>

<p>As is clear from the image, the elliptic filter is sharper than the others, but at the expense of <a href="ripple_(filters)" title="wikilink">ripples</a> in both its passband and stopband. The Butterworth filter has the poorest transition but has a more even response, avoiding ripples in either the passband or stopband. A <a href="Bessel_filter" title="wikilink">Bessel filter</a> (not shown) has an even poorer transition in the frequency domain, but maintains the best phase fidelity of a waveform. Different applications emphasize different design requirements, leading to different choices among these (and other) optimizations, or requiring a filter of a higher order.</p>
<figure><b>(Figure)</b>
<figcaption>Low-pass filter implemented with a Sallen–Key topology</figcaption>
</figure>
<h2 id="example-implementations">Example implementations</h2>

<p>A popular circuit implementing a second order active R-C filter is the <a href="Sallen_Key_filter" title="wikilink">Sallen-Key</a> design, whose schematic diagram is shown here. This topology can be adapted to produce low-pass, band-pass, and high pass filters.</p>
<figure><b>(Figure)</b>
<figcaption>A discrete-time FIR filter of order <em>N</em>. The top part is an <em>N</em>-sample delay line; each delay step is denoted <em>z</em><sup>−1</sup>.</figcaption>
</figure>

<p>An N<sup>th</sup> order FIR filter can be implemented in a discrete time system using a computer program or specialized hardware in which the input signal is subject to N delay stages. The output of the filter is formed as the weighted sum of those delayed signals, as is depicted in the accompanying signal flow diagram. The response of the filter depends on the weighting coefficients denoted <em>b<sub>0</sub></em>, <em>b<sub>1</sub></em>, .... <em>b<sub>N</sub></em>. For instance, if all of the coefficients were equal to unity, a so-called <a href="boxcar_function" title="wikilink">boxcar function</a>, then it would implement a low-pass filter with a low frequency gain of N+1 and a frequency response given by the <a href="sinc_function" title="wikilink">sinc function</a>. Superior shapes for the frequency response can be obtained using coefficients derived from a more sophisticated design procedure.</p>
<h2 id="mathematics-of-filter-design">Mathematics of filter design</h2>

<p><a href="LTI_system_theory" title="wikilink">LTI system theory</a> describes linear <em><a class="uri" href="time-invariant" title="wikilink">time-invariant</a></em> (LTI) filters of all types. LTI filters can be completely described by their <a href="frequency_response" title="wikilink">frequency response</a> and <a href="phase_response" title="wikilink">phase response</a>, the specification of which uniquely defines their <a href="impulse_response" title="wikilink">impulse response</a>, and <em>vice versa</em>. From a mathematical viewpoint, continuous-time IIR LTI filters may be described in terms of linear <a href="differential_equation" title="wikilink">differential equations</a>, and their impulse responses considered as <a href="Green's_function" title="wikilink">Green's functions</a> of the equation. Continuous-time LTI filters may also be described in terms of the <a href="Laplace_transform" title="wikilink">Laplace transform</a> of their impulse response, which allows all of the characteristics of the filter to be analyzed by considering the pattern of <a href="pole_(complex_analysis)" title="wikilink">poles</a> and <a href="zero_(complex_analysis)" title="wikilink">zeros</a> of their Laplace transform in the <a href="complex_plane" title="wikilink">complex plane</a>. Similarly, discrete-time LTI filters may be analyzed via the <a class="uri" href="Z-transform" title="wikilink">Z-transform</a> of their impulse response.</p>

<p>Before the advent of computer filter synthesis tools, graphical tools such as <a href="Bode_plot" title="wikilink">Bode plots</a> and <a href="Nyquist_plot" title="wikilink">Nyquist plots</a> were extensively used as design tools. Even today, they are invaluable tools to understanding filter behavior. Reference books<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> had extensive plots of frequency response, phase response, group delay, and impulse response for various types of filters, of various orders. They also contained tables of values showing how to implement such filters as RLC ladders - very useful when amplifying elements were expensive compared to passive components. Such a ladder can also be designed to have minimal sensitivity to component variation<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> a property hard to evaluate without computer tools.</p>

<p>Many different analog filter designs have been developed, each trying to optimise some feature of the system response. For practical filters, a custom design is sometimes desirable, that can offer the best tradeoff between different design criteria, which may include component count and cost, as well as filter response characteristics.</p>

<p>These descriptions refer to the <em>mathematical</em> properties of the filter (that is, the frequency and phase response). These can be <em>implemented</em> as analog circuits (for instance, using a <a href="Sallen_Key_filter" title="wikilink">Sallen Key filter</a> topology, a type of <a href="active_filter" title="wikilink">active filter</a>), or as algorithms in <a href="digital_signal_processing" title="wikilink">digital signal processing</a> systems.</p>

<p>Digital filters are much more flexible to synthesize and use than analog filters, where the constraints of the design permits their use. Notably, there is no need to consider component tolerances, and very high Q levels may be obtained.</p>

<p>FIR digital filters may be implemented by the direct <a class="uri" href="convolution" title="wikilink">convolution</a> of the desired impulse response with the input signal. They can easily be designed to give a <a href="matched_filter" title="wikilink">matched filter</a> for any arbitrary pulse shape.</p>

<p>IIR digital filters are often more difficult to design, due to problems including dynamic range issues, <a href="quantization_noise" title="wikilink">quantization noise</a> and instability. Typically digital IIR filters are designed as a series of <a href="digital_biquad_filter" title="wikilink">digital biquad filters</a>.</p>

<p>All low-pass second-order continuous-time filters have a <a href="transfer_function" title="wikilink">transfer function</a> given by</p>

<p>

<math display="block" id="Linear_filter:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>K</mi>
      <msubsup>
       <mi>ω</mi>
       <mn>0</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mrow>
      <msup>
       <mi>s</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msub>
         <mi>ω</mi>
         <mn>0</mn>
        </msub>
        <mi>Q</mi>
       </mfrac>
       <mi>s</mi>
      </mrow>
      <mo>+</mo>
      <msubsup>
       <mi>ω</mi>
       <mn>0</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>Q</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)=\frac{K\omega^{2}_{0}}{s^{2}+\frac{\omega_{0}}{Q}s+\omega^{2}_{0}}.
  </annotation>
 </semantics>
</math>

</p>

<p>All band-pass second-order continuous-time have a transfer function given by</p>

<p>

<math display="block" id="Linear_filter:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>K</mi>
      <mfrac>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
       <mi>Q</mi>
      </mfrac>
      <mi>s</mi>
     </mrow>
     <mrow>
      <msup>
       <mi>s</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msub>
         <mi>ω</mi>
         <mn>0</mn>
        </msub>
        <mi>Q</mi>
       </mfrac>
       <mi>s</mi>
      </mrow>
      <mo>+</mo>
      <msubsup>
       <mi>ω</mi>
       <mn>0</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>Q</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>Q</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)=\frac{K\frac{\omega_{0}}{Q}s}{s^{2}+\frac{\omega_{0}}{Q}s+\omega^{2}_{0}}.
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<ul>
<li><em>K</em> is the gain (low-pass DC gain, or band-pass mid-band gain) (<em>K</em> is 1 for passive filters)</li>
<li><em>Q</em> is the <a href="Q_factor" title="wikilink">Q factor</a></li>
<li>

<math display="inline" id="Linear_filter:11">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}
  </annotation>
 </semantics>
</math>

 is the center frequency</li>
<li>

<math display="inline" id="Linear_filter:12">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>σ</mi>
    <mo>+</mo>
    <mrow>
     <mi>j</mi>
     <mi>ω</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\sigma+j\omega
  </annotation>
 </semantics>
</math>

 is the complex frequency</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Filter_design" title="wikilink">Filter design</a></li>
<li><a href="Laplace_transform" title="wikilink">Laplace transform</a></li>
<li><a href="Green's_function" title="wikilink">Green's function</a></li>
<li><a href="Prototype_filter" title="wikilink">Prototype filter</a></li>
<li><a class="uri" href="Z-transform" title="wikilink">Z-transform</a></li>
<li><a href="System_theory" title="wikilink">System theory</a>
<ul>
<li><a href="LTI_system_theory" title="wikilink">LTI system theory</a></li>
</ul></li>
<li><a href="Nonlinear_filter" title="wikilink">Nonlinear filter</a></li>
<li><a href="Wiener_filter" title="wikilink">Wiener filter</a></li>
<li><a href="Gabor_filter" title="wikilink">Gabor filter</a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li><a href="http://www.national.com/an/AN/AN-779.pdf">National Semiconductor AN-779</a> application note describing analog filter theory</li>
<li><a href="http://www.latticesemi.com/lit/docs/appnotes/pac/an6017.pdf">Lattice AN6017</a> application note comparing and contrasting filters (in order of damping coefficient, from lower to higher values): Gaussian, Bessel, linear phase, Butterworth, Chebyshev, Legendre, elliptic. (with graphs).</li>
<li><a href="http://www.analog.com/Wizard/filter/detail_filter_help.pdf">USING THE ANALOG DEVICES ACTIVE FILTER DESIGN TOOL</a>: a similar application note from <a href="Analog_Devices" title="wikilink">Analog Devices</a> with extensive graphs, active RC filter topologies, and tables for practical design.</li>
<li>[<a class="uri" href="http://books.google.com/books?id=l7oC-LJwyegC&amp;pg">http://books.google.com/books?id=l7oC-LJwyegC&amp;pg;</a>;=PA267&amp;lpg;=PA267&amp;dq;=%22legendre+filter%22&amp;source;=web&amp;ots;=xRLtCLfslz&amp;sig;=0Nw2zhb8Y7FSrylN3wDaoIMkekQ#PPA238,M1 "Design and Analysis of Analog Filters: A Signal Processing Perspective"] by L. D. Paarmann</li>
</ul>

<p>"</p>

<p><a href="Category:Linear_filters" title="wikilink">*</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">However, there are a few cases in which FIR filters directly process analog signals, involving non-feedback topologies and analog delay elements. An example is the discrete-time <em><a href="analog_sampled_filter" title="wikilink">analog sampled filter</a></em>, implemented using a so-called <a href="bucket-brigade_device" title="wikilink">bucket-brigade device</a> clocked at a certain sampling rate, outputting copies of the input signal at different delays that can be combined with some weighting to realize an FIR filter. Electromechanical filters such as <a href="Electronic_filter#SAW_filters" title="wikilink">SAW filters</a> can likewise implement FIR filter responses; these operate in continuous time and can thus be designed for higher frequencies.<a href="#fnref1">↩</a></li>
<li id="fn2">Outside of trivial cases, stable IIR filters with zero phase response are possible if they are not causal (and thus are unusable in real-time applications) or implementing transfer functions classified as unstable or "marginally stable" such as a <a href="double_integrator" title="wikilink">double integrator</a>.<a href="#fnref2">↩</a></li>
<li id="fn3">A. Zverev, <em>Handbook of Filter Synthesis</em>, John Wiley and Sons, 1967, ISBN 0-471-98680-1<a href="#fnref3">↩</a></li>
<li id="fn4">Normally, computing sensitivities is a very laborious operation. But in the special case of an LC ladder driven by an impedance and terminated by a resistor, there is a neat argument showing the sensitivities are small. In such as case, the transmission at the maximum frequency(s) transfers the maximal possible energy to the output load, as determined by the physics of the source and load impedances. Since this point is a maximum, <em>all</em> derivatives with respect to <em>all</em> component values must be zero, since the result of changing <em>any</em> component value in <em>any</em> direction can only result in a reduction. This result only strictly holds true at the peaks of the response, but is roughly true at nearby points as well.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
