<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1381">Shortest path problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shortest path problem</h1>
<hr/>

<p>  In <a href="graph_theory" title="wikilink">graph theory</a>, the <strong>shortest path problem</strong> is the problem of finding a <a href="path_(graph_theory)" title="wikilink">path</a> between two <a href="vertex_(graph_theory)" title="wikilink">vertices</a> (or nodes) in a <a href="graph_(mathematics)" title="wikilink">graph</a> such that the sum of the <a href="Glossary_of_graph_theory#Weighted_graphs_and_networks" title="wikilink">weights</a> of its constituent edges is minimized.</p>

<p>This is analogous to the problem of finding the shortest path between two intersections on a road map: the graph's vertices correspond to intersections and the edges correspond to road segments, each weighted by the length of its road segment.</p>
<h2 id="definition">Definition</h2>

<p>The shortest path problem can be defined for <a href="Graph_(mathematics)" title="wikilink">graphs</a> whether <a href="Graph_(mathematics)#Undirected_graph" title="wikilink">undirected</a>, <a href="Graph_(mathematics)#Directed_graph" title="wikilink">directed</a>, or <a href="Mixed_graph" title="wikilink">mixed</a>. It is defined here for undirected graphs; for directed graphs the definition of path requires that consecutive vertices be connected by an appropriate directed edge.</p>

<p>Two vertices are adjacent when they are both incident to a common edge. A <a href="Path_(graph_theory)" title="wikilink">path</a> in an undirected graph is a <a class="uri" href="sequence" title="wikilink">sequence</a> of vertices 

<math display="inline" id="Shortest_path_problem:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>×</mo>
    <mi>V</mi>
    <mo>×</mo>
    <mi mathvariant="normal">…</mi>
    <mo>×</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>P</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>V</ci>
      <ci>normal-…</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(v_{1},v_{2},\ldots,v_{n})\in V\times V\times\ldots\times V
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Shortest_path_problem:1">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 is adjacent to 

<math display="inline" id="Shortest_path_problem:2">
 <semantics>
  <msub>
   <mi>v</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i+1}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Shortest_path_problem:3">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i<n
  </annotation>
 </semantics>
</math>


. Such a path 

<math display="inline" id="Shortest_path_problem:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is called a path of length 

<math display="inline" id="Shortest_path_problem:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Shortest_path_problem:6">
 <semantics>
  <msub>
   <mi>v</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Shortest_path_problem:7">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{n}
  </annotation>
 </semantics>
</math>

. (The 

<math display="inline" id="Shortest_path_problem:8">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>


 are variables; their numbering here relates to their position in the sequence and needs not to relate to any canonical labeling of the vertices.)</p>

<p>Let 

<math display="inline" id="Shortest_path_problem:9">
 <semantics>
  <msub>
   <mi>e</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i,j}
  </annotation>
 </semantics>
</math>

 be the edge incident to both 

<math display="inline" id="Shortest_path_problem:10">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shortest_path_problem:11">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

. Given a <a href="Function_(mathematics)#Real-valued_functions" title="wikilink">real-valued</a> weight function 

<math display="inline" id="Shortest_path_problem:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>E</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:E\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

, and an undirected (simple) graph 

<math display="inline" id="Shortest_path_problem:13">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


, the shortest path from 

<math display="inline" id="Shortest_path_problem:14">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Shortest_path_problem:15">
 <semantics>
  <msup>
   <mi>v</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>v</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}
  </annotation>
 </semantics>
</math>

 is the path 

<math display="inline" id="Shortest_path_problem:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(v_{1},v_{2},\ldots,v_{n})
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Shortest_path_problem:17">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}=v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shortest_path_problem:18">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>v</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{n}=v^{\prime}
  </annotation>
 </semantics>
</math>


) that over all possible 

<math display="inline" id="Shortest_path_problem:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 minimizes the sum 

<math display="inline" id="Shortest_path_problem:20">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>e</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <list>
       <ci>i</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n-1}f(e_{i,i+1}).
  </annotation>
 </semantics>
</math>

 When each edge in the graph has unit weight or 

<math display="inline" id="Shortest_path_problem:21">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>E</ci>
     <set>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:E\rightarrow\{1\}
  </annotation>
 </semantics>
</math>

, this is equivalent to finding the path with fewest edges.</p>

<p>The problem is also sometimes called the <strong>single-pair shortest path problem</strong>, to distinguish it from the following variations:</p>
<ul>
<li>The <strong>single-source shortest path problem</strong>, in which we have to find shortest paths from a source vertex <em>v</em> to all other vertices in the graph.</li>
<li>The <strong>single-destination shortest path problem</strong>, in which we have to find shortest paths from all vertices in the directed graph to a single destination vertex <em>v</em>. This can be reduced to the single-source shortest path problem by reversing the arcs in the directed graph.</li>
<li>The <strong>all-pairs shortest path problem</strong>, in which we have to find shortest paths between every pair of vertices <em>v</em>, ''v' '' in the graph.</li>
</ul>

<p>These generalizations have significantly more efficient algorithms than the simplistic approach of running a single-pair shortest path algorithm on all relevant pairs of vertices.</p>
<h2 id="algorithms">Algorithms</h2>

<p>The most important algorithms for solving this problem are:</p>
<ul>
<li><a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> solves the single-source shortest path problem.</li>
<li><a href="Bellman–Ford_algorithm" title="wikilink">Bellman–Ford algorithm</a> solves the single-source problem if edge weights may be negative.</li>
<li><a href="A*_search_algorithm" title="wikilink">A* search algorithm</a> solves for single pair shortest path using heuristics to try to speed up the search.</li>
<li><a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a> solves all pairs shortest paths.</li>
<li><a href="Johnson's_algorithm" title="wikilink">Johnson's algorithm</a> solves all pairs shortest paths, and may be faster than Floyd–Warshall on <a href="sparse_graph" title="wikilink">sparse graphs</a>.</li>
<li><a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> solves the shortest stochastic path problem with an additional probabilistic weight on each node.</li>
</ul>

<p>Additional algorithms and associated evaluations may be found in Cherkassky et al.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="road-networks">Road networks</h2>

<p>A road network can be considered as a graph with positive weights. The nodes represent road junctions and each edge of the graph is associated with a road segment between two junctions. The weight of an edge may correspond to the length of the associated road segment, the time needed to traverse the segment or the cost of traversing the segment. Using directed edges it is also possible to model one-way streets. Such graphs are special in the sense that some edges are more important than others for long distance travel (e.g. highways). This property has been formalized using the notion of highway dimension.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> There are a great number of algorithms that exploit this property and are therefore able to compute the shortest path a lot quicker than would be possible on general graphs.</p>

<p>All of these algorithms work in two phases. In the first phase, the graph is preprocessed without knowing the source or target node. This phase may take several days for realistic data and some techniques. The second phase is the query phase. In this phase, source and target node are known. The running time of the second phase is generally less than a second. The idea is that the road network is static, so the preprocessing phase can be done once and used for a large number of queries on the same road network.</p>

<p>The algorithm with the fastest known query time is called hub labeling and is able to compute shortest path on the road networks of Europe or the USA in a fraction of a microsecond.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Other techniques that have been used are:</p>
<ul>
<li>ALT</li>
<li>Arc Flags</li>
<li><a href="Contraction_hierarchies" title="wikilink">Contraction hierarchies</a></li>
<li>Transit Node Routing</li>
<li>Reach based Pruning</li>
<li>Labeling</li>
</ul>
<h2 id="single-source-shortest-paths">Single-source shortest paths</h2>
<h3 id="undirected-graphs">Undirected graphs</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Weights</p></th>
<th style="text-align: left;">
<p>Time complexity</p></th>
<th style="text-align: left;">
<p>Author</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>ℝ<sub>+</sub></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em> + <em>V</em> log <em>V</em>)</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ℕ</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em>)</p></td>
<td style="text-align: left;">
<p>Thorup<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (requires constant-time multiplication).</p></td>
</tr>
</tbody>
</table>
<h3 id="directed-unweighted-graphs">Directed unweighted graphs</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Algorithm</p></th>
<th style="text-align: left;">
<p>Time complexity</p></th>
<th style="text-align: left;">
<p>Author</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Breadth-first_search" title="wikilink">Breadth-first search</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em>)</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="directed-acyclic-graphs">Directed acyclic graphs</h3>

<p>An algorithm using <a href="Topological_sorting#Application_to_shortest_path_finding" title="wikilink">topological sorting</a> can solve the single-source shortest path problem in linear time, 

<math display="inline" id="Shortest_path_problem:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mo>+</mo>
     <mi>V</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <plus></plus>
     <ci>E</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Θ(E+V)
  </annotation>
 </semantics>
</math>

, in weighted DAGs.</p>
<h3 id="directed-graphs-with-nonnegative-weights">Directed graphs with nonnegative weights</h3>

<p>The following table is taken from Schrijver (2004).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> A green background indicates an asymptotically best bound in the table.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Algorithm</p></th>
<th style="text-align: left;">
<p>Time complexity</p></th>
<th style="text-align: left;">
<p>Author</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>2</sup><em>EL</em>)</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Bellman–Ford_algorithm" title="wikilink">Bellman–Ford algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>VE</em>)</p></td>
<td style="text-align: left;">

<p>, </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>2</sup> log <em>V</em>)</p></td>
<td style="text-align: left;">

<p>, , Minty (cf. ), </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> with list</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>2</sup>)</p></td>
<td style="text-align: left;">

<p>, </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> with modified <a href="binary_heap" title="wikilink">binary heap</a></p></td>
<td style="text-align: left;">
<p><em>O</em>((<em>E</em> + <em>V</em>) log <em>V</em>)</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>. . .</p></td>
<td style="text-align: left;">
<p>. . .</p></td>
<td style="text-align: left;">
<p>. . .</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Dijkstra's algorithm with <a href="Fibonacci_heap" title="wikilink">Fibonacci heap</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em> + <em>V</em> log <em>V</em>)</p></td>
<td style="text-align: left;">

<p>, </p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em> log log <em>L</em>)</p></td>
<td style="text-align: left;">

<p>, </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Gabow's_algorithm_(single-source_shortest_paths)" title="wikilink">Gabow's algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em> log<sub><em>E</em>/<em>V</em></sub> <em>L</em>)</p></td>
<td style="text-align: left;">

<p>, </p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em> + <em>V</em>√

<math display="inline" id="Shortest_path_problem:23">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>o</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{log}{L}
  </annotation>
 </semantics>
</math>


)</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="planar-directed-graphs-with-nonnegative-weights">Planar directed graphs with nonnegative weights</h3>
<h3 id="directed-graphs-with-arbitrary-weights">Directed graphs with arbitrary weights</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Algorithm</p></th>
<th style="text-align: left;">
<p>Time complexity</p></th>
<th style="text-align: left;">
<p>Author</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Bellman–Ford_algorithm" title="wikilink">Bellman–Ford algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>VE</em>)</p></td>
<td style="text-align: left;">

<p>, </p></td>
</tr>
</tbody>
</table>
<h3 id="planar-directed-graphs-with-arbitrary-weights">Planar directed graphs with arbitrary weights</h3>
<h2 id="all-pairs-shortest-paths">All-pairs shortest paths</h2>

<p>The all-pairs shortest path problem finds the shortest paths between every pair of vertices 

<math display="inline" id="Shortest_path_problem:24">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Shortest_path_problem:25">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in the graph. The all-pairs shortest paths problem for unweighted directed graphs was introduced by , who observed that it could be solved by a linear number of matrix multiplications that takes a total time of <mtpl></mtpl>.</p>
<h3 id="undirected-graph">Undirected graph</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Weights</p></th>
<th style="text-align: left;">
<p>Time complexity</p></th>
<th style="text-align: left;">
<p>Algorithm</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>ℝ<sub>+</sub></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>3</sup>)</p></td>
<td style="text-align: left;">
<p><a href="Floyd-Warshall_algorithm" title="wikilink">Floyd-Warshall algorithm</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ℝ<sub>+</sub></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>EV</em> log α(<em>E</em>,<em>V</em>))</p></td>
<td style="text-align: left;">
<p>Pettie-Ramachandran<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>ℕ</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>EV</em>)</p></td>
<td style="text-align: left;">
<p>Thorup<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> (requires constant-time multiplication).</p></td>
</tr>
</tbody>
</table>
<h3 id="directed-graph">Directed graph</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Weights</p></th>
<th style="text-align: left;">
<p>Time complexity</p></th>
<th style="text-align: left;">
<p>Algorithm</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>ℝ (no negative cycles)</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>3</sup>)</p></td>
<td style="text-align: left;">
<p><a href="Floyd-Warshall_algorithm" title="wikilink">Floyd-Warshall algorithm</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ℝ (no negative cycles)</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>EV</em> + <em>V</em><sup>2</sup> log <em>V</em>)</p></td>
<td style="text-align: left;">
<p><a href="Johnson's_algorithm" title="wikilink">Johnson-Dijkstra</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>ℝ (no negative cycles)</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>EV</em> + <em>V</em><sup>2</sup> log log <em>V</em>)</p></td>
<td style="text-align: left;">
<p>Johnson-Pettie<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ℕ</p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>EV</em> + <em>V</em><sup>2</sup> log log <em>V</em>)</p></td>
<td style="text-align: left;">
<p>Hagerup<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p></td>
</tr>
</tbody>
</table>
<h2 id="applications">Applications</h2>

<p>Shortest path algorithms are applied to automatically find directions between physical locations, such as driving directions on <a href="web_mapping" title="wikilink">web mapping</a> websites like <a class="uri" href="MapQuest" title="wikilink">MapQuest</a> or <a href="Google_Maps" title="wikilink">Google Maps</a>. For this application fast specialized algorithms are available.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>If one represents a nondeterministic <a href="abstract_machine" title="wikilink">abstract machine</a> as a graph where vertices describe states and edges describe possible transitions, shortest path algorithms can be used to find an optimal sequence of choices to reach a certain goal state, or to establish lower bounds on the time needed to reach a given state. For example, if vertices represent the states of a puzzle like a <a href="Rubik's_Cube" title="wikilink">Rubik's Cube</a> and each directed edge corresponds to a single move or turn, shortest path algorithms can be used to find a solution that uses the minimum possible number of moves.</p>

<p>In a networking or telecommunications mindset, this shortest path problem is sometimes called the min-delay path problem and usually tied with a <a href="widest_path_problem" title="wikilink">widest path problem</a>. For example, the algorithm may seek the shortest (min-delay) widest path, or widest shortest (min-delay) path.</p>

<p>A more lighthearted application is the games of "<a href="six_degrees_of_separation" title="wikilink">six degrees of separation</a>" that try to find the shortest path in graphs like movie stars appearing in the same film.</p>

<p>Other applications, often studied in <a href="operations_research" title="wikilink">operations research</a>, include plant and facility layout, <a class="uri" href="robotics" title="wikilink">robotics</a>, <a class="uri" href="transportation" title="wikilink">transportation</a>, and <a href="Very-large-scale_integration" title="wikilink">VLSI</a> design".<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="related-problems">Related problems</h2>

<p>For shortest path problems in <a href="computational_geometry" title="wikilink">computational geometry</a>, see <a href="Euclidean_shortest_path" title="wikilink">Euclidean shortest path</a>.</p>

<p>The <a href="traveling_salesman_problem" title="wikilink">travelling salesman problem</a> is the problem of finding the shortest path that goes through every vertex exactly once, and returns to the start. Unlike the shortest path problem, which can be solved in polynomial time in graphs without negative cycles, the travelling salesman problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> and, as such, is believed not to be efficiently solvable for large sets of data (see <a href="P_=_NP_problem" title="wikilink">P = NP problem</a>). The problem of <a href="Longest_path_problem" title="wikilink">finding the longest path</a> in a graph is also NP-complete.</p>

<p>The <a href="Canadian_traveller_problem" title="wikilink">Canadian traveller problem</a> and the stochastic shortest path problem are generalizations where either the graph isn't completely known to the mover, changes over time, or where actions (traversals) are probabilistic.</p>

<p>The shortest multiple disconnected path <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> is a representation of the primitive path network within the framework of <a href="Reptation_theory" title="wikilink">Reptation theory</a>.</p>

<p>The <a href="widest_path_problem" title="wikilink">widest path problem</a> seeks a path so that the minimum label of any edge is as large as possible.</p>
<h2 id="linear-programming-formulation">Linear programming formulation</h2>

<p>There is a natural <a href="linear_programming" title="wikilink">linear programming</a> formulation for the shortest path problem, given below. It is very simple compared to most other uses of linear programs in <a href="discrete_optimization" title="wikilink">discrete optimization</a>, however it illustrates connections to other concepts.</p>

<p>Given a directed graph (<em>V</em>, <em>A</em>) with source node <em>s</em>, target node <em>t</em>, and cost <em>w<sub>ij</sub></em> for each edge (<em>i</em>, <em>j</em>) in <em>A</em>, consider the program with variables <em>x<sub>ij</sub></em></p>
<dl>
<dd>minimize 

<math display="inline" id="Shortest_path_problem:26">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mo>∈</mo>
     <mi>A</mi>
    </mrow>
   </msub>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{ij\in A}w_{ij}x_{ij}
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="Shortest_path_problem:27">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\geq 0
  </annotation>
 </semantics>
</math>

 and for all <em>i</em>, 

<math display="inline" id="Shortest_path_problem:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>j</mi>
       <mi>i</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>i</mi>
         </mrow>
         <mo>=</mo>
         <mi>s</mi>
        </mrow>
        <mo>;</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>i</mi>
         </mrow>
         <mo>=</mo>
         <mi>t</mi>
        </mrow>
        <mo>;</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>i</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}x_{ij}-\sum_{j}x_{ji}=\begin{cases}1,&\text{if }i=s;\\
-1,&\text{if }i=t;\\
0,&\text{ otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>



</dd>
</dl>

<p>The intuition behind this is that 

<math display="inline" id="Shortest_path_problem:29">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}
  </annotation>
 </semantics>
</math>

 is an indicator variable for whether edge (<em>i</em>, <em>j</em>) is part of the shortest path: 1 when it is, and 0 if it is not. We wish to select the set of edges with minimal weight, subject to the constraint that this set forms a path from <em>s</em> to <em>t</em> (represented by the equality constraint: for all vertices except <em>s</em> and <em>t</em> the number of incoming and outcoming edges that are part of the path must be the same (i.e., that it should be a path from s to t).</p>

<p>This LP has the special property that it is integral; more specifically, every <a href="Linear_programming#Theory" title="wikilink">basic optimal solution</a> (when one exists) has all variables equal to 0 or 1, and the set of edges whose variables equal 1 form an <em>s</em>-<em>t</em> <a class="uri" href="dipath" title="wikilink">dipath</a>. See Ahuja et al.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> for one proof, although the origin of this approach dates back to mid-20th century.</p>

<p>The dual for this linear program is</p>
<dl>
<dd>maximize <em>y</em><sub><em>t</em></sub> − <em>y</em><sub>s</sub> subject to for all <em>ij</em>, <em>y</em><sub><em>j</em></sub> − <em>y</em><sub><em>i</em></sub> ≤ <em>w</em><sub><em>ij</em></sub>
</dd>
</dl>

<p>and feasible duals correspond to the concept of a <a href="consistent_heuristic" title="wikilink">consistent heuristic</a> for the <a href="A-star_algorithm" title="wikilink">A* algorithm</a> for shortest paths. For any feasible dual <em>y</em> the <a href="reduced_cost" title="wikilink">reduced costs</a> 

<math display="inline" id="Shortest_path_problem:30">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}_{ij}=w_{ij}-y_{j}+y_{i}
  </annotation>
 </semantics>
</math>

 are nonnegative and <a href="A-star_algorithm" title="wikilink">A*</a> essentially runs <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> on these reduced costs.</p>
<h2 id="general-algebraic-framework-on-semirings-the-algebraic-path-problem">General algebraic framework on semirings: the algebraic path problem</h2>

<p>Many problems can be framed as a form of the shortest path for some suitably substituted notions of addition along a path and taking the minimum. The general approach to these is to consider the two operations to be those of a <a class="uri" href="semiring" title="wikilink">semiring</a>. Semiring multiplication is done along the path, and the addition is between paths. This general framework is known as the <a href="algebraic_path_problem" title="wikilink">algebraic path problem</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Most of the classic shortest-path algorithms (and new ones) can be formulated as solving linear systems over such algebraic structures.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>More recently, an even more general framework for solving these (and much less obviously related problems) has been developed under the banner of <a href="valuation_algebra" title="wikilink">valuation algebras</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Pathfinding" title="wikilink">Pathfinding</a></li>
<li><a href="IEEE_802.1aq" title="wikilink">IEEE 802.1aq</a></li>
<li><a href="Flow_network" title="wikilink">Flow network</a></li>
<li><a href="Shortest_path_tree" title="wikilink">Shortest path tree</a></li>
<li><a href="Euclidean_shortest_path" title="wikilink">Euclidean shortest path</a></li>
<li><a href="Min-plus_matrix_multiplication" title="wikilink">Min-plus matrix multiplication</a></li>
<li><a href="Bidirectional_search" title="wikilink">Bidirectional search</a>, an algorithm that finds the shortest path between two vertices on a directed graph</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Network_theory" title="wikilink">Category:Network theory</a> <a href="Category:Polynomial-time_problems" title="wikilink">Category:Polynomial-time problems</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">Abraham, Ittai; Fiat, Amos; <a href="Andrew_V._Goldberg" title="wikilink">Goldberg, Andrew V.</a>; Werneck, Renato F. <a href="http://research.microsoft.com/pubs/115272/soda10.pdf%20research.microsoft.com/pubs/115272/soda10.pdf">"Highway Dimension, Shortest Paths, and Provably Efficient Algorithms"</a>. ACM-SIAM Symposium on Discrete Algorithms, pages 782-793, 2010.<a href="#fnref2">↩</a></li>
<li id="fn3">Abraham, Ittai; Delling, Daniel; <a href="Andrew_V._Goldberg" title="wikilink">Goldberg, Andrew V.</a>; Werneck, Renato F. <a href="http://research.microsoft.com/pubs/142356/HL-TR.pdf">research.microsoft.com/pubs/142356/HL-TR.pdf "A Hub-Based Labeling Algorithm for Shortest Paths on Road Networks"</a>. Symposium on Experimental Algorithms, pages 230-241, 2011.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"> Here: vol.A, sect.7.5b, p.103<a href="#fnref5">↩</a></li>
<li id="fn6"> pp.267–276<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"> pp.47–74<a href="#fnref8">↩</a></li>
<li id="fn9"> pp.61–72<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="Mehryar_Mohri" title="wikilink">Mehryar Mohri</a>, "<a href="http://www.cs.nyu.edu/~mohri/pub/jalc.pdf">Semiring frameworks and algorithms for shortest-distance problems</a>", <a href="Journal_of_Automata,_Languages_and_Combinatorics" title="wikilink">Journal of Automata, Languages and Combinatorics</a>, Volume 7 Issue 3, January 2002, Pages 321 - 350<a href="#fnref15">↩</a></li>
<li id="fn16"><a class="uri" href="http://www.iam.unibe.ch/~run/talks/2008-06-05-Bern-Jonczy.pdf">http://www.iam.unibe.ch/~run/talks/2008-06-05-Bern-Jonczy.pdf</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
