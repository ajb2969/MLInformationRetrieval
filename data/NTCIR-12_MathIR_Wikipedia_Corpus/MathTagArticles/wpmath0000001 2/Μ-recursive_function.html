<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="919">Μ-recursive function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Μ-recursive function</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="computer_science" title="wikilink">computer science</a>, the <strong>μ-recursive functions</strong> are a class of <a href="partial_function" title="wikilink">partial functions</a> from <a href="natural_number" title="wikilink">natural numbers</a> to <a href="natural_number" title="wikilink">natural numbers</a> that are "computable" in an intuitive sense. In fact, in <a href="Computability_theory_(computation)" title="wikilink">computability theory</a> it is shown that the μ-recursive functions are precisely the functions that can be computed by <a href="Turing_machine" title="wikilink">Turing machines</a>. The μ-recursive functions are closely related to <a href="primitive_recursive_function" title="wikilink">primitive recursive functions</a>, and their inductive definition (below) builds upon that of the primitive recursive functions. However, not every μ-recursive function is a primitive recursive function—the most famous example is the <a href="Ackermann_function" title="wikilink">Ackermann function</a>.</p>

<p>Other equivalent classes of functions are the <a href="lambda-recursive_function" title="wikilink">λ-recursive functions</a> and the functions that can be computed by <a href="Markov_algorithm" title="wikilink">Markov algorithms</a>.</p>

<p>The set of all recursive functions is known as <a href="R_(complexity)" title="wikilink">R</a> in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>.</p>
<h2 id="definition">Definition</h2>

<p>The <strong>μ-recursive functions</strong> (or <strong>partial μ-recursive functions</strong>) are partial functions that take finite tuples of natural numbers and return a single natural number. They are the smallest class of partial functions that includes the initial functions and is closed under composition, primitive recursion, and the <a href="μ_operator" title="wikilink">μ operator</a>.</p>

<p>The smallest class of functions including the initial functions and closed under composition and primitive recursion (i.e. without minimisation) is the class of <a href="primitive_recursive_functions" title="wikilink">primitive recursive functions</a>. While all primitive recursive functions are total, this is not true of partial recursive functions; for example, the minimisation of the successor function is undefined. The primitive recursive functions are a subset of the total recursive functions, which are a subset of the partial recursive functions. For example, the <a href="Ackermann_function" title="wikilink">Ackermann function</a> can be proven to be total recursive, but not primitive.</p>

<p>Initial or "basic" functions: (In the following the subscripting is per Kleene (1952) p. 219. For more about some of the various symbolisms found in the literature see <a href="#Symbolism" title="wikilink">Symbolism</a> below.)</p>
<ol>
<li><strong>Constant function</strong>: For each natural number 

<math display="inline" id="Μ-recursive_function:0">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,
  </annotation>
 </semantics>
</math>

 and every 

<math display="inline" id="Μ-recursive_function:1">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>k</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\,
  </annotation>
 </semantics>
</math>

:

<p>

<math display="block" id="Μ-recursive_function:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{k})=n\,
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd>Alternative definitions use compositions of the successor function and use a <strong>zero function</strong>, that always returns zero, in place of the constant function.
</dd>
</dl></li>
<li><strong>Successor function S:</strong>

<p>

<math display="block" id="Μ-recursive_function:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <eq></eq>
      <ci>def</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x)\stackrel{\mathrm{def}}{=}f(x)=x+1\,
  </annotation>
 </semantics>
</math>

</p></li>
<li><strong>Projection function</strong> 

<math display="inline" id="Μ-recursive_function:4">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>i</mi>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}^{k}
  </annotation>
 </semantics>
</math>

 (also called the <strong>Identity function</strong> 

<math display="inline" id="Μ-recursive_function:5">
 <semantics>
  <msubsup>
   <mi>I</mi>
   <mi>i</mi>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>i</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{i}^{k}
  </annotation>
 </semantics>
</math>

): For all natural numbers 

<math display="inline" id="Μ-recursive_function:6">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>k</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>k</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,k\,
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Μ-recursive_function:7">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq k
  </annotation>
 </semantics>
</math>

:

<p>

<math display="block" id="Μ-recursive_function:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>P</mi>
    <mi>i</mi>
    <mi>k</mi>
   </msubsup>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <eq></eq>
      <ci>def</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}^{k}\stackrel{\mathrm{def}}{=}f(x_{1},\ldots,x_{k})=x_{i}
  </annotation>
 </semantics>
</math>

.</p></li>
</ol>

<p>Operators:</p>
<ol>
<li><strong>Composition operator</strong> 

<math display="inline" id="Μ-recursive_function:9">
 <semantics>
  <mo rspace="4.2pt">∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ\,
  </annotation>
 </semantics>
</math>

 (also called the <strong>substitution operator</strong>): Given an m-ary function 

<math display="inline" id="Μ-recursive_function:10">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{1},\ldots,x_{m})\,
  </annotation>
 </semantics>
</math>

 and m k-ary functions 

<math display="inline" id="Μ-recursive_function:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>m</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1}(x_{1},\ldots,x_{k}),\ldots,g_{m}(x_{1},\ldots,x_{k})
  </annotation>
 </semantics>
</math>

:

<p>

<math display="block" id="Μ-recursive_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>g</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>g</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <eq></eq>
      <ci>def</ci>
     </apply>
     <apply>
      <compose></compose>
      <ci>h</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>m</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>h</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">1</cn>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </vector>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>m</ci>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </vector>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\circ(g_{1},\ldots,g_{m})\stackrel{\mathrm{def}}{=}f(x_{1},\ldots,x_{k})=h(g_%
{1}(x_{1},\ldots,x_{k}),\ldots,g_{m}(x_{1},\ldots,x_{k}))\,
  </annotation>
 </semantics>
</math>

.</p></li>
<li><strong>Primitive recursion operator</strong> 

<math display="inline" id="Μ-recursive_function:13">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>ρ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\,
  </annotation>
 </semantics>
</math>

: Given the k-ary function 

<math display="inline" id="Μ-recursive_function:14">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x_{1},\ldots,x_{k})\,
  </annotation>
 </semantics>
</math>

 and k+2 -ary function 

<math display="inline" id="Μ-recursive_function:15">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <vector>
     <ci>y</ci>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(y,z,x_{1},\ldots,x_{k})\,
  </annotation>
 </semantics>
</math>

:

<p>:<math>\begin{align}</math></p></li>
</ol>

<p><code>            \rho(g, h) &amp;\stackrel{\mathrm{def}}{=} f(y, x_1,\ldots, x_k) \quad {\rm where} \\</code><br/>
<code>   f(0,x_1,\ldots,x_k) &amp;= g(x_1,\ldots,x_k) \\</code><br/>
<code> f(y+1,x_1,\ldots,x_k) &amp;= h(y,f(y,x_1,\ldots,x_k),x_1,\ldots,x_k)\,\end{align}</code><code>.</code></p>
<ol>
<li><strong>Minimisation operator</strong> 

<math display="inline" id="Μ-recursive_function:16">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>μ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\,
  </annotation>
 </semantics>
</math>

: Given a (k+1)-ary total function 

<math display="inline" id="Μ-recursive_function:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(y,x_{1},\ldots,x_{k})\,
  </annotation>
 </semantics>
</math>

:

<p>:<math>\begin{align}</math></p></li>
</ol>

<p><code>         \mu(f)(x_1, \ldots, x_k) = z \stackrel{\mathrm{def}}{\iff}\ f(z, x_1, \ldots, x_k)&amp;=0\quad \text{and}\\</code><br/>
<code>            f(i, x_1, \ldots, x_k)&amp;&gt;0 \quad \text{for}\ i=0, \ldots, z-1.</code></p>

<p>\end{align}</p>

<p>#:Intuitively, minimisation seeks—beginning the search from 0 and proceeding upwards—the smallest argument that causes the function to return zero; if there is no such argument, the search never terminates.</p>

<p>The <strong>strong equality</strong> operator 

<math display="inline" id="Μ-recursive_function:18">
 <semantics>
  <mo>≃</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \simeq
  </annotation>
 </semantics>
</math>

 can be used to compare partial μ-recursive functions. This is defined for all partial functions <em>f</em> and <em>g</em> so that</p>

<p>

<math display="block" id="Μ-recursive_function:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>l</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{k})\simeq g(x_{1},\ldots,x_{l})
  </annotation>
 </semantics>
</math>

 holds if and only if for any choice of arguments either both functions are defined and their values are equal or both functions are undefined.</p>
<h2 id="equivalence-with-other-models-of-computability">Equivalence with other models of computability</h2>

<p>In the <a href="Church's_thesis" title="wikilink">equivalence of models of computability</a>, a parallel is drawn between <a href="Turing_machine" title="wikilink">Turing machines</a> that do not terminate for certain inputs and an undefined result for that input in the corresponding partial recursive function. The unbounded search operator is not definable by the rules of primitive recursion as those do not provide a mechanism for "infinite loops" (undefined values).</p>
<h2 id="normal-form-theorem">Normal form theorem</h2>

<p>A <a href="Kleene's_T_predicate#Normal_form_theorem" title="wikilink">normal form theorem</a> due to Kleene says that for each <em>k</em> there are primitive recursive functions 

<math display="inline" id="Μ-recursive_function:20">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo rspace="0.8pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(y)\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Μ-recursive_function:21">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo rspace="0.8pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <vector>
     <ci>y</ci>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(y,e,x_{1},\ldots,x_{k})\!
  </annotation>
 </semantics>
</math>

 such that for any μ-recursive function 

<math display="inline" id="Μ-recursive_function:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo rspace="0.8pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{k})\!
  </annotation>
 </semantics>
</math>

 with <em>k</em> free variables there is an <em>e</em> such that</p>

<p>

<math display="block" id="Μ-recursive_function:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mpadded width="+1.7pt">
       <mi>y</mi>
      </mpadded>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>e</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>y</ci>
      <ci>T</ci>
      <vector>
       <ci>y</ci>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{k})\simeq U(\mu y\,T(y,e,x_{1},\ldots,x_{k}))
  </annotation>
 </semantics>
</math>

. The number <em>e</em> is called an <strong>index</strong> or <strong>Gödel number</strong> for the function <em>f</em>. A consequence of this result is that any μ-recursive function can be defined using a single instance of the μ operator applied to a (total) primitive recursive function.</p>

<p>Minsky (1967) observes (as does Boolos-Burgess-Jeffrey (2002) pp. 94–95) that the U defined above is in essence the μ-recursive equivalent of the <a href="universal_Turing_machine" title="wikilink">universal Turing machine</a>:</p>
<dl>
<dd>To construct U is to write down the definition of a general-recursive function U(n, x) that correctly interprets the number n and computes the appropriate function of x. to construct U directly would involve essentially the same amount of effort, <em>and essentially the same ideas</em>, as we have invested in constructing the universal Turing machine. (italics in original, Minsky (1967) p. 189)
</dd>
</dl>
<h2 id="symbolism">Symbolism</h2>

<p>A number of different symbolisms are used in the literature. An advantage to using the symbolism is a derivation of a function by "nesting" of the operators one inside the other is easier to write in a compact form. In the following we will abbreviate the string of parameters x<sub>1</sub>, ..., x<sub>n</sub> as <strong>x</strong>:</p>
<ul>
<li><strong>Constant function</strong>: Kleene uses " C<sub>q</sub><sup>n</sup>(<strong>x</strong>) = q " and Boolos-Burgess-Jeffry (2002) (B-B-J) use the abbreviation " const<sub>n</sub>( <strong>x</strong>) = n ":</li>
</ul>
<dl>
<dd><dl>
<dd>e.g. C<sub>13</sub><sup>7</sup> ( r, s, t, u, v, w, x ) = 13
</dd>
<dd>e.g. const<sub>13</sub> ( r, s, t, u, v, w, x ) = 13
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Successor function</strong>: Kleene uses x' and S for "Successor". As "successor" is considered to be primitive, most texts use the apostrophe as follows:</li>
</ul>
<dl>
<dd><dl>
<dd>S(a) = a +1 =<sub>def</sub> a', where 1 =<sub>def</sub> 0', 2 =<sub>def</sub> 0 ' ', etc.
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Identity function</strong>: Kleene (1952) uses " U<sub>i</sub><sup>n</sup> " to indicate the identity function over the variables x<sub>i</sub>; B-B-J use the identity function id<sub>i</sub><sup>n</sup> over the variables x<sub>1</sub> to x<sub>n</sub>:</li>
</ul>
<dl>
<dd>U<sub>i</sub><sup>n</sup>( <strong>x</strong> ) = id<sub>i</sub><sup>n</sup>( <strong>x</strong> ) = x<sub>i</sub>
</dd>
<dd>e.g. U<sub>3</sub><sup>7</sup> = id<sub>3</sub><sup>7</sup> ( r, s, t, u, v, w, x ) = t
</dd>
</dl>
<ul>
<li><strong>Composition (Substitution) operator</strong>: Kleene uses a bold-face <strong>S</strong><sub>n</sub><sup>m</sup> (not to be confused with his S for "successor" <strong>!</strong> ). The superscript "m" refers to the m<sup>th</sup> of function "f<sub>m</sub>", whereas the subscript "n" refers to the n<sup>th</sup> variable "x<sub>n</sub>":</li>
</ul>
<dl>
<dd>If we are given h( <strong>x</strong> )= g( f<sub>1</sub>(<strong>x</strong>), ... , f<sub>m</sub>(<strong>x</strong>) )
<dl>
<dd>h(<strong>x</strong>) = <strong>S</strong><sub>m</sub><sup>n</sup>(g, f<sub>1</sub>, ... , f<sub>m</sub> )
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>In a similar manner, but without the sub- and superscripts, B-B-J write:
<dl>
<dd>h(<em>x<strong>)= Cn[g, f<sub>1</sub> ,..., f<sub>m</sub>](</strong>x</em>')
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Primitive Recursion</strong>: Kleene uses the symbol " <strong>R</strong><sup>n</sup>(base step, induction step) " where n indicates the number of variables, B-B-J use " Pr(base step, induction step)(<strong>x</strong>)". Given:</li>
</ul>

<p>:* base step: h( 0, <strong>x</strong> )= f( <strong>x</strong> ), and</p>

<p>:* induction step: h( y+1, <strong>x</strong> ) = g( y, h(y, <strong>x</strong>),<strong>x</strong> )</p>
<dl>
<dd>Example: primitive recursion definition of a + b:

<p>:* base step: f( 0, a ) = a = U<sub>1</sub><sup>1</sup>(a)</p>

<p>:* induction step: f( b' , a ) = ( f ( b, a ) )' = g( b, f( b, a), a ) = g( b, c, a ) = c' = S(U<sub>2</sub><sup>3</sup>( b, c, a )</p>
<dl>
<dd><dl>
<dd>R<sup>2</sup> { U<sub>1</sub><sup>1</sup>(a), S [ (U<sub>2</sub><sup>3</sup>( b, c, a ) ] }
</dd>
<dd>Pr{ U<sub>1</sub><sup>1</sup>(a), S[ (U<sub>2</sub><sup>3</sup>( b, c, a ) ] }
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p><strong>Example</strong>: Kleene gives an example of how to perform the recursive derivation of f(b, a) = b + a (notice reversal of variables a and b). He starting with 3 initial functions</p>

<p>:# S(a) = a'</p>

<p>:# U<sub>1</sub><sup>1</sup>(a) = a</p>

<p>:# U<sub>2</sub><sup>3</sup>( b, c, a ) = c</p>

<p>:# g(b, c, a) = S(U<sub>2</sub><sup>3</sup>( b, c, a )) = c'</p>

<p>:# base step: h( 0, a ) = U<sub>1</sub><sup>1</sup>(a)</p>
<dl>
<dd><dl>
<dd>induction step: h( b', a ) = g( b, h( b, a ), a )
</dd>
</dl>
</dd>
</dl>

<p>He arrives at:</p>
<dl>
<dd><dl>
<dd>a+b = <strong>R</strong><sup>2</sup>[ U<sub>1</sub><sup>1</sup>, <strong>S</strong><sub>1</sub><sup>3</sup>(S, U<sub>2</sub><sup>3</sup>) ]
</dd>
</dl>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<ul>
<li><a href="Fibonacci_number" title="wikilink">Fibonacci number</a></li>
<li><a href="McCarthy_91_function" title="wikilink">McCarthy 91 function</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Recursion_theory" title="wikilink">Recursion theory</a></li>
<li><a class="uri" href="Recursion" title="wikilink">Recursion</a></li>
<li><a href="Recursion_(computer_science)" title="wikilink">Recursion (computer science)</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a> (1952) <em>Introduction to Metamathematics</em>. Walters-Noordhoff &amp; North-Holland, with corrections (6th imprint 1971); Tenth impression 1991, ISBN 0-7204-2103-9.</li>
<li>Soare, R. Recursively enumerable sets and degrees. Springer-Verlag 1987.</li>
<li><a href="Marvin_L._Minsky" title="wikilink">Marvin L. Minsky</a> (1967), <em>Computation: Finite and Infinite Machines</em>, Prentice-Hall, Inc. Englewood Cliffs, N.J.</li>
</ul>
<dl>
<dd>On pages 210-215 Minsky shows how to create the μ-operator using the <a href="register_machine" title="wikilink">register machine</a> model, thus demonstrating its equivalence to the general recursive functions.
</dd>
</dl>
<ul>
<li><a href="George_Boolos" title="wikilink">George Boolos</a>, <a href="John_P._Burgess" title="wikilink">John Burgess</a>, <a href="Richard_Jeffrey" title="wikilink">Richard Jeffrey</a> (2002), <em>Computability and Logic: Fourth Edition</em>, Cambridge University Press, Cambridge, UK. Cf pp. 70–71.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://plato.stanford.edu/entries/recursive-functions/">Stanford Encyclopedia of Philosophy entry</a></li>
<li><a href="http://people.irisa.fr/Francois.Schwarzentruber/recursive_functions_to_turing_machines/">A compiler for transforming a recursive function into an equivalent Turing machine</a></li>
</ul>

<p><a href="ru:Рекурсивная_функция_(теория_вычислимости)#Частично_рекурсивная_функция" title="wikilink">ru:Рекурсивная функция (теория вычислимости)#Частично рекурсивная функция</a>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
</body>
</html>
