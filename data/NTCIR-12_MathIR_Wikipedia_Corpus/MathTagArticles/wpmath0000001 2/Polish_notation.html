<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="853">Polish notation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Polish notation</h1>
<hr/>

<p><strong>Polish notation</strong>, also known as <strong>Polish prefix notation</strong> or simply <strong>prefix notation</strong>, is a form of notation for <a class="uri" href="logic" title="wikilink">logic</a>, <a class="uri" href="arithmetic" title="wikilink">arithmetic</a>, and <a class="uri" href="algebra" title="wikilink">algebra</a>. Its distinguishing feature is that it places <a href="Operator_(mathematics)" title="wikilink">operators</a> to the left of their <a href="operand" title="wikilink">operands</a>. If the <a class="uri" href="arity" title="wikilink">arity</a> of the operators is fixed, the result is a syntax lacking parentheses or other brackets that can still be parsed without ambiguity. The <a href="Poland" title="wikilink">Polish</a> logician <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a> invented this notation in 1924 in order to simplify <a href="Propositional_calculus" title="wikilink">sentential logic</a>.</p>

<p>The term <em>Polish notation</em> is sometimes taken (as the opposite of <em><a href="infix_notation" title="wikilink">infix notation</a></em>) to also include Polish <em>postfix</em> notation, or <a href="reverse_Polish_notation" title="wikilink">reverse Polish notation</a>, in which the operator is placed <em>after</em> the operands.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>When Polish notation is used as a syntax for mathematical expressions by <a href="programming_language" title="wikilink">programming language</a> <a href="Interpreter_(computing)" title="wikilink">interpreters</a>, it is readily parsed into <a href="abstract_syntax_tree" title="wikilink">abstract syntax trees</a> and can, in fact, define a <a href="Bijection" title="wikilink">one-to-one representation</a> for the same. Because of this, <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> (<a href="#Computer_programming" title="wikilink">see below</a>) and related programming languages define their entire syntax in terms of prefix notation (and others use postfix notation).</p>

<p>Here is a quotation from a paper by <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a>, <em>Remarks on Nicod's Axiom and on "Generalizing Deduction"</em>, page 180.</p>
<blockquote>

<p>I came upon the idea of a parenthesis-free notation in 1924. I used that notation for the first time in my article Łukasiewicz(1), p. 610, footnote.</p>
</blockquote>

<p>The reference cited by Jan Łukasiewicz above is apparently a lithographed report in <a href="Polish_language" title="wikilink">Polish</a>. The referring paper by Łukasiewicz <em>Remarks on Nicod's Axiom and on "Generalizing Deduction"</em> was reviewed by <a href="Henry_Pogorzelski" title="wikilink">H. A. Pogorzelski</a> in the <em>Journal of Symbolic Logic</em> in 1965.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><a href="Alonzo_Church" title="wikilink">Alonzo Church</a> mentions this notation in his classic book on <a href="mathematical_logic" title="wikilink">mathematical logic</a> as worthy of remark in notational systems even contrasted to <a href="Alfred_North_Whitehead" title="wikilink">Whitehead</a> and <a href="Bertrand_Russell" title="wikilink">Russell</a>'s logical notational exposition and work in <a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>In Łukasiewicz 1951 book, <em>Aristotle’s Syllogistic from the Standpoint of Modern Formal Logic</em>, he mentions that the principle of his notation was to write the <a href="Function_symbol" title="wikilink">functors</a> before the <a href="Argument_of_a_function" title="wikilink">arguments</a> to avoid brackets and that he had employed his notation in his logical papers since 1929.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> He then goes on to cite, as an example, a 1930 paper he wrote with <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a> on the <a href="Propositional_calculus" title="wikilink">sentential calculus</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>While no longer used much in logic,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Polish notation has since found a place in <a href="computer_science" title="wikilink">computer science</a>.</p>
<h2 id="arithmetic">Arithmetic</h2>

<p>The expression for adding the numbers 1 and 2 is, in prefix notation, written "+ 1 2" rather than "1 + 2". In more complex expressions, the operators still precede their operands, but the operands may themselves be nontrivial expressions including operators of their own. For instance, the expression that would be written in conventional infix notation as</p>
<dl>
<dd>(5 − 6) × 7
</dd>
</dl>

<p>can be written in prefix as</p>
<dl>
<dd>× (− 5 6) 7
</dd>
</dl>

<p>Since the simple arithmetic operators are all <a href="binary_function" title="wikilink">binary</a> (at least, in arithmetic contexts), any prefix representation thereof is unambiguous, and bracketing the prefix expression is unnecessary. As such, the previous expression can be further simplified to</p>
<dl>
<dd>× − 5 6 7
</dd>
</dl>

<p>The processing of the product is deferred until its two operands are available (i.e., 5 minus 6, and 7). As with <em>any</em> notation, the innermost expressions are evaluated first, but in prefix notation this "innermost-ness" can be conveyed by order rather than bracketing.</p>

<p>In the classical notation, the parentheses in the infix version were required, since moving them</p>
<dl>
<dd>5 − (6 × 7)
</dd>
</dl>

<p>or simply removing them</p>
<dl>
<dd>5 − 6 × 7
</dd>
</dl>

<p>would change the meaning and result of the overall expression, due to the <a href="Order_of_operations" title="wikilink">precedence rule</a>.</p>

<p>Similarly</p>
<dl>
<dd>5 − (6 × 7)
</dd>
</dl>

<p>can be written in Polish notation as</p>
<dl>
<dd>− 5 × 6 7
</dd>
</dl>
<h2 id="computer-programming">Computer programming</h2>

<p>Prefix notation has seen wide application in <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> <a class="uri" href="s-expressions" title="wikilink">s-expressions</a>, where the brackets are required since the operators in the language are themselves data (<a href="first-class_function" title="wikilink">first-class functions</a>). Lisp functions may also have variable <a class="uri" href="arity" title="wikilink">arity</a>. The <a class="uri" href="Tcl" title="wikilink">Tcl</a> programming language, much like Lisp also uses polish notation through the mathop library. The <a href="https://code.google.com/p/ambi/">Ambi</a> programming language uses Polish Notation for arithmetic operations and program construction. The postfix <a href="reverse_Polish_notation" title="wikilink">reverse Polish notation</a> is used in many <a href="Stack-oriented_programming_language" title="wikilink">stack-based programming languages</a> like <a class="uri" href="PostScript" title="wikilink">PostScript</a> and <a href="FORTH" title="wikilink">Forth</a>, and is the operating principle of certain <a href="calculator" title="wikilink">calculators</a>, notably from <a href="HP_calculators" title="wikilink">Hewlett-Packard</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p><a class="uri" href="CoffeeScript" title="wikilink">CoffeeScript</a> syntax also allows functions to be called using prefix notation, while still supporting the unary postfix syntax common in other languages.</p>

<p>The number of return values of an expression equals the difference between the number of operands in an expression and the total arity of the operators minus the total number of return values of the operators.</p>
<h2 id="order-of-operations">Order of operations</h2>

<p>Order of operations is defined within the structure of prefix notation and can be easily determined. One thing to keep in mind is that when executing an operation, the operation is applied <em>to</em> the first operand <em>by</em> the second operand. This is not an issue with operations that commute, but for non-commutative operations like division or subtraction, this fact is crucial to the analysis of a statement. For example, the following statement:</p>

<p><code> ÷ 10 5 = 2</code></p>

<p>is read as "divide 10 by 5". Thus the solution is 2, not 1/2 as would be the result of an incorrect analysis.</p>

<p>Prefix notation is especially popular with <a href="Stack-oriented_programming_language" title="wikilink">stack-based</a> operations due to its innate ability to easily distinguish order of operations without the need for parentheses. To evaluate order of operations under prefix notation, one does not even need to memorize an operational hierarchy, as with <a href="infix_notation" title="wikilink">infix notation</a>. Instead, one looks directly to the notation to discover which operator to evaluate first. Reading an expression from left to right, one first looks for an operator and proceeds to look for two operands. If another operator is found before two operands are found, then the old operator is placed aside until this new operator is resolved. This process iterates until an operator is resolved, which must happen eventually, as there must be one more operand than there are operators in a complete statement. Once resolved, the operator and the two operands are replaced with a new operand. Because one operator and two operands are removed and one operand is added, there is a net loss of one operator and one operand, which still leaves an expression with <em>N</em> operators and <em>N</em> + 1 operands, thus allowing the iterative process to continue. This is the general theory behind using stacks in programming languages to evaluate a statement in prefix notation, although there are various algorithms that manipulate the process. Once analyzed, a statement in prefix notation becomes less intimidating to the human mind as it allows some separation from convention with added convenience. An example shows the ease with which a complex statement in prefix notation can be deciphered through order of operations:</p>

<p><code>− × ÷ 15 − 7 </code><code> 3 + 2 + 1 1 =</code><br/>
<code>− × ÷ 15 </code><code>     3 + 2 + 1 1 =</code><br/>
<code>− × </code><code>         3 + 2 + 1 1 =</code><br/>
<code>− </code><code> + 2 + 1 1 =</code><br/>
<code>− </code><strong><code>9</code></strong><code>                  + 2 </code><code> =</code><br/>
<code>− 9                  </code><code>     =</code><br/>
<code>         =</code><br/>
<strong><code>5</code></strong></p>

<p>An equivalent in-fix is as follows: ((15 ÷ (7 − (1 + 1))) × 3) − (2 + (1 + 1)) = 5</p>

<p>Here is an implementation (in pseudocode) of prefix evaluation using a stack. Note that under this implementation the input string is scanned from right to left. This differs from the algorithm described above in which the string is processed from left to right. Both algorithms compute the same value for all valid strings.</p>

<p><code>Scan the given prefix expression from right to left</code><br/>
<code>for each symbol</code><br/>
<code> {</code><br/>
<code>  if operand then</code><br/>
<code>    push onto stack</code><br/>
<code>  if operator then</code><br/>
<code>   {</code><br/>
<code>    operand1=pop stack</code><br/>
<code>    operand2=pop stack</code><br/>
<code>    compute operand1 operator operand2</code><br/>
<code>    push result onto stack</code><br/>
<code>   }</code><br/>
<code> }</code><br/>
<code>return top of stack as result</code></p>

<p>Applying this algorithm to the example above yields the following:</p>

<p><code>− × ÷ 15 − 7 + 1 1 3 + 2 </code><code> =</code><br/>
<code>− × ÷ 15 − 7 + 1 1 3 </code><code>     =</code><br/>
<code>− × ÷ 15 − 7 </code><code> 3 </code><strong><code>4</code></strong><code>         =</code><br/>
<code>− × ÷ 15 </code><code>     3 4         =</code><br/>
<code>− × </code><code>         3 4         =</code><br/>
<code>− </code><code> 4         =</code><br/>
<code>         =</code><br/>
<strong><code>5</code></strong></p>
<h2 id="example">Example</h2>

<p>This uses the same expression as before and the algorithm above.</p>

<p>− × ÷ 15 − 7 + 1 1 3 + 2 + 1 1</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Token</p></th>
<th style="text-align: left;">
<p>Action</p></th>
<th style="text-align: left;">
<p>Stack</p></th>
<th style="text-align: left;">
<p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>1 1</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>Pop the two operands (1, 1), calculate (1 + 1 = 2) and push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>2 2</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>Pop the two operands (2, 2), calculate (2 + 2 = 4) and push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>3 4</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>1 3 4</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>1 1 3 4</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>2 3 4</p></td>
<td style="text-align: left;">
<p>Pop the two operands (1, 1), calculate (1 + 1 = 2) and push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>7 2 3 4</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>5 3 4</p></td>
<td style="text-align: left;">
<p>Pop the two operands (7, 2), calculate (7 − 2 = 5) and push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>Operand</p></td>
<td style="text-align: left;">
<p>15 5 3 4</p></td>
<td style="text-align: left;">
<p>Push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>÷</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>3 3 4</p></td>
<td style="text-align: left;">
<p>Pop the two operands (15, 5), calculate (15 ÷ 5 = 3) and push onto stack.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>×</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>9 4</p></td>
<td style="text-align: left;">
<p>Pop the two operands (3, 3), calculate (3 × 3 = 9) and push onto stack.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−</p></td>
<td style="text-align: left;">
<p>Operator</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>Pop the two operands (9, 4), calculate (9 − 4 = 5) and push onto stack.</p></td>
</tr>
</tbody>
</table>

<p>The result is at the top of the stack.</p>
<h2 id="polish-notation-for-logic">Polish notation for logic</h2>

<p>The table below shows the core of <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a>'s notation for <a href="sentential_logic" title="wikilink">sentential logic</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Some letters in the Polish notation table stand for particular words in <a href="Polish_language" title="wikilink">Polish</a>, as shown:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Concept</p></th>
<th style="text-align: left;">
<p>Conventional<br/>
 notation</p></th>
<th style="text-align: left;">
<p>Polish<br/>
 notation</p></th>
<th style="text-align: left;">
<p>Polish<br/>
term</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Negation" title="wikilink">Negation</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">N</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-N</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{N}\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>negacja</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Logical_conjunction" title="wikilink">Conjunction</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:2">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>∧</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\land\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:3">
 <semantics>
  <mrow>
   <mi mathvariant="normal">K</mi>
   <mi>φ</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-K</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{K}\varphi\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>koniunkcja</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Disjunction" title="wikilink">Disjunction</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:4">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>∨</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\lor\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">A</mi>
   <mi>φ</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-A</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{A}\varphi\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>alternatywa</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Material_conditional" title="wikilink">Material conditional</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:6">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\to\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">C</mi>
   <mi>φ</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-C</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{C}\varphi\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>implikacja</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Biconditional" title="wikilink">Biconditional</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:8">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>↔</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\leftrightarrow\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">E</mi>
   <mi>φ</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-E</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{E}\varphi\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>ekwiwalencja</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Falsum" title="wikilink">Falsum</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:10">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:11">
 <semantics>
  <mi mathvariant="normal">O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{O}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>fałsz</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Sheffer_stroke" title="wikilink">Sheffer stroke</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:12">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>∣</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">φ</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">ψ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\mid\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">D</mi>
   <mi>φ</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-D</ci>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{D}\varphi\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>dysjunkcja</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Modal_logic" title="wikilink">Possibility</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">◇</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-◇</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">M</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-M</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{M}\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>możliwość</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Modal_logic" title="wikilink">Necessity</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:17">
 <semantics>
  <mrow>
   <mi mathvariant="normal">L</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-L</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{L}\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>konieczność</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Universal_quantification" title="wikilink">Universal quantifier</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:18">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>p</mi>
    </mpadded>
    <mi>φ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall p\,\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Π</mi>
   <mpadded width="+1.7pt">
    <mi>p</mi>
   </mpadded>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Π</ci>
    <ci>p</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi p\,\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>kwantyfikator ogólny</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Existential_quantification" title="wikilink">Existential quantifier</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:20">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>p</mi>
    </mpadded>
    <mi>φ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists p\,\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Polish_notation:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mpadded width="+1.7pt">
    <mi>p</mi>
   </mpadded>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Σ</ci>
    <ci>p</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma p\,\varphi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>kwantyfikator szczegółowy</em></p></td>
</tr>
</tbody>
</table>

<p>Note that the quantifiers ranged over propositional values in Łukasiewicz's work on many-valued logics.</p>

<p><a href="Józef_Maria_Bocheński" title="wikilink">Bocheński</a> introduced an incompatible system of Polish notation that names all 16 binary <a href="logical_connective" title="wikilink">connectives</a> of classical propositional logic.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Reverse_Polish_notation" title="wikilink">Reverse Polish notation</a></li>
<li><a href="Function_application" title="wikilink">Function application</a></li>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="Lisp_(programming_language)" title="wikilink">Lisp (programming language)</a>
<ul>
<li><a class="uri" href="S-expression" title="wikilink">S-expression</a></li>
</ul></li>
<li><a href="Hungarian_notation" title="wikilink">Hungarian notation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li>Łukasiewicz, Jan, "Philosophische Bemerkungen zu mehrwertigen Systemen des Aussagenkalküls", <em>Comptes rendus des séances de la Société des Sciences et des Lettres de Varsovie</em>, 23:51-77 (1930). Translated by H. Weber as "Philosophical Remarks on Many-Valued Systems of Propositional Logics", in Storrs McCall, <em>Polish Logic 1920-1939</em>, <a href="Clarendon_Press" title="wikilink">Clarendon Press</a>: Oxford (1967).</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_notation" title="wikilink">Category:Mathematical notation</a> <a href="Category:Polish_inventions" title="wikilink">Category:Polish inventions</a> <a href="Category:Science_and_technology_in_Poland" title="wikilink">Category:Science and technology in Poland</a> <a href="Category:Operators_(programming)" title="wikilink">Category:Operators (programming)</a> <a href="Category:Logical_expressions" title="wikilink">Category:Logical expressions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Pogorzelski, H. A., <a href="http://www.jstor.org/stable/2269644">"Reviewed work(s): Remarks on Nicod's Axiom and on "Generalizing Deduction" by Jan Łukasiewicz; Jerzy Słupecki; Państwowe Wydawnictwo Naukowe"</a>, <em>The Journal of Symbolic Logic</em>, Vol. 30, No. 3 (Sep. 1965), pp. 376–377. The original paper by Jan Łukasiewicz was published in Warsaw in 1961 in a volume edited by Jerzy Słupecki.<a href="#fnref2">↩</a></li>
<li id="fn3"> – p. 38: "Worthy of remark is the parenthesis-free notation of Jan Łukasiewicz. In this the letters N, A, C, E, K are used in the roles of negation, disjunction, implication, equivalence, conjunction respectively. ..."<a href="#fnref3">↩</a></li>
<li id="fn4">Cf. Łukasiewicz, (1951) <em>Aristotle’s Syllogistic from the Standpoint of Modern Formal Logic</em>, Chapter IV "Aristotle's System in Symbolic Form" (section on "Explanation of the Symbolism"), p. 78 and on.<a href="#fnref4">↩</a></li>
<li id="fn5">Łukasiewicz, Jan; Tarski, Alfred, "Untersuchungen über den Aussagenkalkül" ["Investigations into the sentential calculus"], <em>Comptes Rendus des séances de la Société des Sciences et des Lettres de Varsovie</em>, Vol, 23 (1930) Cl. III, pp. 31–32.<a href="#fnref5">↩</a></li>
<li id="fn6">, p. 166: [<a class="uri" href="http://books.google.com/books?id=be-pTR5TmZIC&amp;pg">http://books.google.com/books?id=be-pTR5TmZIC&amp;pg;</a>;=PA166 "Polish or prefix notation has come to disuse given the difficulty that using it implies."]<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://h20331.www2.hp.com/Hpsub/downloads/35_02_RPN_Mode.pdf">1</a>, HP 35s RPN Mode<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">Bocheński, Józef Maria (1959). A Precis of Mathematical Logic, translated by Otto Bird from the French and German editions, D. Reidel: Dordrecht, Holland.<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
