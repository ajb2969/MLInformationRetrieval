<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1810">Grover's algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Grover's algorithm</h1>
<hr/>

<p><strong>Grover's algorithm</strong> is a <a href="quantum_algorithm" title="wikilink">quantum algorithm</a> that finds with high probability the unique input to a <a href="black_box" title="wikilink">black box</a> function that produces a particular output value, using just <mtpl></mtpl> evaluations of the function, where 

<math display="inline" id="Grover's_algorithm:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the size of the function's <a href="domain_of_a_function" title="wikilink">domain</a>.</p>

<p>The analogous problem in classical computation cannot be solved in fewer than 

<math display="inline" id="Grover's_algorithm:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N)
  </annotation>
 </semantics>
</math>

 evaluations (because, in the worst case, the correct input might be the last one that is tried). At roughly the same time that Grover published his algorithm, Bennett, Bernstein, Brassard, and Vazirani published a proof that no quantum solution to the problem can evaluate the function fewer than <mtpl></mtpl> times, so Grover's algorithm is asymptotically optimal.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Unlike other quantum algorithms, which may provide exponential speedup over their classical counterparts, Grover's algorithm provides only a quadratic speedup. However, even quadratic speedup is considerable when 

<math display="inline" id="Grover's_algorithm:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is large. Grover's algorithm could <a href="brute-force_attack" title="wikilink">brute force</a> a 128-bit symmetric cryptographic key in roughly 2<sup>64</sup> iterations, or a 256-bit key in roughly 2<sup>128</sup> iterations. As a result, it is sometimes suggested that symmetric key lengths be doubled to protect against future quantum attacks.</p>

<p>Like many quantum algorithms, Grover's algorithm is probabilistic in the sense that it gives the correct answer with a <a class="uri" href="probability" title="wikilink">probability</a> of less than 1. Though there is technically no upper bound on the number of repetitions that might be needed before the correct answer is obtained, the expected number of repetitions is a constant factor that does not grow with 

<math display="inline" id="Grover's_algorithm:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

.</p>

<p>Grover's original paper described the algorithm as a database search algorithm, and this description is still common. The database in this analogy is a table of all of the function's outputs, indexed by the corresponding input.</p>
<h2 id="applications">Applications</h2>

<p>Although the purpose of Grover's algorithm is usually described as "searching a database", it may be more accurate to describe it as "inverting a function". Roughly speaking, if we have a function <em>y = f(x)</em> that can be evaluated on a quantum computer, Grover's algorithm allows us to calculate <em>x</em> when given <em>y</em>. Inverting a function is related to the searching of a database because we could come up with a function that produces one particular value of <em>y</em> ("true" for instance) if <em>x</em> matches a desired entry in a database, and another value of <em>y</em> ("false") for other values of <em>x</em>.</p>

<p>Grover's algorithm can also be used for estimating the <a class="uri" href="mean" title="wikilink">mean</a> and <a class="uri" href="median" title="wikilink">median</a> of a set of numbers, and for solving the <a href="Collision_problem" title="wikilink">Collision problem</a>. The algorithm can be further optimized if there is more than one matching entry and the number of matches is known beforehand.</p>
<h2 id="setup">Setup</h2>

<p>Consider an unsorted database with <em>N</em> entries. The algorithm requires an <em>N</em>-dimensional <a href="mathematical_formulation_of_quantum_mechanics" title="wikilink">state space</a> <em>H</em>, which can be supplied by <em>n</em>=log<sub>2</sub> <em>N</em> <a href="qubit" title="wikilink">qubits</a>. Consider the problem of determining the index of the database entry which satisfies some search criterion. Let <em>f</em> be the function which maps database entries to <em>0</em> or <em>1</em>, where <em>f(ω)=1</em> if and only if <em>ω</em> satisfies the search criterion. We are provided with (quantum black box) access to a <a class="uri" href="subroutine" title="wikilink">subroutine</a> in the form of a <a href="unitary_operator" title="wikilink">unitary operator</a>, <em>U<sub>ω</sub></em>, which acts as follows (for the <em>ω</em> for which <em>f(ω)=1</em>):</p>

<p>

<math display="block" id="Grover's_algorithm:4">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo>-</mo>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <minus></minus>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}|\omega\rang=-|\omega\rang
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Grover's_algorithm:5">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mpadded width="+5pt">
    <mtext>for all</mtext>
   </mpadded>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
    <ci>italic-</ci>
    <mtext>for all</mtext>
    <csymbol cd="unknown">x</csymbol>
    <neq></neq>
    <csymbol cd="unknown">ω</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}|x\rang=|x\rang\qquad\mbox{for all}\ x\neq\omega
  </annotation>
 </semantics>
</math>

</p>

<p>Our goal is to identify the index 

<math display="inline" id="Grover's_algorithm:6">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algorithm-steps">Algorithm steps</h2>

<p> The steps of Grover's algorithm are given as follows. Let 

<math display="inline" id="Grover's_algorithm:7">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>s</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rangle
  </annotation>
 </semantics>
</math>

 denote the uniform superposition over all states</p>

<p>

<math display="block" id="Grover's_algorithm:8">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>x</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang=\frac{1}{\sqrt{N}}\sum_{x=1}^{N}|x\rang
  </annotation>
 </semantics>
</math>

.</p>

<p>Then the operator</p>

<p>

<math display="block" id="Grover's_algorithm:9">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo fence="true">|</mo>
      <mi>s</mi>
      <mo>⟩</mo>
     </mrow>
     <mrow>
      <mo>⟨</mo>
      <mi>s</mi>
      <mo fence="true">|</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}=2\left|s\right\rangle\left\langle s\right|-I
  </annotation>
 </semantics>
</math>

</p>

<p>is known as the Grover diffusion operator.</p>

<p>Here is the algorithm:</p>
<ol>
<li>Initialize the system to the state<br/>


<math display="inline" id="Grover's_algorithm:10">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>x</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </msubsup>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang=\frac{1}{\sqrt{N}}\sum_{x=1}^{N}|x\rang
  </annotation>
 </semantics>
</math>

</li>
<li>Perform the following "Grover iteration" <em>r(N)</em> times. The function <em>r(N),</em> which is asymptotically <em>O(N<sup>½</sup>)</em>, is described below.
<ol>
<li>Apply the operator 

<math display="inline" id="Grover's_algorithm:11">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

.</li>
<li>Apply the operator 

<math display="inline" id="Grover's_algorithm:12">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}
  </annotation>
 </semantics>
</math>

.</li>
</ol></li>
<li>Perform the measurement Ω. The <a href="Measurement_in_quantum_mechanics" title="wikilink">measurement</a> result will be eigenvalue λ<sub>ω</sub> with probability approaching 1 for N≫1. From λ<sub>ω</sub>, ω may be obtained.</li>
</ol>
<h2 id="the-first-iteration">The first iteration</h2>

<p>A preliminary observation, in parallel with our definition</p>

<p>

<math display="block" id="Grover's_algorithm:13">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo fence="true">|</mo>
      <mi>s</mi>
      <mo>⟩</mo>
     </mrow>
     <mrow>
      <mo>⟨</mo>
      <mi>s</mi>
      <mo fence="true">|</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}=2\left|s\right\rangle\left\langle s\right|-I
  </annotation>
 </semantics>
</math>

, is that <em>U<sub>ω</sub></em> can be expressed in an alternate way:</p>

<p>

<math display="block" id="Grover's_algorithm:14">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo fence="true">|</mo>
      <mi>ω</mi>
      <mo>⟩</mo>
     </mrow>
     <mrow>
      <mo>⟨</mo>
      <mi>ω</mi>
      <mo fence="true">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>I</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ω</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}=I-2\left|\omega\right\rangle\left\langle\omega\right|
  </annotation>
 </semantics>
</math>

. To prove this it suffices to check how <em>U<sub>ω</sub></em> acts on basis states:</p>

<p>

<math display="block" id="Grover's_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo>-</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mi>ω</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ω</mi>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mn>2</mn>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <mo stretchy="false">⟩</mo>
   <mo stretchy="false">⟨</mo>
   <mi>ω</mi>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo>-</mo>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <mo stretchy="false">⟩</mo>
   <mo>=</mo>
   <mi>U</mi>
   <msub>
    <mi></mi>
    <mi>ω</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-|</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <cn type="integer">2</cn>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-⟩</ci>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <minus></minus>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-⟩</ci>
    <eq></eq>
    <csymbol cd="unknown">U</csymbol>
    <apply>
     <ci>ω</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I-2|\omega\rangle\langle\omega|)|\omega\rang=|\omega\rang-2|\omega\rangle%
\langle\omega|\omega\rang=-|\omega\rangle=U_{\omega}|\omega\rang
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Grover's_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo>-</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mi>ω</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ω</mi>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mn>2</mn>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <mo stretchy="false">⟩</mo>
   <mo stretchy="false">⟨</mo>
   <mi>ω</mi>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
   <mo>=</mo>
   <mi>U</mi>
   <msub>
    <mi></mi>
    <mi>ω</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-|</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <cn type="integer">2</cn>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-⟩</ci>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-⟩</ci>
    <eq></eq>
    <csymbol cd="unknown">U</csymbol>
    <apply>
     <ci>ω</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I-2|\omega\rangle\langle\omega|)|x\rang=|x\rang-2|\omega\rangle\langle\omega|%
x\rang=|x\rangle=U_{\omega}|x\rang
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Grover's_algorithm:17">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq\omega
  </annotation>
 </semantics>
</math>

.</p>

<p>The following computations show what happens in the first iteration:</p>

<p>

<math display="block" id="Grover's_algorithm:18">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>ω</mi>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>s</mi>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lang\omega|s\rang=\lang s|\omega\rang=\frac{1}{\sqrt{N}}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Grover's_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>s</mi>
     <mo fence="true" stretchy="false">|</mo>
    </mrow>
    <mi>s</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\rang</mtext>
    </merror>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mfrac>
    </mrow>
    <mo>⋅</mo>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <ci>s</ci>
      </apply>
      <ci>s</ci>
      <mtext>\rang</mtext>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <root></root>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle s|s\rang=N\frac{1}{\sqrt{N}}\cdot\frac{1}{\sqrt{N}}=1
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Grover's_algorithm:20">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo>-</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mi>ω</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ω</mi>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mn>2</mn>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <mo stretchy="false">⟩</mo>
   <mo stretchy="false">⟨</mo>
   <mi>ω</mi>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mfrac>
    <mn>2</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-|</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <cn type="integer">2</cn>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-⟩</ci>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-⟩</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}|s\rang=(I-2|\omega\rangle\langle\omega|)|s\rang=|s\rang-2|\omega%
\rangle\langle\omega|s\rang=|s\rang-\frac{2}{\sqrt{N}}|\omega\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Grover's_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>s</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo stretchy="false">|</mo>
     <mi>s</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
     <mo>-</mo>
     <mfrac>
      <mn>2</mn>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mfrac>
     <mo stretchy="false">|</mo>
     <mi>ω</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\rang</mtext>
    </merror>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\lang</mtext>
    </merror>
    <mi>s</mi>
    <mo stretchy="false">|</mo>
    <mo>-</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\rang</mtext>
    </merror>
    <mo>-</mo>
    <mfrac>
     <mn>2</mn>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mfrac>
    <mo stretchy="false">|</mo>
    <mi>ω</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mn>2</mn>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>s</mi>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mfrac>
    <mn>4</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo stretchy="false">⟨</mo>
   <mi>s</mi>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>+</mo>
   <mfrac>
    <mn>2</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>s</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-|</ci>
      <csymbol cd="unknown">s</csymbol>
      <mtext>\rang</mtext>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
      <ci>normal-|</ci>
      <csymbol cd="unknown">ω</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <mtext>\rang</mtext>
     <mtext>\lang</mtext>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-|</ci>
     <minus></minus>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <mtext>\rang</mtext>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>N</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
    <cn type="integer">2</cn>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}(|s\rang-\frac{2}{\sqrt{N}}|\omega\rangle)=(2|s\rang\lang s|-I)(|s\rang-%
\frac{2}{\sqrt{N}}|\omega\rangle)=2|s\rang\lang s|s\rang-|s\rang-\frac{4}{%
\sqrt{N}}|s\rang\langle s|\omega\rang+\frac{2}{\sqrt{N}}|\omega\rang=
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Grover's_algorithm:22">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mn>2</mn>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mfrac>
    <mn>4</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo>⋅</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>+</mo>
   <mfrac>
    <mn>2</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>-</mo>
   <mfrac>
    <mn>4</mn>
    <mi>N</mi>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>+</mo>
   <mfrac>
    <mn>2</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>4</mn>
    </mrow>
    <mi>N</mi>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>+</mo>
   <mfrac>
    <mn>2</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cn type="integer">2</cn>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-⋅</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =2|s\rang-|s\rang-\frac{4}{\sqrt{N}}\cdot\frac{1}{\sqrt{N}}|s\rang+\frac{2}{%
\sqrt{N}}|\omega\rang=|s\rang-\frac{4}{N}|s\rang+\frac{2}{\sqrt{N}}|\omega%
\rang=\frac{N-4}{N}|s\rang+\frac{2}{\sqrt{N}}|\omega\rang
  </annotation>
 </semantics>
</math>

. After application of the two operators ( 

<math display="inline" id="Grover's_algorithm:23">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:24">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}
  </annotation>
 </semantics>
</math>

 ), the amplitude of the searched-for element has increased from 

<math display="inline" id="Grover's_algorithm:25">
 <semantics>
  <mrow>
   <mo>|</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>ω</mi>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <msup>
    <mo>|</mo>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>1</mn>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-|</ci>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\lang\omega|s\rang\right|^{2}=1/N
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Grover's_algorithm:26">
 <semantics>
  <mrow>
   <mo>|</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>ω</mi>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>U</mi>
    <mi>s</mi>
   </msub>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <msup>
    <mo>|</mo>
    <mn>2</mn>
   </msup>
   <mo>≈</mo>
   <mn>9</mn>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">ω</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-|</ci>
     <cn type="integer">2</cn>
    </apply>
    <approx></approx>
    <cn type="integer">9</cn>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\lang\omega|U_{s}U_{\omega}s\rang\right|^{2}\approx 9/N
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="description-of-uω">Description of <em>U<sub>ω</sub></em></h2>

<p>Grover's algorithm requires a "quantum oracle" operator 

<math display="inline" id="Grover's_algorithm:27">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

 which can recognize solutions to the search problem and give them a negative sign. In order to keep the search algorithm general, we will leave the inner workings of the oracle as a black box, but will explain how the sign is flipped. The oracle contains a function 

<math display="inline" id="Grover's_algorithm:28">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 which returns 

<math display="inline" id="Grover's_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=1
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Grover's_algorithm:30">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang
  </annotation>
 </semantics>
</math>

 is a solution to the search problem and 

<math display="inline" id="Grover's_algorithm:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=0
  </annotation>
 </semantics>
</math>

 otherwise. The oracle is a unitary operator which operates on two qubits, the index qubit 

<math display="inline" id="Grover's_algorithm:32">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang
  </annotation>
 </semantics>
</math>

 and the oracle qubit 

<math display="inline" id="Grover's_algorithm:33">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>q</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">q</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |q\rang
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Grover's_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>x</mi>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>q</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\rang</mtext>
    </merror>
    <mover accent="true">
     <mo>⟶</mo>
     <msub>
      <mi>U</mi>
      <mi>ω</mi>
     </msub>
    </mover>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>x</mi>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>q</mi>
   </mrow>
   <mo>⊕</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\rang</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>x</ci>
       <mtext>\rang</mtext>
      </apply>
     </apply>
     <ci>q</ci>
     <mtext>\rang</mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>ω</ci>
      </apply>
      <ci>normal-⟶</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>x</ci>
       <mtext>\rang</mtext>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
     <mtext>\rang</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang|q\rang\overset{U_{\omega}}{\longrightarrow}|x\rang|q\oplus f(x)\rang
  </annotation>
 </semantics>
</math>

</p>

<p>As usual, 

<math display="inline" id="Grover's_algorithm:35">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 denotes addition modulo 2. The operation flips the oracle qubit if 

<math display="inline" id="Grover's_algorithm:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=1
  </annotation>
 </semantics>
</math>

 and leaves it alone otherwise. In Grover's algorithm we want to flip the sign of the state 

<math display="inline" id="Grover's_algorithm:37">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang
  </annotation>
 </semantics>
</math>

 if it labels a solution. This is achieved by setting the oracle qubit in the state 

<math display="inline" id="Grover's_algorithm:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mn>0</mn>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
       </mrow>
       <mo>-</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>1</mn>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>\rang</mtext>
       </apply>
       <minus></minus>
      </apply>
     </apply>
     <cn type="integer">1</cn>
     <mtext>\rang</mtext>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|0\rang-|1\rang)/\sqrt{2}
  </annotation>
 </semantics>
</math>

, which is flipped to 

<math display="inline" id="Grover's_algorithm:39">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mn>1</mn>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
       </mrow>
       <mo>-</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>0</mn>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <mtext>\rang</mtext>
       </apply>
       <minus></minus>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <mtext>\rang</mtext>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|1\rang-|0\rang)/\sqrt{2}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Grover's_algorithm:40">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang
  </annotation>
 </semantics>
</math>

 is a solution:</p>

<p>

<math display="block" id="Grover's_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>x</mi>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">|</mo>
           <mrow>
            <mrow>
             <mn>0</mn>
             <merror class="ltx_ERROR undefined undefined">
              <mtext>\rang</mtext>
             </merror>
            </mrow>
            <mo>-</mo>
           </mrow>
           <mo stretchy="false">|</mo>
          </mrow>
          <mn>1</mn>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\rang</mtext>
          </merror>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
      <mover accent="true">
       <mo>⟶</mo>
       <msub>
        <mi>U</mi>
        <mi>ω</mi>
       </msub>
      </mover>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>x</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\rang</mtext>
    </merror>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mn>0</mn>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\rang</mtext>
         </merror>
        </mrow>
        <mo>-</mo>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>1</mn>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>x</ci>
         <mtext>\rang</mtext>
         <apply>
          <times></times>
          <apply>
           <abs></abs>
           <apply>
            <csymbol cd="latexml">limit-from</csymbol>
            <apply>
             <times></times>
             <cn type="integer">0</cn>
             <mtext>\rang</mtext>
            </apply>
            <minus></minus>
           </apply>
          </apply>
          <cn type="integer">1</cn>
          <mtext>\rang</mtext>
         </apply>
        </apply>
        <apply>
         <root></root>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>ω</ci>
        </apply>
        <ci>normal-⟶</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>x</ci>
     <mtext>\rang</mtext>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <apply>
         <times></times>
         <cn type="integer">0</cn>
         <mtext>\rang</mtext>
        </apply>
        <minus></minus>
       </apply>
      </apply>
      <cn type="integer">1</cn>
      <mtext>\rang</mtext>
     </apply>
    </apply>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang\left(|0\rang-|1\rang\right)/\sqrt{2}\overset{U_{\omega}}{%
\longrightarrow}(-1)^{f(x)}|x\rang\left(|0\rang-|1\rang\right)/\sqrt{2}
  </annotation>
 </semantics>
</math>

</p>

<p>We regard 

<math display="inline" id="Grover's_algorithm:42">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang
  </annotation>
 </semantics>
</math>

 as flipped, thus the oracle qubit is not changed, so by convention the oracle qubits are usually not mentioned in the specification of Grover's algorithm. Thus the operation of the oracle 

<math display="inline" id="Grover's_algorithm:43">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

 is simply written as:</p>

<p>

<math display="block" id="Grover's_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>x</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
     <mover accent="true">
      <mo>⟶</mo>
      <msub>
       <mi>U</mi>
       <mi>ω</mi>
      </msub>
     </mover>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>x</ci>
      <mtext>\rang</mtext>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>ω</ci>
       </apply>
       <ci>normal-⟶</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>x</ci>
    <mtext>\rang</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rang\overset{U_{\omega}}{\longrightarrow}(-1)^{f(x)}|x\rang
  </annotation>
 </semantics>
</math>

</p>
<h2 id="geometric-proof-of-correctness">Geometric proof of correctness</h2>

<p> Consider the plane spanned by 

<math display="inline" id="Grover's_algorithm:45">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:46">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

; equivalently, the plane spanned by 

<math display="inline" id="Grover's_algorithm:47">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

 and the perpendicular ket 

<math display="inline" id="Grover's_algorithm:48">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msqrt>
   </mfrac>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>x</mi>
     <mo>≠</mo>
     <mi>ω</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <mtext>\rang</mtext>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <neq></neq>
      <ci>x</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s^{\prime}\rang=\frac{1}{\sqrt{N-1}}\sum_{x\neq\omega}|x\rang
  </annotation>
 </semantics>
</math>

. We will consider the first iteration, acting on the initial ket 

<math display="inline" id="Grover's_algorithm:49">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Grover's_algorithm:50">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

 is one of the basis vectors in 

<math display="inline" id="Grover's_algorithm:51">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang
  </annotation>
 </semantics>
</math>

 the overlap is</p>

<p>

<math display="block" id="Grover's_algorithm:52">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>=</mo>
   <msqrt>
    <mfrac>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </mfrac>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>\lang</mtext>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lang s^{\prime}|s\rang=\sqrt{\frac{N-1}{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>In geometric terms, the angle 

<math display="inline" id="Grover's_algorithm:53">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>θ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta/2
  </annotation>
 </semantics>
</math>

 between 

<math display="inline" id="Grover's_algorithm:54">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:55">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s^{\prime}\rang
  </annotation>
 </semantics>
</math>

 is given by:</p>

<p>

<math display="block" id="Grover's_algorithm:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mi>θ</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sin></sin>
     <apply>
      <divide></divide>
      <ci>θ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin\theta/2=\frac{1}{\sqrt{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>The operator 

<math display="inline" id="Grover's_algorithm:57">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

 is a reflection at the hyperplane orthogonal to 

<math display="inline" id="Grover's_algorithm:58">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

 for vectors in the plane spanned by 

<math display="inline" id="Grover's_algorithm:59">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s^{\prime}\rang
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:60">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

; i.e. it acts as a reflection across 

<math display="inline" id="Grover's_algorithm:61">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s^{\prime}\rang
  </annotation>
 </semantics>
</math>

. The operator 

<math display="inline" id="Grover's_algorithm:62">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}
  </annotation>
 </semantics>
</math>

 is a reflection through 

<math display="inline" id="Grover's_algorithm:63">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s\rang
  </annotation>
 </semantics>
</math>

. Therefore, the state vector remains in the plane spanned by 

<math display="inline" id="Grover's_algorithm:64">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s^{\prime}\rang
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:65">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

 after each application of the operators 

<math display="inline" id="Grover's_algorithm:66">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:67">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

, and it is straightforward to check that the operator 

<math display="inline" id="Grover's_algorithm:68">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>s</mi>
   </msub>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}U_{\omega}
  </annotation>
 </semantics>
</math>

 of each Grover iteration step rotates the state vector by an angle of 

<math display="inline" id="Grover's_algorithm:69">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>arcsin</mi>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <arcsin></arcsin>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=2\arcsin\frac{1}{\sqrt{N}}
  </annotation>
 </semantics>
</math>

.</p>

<p>We need to stop when the state vector passes close to 

<math display="inline" id="Grover's_algorithm:70">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

; after this, subsequent iterations rotate the state vector <em>away</em> from 

<math display="inline" id="Grover's_algorithm:71">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\omega\rang
  </annotation>
 </semantics>
</math>

, reducing the probability of obtaining the correct answer. The exact probability of measuring the correct answer is:</p>

<p>

<math display="block" id="Grover's_algorithm:72">
 <semantics>
  <mrow>
   <msup>
    <mi>sin</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>r</mi>
       <mo>+</mo>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>θ</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <sin></sin>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>r</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin^{2}\left(\left(r+\frac{1}{2}\right)\theta\right)
  </annotation>
 </semantics>
</math>

 where <em>r</em> is the (integer) number of Grover iterations. The earliest time that we get a near-optimal measurement is therefore 

<math display="inline" id="Grover's_algorithm:73">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mrow>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>π</ci>
      <apply>
       <root></root>
       <ci>N</ci>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\approx\pi\sqrt{N}/4
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algebraic-proof-of-correctness">Algebraic proof of correctness</h2>

<p>To complete the algebraic analysis we need to find out what happens when we repeatedly apply 

<math display="inline" id="Grover's_algorithm:74">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>s</mi>
   </msub>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}U_{\omega}
  </annotation>
 </semantics>
</math>

. A natural way to do this is by eigenvalue analysis of a matrix. Notice that during the entire computation, the state of the algorithm is a linear combination of 

<math display="inline" id="Grover's_algorithm:75">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:76">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

. We can write the action of 

<math display="inline" id="Grover's_algorithm:77">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:78">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

 in the space spanned by 

<math display="inline" id="Grover's_algorithm:79">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>,</mo>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <ci>normal-,</ci>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|s\rang,|\omega\rang\}
  </annotation>
 </semantics>
</math>

 as:</p>

<p>

<math display="block" id="Grover's_algorithm:80">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>s</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mi>ω</mi>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\rang</mtext>
         </merror>
        </mrow>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mi>s</mi>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>ω</mi>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\rang</mtext>
          </merror>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>s</mi>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mn>2</mn>
           <mo>/</mo>
           <msqrt>
            <mi>N</mi>
           </msqrt>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mi>a</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi>b</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <abs></abs>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>ω</ci>
         <mtext>\rang</mtext>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>s</ci>
      <mtext>\rang</mtext>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>ω</ci>
         <mtext>\rang</mtext>
        </apply>
       </apply>
       <ci>s</ci>
       <mtext>\rang</mtext>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <apply>
          <root></root>
          <ci>N</ci>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>a</ci>
       </matrixrow>
       <matrixrow>
        <ci>b</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}:a|\omega\rang+b|s\rang\mapsto(|\omega\rang\,|s\rang)\begin{pmatrix}-1&0%
\\
2/\sqrt{N}&1\end{pmatrix}\begin{pmatrix}a\\
b\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Grover's_algorithm:81">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>ω</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mi>ω</mi>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\rang</mtext>
         </merror>
        </mrow>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mi>s</mi>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>ω</mi>
          <merror class="ltx_ERROR undefined undefined">
           <mtext>\rang</mtext>
          </merror>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>s</mi>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <mo>/</mo>
            <msqrt>
             <mi>N</mi>
            </msqrt>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mi>a</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi>b</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <abs></abs>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>ω</ci>
         <mtext>\rang</mtext>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>s</ci>
      <mtext>\rang</mtext>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>ω</ci>
         <mtext>\rang</mtext>
        </apply>
       </apply>
       <ci>s</ci>
       <mtext>\rang</mtext>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <apply>
           <root></root>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>a</ci>
       </matrixrow>
       <matrixrow>
        <ci>b</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}:a|\omega\rang+b|s\rang\mapsto(|\omega\rang\,|s\rang)\begin{pmatrix}%
-1&-2/\sqrt{N}\\
0&1\end{pmatrix}\begin{pmatrix}a\\
b\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>So in the basis 

<math display="inline" id="Grover's_algorithm:82">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo stretchy="false">|</mo>
   <mi>ω</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo>,</mo>
   <mo stretchy="false">|</mo>
   <mi>s</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <ci>normal-|</ci>
    <csymbol cd="unknown">ω</csymbol>
    <mtext>\rang</mtext>
    <ci>normal-,</ci>
    <ci>normal-|</ci>
    <csymbol cd="unknown">s</csymbol>
    <mtext>\rang</mtext>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|\omega\rang,|s\rang\}
  </annotation>
 </semantics>
</math>

 (which is neither orthogonal nor a basis of the whole space) the action 

<math display="inline" id="Grover's_algorithm:83">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>s</mi>
   </msub>
   <msub>
    <mi>U</mi>
    <mi>ω</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}U_{\omega}
  </annotation>
 </semantics>
</math>

 of applying 

<math display="inline" id="Grover's_algorithm:84">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\omega}
  </annotation>
 </semantics>
</math>

 followed by 

<math display="inline" id="Grover's_algorithm:85">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}
  </annotation>
 </semantics>
</math>

 is given by the matrix</p>

<p>

<math display="block" id="Grover's_algorithm:86">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>U</mi>
      <mi>s</mi>
     </msub>
     <msub>
      <mi>U</mi>
      <mi>ω</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mn>2</mn>
          <mo>/</mo>
          <msqrt>
           <mi>N</mi>
          </msqrt>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mrow>
           <mn>2</mn>
           <mo>/</mo>
           <msqrt>
            <mi>N</mi>
           </msqrt>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mn>2</mn>
         <mo>/</mo>
         <msqrt>
          <mi>N</mi>
         </msqrt>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mo>/</mo>
          <msqrt>
           <mi>N</mi>
          </msqrt>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mn>4</mn>
          <mo>/</mo>
          <mi>N</mi>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <apply>
          <root></root>
          <ci>N</ci>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <apply>
           <root></root>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <apply>
         <root></root>
         <ci>N</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <apply>
          <root></root>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <cn type="integer">4</cn>
         <ci>N</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}U_{\omega}=\begin{pmatrix}-1&0\\
2/\sqrt{N}&1\end{pmatrix}\begin{pmatrix}-1&-2/\sqrt{N}\\
0&1\end{pmatrix}=\begin{pmatrix}1&2/\sqrt{N}\\
-2/\sqrt{N}&1-4/N\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>This matrix happens to have a very convenient <a href="Jordan_form" title="wikilink">Jordan form</a>. If we define 

<math display="inline" id="Grover's_algorithm:87">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>arcsin</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <arcsin></arcsin>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=\arcsin(1/\sqrt{N})
  </annotation>
 </semantics>
</math>

, it is</p>

<p>

<math display="block" id="Grover's_algorithm:88">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>s</mi>
    </msub>
    <msub>
     <mi>U</mi>
     <mi>ω</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>exp</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>2</mn>
           <mi>i</mi>
           <mi>t</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>exp</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <mi>i</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <msup>
     <mi>M</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <matrix>
      <matrixrow>
       <apply>
        <exp></exp>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <exp></exp>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>i</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{s}U_{\omega}=M\begin{pmatrix}\exp(2it)&0\\
0&\exp(-2it)\end{pmatrix}M^{-1}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Grover's_algorithm:89">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mi>i</mi>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mi>i</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>exp</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>i</mi>
           <mi>t</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>exp</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>i</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
      <ci>i</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <exp></exp>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\begin{pmatrix}-i&i\\
\exp(it)&\exp(-it)\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>It follows that <em>r</em>th power of the matrix (corresponding to <em>r</em> iterations) is</p>

<p>

<math display="block" id="Grover's_algorithm:90">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>U</mi>
       <mi>s</mi>
      </msub>
      <msub>
       <mi>U</mi>
       <mi>ω</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>r</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>exp</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>2</mn>
           <mi>r</mi>
           <mi>i</mi>
           <mi>t</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>exp</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <mi>r</mi>
            <mi>i</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <msup>
     <mi>M</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <matrix>
      <matrixrow>
       <apply>
        <exp></exp>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>r</ci>
         <ci>i</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <exp></exp>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>r</ci>
          <ci>i</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U_{s}U_{\omega})^{r}=M\begin{pmatrix}\exp(2rit)&0\\
0&\exp(-2rit)\end{pmatrix}M^{-1}
  </annotation>
 </semantics>
</math>

 Using this form we can use trigonometric identities to compute the probability of observing <em>ω</em> after <em>r</em> iterations mentioned in the previous section,</p>

<p>

<math display="block" id="Grover's_algorithm:91">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <merror class="ltx_ERROR undefined undefined">
            <mtext>\lang</mtext>
           </merror>
           <mi>ω</mi>
           <mo stretchy="false">|</mo>
           <mi>ω</mi>
           <merror class="ltx_ERROR undefined undefined">
            <mtext>\rang</mtext>
           </merror>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <merror class="ltx_ERROR undefined undefined">
            <mtext>\lang</mtext>
           </merror>
           <mi>ω</mi>
           <mo stretchy="false">|</mo>
           <mi>s</mi>
           <merror class="ltx_ERROR undefined undefined">
            <mtext>\rang</mtext>
           </merror>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>U</mi>
          <mi>s</mi>
         </msub>
         <msub>
          <mi>U</mi>
          <mi>ω</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>r</mi>
      </msup>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>sin</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>r</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>t</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <mtext>\lang</mtext>
          <csymbol cd="unknown">ω</csymbol>
          <ci>normal-|</ci>
          <csymbol cd="unknown">ω</csymbol>
          <mtext>\rang</mtext>
         </cerror>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <mtext>\lang</mtext>
          <csymbol cd="unknown">ω</csymbol>
          <ci>normal-|</ci>
          <csymbol cd="unknown">s</csymbol>
          <mtext>\rang</mtext>
         </cerror>
        </matrixrow>
       </matrix>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>U</ci>
          <ci>s</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>U</ci>
          <ci>ω</ci>
         </apply>
        </apply>
        <ci>r</ci>
       </apply>
       <matrix>
        <matrixrow>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">1</cn>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <sin></sin>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>r</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\begin{pmatrix}\lang\omega|\omega\rang&\lang\omega|s\rang\end{pmatrix}(U%
_{s}U_{\omega})^{r}\begin{pmatrix}0\\
1\end{pmatrix}\right|^{2}=\sin^{2}\left((2r+1)t\right)
  </annotation>
 </semantics>
</math>

. Alternatively, one might reasonably imagine that a near-optimal time to distinguish would be when the angles <em>2rt</em> and <em>-2rt</em> are as far apart as possible, which corresponds to 

<math display="inline" id="Grover's_algorithm:92">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>r</mi>
    <mi>t</mi>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>π</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2rt\approx\pi/2
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Grover's_algorithm:93">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
    <mrow>
     <mi>arcsin</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msqrt>
        <mi>N</mi>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mrow>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>r</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>π</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>π</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <arcsin></arcsin>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <root></root>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\pi/4t=\pi/4\arcsin(1/\sqrt{N})\approx\pi\sqrt{N}/4
  </annotation>
 </semantics>
</math>

. Then the system is in state</p>

<p>

<math display="block" id="Grover's_algorithm:94">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>ω</mi>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\rang</mtext>
         </merror>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mi>s</mi>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\rang</mtext>
       </merror>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>U</mi>
         <mi>s</mi>
        </msub>
        <msub>
         <mi>U</mi>
         <mi>ω</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>r</mi>
     </msup>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>ω</mi>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\rang</mtext>
         </merror>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mi>s</mi>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\rang</mtext>
       </merror>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>M</mi>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>i</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>i</mi>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <msup>
      <mi>M</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mi>w</mi>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\rang</mtext>
        </merror>
        <mfrac>
         <mn>1</mn>
         <mrow>
          <mi>cos</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
       <mo>-</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>s</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
     <mfrac>
      <mrow>
       <mi>sin</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>ω</ci>
         <mtext>\rang</mtext>
        </apply>
       </apply>
       <ci>s</ci>
       <mtext>\rang</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>s</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>ω</ci>
        </apply>
       </apply>
       <ci>r</ci>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>ω</ci>
         <mtext>\rang</mtext>
        </apply>
       </apply>
       <ci>s</ci>
       <mtext>\rang</mtext>
      </apply>
      <ci>M</ci>
      <matrix>
       <matrixrow>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <apply>
         <minus></minus>
         <ci>i</ci>
        </apply>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <apply>
         <times></times>
         <ci>w</ci>
         <mtext>\rang</mtext>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <apply>
           <cos></cos>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <minus></minus>
       </apply>
      </apply>
      <ci>s</ci>
      <mtext>\rang</mtext>
      <apply>
       <divide></divide>
       <apply>
        <sin></sin>
        <ci>t</ci>
       </apply>
       <apply>
        <cos></cos>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (|\omega\rang\,|s\rang)(U_{s}U_{\omega})^{r}\begin{pmatrix}0\\
1\end{pmatrix}\approx(|\omega\rang\,|s\rang)M\begin{pmatrix}i&0\\
0&-i\end{pmatrix}M^{-1}\begin{pmatrix}0\\
1\end{pmatrix}=|w\rang\frac{1}{\cos(t)}-|s\rang\frac{\sin(t)}{\cos(t)}.
  </annotation>
 </semantics>
</math>

 A short calculation now shows that the observation yields the correct answer <em>ω</em> with error <em>O(1/N)</em>.</p>
<h2 id="extension-to-space-with-multiple-targets">Extension to space with multiple targets</h2>

<p>If, instead of 1 matching entry, there are <em>k</em> matching entries, the same algorithm works but the number of iterations must be <em>π(N/k)<sup>1/2</sup>/4</em> instead of <em>πN<sup>1/2</sup>/4</em>. There are several ways to handle the case if <em>k</em> is unknown. For example, one could run Grover's algorithm several times, with</p>

<p>

<math display="block" id="Grover's_algorithm:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mfrac>
     <msup>
      <mi>N</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mn>4</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>π</mi>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mn>4</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>π</mi>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mn>4</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>N</ci>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi\frac{N^{1/2}}{4},\pi\frac{(N/2)^{1/2}}{4},\pi\frac{(N/4)^{1/2}}{4},\ldots
  </annotation>
 </semantics>
</math>

</p>

<p>iterations. For any <em>k</em>, one of the iterations will find a matching entry with a sufficiently high probability. The total number of iterations is at most</p>

<p>

<math display="block" id="Grover's_algorithm:96">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mfrac>
     <msup>
      <mi>N</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mn>4</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <mn>1</mn>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mfrac>
      <mo>+</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>π</mi>
    <mfrac>
     <msup>
      <mi>N</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mn>4</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mn>2</mn>
      <mo>+</mo>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi\frac{N^{1/2}}{4}\left(1+\frac{1}{\sqrt{2}}+\frac{1}{2}+\cdots\right)=\pi%
\frac{N^{1/2}}{4}\left(2+\sqrt{2}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>which is still O(<em>N<sup>1/2</sup></em>). It can be shown that this can be improved. If the number of marked items is <em>k</em>, where <em>k</em> is unknown, there is an algorithm that finds the solution in 

<math display="inline" id="Grover's_algorithm:97">
 <semantics>
  <msqrt>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>k</mi>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N/k}
  </annotation>
 </semantics>
</math>

 queries. This fact is used in order to solve the collision problem. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="quantum-partial-search">Quantum partial search</h2>

<p>A modification of Grover's algorithm called quantum partial search was described by Grover and Radhakrishnan in 2004.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In partial search, one is not interested in finding the exact address of the target item, only the first few digits of the address. Equivalently, we can think of "chunking" the search space into blocks, and then asking "in which block is the target item?". In many applications, such a search yields enough information if the target address contains the information wanted. For instance, to use the example given by L.K. Grover, if one has a list of students organized by class rank, we may only be interested in whether a student is in the lower 25%, 25-50%, 50-70% or 75-100% percentile.</p>

<p>To describe partial search, we consider a database separated into 

<math display="inline" id="Grover's_algorithm:98">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 blocks, each of size 

<math display="inline" id="Grover's_algorithm:99">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=N/K
  </annotation>
 </semantics>
</math>


. Obviously, the partial search problem is easier. Consider the approach we would take classically - we pick one block at random, and then perform a normal search through the rest of the blocks (in set theory language, the complement). If we don't find the target, then we know it's in the block we didn't search. The average number of iterations drops from 

<math display="inline" id="Grover's_algorithm:100">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N/2
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Grover's_algorithm:101">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <ci>b</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N-b)/2
  </annotation>
 </semantics>
</math>

.</p>

<p>Grover's algorithm requires 

<math display="inline" id="Grover's_algorithm:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>π</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi/4\sqrt{N}
  </annotation>
 </semantics>
</math>

 iterations. Partial search will be faster by a numerical factor which depends on the number of blocks 

<math display="inline" id="Grover's_algorithm:103">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

. Partial search uses 

<math display="inline" id="Grover's_algorithm:104">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}
  </annotation>
 </semantics>
</math>


 global iterations and 

<math display="inline" id="Grover's_algorithm:105">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{2}
  </annotation>
 </semantics>
</math>

 local iterations. The global Grover operator is designated 

<math display="inline" id="Grover's_algorithm:106">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

 and the local Grover operator is designated 

<math display="inline" id="Grover's_algorithm:107">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>The global Grover operator acts on the blocks. Essentially, it is given as follows:</p>
<ol>
<li>Perform 

<math display="inline" id="Grover's_algorithm:108">
 <semantics>
  <msub>
   <mi>j</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>j</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j_{1}
  </annotation>
 </semantics>
</math>

 standard Grover iterations on the entire database.</li>
<li>Perform 

<math display="inline" id="Grover's_algorithm:109">
 <semantics>
  <msub>
   <mi>j</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>j</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j_{2}
  </annotation>
 </semantics>
</math>


 local Grover iterations. A local Grover iteration is a direct sum of Grover iterations over each block.</li>
<li>Perform one standard Grover iteration</li>
</ol>

<p>The optimal values of 

<math display="inline" id="Grover's_algorithm:110">
 <semantics>
  <msub>
   <mi>j</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>j</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grover's_algorithm:111">
 <semantics>
  <msub>
   <mi>j</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>j</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j_{2}
  </annotation>
 </semantics>
</math>

 are discussed in the paper by Grover and Radhakrishnan. One might also wonder what happens if one applies successive partial searches at different levels of "resolution". This idea was studied in detail by <a href="Vladimir_Korepin" title="wikilink">Korepin</a> and Xu, who called it binary quantum search. They proved that it is not in fact any faster than performing a single partial search.</p>
<h2 id="optimality">Optimality</h2>

<p>It is known that Grover's algorithm is optimal. That is, any algorithm that accesses the database only by using the operator U<sub>ω</sub> must apply U<sub>ω</sub> at least as many times as Grover's algorithm.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This result is important in understanding the limits of quantum computation. If the Grover's search problem was solvable with <em>log<sup>c</sup> N</em> applications of U<sub>ω</sub>, that would imply that <a href="NP_(complexity_class)" title="wikilink">NP</a> is contained in <a class="uri" href="BQP" title="wikilink">BQP</a>, by transforming problems in NP into Grover-type search problems. The optimality of Grover's algorithm suggests (but does not prove) that NP is not contained in BQP.</p>

<p>The number of iterations for <em>k</em> matching entries, <em>π(N/k)<sup>1/2</sup>/4</em>, is also optimal.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="applicability-and-limitations">Applicability and Limitations</h2>

<p>When applications of Grover's algorithm are considered, it should be emphasized that the database is not represented explicitly. Instead, an oracle is invoked to evaluate an item by its index. Reading a full data-base item by item and converting it into such a representation may take a lot longer than Grover's search. To account for such effects, Grover's algorithm can be viewed as solving an equation or satisfying a constraint. In such applications, the oracle is a way to check the constraint and is not related to the search algorithm. This separation usually prevents algorithmic optimizations, whereas conventional search algorithms often rely on such optimizations and avoid exhaustive search. These and other considerations about using Grover's algorithm are discussed in <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Amplitude_amplification" title="wikilink">Amplitude amplification</a></li>
<li><a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Grover L.K.: <em><a href="http://arxiv.org/abs/quant-ph/9605043">A fast quantum mechanical algorithm for database search</a></em>, Proceedings, 28th Annual ACM Symposium on the Theory of Computing, (May 1996) p. 212</li>
<li>Grover L.K.: <em><a href="http://arxiv.org/abs/quant-ph/0109116">From Schrödinger's equation to quantum search algorithm</a></em>, American Journal of Physics, 69(7): 769-777, 2001. Pedagogical review of the algorithm and its history.</li>
<li>Nielsen, M.A. and Chuang, I.L. <em>Quantum computation and quantum information</em>. Cambridge University Press, 2000. Chapter 6.</li>
<li><a href="http://www.bell-labs.com/user/feature/archives/lkgrover/">What's a Quantum Phone Book?</a>, Lov Grover, Lucent Technologies</li>
<li><a href="http://arxiv.org/abs/quant-ph/0301079">Grover's Algorithm: Quantum Database Search</a>, C. Lavor, L.R.U. Manssur, R. Portugal</li>
<li>[<a class="uri" href="http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1">http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1;</a>;=359266 Grover's algorithm on arxiv.org]</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.davyw.com/quantum/?example=Grover%27s%20Algorithm">1</a> simulation and circuit diagram.</li>
<li><a href="http://twistedoakstudios.com/blog/Post2644_grovers-quantum-search-algorithm">Grover’s Quantum Search Algorithm</a> animated explanation.</li>
<li><a href="http://www.irisa.fr/prive/fschwarz/mit1_algo2_2013/grover_s_algorithm/">2</a> simulation and circuit diagram with cats.</li>
<li><a href="http://demonstrations.wolfram.com/QuantumCircuitImplementingGroversSearchAlgorithm/">Wolfram Demonstration Project: Quantum Circuit Implementing Grover's Search Algorithm</a></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_algorithms" title="wikilink">Category:Quantum algorithms</a> <a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bennett C.H., Bernstein E., Brassard G., Vazirani U., <em><a href="http://www.cs.berkeley.edu/~vazirani/pubs/bbbv.ps">The strengths and weaknesses of quantum computation</a></em>. <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a> 26(5): 1510–1523 (1997). Shows the optimality of Grover's algorithm.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">L.K. Grover and J. Radhakrishnan,<em>Is partial quantum search of a database any easier?</em>. <a href="http://arxiv.org/abs/quant-ph/0407122">quant-ph/0407122</a><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
