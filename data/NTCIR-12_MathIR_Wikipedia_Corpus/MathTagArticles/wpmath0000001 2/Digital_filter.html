<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1279">Digital filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Digital filter</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A general <a href="finite_impulse_response" title="wikilink">finite impulse response</a> filter with <em>n</em> stages, each with an independent delay, <em>d</em><sub>i</sub>, and amplification gain, <em>a</em><sub>i</sub>.</figcaption>
</figure>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, a <strong>digital filter</strong> is a system that performs mathematical operations on a <a href="Sampling_(signal_processing)" title="wikilink">sampled</a>, <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> <a href="Signal_(electrical_engineering)" title="wikilink">signal</a> to reduce or enhance certain aspects of that signal. This is in contrast to the other major type of <a href="electronic_filter" title="wikilink">electronic filter</a>, the <a href="analog_filter" title="wikilink">analog filter</a>, which is an <a href="electronic_circuit" title="wikilink">electronic circuit</a> operating on <a class="uri" href="continuous-time" title="wikilink">continuous-time</a> <a href="analog_signal" title="wikilink">analog signals</a>.</p>

<p>A digital filter system usually consists of an <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converter</a> to sample the input signal, followed by a microprocessor and some peripheral components such as memory to store data and filter coefficients etc. Finally a <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converter</a> to complete the output stage. Program Instructions (software) running on the microprocessor implement the digital filter by performing the necessary mathematical operations on the numbers received from the ADC. In some high performance applications, an <a href="Field-programmable_gate_array" title="wikilink">FPGA</a> or <a href="Application-specific_integrated_circuit" title="wikilink">ASIC</a> is used instead of a general purpose microprocessor, or a specialized DSP with specific paralleled architecture for expediting operations such as filtering.</p>

<p>Digital filters may be more expensive than an equivalent analog filter due to their increased complexity, but they make practical many designs that are impractical or impossible as analog filters. When used in the context of real-time analog systems, digital filters sometimes have problematic latency (the difference in time between the input and the response) due to the associated <a class="uri" href="analog-to-digital" title="wikilink">analog-to-digital</a> and <a class="uri" href="digital-to-analog" title="wikilink">digital-to-analog</a> conversions and <a href="anti-aliasing_filter" title="wikilink">anti-aliasing filters</a>, or due to other delays in their implementation.</p>

<p>Digital filters are commonplace and an essential element of everyday electronics such as <a href="radio" title="wikilink">radios</a>, <a href="cellphone" title="wikilink">cellphones</a>, and <a href="AV_receivers" title="wikilink">AV receivers</a>.</p>
<h2 id="characterization">Characterization</h2>

<p>A digital filter is characterized by its <a href="transfer_function" title="wikilink">transfer function</a>, or equivalently, its <a href="difference_equation" title="wikilink">difference equation</a>. Mathematical analysis of the transfer function can describe how it will respond to any input. As such, designing a filter consists of developing specifications appropriate to the problem (for example, a second-order low pass filter with a specific cut-off frequency), and then producing a transfer function which meets the specifications.</p>

<p>The <a href="transfer_function" title="wikilink">transfer function</a> for a linear, time-invariant, digital filter can be expressed as a transfer function in the <a href="Z-transform" title="wikilink"><em>Z</em>-domain</a>; if it is causal, then it has the form:</p>

<p>

<math display="block" id="Digital_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>N</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mi>N</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>M</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mi>M</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>N</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>M</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <ci>M</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)=\frac{B(z)}{A(z)}=\frac{{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+\cdots+b_{N}z^{-N}%
}}{{1+a_{1}z^{-1}+a_{2}z^{-2}+\cdots+a_{M}z^{-M}}}
  </annotation>
 </semantics>
</math>

</p>

<p>where the order of the filter is the greater of <em>N</em> or <em>M</em>. See <a href="Z-transform#Linear_constant-coefficient_difference_equation" title="wikilink"><em>Z</em>-transform's LCCD equation</a> for further discussion of this <a href="transfer_function" title="wikilink">transfer function</a>.</p>

<p>This is the form for a <a href="recursive_filter" title="wikilink">recursive filter</a> with both the inputs (Numerator) and outputs (Denominator), which typically leads to an IIR <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> behaviour, but if the <a class="uri" href="denominator" title="wikilink">denominator</a> is made equal to <a href="1_(number)" title="wikilink">unity</a> i.e. no feedback, then this becomes an FIR or <a href="finite_impulse_response" title="wikilink">finite impulse response</a> filter.</p>
<h3 id="analysis-techniques">Analysis techniques</h3>

<p>A variety of mathematical techniques may be employed to analyze the behaviour of a given digital filter. Many of these analysis techniques may also be employed in designs, and often form the basis of a filter specification.</p>

<p>Typically, one characterizes filters by calculating how they will respond to a simple input such as an impulse. One can then extend this information to compute the filter's response to more complex signals.</p>
<h4 id="impulse-response">Impulse response</h4>

<p>The <a href="impulse_response" title="wikilink">impulse response</a>, often denoted 

<math display="inline" id="Digital_filter:1">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[k]
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Digital_filter:2">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{k}
  </annotation>
 </semantics>
</math>

, is a measurement of how a filter will respond to the <a href="Kronecker_delta" title="wikilink">Kronecker delta</a> function. For example, given a difference equation, one would set 

<math display="inline" id="Digital_filter:3">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Digital_filter:4">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}=0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Digital_filter:5">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\neq 0
  </annotation>
 </semantics>
</math>

 and evaluate. The impulse response is a characterization of the filter's behaviour. Digital filters are typically considered in two categories: <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR) and <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR). In the case of linear time-invariant FIR filters, the impulse response is exactly equal to the sequence of filter coefficients:</p>

<p>

<math display="block" id="Digital_filter:6">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ y_{n}=\sum_{k=0}^{n-1}h_{k}x_{n-k}
  </annotation>
 </semantics>
</math>

</p>

<p>IIR filters on the other hand are recursive, with the output depending on both current and previous inputs as well as previous outputs. The general form of an IIR filter is thus:</p>

<p>

<math display="block" id="Digital_filter:7">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" lspace="7.5pt" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>m</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \sum_{m=0}^{M-1}a_{m}y_{n-m}=\sum_{k=0}^{n-1}b_{k}x_{n-k}
  </annotation>
 </semantics>
</math>

</p>

<p>Plotting the impulse response will reveal how a filter will respond to a sudden, momentary disturbance.</p>
<h4 id="difference-equation">Difference equation</h4>

<p>In <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> systems, the digital filter is often implemented by converting the <a href="transfer_function" title="wikilink">transfer function</a> to a <a href="Z-transform#Linear_constant-coefficient_difference_equation" title="wikilink">linear constant-coefficient difference equation</a> (LCCD) via the <a class="uri" href="Z-transform" title="wikilink">Z-transform</a>. The discrete <a href="Frequency_domain" title="wikilink">frequency-domain</a> transfer function is written as the ratio of two polynomials. For example:</p>

<p>

<math display="block" id="Digital_filter:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mfrac>
        <mn>3</mn>
        <mn>4</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)=\frac{(z+1)^{2}}{(z-\frac{1}{2})(z+\frac{3}{4})}
  </annotation>
 </semantics>
</math>

</p>

<p>This is expanded:</p>

<p>

<math display="block" id="Digital_filter:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>z</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>z</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <mi>z</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mn>3</mn>
      <mn>8</mn>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>z</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">4</cn>
        </apply>
        <ci>z</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">3</cn>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)=\frac{z^{2}+2z+1}{z^{2}+\frac{1}{4}z-\frac{3}{8}}
  </annotation>
 </semantics>
</math>

</p>

<p>and to make the corresponding filter <a href="causal_filter" title="wikilink">causal</a>, the numerator and denominator are divided by the highest order of 

<math display="inline" id="Digital_filter:10">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Digital_filter:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>3</mn>
       <mn>8</mn>
      </mfrac>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">3</cn>
         <cn type="integer">8</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)=\frac{1+2z^{-1}+z^{-2}}{1+\frac{1}{4}z^{-1}-\frac{3}{8}z^{-2}}=\frac{Y(z)%
}{X(z)}
  </annotation>
 </semantics>
</math>

</p>

<p>The coefficients of the denominator, 

<math display="inline" id="Digital_filter:12">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k}
  </annotation>
 </semantics>
</math>

, are the 'feed-backward' coefficients and the coefficients of the numerator are the 'feed-forward' coefficients, 

<math display="inline" id="Digital_filter:13">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{k}
  </annotation>
 </semantics>
</math>

. The resultant <a href="difference_equation" title="wikilink">linear difference equation</a> is:</p>

<p>

<math display="block" id="Digital_filter:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>k</ci>
        </apply>
        <ci>y</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]=-\sum_{k=1}^{M}a_{k}y[n-k]+\sum_{k=0}^{N}b_{k}x[n-k]
  </annotation>
 </semantics>
</math>

</p>

<p>or, for the example above:</p>

<p>

<math display="block" id="Digital_filter:15">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>3</mn>
       <mn>8</mn>
      </mfrac>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">4</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">8</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{Y(z)}{X(z)}=\frac{1+2z^{-1}+z^{-2}}{1+\frac{1}{4}z^{-1}-\frac{3}{8}z^{-2}}
  </annotation>
 </semantics>
</math>

</p>

<p>rearranging terms:</p>

<p>

<math display="block" id="Digital_filter:16">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>4</mn>
        </mfrac>
        <msup>
         <mi>z</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>3</mn>
        <mn>8</mn>
       </mfrac>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>+</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">3</cn>
         <cn type="integer">8</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>Y</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>X</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow(1+\frac{1}{4}z^{-1}-\frac{3}{8}z^{-2})Y(z)=(1+2z^{-1}+z^{-2})X(z)
  </annotation>
 </semantics>
</math>

</p>

<p>then by taking the inverse <em>z</em>-transform:</p>

<p>

<math display="block" id="Digital_filter:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>3</mn>
      <mn>8</mn>
     </mfrac>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">4</cn>
        </apply>
        <ci>y</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">8</cn>
       </apply>
       <ci>y</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow y[n]+\frac{1}{4}y[n-1]-\frac{3}{8}y[n-2]=x[n]+2x[n-1]+x[n-2]
  </annotation>
 </semantics>
</math>

</p>

<p>and finally, by solving for 

<math display="inline" id="Digital_filter:18">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Digital_filter:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>3</mn>
      <mn>8</mn>
     </mfrac>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
       <ci>y</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">3</cn>
       <cn type="integer">8</cn>
      </apply>
      <ci>y</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]=-\frac{1}{4}y[n-1]+\frac{3}{8}y[n-2]+x[n]+2x[n-1]+x[n-2]
  </annotation>
 </semantics>
</math>

</p>

<p>This equation shows how to compute the next output sample, 

<math display="inline" id="Digital_filter:20">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]
  </annotation>
 </semantics>
</math>

, in terms of the past outputs, 

<math display="inline" id="Digital_filter:21">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n-p]
  </annotation>
 </semantics>
</math>

, the present input, 

<math display="inline" id="Digital_filter:22">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

, and the past inputs, 

<math display="inline" id="Digital_filter:23">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n-p]
  </annotation>
 </semantics>
</math>

. Applying the filter to an input in this form is equivalent to a Direct Form I or II realization, depending on the exact order of evaluation.</p>
<h2 id="filter-design">Filter design</h2>

<p>The design of digital filters is a deceptively complex topic.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Although filters are easily understood and calculated, the practical challenges of their design and implementation are significant and are the subject of much advanced research.</p>

<p>There are two categories of digital filter: the <a href="recursive_filter" title="wikilink">recursive filter</a> and the <a href="nonrecursive_filter" title="wikilink">nonrecursive filter</a>. These are often referred to as <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR) filters and <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filters, respectively.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="filter-realization">Filter realization</h2>

<p>After a filter is designed, it must be <em>realized</em> by developing a signal flow diagram that describes the filter in terms of operations on sample sequences.</p>

<p>A given transfer function may be realized in many ways. Consider how a simple expression such as 

<math display="inline" id="Digital_filter:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>b</mi>
    <mi>x</mi>
   </mrow>
   <mo>+</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>x</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax+bx+c
  </annotation>
 </semantics>
</math>

 could be evaluated – one could also compute the equivalent 

<math display="inline" id="Digital_filter:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(a+b)+c
  </annotation>
 </semantics>
</math>

. In the same way, all realizations may be seen as "factorizations" of the same transfer function, but different realizations will have different numerical properties. Specifically, some realizations are more efficient in terms of the number of operations or storage elements required for their implementation, and others provide advantages such as improved numerical stability and reduced round-off error. Some structures are better for <a href="fixed-point_arithmetic" title="wikilink">fixed-point arithmetic</a> and others may be better for <a href="floating-point_arithmetic" title="wikilink">floating-point arithmetic</a>.</p>
<h3 id="direct-form-i">Direct Form I</h3>

<p>A straightforward approach for IIR filter realization is <a href="Digital_biquad_filter#Direct_Form_1" title="wikilink">Direct Form I</a>, where the difference equation is evaluated directly. This form is practical for small filters, but may be inefficient and impractical (numerically unstable) for complex designs.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In general, this form requires 2N delay elements (for both input and output signals) for a filter of order N.</p>
<figure><b>(Figure)</b>
<figcaption>Biquad filter DF-I.svg</figcaption>
</figure>
<h3 id="direct-form-ii">Direct Form II</h3>

<p>The alternate <a href="Digital_biquad_filter#Direct_Form_2" title="wikilink">Direct Form II</a> only needs <em>N</em> delay units, where <em>N</em> is the order of the filter – potentially half as much as Direct Form I. This structure is obtained by reversing the order of the numerator and denominator sections of Direct Form I, since they are in fact two linear systems, and the commutativity property applies. Then, one will notice that there are two columns of delays (

<math display="inline" id="Digital_filter:26">
 <semantics>
  <msup>
   <mi>z</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{-1}
  </annotation>
 </semantics>
</math>

) that tap off the center net, and these can be combined since they are redundant, yielding the implementation as shown below.</p>

<p>The disadvantage is that Direct Form II increases the possibility of arithmetic overflow for filters of high Q or resonance.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It has been shown that as Q increases, the round-off noise of both direct form topologies increases without bounds.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This is because, conceptually, the signal is first passed through an all-pole filter (which normally boosts gain at the resonant frequencies) before the result of that is saturated, then passed through an all-zero filter (which often attenuates much of what the all-pole half amplifies).</p>
<figure><b>(Figure)</b>
<figcaption>Biquad filter DF-II.svg</figcaption>
</figure>
<h3 id="cascaded-second-order-sections">Cascaded second-order sections</h3>

<p>A common strategy is to realize a higher-order (greater than 2) digital filter as a cascaded series of second-order "biquadratric" (or "biquad") sections<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> (see <a href="digital_biquad_filter" title="wikilink">digital biquad filter</a>). The advantage of this strategy is that the coefficient range is limited. Cascading direct form II sections results in N delay elements for filters of order N. Cascading direct form I sections results in N+2 delay elements since the delay elements of the input of any section (except the first section) are redundant with the delay elements of the output of the preceding section.</p>
<h3 id="other-forms">Other forms</h3>

<p>Other forms include:</p>
<ul>
<li>Direct Form I and II transpose</li>
<li>Series/cascade lower (typical second) order subsections</li>
<li>Parallel lower (typical second) order subsections
<ul>
<li>Continued fraction expansion</li>
</ul></li>
<li>Lattice and ladder
<ul>
<li>One, two and three-multiply lattice forms</li>
<li>Three and four-multiply normalized ladder forms</li>
<li>ARMA structures</li>
</ul></li>
<li>State-space structures:
<ul>
<li>optimal (in the minimum noise sense)

<math display="block" id="Digital_filter:27">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N+1)^{2}
  </annotation>
 </semantics>
</math>

 parameters</li>
<li>block-optimal and section-optimal

<math display="block" id="Digital_filter:28">
 <semantics>
  <mrow>
   <mrow>
    <mn>4</mn>
    <mi>N</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4N-1
  </annotation>
 </semantics>
</math>

 parameters</li>
<li>input balanced with Givens rotation

<math display="block" id="Digital_filter:29">
 <semantics>
  <mrow>
   <mrow>
    <mn>4</mn>
    <mi>N</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4N-1
  </annotation>
 </semantics>
</math>

 parameters<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul></li>
<li>Coupled forms: Gold Rader (normal), State Variable (Chamberlin), Kingsbury, Modified State Variable, Zölzer, Modified Zölzer</li>
<li>Wave Digital Filters (WDF)<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
<li>Agarwal–Burrus (1AB and 2AB)</li>
<li>Harris–Brooking</li>
<li>ND-TDL</li>
<li>Multifeedback</li>
<li>Analog-inspired forms such as Sallen-key and state variable filters</li>
<li><a href="Systolic_array" title="wikilink">Systolic arrays</a></li>
</ul>
<h2 id="comparison-of-analog-and-digital-filters">Comparison of analog and digital filters</h2>

<p>Digital filters are not subject to the component non-linearities that greatly complicate the design of analog filters. Analog filters consist of imperfect electronic components, whose values are specified to a limit tolerance (e.g. resistor values often have a tolerance of ±5%) and which may also change with temperature and drift with time. As the order of an analog filter increases, and thus its component count, the effect of variable component errors is greatly magnified. In digital filters, the coefficient values are stored in computer memory, making them far more stable and predictable.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Because the coefficients of digital filters are definite, they can be used to achieve much more complex and selective designs – specifically with digital filters, one can achieve a lower passband ripple, faster transition, and higher stopband attenuation than is practical with analog filters. Even if the design could be achieved using analog filters, the engineering cost of designing an equivalent digital filter would likely be much lower. Furthermore, one can readily modify the coefficients of a digital filter to make an <a href="adaptive_filter" title="wikilink">adaptive filter</a> or a user-controllable parametric filter. While these techniques are possible in an analog filter, they are again considerably more difficult.</p>

<p>Digital filters can be used in the design of finite impulse response filters. Analog filters do not have the same capability, because finite impulse response filters require delay elements.</p>

<p>Digital filters rely less on analog circuitry, potentially allowing for a better <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a>. A digital filter will introduce noise to a signal during analog low pass filtering, analog to digital conversion, digital to analog conversion and may introduce digital noise due to quantization. With analog filters, every component is a source of thermal noise (such as <a href="Johnson_noise" title="wikilink">Johnson noise</a>), so as the filter complexity grows, so does the noise.</p>

<p>However, digital filters do introduce a higher fundamental latency to the system. In an analog filter, latency is often negligible; strictly speaking it is the time for an electrical signal to propagate through the filter circuit. In digital systems, latency is introduced by delay elements in the digital signal path, and by <a href="Analog-to-digital_converter" title="wikilink">analog-to-digital</a> and <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converters</a> that enable the system to process analog signals.</p>

<p>In very simple cases, it is more cost effective to use an analog filter. Introducing a digital filter requires considerable overhead circuitry, as previously discussed, including two low pass analog filters.</p>

<p>Another argument for analog filters is low power consumption. Analog filters require substantially less power and are therefor the only solution when power requirements are tight.</p>

<p>When making an electrical circuit on a <a href="Printed_circuit_board" title="wikilink">PCB</a> it is generally easier to use a digital solution, because the processing units are highly optimized over the years. Making the same circuit with analog components would take up a lot more space when using <a href="Discrete_circuit" title="wikilink">discrete components</a>. Two alternatives are <a href="Field-programmable_analog_array" title="wikilink">FPAA's</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and <a href="Application-specific_integrated_circuit" title="wikilink">ASIC's</a>, but they are expensive for low quantities.</p>
<h2 id="types-of-digital-filters">Types of digital filters</h2>

<p>Many digital filters are based on the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a>, a mathematical algorithm that quickly extracts the <a href="frequency_spectrum" title="wikilink">frequency spectrum</a> of a signal, allowing the spectrum to be manipulated (such as to create band-pass filters) before converting the modified spectrum back into a time-series signal.</p>

<p>Another form of a digital filter is that of a <a href="state_space_(controls)" title="wikilink">state-space</a> model. A well used state-space filter is the <a href="Kalman_filter" title="wikilink">Kalman filter</a> published by <a href="Rudolf_Kalman" title="wikilink">Rudolf Kalman</a> in 1960.</p>

<p>Traditional linear filters are usually based on attenuation. Alternatively nonlinear filters can be designed, including energy transfer filters <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> which allow the user to move energy in a designed way. So that unwanted noise or effects can be moved to new frequency bands either lower or higher in frequency, spread over a range of frequencies, split, or focused. Energy transfer filters complement traditional filter designs and introduce many more degrees of freedom in filter design. Digital energy transfer filters are relatively easy to design and to implement and exploit nonlinear dynamics.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bessel_filter" title="wikilink">Bessel filter</a></li>
<li><a href="Butterworth_filter" title="wikilink">Butterworth filter</a></li>
<li><a href="Elliptical_filter" title="wikilink">Elliptical filter (Cauer filter)</a></li>
<li><a href="Linkwitz–Riley_filter" title="wikilink">Linkwitz–Riley filter</a></li>
<li><a href="Chebyshev_filter" title="wikilink">Chebyshev filter</a></li>
<li><a href="Sample_(signal)" title="wikilink">Sample (signal)</a></li>
<li><a href="Electronic_filter" title="wikilink">Electronic filter</a></li>
<li><a href="Filter_design" title="wikilink">Filter design</a></li>
<li><a href="Digital_biquad_filter" title="wikilink">Biquad filter</a></li>
<li><a href="High-pass_filter" title="wikilink">High-pass filter</a>, <a href="Low-pass_filter" title="wikilink">Low-pass filter</a></li>
<li><a href="Infinite_impulse_response" title="wikilink">Infinite impulse response</a>, <a href="Finite_impulse_response" title="wikilink">Finite impulse response</a></li>
<li><a href="Bilinear_transform" title="wikilink">Bilinear transform</a></li>
<li><a href="Savitzky–Golay_filter" title="wikilink">Savitzky–Golay filter</a></li>
</ul>
<h2 id="references">References</h2>
<h3 id="general">General</h3>
<ul>
<li>A. Antoniou, <em>Digital Filters: Analysis, Design, and Applications</em>, New York, NY: McGraw-Hill, 1993.</li>
<li>J. O. Smith III, <a href="http://ccrma-www.stanford.edu/~jos/filters/filters.html">Introduction to Digital Filters with Audio Applications</a>, Center for Computer Research in Music and Acoustics (CCRMA), Stanford University, September 2007 Edition.</li>
<li>S.K. Mitra, <em>Digital Signal Processing: A Computer-Based Approach</em>, New York, NY: McGraw-Hill, 1998.</li>
<li>A.V. Oppenheim and R.W. Schafer, <em>Discrete-Time Signal Processing</em>, Upper Saddle River, NJ: Prentice-Hall, 1999.</li>
<li>J.F. Kaiser, <em>Nonrecursive Digital Filter Design Using the Io-sinh Window Function,</em> Proc. 1974 IEEE Int. Symp. Circuit Theory, pp. 20–23, 1974.</li>
<li>S.W.A. Bergen and A. Antoniou, <em>Design of Nonrecursive Digital Filters Using the Ultraspherical Window Function,</em> EURASIP Journal on Applied Signal Processing, vol. 2005, no. 12, pp. 1910–1922, 2005.</li>
<li><a href="Thomas_W._Parks" title="wikilink">T.W. Parks</a> and <a href="James_H._McClellan" title="wikilink">J.H. McClellan</a>, <a href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1083419">Chebyshev Approximation for Nonrecursive Digital Filters with Linear Phase</a>, IEEE Trans. Circuit Theory, vol. CT-19, pp. 189–194, Mar. 1972.</li>
<li><a href="L._R._Rabiner" title="wikilink">L. R. Rabiner</a>, J.H. McClellan, and T.W. Parks, <a href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1451724">FIR Digital Filter Design Techniques Using Weighted Chebyshev Approximation</a>, Proc. IEEE, vol. 63, pp. 595–610, Apr. 1975.</li>
<li>A.G. Deczky, <a href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1162392">Synthesis of Recursive Digital Filters Using the Minimum p-Error Criterion</a>, IEEE Trans. Audio Electroacoust., vol. AU-20, pp. 257–263, Oct. 1972.</li>
</ul>
<h3 id="cited">Cited</h3>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.winfilter.20m.com/">WinFilter</a> – Free filter design software</li>
<li><a href="http://www.digitalfilterdesign.com/">DISPRO</a> – Free filter design software</li>
<li><a href="http://www.falstad.com/dfilter/">Java demonstration of digital filters</a></li>
<li><a href="http://www.terdina.net/iir/iir_explorer.html">IIR Explorer educational software</a></li>
<li><a href="http://math.fullerton.edu/mathews/c2003/ZTransformFilterMod.html">Introduction to Filtering</a></li>
<li><a href="http://ccrma.stanford.edu/~jos/filters/filters.html">Introduction to Digital Filters</a></li>
<li><a href="http://www.cs.tut.fi/~ts/">Publicly available, very comprehensive lecture notes on Digital Linear Filtering (see bottom of the page)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Synthesiser_modules" title="wikilink">Category:Synthesiser modules</a> <a href="Category:Signal_processing_filter" title="wikilink">*</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. E. Valdez, <a href="http://home.mchsi.com/~mikevald/Digfilt.html">Digital Filters</a>, 2001.<a href="#fnref1">↩</a></li>
<li id="fn2">A. Antoniou, chapter 1<a href="#fnref2">↩</a></li>
<li id="fn3">J. O. Smith III, <a href="http://ccrma-www.stanford.edu/~jos/filters/Direct_Form_I.html">Direct Form I</a><a href="#fnref3">↩</a></li>
<li id="fn4">J. O. Smith III, <a href="http://ccrma-www.stanford.edu/~jos/filters/Direct_Form_II.html">Direct Form II</a><a href="#fnref4">↩</a></li>
<li id="fn5">L. B. Jackson, "On the Interaction of Roundoff Noise and Dynamic Range in Digital Filters," <em>Bell Sys. Tech. J.</em>, vol. 49 (1970 Feb.), reprinted in <em>Digital Signal Process</em>, L. R. Rabiner and C. M. Rader, Eds. (IEEE Press, New York, 1972).<a href="#fnref5">↩</a></li>
<li id="fn6">J. O. Smith III, <a href="http://ccrma-www.stanford.edu/~jos/filters/Series_Second_Order_Sections.html">Series Second Order Sections</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a class="uri" href="http://www.dspguide.com/ch21/1.htm">http://www.dspguide.com/ch21/1.htm</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">Billings S.A. "Nonlinear System Identification: NARMAX Methods in the Time, Frequency, and Spatio-Temporal Domains". Wiley, 2013<a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
