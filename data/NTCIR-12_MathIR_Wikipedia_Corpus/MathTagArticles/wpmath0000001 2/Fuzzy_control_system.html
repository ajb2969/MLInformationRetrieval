<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1574">Fuzzy control system</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fuzzy control system</h1>
<hr/>

<p>A <strong>fuzzy control system</strong> is a <a href="control_system" title="wikilink">control system</a> based on <a href="fuzzy_logic" title="wikilink">fuzzy logic</a>—a <a href="mathematics" title="wikilink">mathematical</a> system that analyzes <a href="analog_signal" title="wikilink">analog</a> input values in terms of <a href="mathematical_logic" title="wikilink">logical</a> variables that take on continuous values between 0 and 1, in contrast to classical or <a href="Digital_data" title="wikilink">digital</a> logic, which operates on discrete values of either 1 or 0 (true or false, respectively).</p>
<h2 id="overview">Overview</h2>

<p>Fuzzy logic is widely used in a machine control. The term "fuzzy" refers to the fact that the logic involved can deal with concepts that cannot be expressed as the "true" or "false" but rather as "partially true". Although alternative approaches such as genetic algorithms and neural networks can perform just as well as fuzzy logic in many cases, fuzzy logic has the advantage that the solution to the problem can be cast in terms that human operators can understand, so that their experience can be used in the design of the controller. This makes it easier to mechanize tasks that are already successfully performed by humans.</p>
<h2 id="history-and-applications">History and applications</h2>

<p>Fuzzy logic was first proposed by <a href="Lotfi_A._Zadeh" title="wikilink">Lotfi A. Zadeh</a> of the University of California at Berkeley in a 1965 paper. He elaborated on his ideas in a 1973 paper that introduced the concept of "linguistic variables", which in this article equates to a variable defined as a fuzzy set. Other research followed, with the first industrial application, a cement <a class="uri" href="kiln" title="wikilink">kiln</a> built in Denmark, coming on line in 1975.</p>

<p>Fuzzy systems were initially implemented in Japan.</p>
<ul>
<li>Interest in fuzzy systems was sparked by Seiji Yasunobu and Soji Miyamoto of <a class="uri" href="Hitachi" title="wikilink">Hitachi</a>, who in 1985 provided simulations that demonstrated the feasibility of fuzzy control systems for the <a class="uri" href="Sendai" title="wikilink">Sendai</a> railway. Their ideas were adopted, and fuzzy systems were used to control accelerating, braking, and stopping when the line opened in 1987.</li>
</ul>
<ul>
<li>In 1987, Takeshi Yamakawa demonstrated the use of fuzzy control, through a set of simple dedicated fuzzy logic chips, in an "<a href="inverted_pendulum" title="wikilink">inverted pendulum</a>" experiment. This is a classic control problem, in which a vehicle tries to keep a pole mounted on its top by a hinge upright by moving back and forth. Yamakawa subsequently made the demonstration more sophisticated by mounting a wine glass containing water and even a live mouse to the top of the pendulum: the system maintained stability in both cases. Yamakawa eventually went on to organize his own fuzzy-systems research lab to help exploit his patents in the field.</li>
</ul>
<ul>
<li>Japanese engineers subsequently developed a wide range of fuzzy systems for both industrial and consumer applications. In 1988 Japan established the Laboratory for International Fuzzy Engineering (LIFE), a cooperative arrangement between 48 companies to pursue fuzzy research. The automotive company Volkswagen was the only foreign corporate member of LIFE, dispatching a researcher for a duration of three years.</li>
</ul>
<ul>
<li>Japanese consumer goods often incorporate fuzzy systems. Matsushita vacuum cleaners use microcontrollers running fuzzy algorithms to interrogate dust sensors and adjust <a href="suction_power" title="wikilink">suction power</a> accordingly. Hitachi washing machines use fuzzy controllers to load-weight, fabric-mix, and dirt sensors and automatically set the wash cycle for the best use of power, water, and detergent.</li>
</ul>
<ul>
<li>Canon developed an <a href="autofocus" title="wikilink">autofocusing</a> camera that uses a <a href="charge-coupled_device" title="wikilink">charge-coupled device</a> (CCD) to measure the clarity of the image in six regions of its field of view and use the information provided to determine if the image is in focus. It also tracks the rate of change of lens movement during focusing, and controls its speed to prevent overshoot. The camera's fuzzy control system uses 12 inputs: 6 to obtain the current clarity data provided by the CCD and 6 to measure the rate of change of lens movement. The output is the position of the lens. The fuzzy control system uses 13 rules and requires 1.1 kilobytes of memory.</li>
</ul>
<ul>
<li>An industrial <a href="air_conditioner" title="wikilink">air conditioner</a> designed by Mitsubishi uses 25 heating rules and 25 cooling rules. A temperature sensor provides input, with control outputs fed to an <a href="inverter_(logic_gate)" title="wikilink">inverter</a>, a compressor valve, and a fan motor. Compared to the previous design, the fuzzy controller heats and cools five times faster, reduces power consumption by 24%, increases temperature stability by a factor of two, and uses fewer sensors.</li>
</ul>
<ul>
<li>Other applications investigated or implemented include: character and handwriting recognition; optical fuzzy systems; robots, including one for making Japanese flower arrangements; <a href="voice_control" title="wikilink">voice-controlled</a> robot helicopters (hovering is a "balancing act" rather similar to the inverted pendulum problem); control of flow of powders in film manufacture; elevator systems; and so on.</li>
</ul>

<p>Work on fuzzy systems is also proceeding in the United State and Europe, although on a less extensive scale than in Japan.</p>
<ul>
<li>The <a href="US_Environmental_Protection_Agency" title="wikilink">US Environmental Protection Agency</a> has investigated fuzzy control for <a href="Efficient_energy_use" title="wikilink">energy-efficient</a> motors, and <a class="uri" href="NASA" title="wikilink">NASA</a> has studied fuzzy control for automated space docking: simulations show that a fuzzy control system can greatly reduce fuel consumption.</li>
</ul>
<ul>
<li>Firms such as <a class="uri" href="Boeing" title="wikilink">Boeing</a>, <a href="General_Motors" title="wikilink">General Motors</a>, <a class="uri" href="Allen-Bradley" title="wikilink">Allen-Bradley</a>, <a class="uri" href="Chrysler" title="wikilink">Chrysler</a>, <a href="Eaton_Corporation" title="wikilink">Eaton</a>, and <a href="Whirlpool_Corporation" title="wikilink">Whirlpool</a> have worked on fuzzy logic for use in low-power refrigerators, improved automotive transmissions, and energy-efficient electric motors.</li>
</ul>
<ul>
<li>In 1995 <a class="uri" href="Maytag" title="wikilink">Maytag</a> introduced an "intelligent" <a class="uri" href="dishwasher" title="wikilink">dishwasher</a> based on a fuzzy controller and a "one-stop sensing module" that combines a <a class="uri" href="thermistor" title="wikilink">thermistor</a>, for temperature measurement; a conductivity sensor, to measure detergent level from the ions present in the wash; a turbidity sensor that measures scattered and transmitted light to measure the soiling of the wash; and a magnetostrictive sensor to read spin rate. The system determines the optimum wash cycle for any load to obtain the best results with the least amount of energy, detergent, and water. It even adjusts for dried-on foods by tracking the last time the door was opened, and estimates the number of dishes by the number of times the door was opened.</li>
</ul>

<p>Research and development is also continuing on fuzzy applications in software, as opposed to <a class="uri" href="firmware" title="wikilink">firmware</a>, design, including fuzzy <a href="expert_system" title="wikilink">expert systems</a> and integration of fuzzy logic with <a href="neural_network" title="wikilink">neural-network</a> and so-called adaptive "<a href="genetic_algorithm" title="wikilink">genetic</a>" software systems, with the ultimate goal of building "self-learning" fuzzy-control systems.</p>
<h2 id="fuzzy-sets">Fuzzy sets</h2>

<p>The input variables in a fuzzy control system are in general mapped by sets of membership functions similar to this, known as "fuzzy sets". The process of converting a crisp input value to a fuzzy value is called "fuzzification".</p>

<p>A control system may also have various types of <a class="uri" href="switch" title="wikilink">switch</a>, or "ON-OFF", inputs along with its analog inputs, and such switch inputs of course will always have a truth value equal to either 1 or 0, but the scheme can deal with them as simplified fuzzy functions that happen to be either one value or another.</p>

<p>Given "<a href="Map_(mathematics)" title="wikilink">mappings</a>" of input variables into membership functions and <a href="truth_value" title="wikilink">truth values</a>, the <a class="uri" href="microcontroller" title="wikilink">microcontroller</a> then <a href="decision_making" title="wikilink">makes decisions</a> for what action to take, based on a set of "rules", each of the form:</p>

<p><code>  IF brake temperature IS warm AND speed IS not very fast </code><br/>
<code>  THEN brake pressure IS slightly decreased.</code></p>

<p>In this example, the two input variables are "brake temperature" and "speed" that have values defined as fuzzy sets. The output variable, "brake pressure" is also defined by a fuzzy set that can have values like "static" or "slightly increased" or "slightly decreased" etc.</p>

<p>This rule by itself is very puzzling since it looks like it could be used without bothering with fuzzy logic, but remember that the decision is based on a set of rules:</p>
<ul>
<li>All the rules that apply are invoked, using the membership functions and truth values obtained from the inputs, to determine the result of the rule.</li>
<li>This result in turn will be mapped into a membership function and truth value controlling the output variable.</li>
<li>These results are combined to give a specific ("crisp") answer, the actual brake pressure, a procedure known as "<a class="uri" href="defuzzification" title="wikilink">defuzzification</a>".</li>
</ul>

<p>This combination of fuzzy operations and <a href="Rule-based_system" title="wikilink">rule-based</a> "<a class="uri" href="inference" title="wikilink">inference</a>" describes a "fuzzy expert system".</p>

<p>Traditional control systems are based on mathematical models in which the control system is described using one or more <a href="differential_equation" title="wikilink">differential equations</a> that define the system response to its inputs. Such systems are often implemented as "PID controllers" (<a href="PID_controller" title="wikilink">proportional-integral-derivative controllers</a>). They are the products of decades of development and theoretical analysis, and are highly effective.</p>

<p>If PID and other traditional control systems are so well-developed, why bother with fuzzy control? It has some advantages. In many cases, the mathematical model of the control process may not exist, or may be too "expensive" in terms of computer processing power and memory, and a system based on empirical rules may be more effective.</p>

<p>Furthermore, fuzzy logic is well suited to low-cost implementations based on cheap sensors, low-resolution analog-to-digital converters, and 4-bit or 8-bit one-chip microcontroller chips. Such systems can be easily upgraded by adding new rules to improve performance or add new features. In many cases, fuzzy control can be used to improve existing traditional controller systems by adding an extra layer of intelligence to the current control method.</p>
<h3 id="fuzzy-control-in-detail">Fuzzy control in detail</h3>

<p>Fuzzy controllers are very simple conceptually. They consist of an input stage, a processing stage, and an output stage. The input stage maps sensor or other inputs, such as switches, thumbwheels, and so on, to the appropriate membership functions and truth values. The processing stage invokes each appropriate rule and generates a result for each, then combines the results of the rules. Finally, the output stage converts the combined result back into a specific control output value.</p>

<p>The most common shape of membership functions is triangular, although trapezoidal and bell curves are also used, but the shape is generally less important than the number of curves and their placement. From three to seven curves are generally appropriate to cover the required range of an input value, or the "<a href="universe_of_discourse" title="wikilink">universe of discourse</a>" in fuzzy jargon.</p>

<p>As discussed earlier, the processing stage is based on a collection of logic rules in the form of IF-THEN statements, where the IF part is called the "antecedent" and the THEN part is called the "consequent". Typical fuzzy control systems have dozens of rules.</p>

<p>Consider a rule for a thermostat:</p>

<p><code>  IF (temperature is "cold") THEN (heater is "high")</code></p>

<p>This rule uses the truth value of the "temperature" input, which is some truth value of "cold", to generate a result in the fuzzy set for the "heater" output, which is some value of "high". This result is used with the results of other rules to finally generate the crisp composite output. Obviously, the greater the truth value of "cold", the higher the truth value of "high", though this does not necessarily mean that the output itself will be set to "high" since this is only one rule among many. In some cases, the membership functions can be modified by "hedges" that are equivalent to adverbs. Common hedges include "about", "near", "close to", "approximately", "very", "slightly", "too", "extremely", and "somewhat". These operations may have precise definitions, though the definitions can vary considerably between different implementations. "Very", for one example, squares membership functions; since the membership values are always less than 1, this narrows the membership function. "Extremely" cubes the values to give greater narrowing, while "somewhat" broadens the function by taking the square root.</p>

<p>In practice, the fuzzy rule sets usually have several antecedents that are combined using fuzzy operators, such as AND, OR, and NOT, though again the definitions tend to vary: AND, in one popular definition, simply uses the minimum weight of all the antecedents, while OR uses the maximum value. There is also a NOT operator that subtracts a membership function from 1 to give the "complementary" function.</p>

<p>There are several ways to define the result of a rule, but one of the most common and simplest is the "max-min" <a class="uri" href="inference" title="wikilink">inference</a> method, in which the output membership function is given the truth value generated by the premise.</p>

<p>Rules can be solved in parallel in hardware, or sequentially in software. The results of all the rules that have fired are "defuzzified" to a crisp value by one of several methods. There are dozens, in theory, each with various advantages or drawbacks.</p>

<p>The "centroid" method is very popular, in which the "center of mass" of the result provides the crisp value. Another approach is the "height" method, which takes the value of the biggest contributor. The centroid method favors the rule with the output of greatest area, while the height method obviously favors the rule with the greatest output value.</p>

<p>The diagram below demonstrates max-min inferencing and centroid defuzzification for a system with input variables "x", "y", and "z" and an output variable "n". Note that "mu" is standard fuzzy-logic nomenclature for "truth value":</p>
<figure><b>(Figure)</b>
<figcaption>Fuzzy control - centroid defuzzification using max-min inferencing.png</figcaption>
</figure>

<p>Notice how each rule provides a result as a truth value of a particular membership function for the output variable. In centroid defuzzification the values are OR'd, that is, the maximum value is used and values are not added, and the results are then combined using a centroid calculation.</p>

<p>Fuzzy control system design is based on empirical methods, basically a methodical approach to <a class="uri" href="trial-and-error" title="wikilink">trial-and-error</a>. The general process is as follows:</p>
<ul>
<li>Document the system's operational specifications and inputs and outputs.</li>
<li>Document the fuzzy sets for the inputs.</li>
<li>Document the rule set.</li>
<li>Determine the defuzzification method.</li>
<li>Run through test suite to validate system, adjust details as required.</li>
<li>Complete document and release to production.</li>
</ul>

<p>As a general example, consider the design of a fuzzy controller for a steam turbine. The block diagram of this control system appears as follows:</p>

<p>The input and output variables map into the following fuzzy set:</p>

<p>—where:</p>

<p><code>  N3:   Large negative.</code><br/>
<code>  N2:   Medium negative.</code><br/>
<code>  N1:   Small negative.</code><br/>
<code>  Z:    Zero.</code><br/>
<code>  P1:   Small positive.</code><br/>
<code>  P2:   Medium positive.</code><br/>
<code>  P3:   Large positive.</code></p>

<p>The rule set includes such rules as:</p>

<p><code>rule 1:  IF temperature IS cool AND pressure IS weak,   </code><br/>
<code>         THEN throttle is P3.</code></p>

<p><code>rule 2:  IF temperature IS cool AND pressure IS low,    </code><br/>
<code>         THEN throttle is P2.</code></p>

<p><code>rule 3:  IF temperature IS cool AND pressure IS ok,     </code><br/>
<code>         THEN throttle is Z.</code></p>

<p><code>rule 4:  IF temperature IS cool AND pressure IS strong, </code><br/>
<code>         THEN throttle is N2.</code></p>

<p>In practice, the controller accepts the inputs and maps them into their membership functions and truth values. These mappings are then fed into the rules. If the rule specifies an AND relationship between the mappings of the two input variables, as the examples above do, the minimum of the two is used as the combined truth value; if an OR is specified, the maximum is used. The appropriate output state is selected and assigned a membership value at the truth level of the premise. The truth values are then defuzzified. For an example, assume the temperature is in the "cool" state, and the pressure is in the "low" and "ok" states. The pressure values ensure that only rules 2 and 3 fire:</p>
<figure><b>(Figure)</b>
<figcaption>Fuzzy control - Rule 2 evaluation.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Fuzzy control - Rule 3 evaluation.png</figcaption>
</figure>

<p>The two outputs are then defuzzified through centroid defuzzification:</p>
<pre><code>   __________________________________________________________________

                                       |          Z      P2
                                    1 -+          *       *
                                       |         * *     * *
                                       |        *   *   *   *
                                       |       *     * *     *
                                       |      *       222222222
                                       |     *       22222222222
                                       |    333333332222222222222
                                       +---33333333222222222222222--&gt;
                                                        ^ 
                                                      +150 
   __________________________________________________________________</code></pre>

<p>The output value will adjust the throttle and then the control cycle will begin again to generate the next value .</p>
<h3 id="building-a-fuzzy-controller">Building a fuzzy controller</h3>

<p>Consider implementing with a microcontroller chip a simple feedback controller:</p>
<figure><b>(Figure)</b>
<figcaption>Fuzzy control system-feedback controller.png</figcaption>
</figure>

<p>A fuzzy set is defined for the input error variable "e", and the derived change in error, "delta", as well as the "output", as follows:</p>

<p><code>  LP:  large positive</code><br/>
<code>  SP:  small positive</code><br/>
<code>  ZE:  zero</code><br/>
<code>  SN:  small negative</code><br/>
<code>  LN:  large negative</code></p>

<p>If the error ranges from -1 to +1, with the analog-to-digital converter used having a resolution of 0.25, then the input variable's fuzzy set (which, in this case, also applies to the output variable) can be described very simply as a table, with the error / delta / output values in the top row and the truth values for each membership function arranged in rows beneath:</p>

<p><code>  _______________________________________________________________________</code><br/>
<br/>
<code>              -1    -0.75  -0.5   -0.25    0     0.25   0.5    0.75    1</code><br/>
<code>  _______________________________________________________________________</code><br/>
<br/>
<code>   mu(LP)      0      0      0      0      0      0     0.3    0.7     1</code><br/>
<code>   mu(SP)      0      0      0      0     0.3    0.7     1     0.7    0.3</code><br/>
<code>   mu(ZE)      0      0     0.3    0.7     1     0.7    0.3     0      0</code><br/>
<code>   mu(SN)     0.3    0.7     1     0.7    0.3     0      0      0      0</code><br/>
<code>   mu(LN)      1     0.7    0.3     0      0      0      0      0      0</code><br/>
<code>  _______________________________________________________________________—or, in graphical form (where each "X" has a value of 0.1):</code></p>

<p><code>         LN           SN           ZE           SP           LP</code><br/>
<code>      +------------------------------------------------------------------+</code><br/>
<code>      |                                                                  |</code><br/>
<code>-1.0  |  XXXXXXXXXX   XXX          :            :            :           |</code><br/>
<code>-0.75 |  XXXXXXX      XXXXXXX      :            :            :           |</code><br/>
<code>-0.5  |  XXX          XXXXXXXXXX   XXX          :            :           |</code><br/>
<code>-0.25 |  :            XXXXXXX      XXXXXXX      :            :           |</code><br/>
<code> 0.0  |  :            XXX          XXXXXXXXXX   XXX          :           |</code><br/>
<code> 0.25 |  :            :            XXXXXXX      XXXXXXX      :           |</code><br/>
<code> 0.5  |  :            :            XXX          XXXXXXXXXX   XXX         |</code><br/>
<code> 0.75 |  :            :            :            XXXXXXX      XXXXXXX     |</code><br/>
<code> 1.0  |  :            :            :            XXX          XXXXXXXXXX  |</code><br/>
<code>      |                                                                  |</code><br/>
<code>      +------------------------------------------------------------------+</code></p>

<p>Suppose this fuzzy system has the following rule base:</p>

<p><code>  rule 1:  IF e = ZE AND delta = ZE THEN output = ZE</code><br/>
<code>  rule 2:  IF e = ZE AND delta = SP THEN output = SN</code><br/>
<code>  rule 3:  IF e = SN AND delta = SN THEN output = LP</code><br/>
<code>  rule 4:  IF e = LP OR  delta = LP THEN output = LN</code></p>

<p>These rules are typical for control applications in that the antecedents consist of the logical combination of the error and error-delta signals, while the consequent is a control command output. The rule outputs can be defuzzified using a discrete centroid computation:</p>

<p><code>  SUM( I = 1 TO 4 OF ( mu(I) * output(I) ) ) / SUM( I = 1 TO 4 OF mu(I) )</code></p>

<p>Now, suppose that at a given time we have:</p>

<p><code>  e     = 0.25</code><br/>
<code>  delta = 0.5</code></p>

<p>Then this gives:</p>

<p><code>  ________________________</code><br/>
<br/>
<code>              e     delta</code><br/>
<code>  ________________________</code><br/>
<br/>
<code>  mu(LP)      0      0.3</code><br/>
<code>  mu(SP)     0.7      1</code><br/>
<code>  mu(ZE)     0.7     0.3</code><br/>
<code>  mu(SN)      0       0</code><br/>
<code>  mu(LN)      0       0</code><br/>
<code>  ________________________</code></p>

<p>Plugging this into rule 1 gives:</p>

<p><code>  rule 1:  IF e = ZE AND delta = ZE THEN output = ZE</code><br/>
<code> </code><br/>
<code>     mu(1)     = MIN( 0.7, 0.3 ) = 0.3</code><br/>
<code>     output(1) = 0</code></p>

<p>-- where:</p>
<ul>
<li>mu(1): Truth value of the result membership function for rule 1. In terms of a centroid calculation, this is the "mass" of this result for this discrete case.</li>
<li>output(1): Value (for rule 1) where the result membership function (ZE) is maximum over the output variable fuzzy set range. That is, in terms of a centroid calculation, the location of the "center of mass" for this individual result. This value is independent of the value of "mu". It simply identifies the location of ZE along the output range.</li>
</ul>

<p>The other rules give:</p>

<p><code>  rule 2:  IF e = ZE AND delta = SP THEN output = SN</code><br/>
<br/>
<code>     mu(2)     = MIN( 0.7, 1 ) = 0.7   </code><br/>
<code>     output(2) = -0.5</code></p>

<p><code>  rule 3: IF e = SN AND delta = SN THEN output = LP</code><br/>
<br/>
<code>     mu(3)     = MIN( 0.0, 0.0 ) = 0</code><br/>
<code>     output(3) = 1</code></p>

<p><code>  rule 4: IF e = LP OR  delta = LP THEN output = LN</code><br/>
<br/>
<code>     mu(4)     = MAX( 0.0, 0.3 ) = 0.3</code><br/>
<code>     output(4) = -1</code></p>

<p>The centroid computation yields:</p>

<p><code>  </code>

<math display="inline" id="Fuzzy_control_system:0">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mrow>
      <mi>o</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mi>p</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mrow>
      <mi>o</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mi>p</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mrow>
      <mi>o</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mi>p</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>4</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
     <mi>p</mi>
     <mi>u</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>4</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>m</mi>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>m</mi>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>3</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>m</mi>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>4</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>u</ci>
       <ci>t</ci>
       <ci>p</ci>
       <ci>u</ci>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>u</ci>
       <ci>t</ci>
       <ci>p</ci>
       <ci>u</ci>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>u</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>u</ci>
       <ci>t</ci>
       <ci>p</ci>
       <ci>u</ci>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>u</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
      <ci>p</ci>
      <ci>u</ci>
      <ci>t</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>u</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>u</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{mu(1).output(1)+mu(2).output(2)+mu(3).output(3)+mu(4).output(4)}{mu(1)+%
mu(2)+mu(3)+mu(4)}
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="inline" id="Fuzzy_control_system:1">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0.3</mn>
      <mo>*</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0.7</mn>
      <mo>*</mo>
      <mo>-</mo>
      <mn>0.5</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>*</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0.3</mn>
      <mo>*</mo>
      <mo>-</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>0.3</mn>
     <mo>+</mo>
     <mn>0.7</mn>
     <mo>+</mo>
     <mn>0</mn>
     <mo>+</mo>
     <mn>0.3</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="float">0.3</cn>
       <times></times>
       <cn type="integer">0</cn>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="float">0.7</cn>
       <times></times>
       <minus></minus>
       <cn type="float">0.5</cn>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">0</cn>
       <times></times>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="float">0.3</cn>
       <times></times>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <plus></plus>
      <cn type="float">0.3</cn>
      <cn type="float">0.7</cn>
      <cn type="integer">0</cn>
      <cn type="float">0.3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{(0.3*0)+(0.7*-0.5)+(0*1)+(0.3*-1)}{0.3+0.7+0+0.3}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Fuzzy_control_system:2">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>0.5</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <cn type="float">0.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =-0.5
  </annotation>
 </semantics>
</math>

—for the final control output. Simple. Of course the hard part is figuring out what rules actually work correctly in practice.</p>

<p>If you have problems figuring out the centroid equation, remember that a centroid is defined by summing all the moments (location times mass) around the center of gravity and equating the sum to zero. So if 

<math display="inline" id="Fuzzy_control_system:3">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 is the center of gravity, 

<math display="inline" id="Fuzzy_control_system:4">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 is the location of each mass, and 

<math display="inline" id="Fuzzy_control_system:5">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>


 is each mass, this gives:</p>

<p><code>  </code>

<math display="inline" id="Fuzzy_control_system:6">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>X</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
     <msub>
      <mi>M</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mn>2</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>X</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
     <msub>
      <mi>M</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mi>n</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>X</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
     <msub>
      <mi>M</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=(X_{1}-X_{0})*M_{1}+(X_{2}-X_{0})*M_{2}+\ldots+(X_{n}-X_{0})*M_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Fuzzy_control_system:7">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>X</mi>
        <mn>1</mn>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>M</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mn>2</mn>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>M</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">…</mi>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mi>n</mi>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>M</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mn>0</mn>
     </msub>
     <mo>*</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>M</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>M</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">…</mi>
       <mo>+</mo>
       <msub>
        <mi>M</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=(X_{1}*M_{1}+X_{2}*M_{2}+\ldots+X_{n}*M_{n})-X_{0}*(M_{1}+M_{2}+\ldots+M_{n})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Fuzzy_control_system:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>0</mn>
    </msub>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>M</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>M</mi>
       <mn>2</mn>
      </msub>
      <mo>+</mo>
      <mi mathvariant="normal">…</mi>
      <mo>+</mo>
      <msub>
       <mi>M</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>X</mi>
      <mn>1</mn>
     </msub>
     <mo>*</mo>
     <msub>
      <mi>M</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mn>2</mn>
     </msub>
     <mo>*</mo>
     <msub>
      <mi>M</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>n</mi>
     </msub>
     <mo>*</mo>
     <msub>
      <mi>M</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}*(M_{1}+M_{2}+\ldots+M_{n})=X_{1}*M_{1}+X_{2}*M_{2}+\ldots+X_{n}*M_{n}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Fuzzy_control_system:9">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>X</mi>
       <mn>1</mn>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>M</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mn>2</mn>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>M</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>M</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>M</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>M</mi>
      <mn>2</mn>
     </msub>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <msub>
      <mi>M</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}=\frac{X_{1}*M_{1}+X_{2}*M_{2}+\ldots+X_{n}*M_{n}}{M_{1}+M_{2}+\ldots+M_{%
n}}
  </annotation>
 </semantics>
</math>

</p>

<p>In our example, the values of mu correspond to the masses, and the values of X to location of the masses (mu, however, only 'corresponds to the masses' if the initial 'mass' of the output functions are all the same/equivalent. If they are not the same, i.e. some are narrow triangles, while others maybe wide trapizoids or shouldered triangles, then the mass or area of the output function must be known or calculated. It is this mass that is then scaled by mu and multiplied by its location X_i).</p>

<p>This system can be implemented on a standard microprocessor, but dedicated fuzzy chips are now available. For example, Adaptive Logic INC of San Jose, California, sells a "fuzzy chip", the AL220, that can accept four analog inputs and generate four analog outputs. A block diagram of the chip is shown below:</p>
<pre><code>              +---------+                              +-------+
 analog --4--&gt;| analog  |                              | mux / +--4--&gt; analog
   in         |   mux   |                              |  SH   |        out
              +----+----+                              +-------+
                   |                                       ^
                   V                                       |
            +-------------+                             +--+--+
            | ADC / latch |                             | DAC |
            +------+------+                             +-----+
                   |                                       ^
                   |                                       |
                   8         +-----------------------------+
                   |         |                             |
                   |         V                             |
                   |   +-----------+      +-------------+  |
                   +--&gt;| fuzzifier |      | defuzzifier +--+
                       +-----+-----+      +-------------+
                             |                   ^
                             |  +-------------+  |
                             |  |    rule     |  |
                             +-&gt;|  processor  +--+
                                | (50 rules)  |
                                +------+------+
                                       |
                                +------+------+
                                |  parameter  |
                                |    memory   |
                                |   256 x 8   |
                                +-------------+

    ADC:  analog-to-digital converter
    DAC:  digital-to-analog converter
    SH:   sample/hold</code></pre>
<h2 id="antilock-brakes">Antilock brakes</h2>

<p>As a first example, consider an <a href="anti-lock_braking_system" title="wikilink">anti-lock braking system</a>, directed by a microcontroller chip. The microcontroller has to make decisions based on brake <a class="uri" href="temperature" title="wikilink">temperature</a>, <a class="uri" href="speed" title="wikilink">speed</a>, and other variables in the system.</p>

<p>The variable "temperature" in this system can be subdivided into a range of "states": "cold", "cool", "moderate", "warm", "hot", "very hot". The transition from one state to the next is hard to define.</p>

<p>An arbitrary static threshold might be set to divide "warm" from "hot". For example, at exactly 90 degrees, warm ends and hot begins. But this would result in a discontinuous change when the input value passed over that threshold. The transition wouldn't be smooth, as would be required in braking situations.</p>

<p>The way around this is to make the states <em>fuzzy</em>. That is, allow them to change gradually from one state to the next. In order to do this there must be a dynamic relationship established between different factors.</p>

<p>We start by defining the input temperature states using "membership functions":</p>
<figure><b>(Figure)</b>
<figcaption>Fuzzy control - definition of input temperature states using membership functions.png</figcaption>
</figure>

<p>With this scheme, the input variable's state no longer jumps abruptly from one state to the next. Instead, as the temperature changes, it loses value in one membership function while gaining value in the next. In other words, its ranking in the category of cold decreases as it becomes more highly ranked in the warmer category.</p>

<p>At any sampled timeframe, the "truth value" of the brake temperature will almost always be in some degree part of two membership functions: i.e.: '0.6 nominal and 0.4 warm', or '0.7 nominal and 0.3 cool', and so on.</p>

<p>The above example demonstrates a simple application, using the <a class="uri" href="abstraction" title="wikilink">abstraction</a> of values from multiple values. This only represents one kind of data, however, in this case, temperature.</p>

<p>Adding additional sophistication to this braking system, could be done by additional factors such as <a href="Traction_(engineering)" title="wikilink">traction</a>, speed, <a class="uri" href="inertia" title="wikilink">inertia</a>, set up in dynamic functions, according to the designed fuzzy system.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="logical-interpretation-of-fuzzy-control">Logical interpretation of fuzzy control</h2>

<p>In spite of the appearance there are several difficulties to give a rigorous logical interpretation of the <em>IF-THEN</em> rules. As an example, interpret a rule as <em>IF (temperature is "cold") THEN (heater is "high")</em> by the first order formula <em>Cold(x)→High(y)</em> and assume that r is an input such that <em>Cold(r)</em> is false. Then the formula <em>Cold(r)→High(t)</em> is true for any <em>t</em> and therefore any <em>t</em> gives a correct control given <em>r</em>. A rigorous logical justification of fuzzy control is given in Hájek's book (see Chapter 7) where fuzzy control is represented as a theory of Hájek's basic logic. Also in Gerla 2005 a logical approach to fuzzy control is proposed based on fuzzy logic programming. Indeed, denote by <em>f</em> the fuzzy function arising of an IF-THEN systems of rules. Then we can translate this system into a fuzzy program P containing a series of rules whose head is "Good(x,y)". The interpretation of this predicate in the least fuzzy Herbrand model of P coincides with f. This gives further useful tools to fuzzy control.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dynamic_logic" title="wikilink">Dynamic logic</a></li>
<li><a href="Bayesian_inference" title="wikilink">Bayesian inference</a></li>
<li><a href="Function_approximation" title="wikilink">Function approximation</a></li>
<li><a href="Fuzzy_markup_language" title="wikilink">Fuzzy markup language</a></li>
<li><a href="Neural_networks" title="wikilink">Neural networks</a></li>
<li><a class="uri" href="Neuro-fuzzy" title="wikilink">Neuro-fuzzy</a></li>
<li><a href="Fuzzy_control_language" title="wikilink">Fuzzy control language</a></li>
<li><a href="Type-2_fuzzy_sets_and_systems" title="wikilink">Type-2 fuzzy sets and systems</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Gerla G., Fuzzy Logic Programming and fuzzy control, Studia Logica, 79 (2005) 231-254.</li>
<li>Bastian A., Identifying Fuzzy Models utilizing Genetic Programming, Fuzzy Sets and Systems 113, 333–350, 2000</li>
<li>Hájek P., Metamathematics of Fuzzy Logic, Kluwer Academic Publishers, Dordrecht, The Netherlands, 1998.</li>
<li>Mamdani, E. H., Application of fuzzy algorithms for the control of a simple dynamic plant. In <em>Proc IEEE</em> (1974), 121-159.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Kevin M. Passino and Stephen Yurkovich, Fuzzy Control, Addison Wesley Longman, Menlo Park, CA, 1998 <a href="http://www.ece.osu.edu/~passino/FCbook.pdf">(522 pages)</a></li>
<li></li>
<li>Cox, E. (Oct. 1992). <em>Fuzzy fundamentals</em>. Spectrum, IEEE, 29:10. pp. 58–61.</li>
<li>Cox, E. (Feb. 1993) <em>Adaptive fuzzy systems</em>. Spectrum, IEEE, 30:2. pp. 7–31.</li>
<li>Jan Jantzen, "Tuning Of Fuzzy PID Controllers", Technical University of Denmark, report 98-H 871, September 30, 1998. <a href="http://www.iau.dtu.dk/~jj/pubs/fpid.pdf">1</a></li>
<li>Jan Jantzen, <em>Foundations of Fuzzy Control</em>. Wiley, 2007 (209 pages) <a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470029633,descCd-tableOfContents.html">(Table of contents)</a></li>
<li><em>Computational Intelligence: A Methodological Introduction</em> by Kruse, Borgelt, Klawonn, Moewes, Steinbrecher, Held, 2013, Springer, ISBN 9781447150121</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://inside.mines.edu/~msimoes/documents/Intro_Fuzzy_Logic.pdf">Introduction to Fuzzy Control</a></li>
<li><a href="http://www.bytecraft.com/downloads/fuzlogic.pdf">Fuzzy Logic in Embedded Microcomputers and Control Systems</a></li>
<li><a href="http://www.fuzzytech.com/binaries/ieccd1.pdf">IEC 1131-7 CD1</a> IEC 1131-7 CD1 PDF</li>
<li><a href="http://demonstrations.wolfram.com/InferenceWithFuzzyIFTHENRules/">Online interactive demonstration of a system with 3 fuzzy rules</a></li>
</ul>

<p>"</p>

<p><a href="Category:Fuzzy_logic" title="wikilink">Category:Fuzzy logic</a> <a href="Category:Control_engineering" title="wikilink">Category:Control engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
