<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1925">Bresenham's line algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bresenham's line algorithm</h1>
<hr/>

<p><strong>Bresenham's line algorithm</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that determines the points of an <em>n</em>-dimensional <a href="raster_graphics" title="wikilink">raster</a> that should be selected in order to form a close approximation to a straight line between two points. It is commonly used to draw lines on a computer screen, as it uses only integer addition, subtraction and <a href="Bitwise_operation" title="wikilink">bit shifting</a>, all of which are very cheap operations in standard <a href="computer_architecture" title="wikilink">computer architectures</a>. It is one of the earliest algorithms developed in the field of <a href="computer_graphics" title="wikilink">computer graphics</a>. An extension to the original algorithm may be used for drawing circles.</p>

<p>While algorithms such as <a href="Xiaolin_Wu's_line_algorithm" title="wikilink">Wu's algorithm</a> are also frequently used in modern computer graphics because they can support <a href="Spatial_anti-aliasing" title="wikilink">antialiasing</a>, the speed and simplicity of Bresenham's line algorithm means that it is still important. The algorithm is used in hardware such as <a href="plotter" title="wikilink">plotters</a> and in the <a href="Graphics_processing_unit" title="wikilink">graphics chips</a> of modern <a href="graphics_card" title="wikilink">graphics cards</a>. It can also be found in many software <a href="graphics_library" title="wikilink">graphics libraries</a>. Because the algorithm is very simple, it is often implemented in either the <a class="uri" href="firmware" title="wikilink">firmware</a> or the <a href="graphics_hardware" title="wikilink">graphics hardware</a> of modern graphics cards.</p>

<p>The label "Bresenham" is used today for a family of algorithms extending or modifying Bresenham's original algorithm.</p>
<h2 id="history">History</h2>

<p>Bresenham's line algorithm is named after <a href="Jack_Elton_Bresenham" title="wikilink">Jack Elton Bresenham</a> who developed it in 1962 at <a href="International_Business_Machines" title="wikilink">IBM</a>. In 2001 Bresenham wrote:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<blockquote>

<p>I was working in the computation lab at IBM's San Jose development lab. A <a href="Calcomp_plotter" title="wikilink">Calcomp plotter</a> had been attached to an <a href="IBM_1401" title="wikilink">IBM 1401</a> via the 1407 typewriter console. [The algorithm] was in production use by summer 1962, possibly a month or so earlier. Programs in those days were freely exchanged among corporations so Calcomp (Jim Newland and Calvin Hefte) had copies. When I returned to Stanford in Fall 1962, I put a copy in the Stanford comp center library.</p>

<p>A description of the line drawing routine was accepted for presentation at the 1963 <a href="Association_for_Computing_Machinery" title="wikilink">ACM</a> national convention in Denver, Colorado. It was a year in which no proceedings were published, only the agenda of speakers and topics in an issue of Communications of the ACM. A person from the IBM Systems Journal asked me after I made my presentation if they could publish the paper. I happily agreed, and they printed it in 1965.</p>
</blockquote>

<p>Bresenham's algorithm was later extended to produce circles, the resulting algorithm being sometimes known as either <em>Bresenham's circle algorithm</em> or <a href="midpoint_circle_algorithm" title="wikilink">midpoint circle algorithm</a>.</p>
<h2 id="method">Method</h2>

<p> The common conventions will be used:</p>
<ul>
<li>the top-left is (0,0) such that pixel coordinates increase in the right and down directions (e.g. that the pixel at (7,4) is directly above the pixel at (7,5)), and</li>
<li>that the pixel centers have integer coordinates.</li>
</ul>

<p>The endpoints of the line are the pixels at 

<math display="inline" id="Bresenham's_line_algorithm:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0},y_{0})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bresenham's_line_algorithm:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1})
  </annotation>
 </semantics>
</math>

, where the first coordinate of the pair is the column and the second is the row.</p>

<p>The algorithm will be initially presented only for the <a href="octant_(plane_geometry)" title="wikilink">octant</a> in which the segment goes down and to the right (

<math display="inline" id="Bresenham's_line_algorithm:2">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\leq x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bresenham's_line_algorithm:3">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}\leq y_{1}
  </annotation>
 </semantics>
</math>


), and its horizontal projection 

<math display="inline" id="Bresenham's_line_algorithm:4">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}-x_{0}
  </annotation>
 </semantics>
</math>

 is longer than the vertical projection 

<math display="inline" id="Bresenham's_line_algorithm:5">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}-y_{0}
  </annotation>
 </semantics>
</math>

 (the line has a negative <a class="uri" href="slope" title="wikilink">slope</a> whose absolute value is less than 1). In this octant, for each column <em>x</em> between 

<math display="inline" id="Bresenham's_line_algorithm:6">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bresenham's_line_algorithm:7">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, there is exactly one row <em>y</em> (computed by the algorithm) containing a pixel of the line, while each row between 

<math display="inline" id="Bresenham's_line_algorithm:8">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Bresenham's_line_algorithm:9">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}
  </annotation>
 </semantics>
</math>

 may contain multiple rasterized pixels.</p>

<p>Bresenham's algorithm chooses the integer <em>y</em> corresponding to the pixel center that is closest to the ideal (fractional) <em>y</em> for the same <em>x</em>; on successive columns <em>y</em> can remain the same or increase by 1. The general equation of the line through the endpoints is given by:</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:10">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>y</mi>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{y-y_{0}}{y_{1}-y_{0}}=\frac{x-x_{0}}{x_{1}-x_{0}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Since we know the column, <em>x</em>, the pixel's row, <em>y</em>, is given by rounding this quantity to the nearest integer:</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:11">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{y_{1}-y_{0}}{x_{1}-x_{0}}(x-x_{0})+y_{0}
  </annotation>
 </semantics>
</math>

.</p>

<p>The slope 

<math display="inline" id="Bresenham's_line_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{1}-y_{0})/(x_{1}-x_{0})
  </annotation>
 </semantics>
</math>

 depends on the endpoint coordinates only and can be precomputed, and the ideal <em>y</em> for successive integer values of <em>x</em> can be computed starting from 

<math display="inline" id="Bresenham's_line_algorithm:13">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}
  </annotation>
 </semantics>
</math>


 and repeatedly adding the slope.</p>

<p>In practice, the algorithm can track, instead of possibly large y values, a small <em>error value</em> between −0.5 and 0.5: the vertical distance between the rounded and the exact <em>y</em> values for the current <em>x</em>. Each time <em>x</em> is increased, the error is increased by the slope; if it exceeds 0.5, the rasterization <em>y</em> is increased by 1 (the line continues on the next lower row of the raster) and the error is decremented by 1.0.</p>

<p>In the following <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> sample <code>plot(x,y)</code> plots a point, <code>sign(T)</code> decides if T is positive or negative, and <code>abs</code> returns <a href="absolute_value" title="wikilink">absolute value</a>:</p>

<p><code> </code><strong><code>function</code></strong><code> line(x0, y0, x1, y1)</code><br/>
<code>     </code><em><code>real</code></em><code> deltax := x1 - x0</code><br/>
<code>     </code><em><code>real</code></em><code> deltay := y1 - y0</code><br/>
<code>     </code><em><code>real</code></em><code> error := 0</code><br/>
<code>     </code><em><code>real</code></em><code> deltaerr := abs (deltay / deltax)    // Assume deltax != 0 (line is not vertical),</code><br/>
<code>           // note that this division needs to be done in a way that preserves the fractional part</code><br/>
<code>     </code><em><code>int</code></em><code> y := y0</code><br/>
<code>     </code><strong><code>for</code></strong><code> x </code><strong><code>from</code></strong><code> x0 </code><strong><code>to</code></strong><code> x1</code><br/>
<code>         plot(x,y)</code><br/>
<code>         error := error + deltaerr</code><br/>
<code>         </code><strong><code>while</code></strong><code> error ≥ 0.5 </code><strong><code>then</code></strong><br/>
<code>             plot(x, y)</code><br/>
<code>             y := y + sign(y1 - y0)</code><br/>
<code>             error := error - 1.0</code></p>
<h2 id="derivation">Derivation</h2>

<p>To derive Bresenham's algorithm, two steps must be taken. The first step is transforming the equation of a line from the typical slope-intercept form into something different; and then using this new equation for a line to draw a line based on the idea of accumulation of error.</p>
<h3 id="line-equation">Line equation</h3>

<p> </p>

<p>The slope-intercept form of a line is written as</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:14">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x)=mx+b
  </annotation>
 </semantics>
</math>

</p>

<p>where m is the slope and b is the y-intercept. This is a function of only x and it would be useful to make this equation written as a function of both x and y. Using algebraic manipulation and recognition that the slope is the "rise over run" or 

<math display="inline" id="Bresenham's_line_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta y/\Delta x
  </annotation>
 </semantics>
</math>

 then</p>

<p>

<math display="inline" id="Bresenham's_line_algorithm:16">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y
  </annotation>
 </semantics>
</math>


</p>

<p>Letting this last equation be a function of x and y then it can be written as</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>B</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=0=Ax+By+C
  </annotation>
 </semantics>
</math>

</p>

<p>where the constants are</p>
<ul>
<li>

<math display="inline" id="Bresenham's_line_algorithm:18">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\Delta y
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Bresenham's_line_algorithm:19">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=-\Delta x
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Bresenham's_line_algorithm:20">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(\Delta x)b
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The line is then defined for some constants A, B, and C and anywhere 

<math display="inline" id="Bresenham's_line_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=0
  </annotation>
 </semantics>
</math>

. For any 

<math display="inline" id="Bresenham's_line_algorithm:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


 not on the line then 

<math display="inline" id="Bresenham's_line_algorithm:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)\neq 0
  </annotation>
 </semantics>
</math>

. It should be noted that everything about this form involves only integers if x and y are integers since the constants are necessarily integers.</p>

<p>As an example, the line 

<math display="inline" id="Bresenham's_line_algorithm:24">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{1}{2}x+1
  </annotation>
 </semantics>
</math>

 then this could be written as 

<math display="inline" id="Bresenham's_line_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>y</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=x-2y+2
  </annotation>
 </semantics>
</math>

. The point (2,2) is on the line</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>-</mo>
     <mn>4</mn>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>y</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <cn type="integer">4</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2,2)=x-2y+2=(2)-2(2)+2=2-4+2=0
  </annotation>
 </semantics>
</math>

</p>

<p>and the point (2,3) is not on the line</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>-</mo>
     <mn>6</mn>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <cn type="integer">6</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2,3)=(2)-2(3)+2=2-6+2=-2
  </annotation>
 </semantics>
</math>

</p>

<p>and neither is the point (2,1)</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2,1)=(2)-2(1)+2=2-2+2=2
  </annotation>
 </semantics>
</math>

</p>

<p>Notice that the points (2,1) and (2,3) are on opposite sides of the line and f(x,y) evaluates to positive or negative. A line splits a plane into halves and the half-plane that has a negative f(x,y) can be called the negative half-plane, and the other half can called the positive half-plane. This observation is very important in the remainder of the derivation.</p>
<h3 id="algorithm">Algorithm</h3>

<p>Clearly, the starting point is on the line</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{0},y_{0})=0
  </annotation>
 </semantics>
</math>

</p>

<p>only because the line is defined to start and end on integer coordinates (though it is entirely reasonable to want to draw a line with non-integer end points).</p>
<figure><b>(Figure)</b>
<figcaption>Candidate point (2,2) in blue and two candidate points in green (3,2) and (3,3)</figcaption>
</figure>

<p>Keeping in mind that the slope is less-than-or-equal-to zero, the problem now presents itself as to whether the next point should be at 

<math display="inline" id="Bresenham's_line_algorithm:30">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+1,y_{0})
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Bresenham's_line_algorithm:31">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+1,y_{0}+1)
  </annotation>
 </semantics>
</math>

. Perhaps intuitively, the point should be chosen based upon which is closer to the line at 

<math display="inline" id="Bresenham's_line_algorithm:32">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}+1
  </annotation>
 </semantics>
</math>


. If it is closer to the former then include the former point on the line, if the latter then the latter. To answer this, evaluate the line function at the midpoint between these two points:</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:33">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{0}+1,y_{0}+1/2)
  </annotation>
 </semantics>
</math>

</p>

<p>If the value of this is positive then the ideal line is below the midpoint and closer to the candidate point 

<math display="inline" id="Bresenham's_line_algorithm:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+1,y_{0}+1)
  </annotation>
 </semantics>
</math>

; in effect the y coordinate has advanced. Otherwise, the ideal line passes through or above the midpoint, and the y coordinate has not advanced; in this case choose the point 

<math display="inline" id="Bresenham's_line_algorithm:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+1,y_{0})
  </annotation>
 </semantics>
</math>

. This observation is crucial to understand! The value of the line function at this midpoint is the sole determinant of which point should be chosen.</p>

<p>The image to the right shows the blue point (2,2) chosen to be on the line with two candidate points in green (3,2) and (3,3). The black point (3, 2.5) is the midpoint between the two candidate points.</p>
<dl>
<dt>Algorithm for integer arithmetic</dt>
</dl>

<p>Alternatively, the difference between points can be used instead of evaluating f(x,y) at midpoints. This alternative method allows for integer-only arithmetic, which is generally considered faster than using floating-point arithmetic. To derive the alternative method, define the difference to be as follows:</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:36">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=f(x_{0}+1,y_{0}+1/2)+f(x_{0},y_{0})
  </annotation>
 </semantics>
</math>

 For the first decision, this formulation is equivalent to the midpoint method since 

<math display="inline" id="Bresenham's_line_algorithm:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{0},y_{0})=0
  </annotation>
 </semantics>
</math>


 at the starting point. Simplifying this expression yields:</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:38">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>y</mi>
          <mn>0</mn>
         </msub>
         <mo>+</mo>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>B</mi>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\left[A(x_{0}+1)+B(y_{0}+\frac{1}{2})+C\right]-\left[Ax_{0}+By_{0}+C\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:39">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>B</mi>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
      <mo>+</mo>
      <mi>A</mi>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>B</mi>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>C</ci>
       <ci>A</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\left[Ax_{0}+By_{0}+C+A+\frac{1}{2}B\right]-\left[Ax_{0}+By_{0}+C\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:40">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =A+\frac{1}{2}B
  </annotation>
 </semantics>
</math>

</p>

<p>Just as with the midpoint method, if D is positive, then choose 

<math display="inline" id="Bresenham's_line_algorithm:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+1,y_{0}+1)
  </annotation>
 </semantics>
</math>

, otherwise choose 

<math display="inline" id="Bresenham's_line_algorithm:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+1,y_{0})
  </annotation>
 </semantics>
</math>


.</p>

<p>The decision for the second point can be written as</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{0}+2,y_{0}+1/2)-f(x_{0}+1,y_{0}+1/2)=A=\Delta y
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bresenham's_line_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mn>3</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">3</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{0}+2,y_{0}+3/2)-f(x_{0}+1,y_{0}+1/2)=A+B=\Delta y-\Delta x
  </annotation>
 </semantics>
</math>

</p>

<p>If the difference is positive then 

<math display="inline" id="Bresenham's_line_algorithm:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+2,y_{0}+1)
  </annotation>
 </semantics>
</math>

 is chosen, otherwise 

<math display="inline" id="Bresenham's_line_algorithm:46">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{0}+2,y_{0})
  </annotation>
 </semantics>
</math>

. This decision can be generalized by accumulating the error.</p>
<figure><b>(Figure)</b>
<figcaption>Plotting the line from (0,1) to (6,4) showing a plot of grid lines and pixels</figcaption>
</figure>

<p>All of the derivation for the algorithm is done. One performance issue is the 1/2 factor in the initial value of D. Since all of this is about the sign of the accumulated difference, then everything can be multiplied by 2 with no consequence.</p>

<p>This results in an algorithm that uses only integer arithmetic.</p>

<p><code>plotLine(x0,y0, x1,y1)</code><br/>
<code>  dx=x1-x0</code><br/>
<code>  dy=y1-y0</code><br/>
<br/>
<code>  D = 2*dy - dx</code><br/>
<code>  plot(x0,y0)</code><br/>
<code>  y=y0</code><br/>
<br/>
<code>  for x from x0+1 to x1</code><br/>
<code>    if D &gt; 0</code><br/>
<code>      y = y+1</code><br/>
<code>      plot(x,y)</code><br/>
<code>      D = D + (2*dy-2*dx)</code><br/>
<code>    else</code><br/>
<code>      plot(x,y)</code><br/>
<code>      D = D + (2*dy)</code></p>

<p>Running this algorithm for 

<math display="inline" id="Bresenham's_line_algorithm:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>y</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=x-2y+2
  </annotation>
 </semantics>
</math>


 from (0,1) to (6,4) yields the following differences with dx=6 and dy=3:</p>
<ul>
<li>D=2*3-6=0</li>
<li><strong>plot(0,1)</strong></li>
<li>Loop from 1 to 6
<ul>
<li>x=1: D≤0: <strong>plot(1,1)</strong>, D=6</li>
<li>x=2: D&gt;0: y=2, <strong>plot(2,2)</strong>, D=6+(6-12)=0</li>
<li>x=3: D≤0: <strong>plot(3,2)</strong>, D=6</li>
<li>x=4: D&gt;0: y=3, <strong>plot(4,3)</strong>, D=6+(6-12)=0</li>
<li>x=5: D≤0: <strong>plot(5,3)</strong>, D=6</li>
<li>x=6: D&gt;0: y=4, <strong>plot(6,4)</strong>, D=6+(6-12)=0</li>
</ul></li>
</ul>

<p>The result of this plot is shown to the right. The plotting can be viewed by plotting at the intersection of lines (blue circles) or filling in pixel boxes (yellow squares). Regardless, the plotting is the same.</p>
<h3 id="all-cases">All cases</h3>

<p>However, as mentioned above this is only for the first <a href="octant_(plane_geometry)" title="wikilink">octant</a>. This means there are eight possible cases to consider. The simplest way to extend the same algorithm, if implemented in hardware, is to flip the co-ordinate system on the input and output of the single-octant drawer.</p>

<p><code>
  function switchToOctantZeroFrom(octant, x, y) 
    switch(octant)  
      case 0: return (x,y)
      case 1: return (y,x)
      case 2: return (y, -x)
      case 3: return (-x, y)
      case 4: return (-x, -y)
      case 5: return (-y, -x)
      case 6: return (-y, x)
      case 7: return (x, -y)

  Octants:
   \2|1/
   3\|/0
  ---+---
   4/|\7
   /5|6\
</code></p>
<h2 id="similar-algorithms">Similar algorithms</h2>

<p>The Bresenham algorithm can be interpreted as slightly modified <a href="Digital_differential_analyzer_(graphics_algorithm)" title="wikilink">digital differential analyzer</a> (using 0.5 as error threshold instead of 0, which is required for non-overlapping polygon rasterizing).</p>

<p>The principle of using an incremental error in place of division operations has other applications in graphics. It is possible to use this technique to calculate the <a href="uv_mapping" title="wikilink">U,V co-ordinates</a> during raster scan of texture mapped polygons. The <a class="uri" href="voxel" title="wikilink">voxel</a> heightmap software-rendering engines seen in some PC games also used this principle.</p>

<p>Bresenham also published a Run-Slice (as opposed to the Run-Length) computational algorithm.</p>

<p>An extension to the algorithm that handles thick lines was created by Alan Murphy at IBM.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Digital_differential_analyzer_(graphics_algorithm)" title="wikilink">Digital differential analyzer (graphics algorithm)</a>, a simple and general method for rasterizing lines and triangles</li>
<li><a href="Xiaolin_Wu's_line_algorithm" title="wikilink">Xiaolin Wu's line algorithm</a>, a similarly fast method of drawing lines with <a href="Spatial_anti-aliasing" title="wikilink">antialiasing</a></li>
<li><a href="Midpoint_circle_algorithm" title="wikilink">Midpoint circle algorithm</a>, a similar algorithm for drawing circles</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="http://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html">"The Bresenham Line-Drawing Algorithm"</a>, by Colin Flanagan</li>
<li>

<p>A very optimized version of the algorithm in C and assembly for use in video games with complete details of its inner workings</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://sites.google.com/site/patrickmaillot/english">Patrick-Gilles Maillot's Thesis</a> an extension of the Bresenham line drawing algorithm to perform 3D hidden lines removal; also published in MICAD '87 proceedings on CAD/CAM and Computer Graphics, page 591 - ISBN 2-86601-084-1.</li>
<li><a href="http://homepages.enterprise.net/murphy/thickline/index.html">Line Thickening by Modification To Bresenham's Algorithm</a>, A.S. Murphy, IBM Technical Disclosure Bulletin, Vol. 20, No. 12, May 1978.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://gpolo.awardspace.info">Didactical Javascript implementation</a></li>
<li><a href="http://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html"><em>The Bresenham Line-Drawing Algorithm</em> by Colin Flanagan</a></li>
<li><a href="http://www.nist.gov/dads/HTML/bresenham.html">National Institute of Standards and Technology page on Bresenham's algorithm</a></li>
<li><a href="http://www.pdp8online.com/563/563.shtml">Calcomp 563 Incremental Plotter Information</a></li>
<li><a href="http://www.cobrabytes.com/index.php?topic=1150.0">3D extension</a></li>
<li><a href="http://sites.google.com/site/proyectosroboticos/bresenham-3d">Bresenham 2D, 3D up to 6D</a></li>
<li><a href="http://rosettacode.org/wiki/Bitmap/Bresenham's_line_algorithm">Bresenham Algorithm in several programming languages</a></li>
<li><a href="http://members.chello.at/~easyfilter/bresenham.html">The Beauty of Bresenham's Algorithm</a> – A simple implementation to plot lines, circles, ellipses and Bézier curves</li>
<li><a href="http://www.etechplanet.com/codesnippets/computer-graphics-draw-a-line-using-bresenham-algorithm.aspx">Draw a Line using Bresenham Algorithm</a></li>
<li><a href="https://github.com/fragkakis/bresenham">Java implementation</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computer_graphics_algorithms" title="wikilink">Category:Computer graphics algorithms</a> <a href="Category:Digital_geometry" title="wikilink">Category:Digital geometry</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Paul E. Black. <em>Dictionary of Algorithms and Data Structures,</em> <a href="National_Institute_of_Standards_and_Technology" title="wikilink">NIST</a>. <a class="uri" href="http://www.nist.gov/dads/HTML/bresenham.html">http://www.nist.gov/dads/HTML/bresenham.html</a><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
