<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="389">Functional programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Functional programming</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>functional programming</strong> is a <a href="programming_paradigm" title="wikilink">programming paradigm</a>—a style of building the structure and elements of computer programs—that treats <a class="uri" href="computation" title="wikilink">computation</a> as the evaluation of <a href="function_(mathematics)" title="wikilink">mathematical functions</a> and avoids changing-<a href="program_state" title="wikilink">state</a> and <a href="immutable_object" title="wikilink">mutable</a> data. It is a <a href="declarative_programming" title="wikilink">declarative programming</a> paradigm, which means programming is done with <a href="Expression_(computer_science)" title="wikilink">expressions</a>. In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function <em>f</em> twice with the same value for an argument <em>x</em> will produce the same result <em>f(x)</em> each time. Eliminating <a href="side_effect_(computer_science)" title="wikilink">side effects</a>, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.</p>

<p>Functional programming has its roots in <a href="lambda_calculus" title="wikilink">lambda calculus</a>, a <a href="formal_system" title="wikilink">formal system</a> developed in the 1930s to investigate <a class="uri" href="computability" title="wikilink">computability</a>, the <a class="uri" href="Entscheidungsproblem" title="wikilink">Entscheidungsproblem</a>, function definition, function application, and <a class="uri" href="recursion" title="wikilink">recursion</a>. Many functional <a href="programming_language" title="wikilink">programming languages</a> can be viewed as elaborations on the lambda calculus. Another well-known declarative programming paradigm, <em><a href="logic_programming" title="wikilink">logic programming</a></em>, is based on <a href="Relation_(logic)" title="wikilink">relations</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In contrast, <a href="imperative_programming" title="wikilink">imperative programming</a> changes state with commands in the source language, the most simple example being assignment. Imperative programming does have functions—not in the mathematical sense—but in the sense of <a href="subroutine" title="wikilink">subroutines</a>. They can have <a href="side_effect_(computer_science)" title="wikilink">side effects</a> that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack <a href="referential_transparency_(computer_science)" title="wikilink">referential transparency</a>, i.e. the same language expression can result in different values at different times depending on the state of the executing program.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Functional programming languages, especially <a href="purely_functional" title="wikilink">purely functional</a> ones such as <a href="Hope_(programming_language)" title="wikilink">Hope</a> and <a href="Rex_(programming_language)" title="wikilink">Rex</a>, have largely been emphasized in <a href="academic" title="wikilink">academia</a> rather than in commercial software development. However, prominent functional programming languages such as <a href="Common_Lisp" title="wikilink">Common Lisp</a>, <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="uri" href="Clojure" title="wikilink">Clojure</a>, <a href="Racket_(programming_language)" title="wikilink">Racket</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a href="Erlang_(programming_language)" title="wikilink">Erlang</a>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a class="uri" href="OCaml" title="wikilink">OCaml</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and <a href="F_Sharp_(programming_language)" title="wikilink">F#</a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> have been used in industrial and commercial applications by a wide variety of organizations. Functional programming is also supported in some <a href="domain-specific_programming_language" title="wikilink">domain-specific programming languages</a> like <a href="R_(programming_language)" title="wikilink">R</a> (statistics),<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> <a href="Wolfram_Language" title="wikilink">Wolfram Language</a> (also known as M or <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>, for symbolic and numeric math),<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a href="J_(programming_language)" title="wikilink">J</a>, <a href="K_(programming_language)" title="wikilink">K</a> and <a href="Q_(programming_language_from_Kx_Systems)" title="wikilink">Q from Kx Systems</a> (financial analysis), <a class="uri" href="XQuery" title="wikilink">XQuery</a>/<a class="uri" href="XSLT" title="wikilink">XSLT</a> (<a class="uri" href="XML" title="wikilink">XML</a>),<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and Opal.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Widespread domain-specific declarative languages like <a class="uri" href="SQL" title="wikilink">SQL</a> and <a href="Lex_(software)" title="wikilink">Lex</a>/<a class="uri" href="Yacc" title="wikilink">Yacc</a> use some elements of functional programming, especially in eschewing <a href="mutable_object" title="wikilink">mutable values</a>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>Programming in a functional style can also be accomplished in languages that aren’t specifically designed for functional programming. For example, the imperative <a class="uri" href="Perl" title="wikilink">Perl</a> programming language has been the subject of a book describing how to apply functional programming concepts.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> This is also true of the <a class="uri" href="PHP" title="wikilink">PHP</a> programming language.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> 3.0 and <a href="Java_programming" title="wikilink">Java</a> 8 added constructs to facilitate the functional style. An interesting case is that of <a href="Scala_(programming_language)" title="wikilink">Scala</a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> – it is frequently written in a functional style, but the presence of side effects and mutable state place it in a grey area between imperative and functional languages.</p>
<h2 id="history">History</h2>

<p><a href="Lambda_calculus" title="wikilink">Lambda calculus</a> provides a theoretical framework for describing functions and their evaluation. Although it is a mathematical abstraction rather than a programming language, it forms the basis of almost all functional programming languages today. An equivalent theoretical formulation, <a href="combinatory_logic" title="wikilink">combinatory logic</a>, is commonly perceived as more abstract than lambda calculus and preceded it in invention. Combinatory logic and lambda calculus were both originally developed to achieve a clearer approach to the <a href="foundations_of_mathematics" title="wikilink">foundations of mathematics</a>.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>An early functional-flavored language was <a href="Lisp_(programming_language)" title="wikilink">Lisp</a>, developed by <a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a> while at <a href="Massachusetts_Institute_of_Technology" title="wikilink">Massachusetts Institute of Technology</a> (MIT) for the <a href="IBM_700/7000_series#Scientific_Architecture" title="wikilink">IBM 700/7000 series</a> scientific computers in the late 1950s.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Lisp introduced many features now found in functional languages, though Lisp is technically a multi-paradigm language. <a href="Scheme_(programming_language)" title="wikilink">Scheme</a> and <a href="Dylan_(programming_language)" title="wikilink">Dylan</a> were later attempts to simplify and improve Lisp.</p>

<p><a href="Information_Processing_Language" title="wikilink">Information Processing Language</a> (IPL) is sometimes cited as the first computer-based functional programming language.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> It is an assembly-style language for manipulating lists of symbols. It does have a notion of "generator", which amounts to a function accepting a function as an argument, and, since it is an assembly-level language, code can be used as data, so IPL can be regarded as having higher-order functions. However, it relies heavily on mutating list structure and similar imperative features.</p>

<p><a href="Kenneth_E._Iverson" title="wikilink">Kenneth E. Iverson</a> developed <a href="APL_(programming_language)" title="wikilink">APL</a> in the early 1960s, described in his 1962 book <em>A Programming Language</em> (ISBN 9780471430148). APL was the primary influence on <a href="John_Backus" title="wikilink">John Backus</a>'s <a href="FP_(programming_language)" title="wikilink">FP</a>. In the early 1990s, Iverson and <a href="Roger_Hui" title="wikilink">Roger Hui</a> created <a href="J_(programming_language)" title="wikilink">J</a>. In the mid-1990s, <a href="Arthur_Whitney_(computer_scientist)" title="wikilink">Arthur Whitney</a>, who had previously worked with Iverson, created <a href="K_(programming_language)" title="wikilink">K</a>, which is used commercially in financial industries along with its descendant <a href="Q_(programming_language_from_Kx_Systems)" title="wikilink">Q</a>.</p>

<p><a href="John_Backus" title="wikilink">John Backus</a> presented <a href="FP_(programming_language)" title="wikilink">FP</a> in his 1977 <a href="Turing_Award" title="wikilink">Turing Award</a> lecture "Can Programming Be Liberated From the <a href="Von_Neumann_architecture" title="wikilink">von Neumann</a> Style? A Functional Style and its Algebra of Programs".<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> He defines functional programs as being built up in a hierarchical way by means of "combining forms" that allow an "algebra of programs"; in modern language, this means that functional programs follow the <a href="principle_of_compositionality" title="wikilink">principle of compositionality</a>. Backus's paper popularized research into functional programming, though it emphasized <a href="function-level_programming" title="wikilink">function-level programming</a> rather than the lambda-calculus style which has come to be associated with functional programming.</p>

<p>In the 1970s, <a href="ML_(programming_language)" title="wikilink">ML</a> was created by <a href="Robin_Milner" title="wikilink">Robin Milner</a> at the <a href="University_of_Edinburgh" title="wikilink">University of Edinburgh</a>, and <a href="David_Turner_(computer_scientist)" title="wikilink">David Turner</a> initially developed the language <a href="SASL_(programming_language)" title="wikilink">SASL</a> at the <a href="University_of_St._Andrews" title="wikilink">University of St. Andrews</a> and later the language <a href="Miranda_(programming_language)" title="wikilink">Miranda</a> at the <a href="University_of_Kent" title="wikilink">University of Kent</a>. Also in Edinburgh in the 1970s, Burstall and Darlington developed the functional language <a href="NPL_(programming_language)" title="wikilink">NPL</a>.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> NPL was based on <a href="Kleene's_recursion_theorem" title="wikilink">Kleene Recursion Equations</a> and was first introduced in their work on program transformation.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Burstall, MacQueen and Sannella then incorporated the polymorphic type checking from ML to produce the language <a href="Hope_(programming_language)" title="wikilink">Hope</a>.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> ML eventually developed into several dialects, the most common of which are now <a class="uri" href="OCaml" title="wikilink">OCaml</a> and <a href="Standard_ML" title="wikilink">Standard ML</a>. Meanwhile, the development of <a href="Scheme_(programming_language)" title="wikilink">Scheme</a> (a partly functional dialect of Lisp), as described in the influential <a href="Lambda_Papers" title="wikilink">Lambda Papers</a> and the 1985 textbook <em><a href="Structure_and_Interpretation_of_Computer_Programs" title="wikilink">Structure and Interpretation of Computer Programs</a></em>, brought awareness of the power of functional programming to the wider programming-languages community.</p>

<p>In the 1980s, <a href="Per_Martin-Löf" title="wikilink">Per Martin-Löf</a> developed <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a> (also called <em>constructive</em> type theory), which associated functional programs with <a href="constructive_proof" title="wikilink">constructive proofs</a> of arbitrarily complex mathematical propositions expressed as <a href="dependent_type" title="wikilink">dependent types</a>. This led to powerful new approaches to <a href="interactive_theorem_proving" title="wikilink">interactive theorem proving</a> and has influenced the development of many subsequent functional programming languages.</p>

<p>The <a href="Haskell_(programming_language)" title="wikilink">Haskell language</a> began with a consensus in 1987 to form an <a href="open_standard" title="wikilink">open standard</a> for functional programming research; implementation releases have been ongoing since 1990.</p>
<h2 id="concepts">Concepts</h2>

<p>A number of concepts and paradigms are specific to functional programming, and generally foreign to <a href="imperative_programming" title="wikilink">imperative programming</a> (including <a href="object-oriented_programming" title="wikilink">object-oriented programming</a>). However, programming languages are often hybrids of several programming paradigms, so programmers using "mostly imperative" languages may have utilized some of these concepts.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h3 id="first-class-and-higher-order-functions">First-class and higher-order functions</h3>

<p><a href="Higher-order_function" title="wikilink">Higher-order functions</a> are functions that can either take other functions as arguments or return them as results. In calculus, an example of a higher-order function is the <a href="differential_operator" title="wikilink">differential operator</a> 

<math display="inline" id="Functional_programming:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mo>/</mo>
    <mi>d</mi>
   </mrow>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>d</ci>
     <ci>d</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d/dx
  </annotation>
 </semantics>
</math>

, which returns the <a class="uri" href="derivative" title="wikilink">derivative</a> of a function 

<math display="inline" id="Functional_programming:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>

<p>Higher-order functions are closely related to <a href="first-class_function" title="wikilink">first-class functions</a> in that higher-order functions and first-class functions both allow functions as arguments and results of other functions. The distinction between the two is subtle: "higher-order" describes a mathematical concept of functions that operate on other functions, while "first-class" is a computer science term that describes programming language entities that have no restriction on their use (thus first-class functions can appear anywhere in the program that other first-class entities like numbers can, including as arguments to other functions and as their return values).</p>

<p>Higher-order functions enable <a href="partial_application" title="wikilink">partial application</a> or <a class="uri" href="currying" title="wikilink">currying</a>, a technique in which a function is applied to its arguments one at a time, with each application returning a new function that accepts the next argument. This allows one to succinctly express, for example, the successor function as the addition operator partially applied to the <a href="natural_number" title="wikilink">natural number</a> one.</p>
<h3 id="pure-functions">Pure functions</h3>

<p><a href="Purely_functional" title="wikilink">Purely functional</a> functions (or expressions) have no <a href="side_effect_(computer_science)" title="wikilink">side effects</a> (memory or I/O). This means that pure functions have several useful properties, many of which can be used to optimize the code:</p>
<ul>
<li>If the result of a pure expression is not used, it can be removed without affecting other expressions.</li>
<li>If a pure function is called with arguments that cause no side-effects, the result is constant with respect to that argument list (sometimes called <a href="referential_transparency_(computer_science)" title="wikilink">referential transparency</a>), i.e. if the pure function is again called with the same arguments, the same result will be returned (this can enable caching optimizations such as <a class="uri" href="memoization" title="wikilink">memoization</a>).</li>
<li>If there is no data dependency between two pure expressions, then their order can be reversed, or they can be performed in <a href="parallelization" title="wikilink">parallel</a> and they cannot interfere with one another (in other terms, the evaluation of any pure expression is <a class="uri" href="thread-safe" title="wikilink">thread-safe</a>).</li>
<li>If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using <a href="deforestation_(computer_science)" title="wikilink">deforestation</a>).</li>
</ul>

<p>While most compilers for imperative programming languages detect pure functions and perform common-subexpression elimination for pure function calls, they cannot always do this for pre-compiled libraries, which generally do not expose this information, thus preventing optimizations that involve those external functions. Some compilers, such as <a href="GNU_Compiler_Collection" title="wikilink">gcc</a>, add extra keywords for a programmer to explicitly mark external functions as pure, to enable such optimizations. <a href="Fortran_95" title="wikilink">Fortran 95</a> also allows functions to be designated "pure".</p>
<h3 id="recursion">Recursion</h3>

<p><a class="uri" href="Iteration" title="wikilink">Iteration</a> (looping) in functional languages is usually accomplished via <a class="uri" href="recursion" title="wikilink">recursion</a>. <a href="recursion_(computer_science)" title="wikilink">Recursive functions</a> invoke themselves, allowing an operation to be performed over and over until the <a href="Recursion_(computer_science)" title="wikilink">base case</a> is reached. Though some recursion requires maintaining a stack, <a href="tail_recursion" title="wikilink">tail recursion</a> can be recognized and optimized by a compiler into the same code used to implement iteration in imperative languages. The <a href="Scheme_(programming_language)" title="wikilink">Scheme</a> language standard requires implementations to recognize and optimize tail recursion. Tail recursion optimization can be implemented by transforming the program into <a href="continuation_passing_style" title="wikilink">continuation passing style</a> during compiling, among other approaches.</p>

<p>Common patterns of recursion can be factored out using higher order functions, with <a href="catamorphism" title="wikilink">catamorphisms</a> and <a href="anamorphism" title="wikilink">anamorphisms</a> (or "folds" and "unfolds") being the most obvious examples. Such higher order functions play a role analogous to built-in control structures such as <a href="Program_loops" title="wikilink">loops</a> in <a href="imperative_languages" title="wikilink">imperative languages</a>.</p>

<p>Most general purpose functional programming languages allow unrestricted recursion and are <a href="Turing_complete" title="wikilink">Turing complete</a>, which makes the <a href="halting_problem" title="wikilink">halting problem</a> <a href="undecidable_problem" title="wikilink">undecidable</a>, can cause unsoundness of <a href="equational_reasoning" title="wikilink">equational reasoning</a>, and generally requires the introduction of <a class="uri" href="inconsistency" title="wikilink">inconsistency</a> into the logic expressed by the language's <a href="type_system" title="wikilink">type system</a>. Some special purpose languages such as <a class="uri" href="Coq" title="wikilink">Coq</a> allow only <a class="uri" href="well-founded" title="wikilink">well-founded</a> recursion and are <a href="strongly_normalizing" title="wikilink">strongly normalizing</a> (nonterminating computations can be expressed only with infinite streams of values called <a class="uri" href="codata" title="wikilink">codata</a>). As a consequence, these languages fail to be Turing complete and expressing certain functions in them is impossible, but they can still express a wide class of interesting computations while avoiding the problems introduced by unrestricted recursion. Functional programming limited to well-founded recursion with a few other constraints is called <a href="total_functional_programming" title="wikilink">total functional programming</a>.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h3 id="strict-versus-non-strict-evaluation">Strict versus non-strict evaluation</h3>

<p>Functional languages can be categorized by whether they use <em>strict (eager)</em> or <em>non-strict (lazy)</em> evaluation, concepts that refer to how function arguments are processed when an expression is being evaluated. The technical difference is in the <a href="denotational_semantics" title="wikilink">denotational semantics</a> of expressions containing failing or divergent computations. Under strict evaluation, the evaluation of any term containing a failing subterm will itself fail. For example, the expression:</p>

<p><code>print length([2+1, 3*2, 1/0, 5-4])</code></p>

<p>will fail under strict evaluation because of the division by zero in the third element of the list. Under lazy evaluation, the length function will return the value 4 (i.e., the number of items in the list), since evaluating it will not attempt to evaluate the terms making up the list. In brief, strict evaluation always fully evaluates function arguments before invoking the function. Lazy evaluation does not evaluate function arguments unless their values are required to evaluate the function call itself.</p>

<p>The usual implementation strategy for lazy evaluation in functional languages is <a href="graph_reduction" title="wikilink">graph reduction</a>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> Lazy evaluation is used by default in several pure functional languages, including <a href="Miranda_(programming_language)" title="wikilink">Miranda</a>, <a href="Clean_(programming_language)" title="wikilink">Clean</a>, and <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>.</p>

<p>argues for lazy evaluation as a mechanism for improving program modularity through <a href="separation_of_concerns" title="wikilink">separation of concerns</a>, by easing independent implementation of producers and consumers of data streams.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> Launchbury 1993 describes some difficulties that lazy evaluation introduces, particularly in analyzing a program's storage requirements, and proposes an <a href="operational_semantics" title="wikilink">operational semantics</a> to aid in such analysis.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Harper 2009 proposes including both strict and lazy evaluation in the same language, using the language's type system to distinguish them.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>
<h3 id="type-systems">Type systems</h3>

<p>Especially since the development of <a href="Hindley–Milner_type_inference" title="wikilink">Hindley–Milner type inference</a> in the 1970s, functional programming languages have tended to use <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a>, as opposed to the <a href="untyped_lambda_calculus" title="wikilink">untyped lambda calculus</a> used in Lisp and its variants (such as <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>). The use of <a href="algebraic_datatypes" title="wikilink">algebraic datatypes</a> and <a href="pattern_matching" title="wikilink">pattern matching</a> makes manipulation of complex data structures convenient and expressive; the presence of strong compile-time type checking makes programs more reliable, while <a href="type_inference" title="wikilink">type inference</a> frees the programmer from the need to manually declare types to the compiler.</p>

<p>Some research-oriented functional languages such as <a class="uri" href="Coq" title="wikilink">Coq</a>, <a href="Agda_(theorem_prover)" title="wikilink">Agda</a>, <a href="Cayenne_(programming_language)" title="wikilink">Cayenne</a>, and <a href="Epigram_(programming_language)" title="wikilink">Epigram</a> are based on <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>, which allows types to depend on terms. Such types are called <a href="dependent_type" title="wikilink">dependent types</a>. These type systems do not have decidable type inference and are difficult to understand and program with. But dependent types can express arbitrary propositions in <a href="predicate_logic" title="wikilink">predicate logic</a>. Through the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>, then, well-typed programs in these languages become a means of writing formal <a href="mathematical_proof" title="wikilink">mathematical proofs</a> from which a compiler can generate <a href="formal_verification" title="wikilink">certified code</a>. While these languages are mainly of interest in academic research (including in <a href="formalized_mathematics" title="wikilink">formalized mathematics</a>), they have begun to be used in engineering as well. <a class="uri" href="Compcert" title="wikilink">Compcert</a> is a <a class="uri" href="compiler" title="wikilink">compiler</a> for a subset of the <a href="C_(programming_language)" title="wikilink">C programming language</a> that is written in Coq and formally verified.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>

<p>A limited form of dependent types called <a href="generalized_algebraic_data_type" title="wikilink">generalized algebraic data types</a> (GADT's) can be implemented in a way that provides some of the benefits of dependently typed programming while avoiding most of its inconvenience.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> GADT's are available in the <a href="Glasgow_Haskell_Compiler" title="wikilink">Glasgow Haskell Compiler</a>, in <a class="uri" href="OCaml" title="wikilink">OCaml</a> (since version 4.00) and in <a href="Scala_(programming_language)" title="wikilink">Scala</a> (as "case classes"), and have been proposed as additions to other languages including Java and C#.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>
<h3 id="functional-programming-in-non-functional-languages">Functional programming in non-functional languages</h3>

<p>It is possible to use a functional style of programming in languages that are not traditionally considered functional languages.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> For example, both <a href="D_(programming_language)" title="wikilink">D</a> and <a href="Fortran_95" title="wikilink">Fortran 95</a> explicitly support pure functions.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p>First-class functions have slowly been added to mainstream languages. <a href="Python_(programming_language)" title="wikilink">Python</a> had first class functions from the beginning, and Amrit Prem added support for "<a href="anonymous_function" title="wikilink">lambda</a>", "<a href="Map_(higher-order_function)" title="wikilink">map</a>", "<a href="Fold_(higher-order_function)" title="wikilink">reduce</a>", and "<a href="Filter_(higher-order_function)" title="wikilink">filter</a>" in 1994, as well as closures in Python 2.2,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> though Python 3 relegated "reduce" to the <code>functools</code> standard library module.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> First-class functions were also introduced in <a class="uri" href="PHP" title="wikilink">PHP</a> 5.3, <a href="Visual_Basic" title="wikilink">Visual Basic</a> 9, <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> 3.0, and <a class="uri" href="C++11" title="wikilink">C++11</a>.</p>

<p>In <a href="Java_(programming_language)" title="wikilink">Java</a>, <a href="anonymous_class" title="wikilink">anonymous classes</a> can sometimes be used to simulate <a href="Closure_(computer_science)" title="wikilink">closures</a>;<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> however, anonymous classes are not always proper replacements to <a href="Closure_(computer_science)" title="wikilink">closures</a> because they have more limited capabilities.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> Java 8 supports lambda expressions as a replacement for some anonymous classes.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> However, the presence of checked exceptions in Java can make functional programming inconvenient, because it can be necessary to catch checked exceptions and then rethrow them—a problem that does not occur in other JVM languages that do not have checked exceptions, such as Scala.</p>

<p>In <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href="anonymous_class" title="wikilink">anonymous classes</a> are not necessary, because <a href="Closure_(computer_science)" title="wikilink">closures</a> and lambdas are fully supported. Libraries and language extensions for non mutable data structures are being developed to aid programming in the functional style in C#.</p>

<p>Many <a class="uri" href="object-oriented" title="wikilink">object-oriented</a> <a href="Design_pattern_(computer_science)" title="wikilink">design patterns</a> are expressible in functional programming terms: for example, the <a href="strategy_pattern" title="wikilink">strategy pattern</a> simply dictates use of a higher-order function, and the <a href="visitor_(design_pattern)" title="wikilink">visitor</a> pattern roughly corresponds to a <a class="uri" href="catamorphism" title="wikilink">catamorphism</a>, or <a href="fold_(higher-order_function)" title="wikilink">fold</a>.</p>

<p>Similarly, the idea of immutable data from functional programming is often included in imperative programming languages,<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> for example the tuple in Python, which is an immutable array.</p>
<h2 id="comparison-to-imperative-programming">Comparison to imperative programming</h2>

<p>Functional programming is very different from <a href="imperative_programming" title="wikilink">imperative programming</a>. The most significant differences stem from the fact that functional programming avoids <a href="side_effect_(computer_science)" title="wikilink">side effects</a>, which are used in imperative programming to implement state and I/O. Pure functional programming completely prevents side-effects and provides <a href="referential_transparency_(computer_science)" title="wikilink">referential transparency</a>, which makes it easier to verify, optimize, and parallelize programs, and easier to write automated tools to perform those tasks.</p>

<p>Higher-order functions are rarely used in older imperative programming. Where a traditional imperative program might use a loop to traverse a list, a functional program would use a different technique. It would use a higher-order function that takes as arguments a function and a list. The higher-order function would then apply the given function to each element of the given list and then return a new list with the results.</p>
<h3 id="simulating-state">Simulating state</h3>

<p>There are tasks (for example, maintaining a bank account balance) that often seem most naturally implemented with state. Pure functional programming performs these tasks, and I/O tasks such as accepting user input and printing to the screen, in a different way.</p>

<p>The pure functional programming language <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> implements them using <a href="monad_(functional_programming)" title="wikilink">monads</a>, derived from <a href="category_theory" title="wikilink">category theory</a>. Monads offer a way to abstract certain types of computational patterns, including (but not limited to) modeling of computations with mutable state (and other side effects such as I/O) in an imperative manner without losing purity. While existing monads may be easy to apply in a program, given appropriate templates and examples, many students find them difficult to understand conceptually, e.g., when asked to define new monads (which is sometimes needed for certain types of libraries).<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></p>

<p>Another way in which functional languages can simulate state is by passing around a <a href="data_structure" title="wikilink">data structure</a> that represents the current state as a parameter to function calls. On each function call, a copy of this data structure is created with whatever differences are the result of the function. This is referred to as '<a href="state-passing_style" title="wikilink">state-passing style</a>'.</p>

<p>Impure functional languages usually include a more direct method of managing mutable state. <a class="uri" href="Clojure" title="wikilink">Clojure</a>, for example, uses managed references that can be updated by applying pure functions to the current state. This kind of approach enables mutability while still promoting the use of pure functions as the preferred way to express computations.</p>

<p>Alternative methods such as <a href="Hoare_logic" title="wikilink">Hoare logic</a> and <a href="uniqueness_type" title="wikilink">uniqueness</a> have been developed to track side effects in programs. Some modern research languages use <a href="effect_system" title="wikilink">effect systems</a> to make the presence of side effects explicit.</p>
<h3 id="efficiency-issues">Efficiency issues</h3>

<p>Functional programming languages are typically less efficient in their use of <a href="central_processing_unit" title="wikilink">CPU</a> and memory than imperative languages such as <a href="C_(programming_language)" title="wikilink">C</a> and <a href="Pascal_(programming_language)" title="wikilink">Pascal</a>.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> This is related to the fact that some mutable data structures like arrays have a very straightforward implementation using present hardware (which is a highly evolved Turing machine). Flat arrays may be accessed very efficiently with deeply pipelined CPUs, prefetched efficiently through caches (with no complex pointer-chasing), or handled with SIMD instructions. It is also not easy to create their equally efficient general-purpose immutable counterparts. For purely functional languages, the worst-case slowdown is logarithmic in the number of memory cells used, because mutable memory can be represented by a purely functional data structure with logarithmic access time (such as a balanced tree).<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> However, such slowdowns are not universal. For programs that perform intensive numerical computations, functional languages such as <a class="uri" href="OCaml" title="wikilink">OCaml</a> and <a href="Clean_(programming_language)" title="wikilink">Clean</a> are only slightly slower than C.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> For programs that handle large <a href="matrix_(mathematics)" title="wikilink">matrices</a> and multidimensional <a href="database" title="wikilink">databases</a>, <a href="array_programming" title="wikilink">array</a> functional languages (such as <a href="J_(programming_language)" title="wikilink">J</a> and <a href="K_(programming_language)" title="wikilink">K</a>) were designed with speed optimizations.</p>

<p>Immutability of data can in many cases lead to execution efficiency by allowing the compiler to make assumptions that are unsafe in an imperative language, thus increasing opportunities for <a href="inline_expansion" title="wikilink">inline expansion</a>.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>

<p><a href="Lazy_evaluation" title="wikilink">Lazy evaluation</a> may also speed up the program, even asymptotically, whereas it may slow it down at most by a constant factor (however, it may introduce <a href="memory_leak" title="wikilink">memory leaks</a> if used improperly). Launchbury 1993<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> discusses theoretical issues related to memory leaks from lazy evaluation, and O'Sullivan <em>et al.</em> 2008<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> give some practical advice for analyzing and fixing them. However, the most general implementations of lazy evaluation making extensive use of dereferenced code and data perform poorly on modern processors with deep pipelines and multi-level caches (where a cache miss may cost hundreds of cycles) .</p>
<h3 id="coding-styles">Coding styles</h3>

<p>Imperative programs tend to emphasize the series of steps taken by a program in carrying out an action, while functional programs tend to emphasize the composition and arrangement of functions, often without specifying explicit <em>steps</em>. A simple example illustrates this with two solutions to the same programming goal (calculating <a href="Fibonacci_number" title="wikilink">Fibonacci numbers</a>). The imperative example is in <a href="Python_(programming_language)" title="wikilink">Python</a>.</p>

<p>Version 1 – With Generators</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Fibonacci numbers, imperative style</span>
<span class="co"># https://docs.python.org/2.7/tutorial/modules.html</span>
<span class="kw">def</span> fibonacci(n, first<span class="op">=</span><span class="dv">0</span>, second<span class="op">=</span><span class="dv">1</span>):
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(n):
        <span class="cf">yield</span> first  <span class="co"># Return current iteration</span>
        first, second <span class="op">=</span> second, first <span class="op">+</span> second
        
<span class="bu">print</span> [x <span class="cf">for</span> x <span class="op">in</span> fibonacci(<span class="dv">10</span>)]</code></pre></div>

<p>Version 2 – Normal</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fibonacci(n):
    first, second <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(n):
        <span class="bu">print</span> first  <span class="co"># Print current iteration</span>
        first, second <span class="op">=</span> second, first <span class="op">+</span> second <span class="co">#Calculate next values</span>
        
fibonacci(<span class="dv">10</span>)</code></pre></div>

<p>Version 3 – Recursive</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fibonacci(n, first<span class="op">=</span><span class="dv">0</span>, second<span class="op">=</span><span class="dv">1</span>):
    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:
        <span class="cf">return</span> [first]
    <span class="cf">else</span>:
        <span class="cf">return</span> [first] <span class="op">+</span> fibonacci(n <span class="op">-</span> <span class="dv">1</span>, second, first <span class="op">+</span> second)
        
<span class="bu">print</span> fibonacci(<span class="dv">10</span>)</code></pre></div>
<h4 id="haskell">Haskell</h4>

<p>A functional version (in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>) has a different feel to it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Fibonacci numbers, functional style</span>

<span class="co">-- describe an infinite list based on the recurrence relation for Fibonacci numbers</span>
fibRecurrence first second <span class="fu">=</span> first <span class="fu">:</span> fibRecurrence second (first <span class="fu">+</span> second)

<span class="co">-- describe fibonacci list as fibRecurrence with initial values 0 and 1</span>
fibonacci <span class="fu">=</span> fibRecurrence <span class="dv">0</span> <span class="dv">1</span>

<span class="co">-- describe action to print the 10th element of the fibonacci list</span>
main <span class="fu">=</span> print (fibonacci <span class="fu">!!</span> <span class="dv">10</span>)</code></pre></div>

<p>Or, more concisely:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fibonacci2 <span class="fu">=</span> <span class="dv">0</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>zipWith (<span class="fu">+</span>) fibonacci2 (tail fibonacci2)</code></pre></div>

<p>The imperative style describes the intermediate steps involved in calculating <code>fibonacci(N)</code>, and places those steps inside a <a href="Program_loops" title="wikilink">loop statement</a>. In contrast, the functional implementation shown here states the mathematical <a href="recurrence_relation" title="wikilink">recurrence relation</a> that defines the entire Fibonacci sequence, then selects an element from the sequence (see also <a href="recursion_(computer_science)" title="wikilink">recursion</a>). This example relies on Haskell's <a href="lazy_evaluation" title="wikilink">lazy evaluation</a> to create an "infinite" list of which only as much as needed (the first 10 elements in this case) will actually be computed. That computation happens when the runtime system carries out the action described by "main".</p>
<h4 id="erlang">Erlang</h4>

<p>The same program in <a href="Erlang_(programming_language)" title="wikilink">Erlang</a> provides a simple example of how functional languages in general do not require their syntax to contain an "<a href="If_statement" title="wikilink">if</a>" statement.</p>
<div class="sourceCode"><pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-module</span><span class="fu">(</span><span class="ch">fibonacci</span><span class="fu">).</span>
<span class="kw">-export</span><span class="fu">([</span><span class="ch">start</span><span class="kw">/</span><span class="dv">1</span><span class="fu">]).</span>

<span class="co">%% Fibonacci numbers in Erlang</span>
<span class="fu">start(</span><span class="dt">N</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">do_fib(</span><span class="dv">0</span><span class="fu">,</span> <span class="dv">1</span><span class="fu">,</span> <span class="dt">N</span><span class="fu">).</span>

<span class="fu">do_fib(</span><span class="dt">_</span><span class="fu">,</span> <span class="dt">B</span><span class="fu">,</span> <span class="dv">1</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">B</span><span class="fu">;</span>
<span class="fu">do_fib(</span><span class="dt">A</span><span class="fu">,</span> <span class="dt">B</span><span class="fu">,</span> <span class="dt">N</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">do_fib(</span><span class="dt">B</span><span class="fu">,</span> <span class="dt">A</span> <span class="kw">+</span> <span class="dt">B</span><span class="fu">,</span> <span class="dt">N</span> <span class="kw">-</span> <span class="dv">1</span><span class="fu">).</span></code></pre></div>

<p>This program is contained within a module called "fibonacci" and declares that the start/1 function will be visible from outside the scope of this module.</p>

<p>The function start/1 accepts a single parameter (as denoted by the "/1" syntax) and then calls an internal function called do_fib/3.</p>

<p>In direct contrast to the imperative coding style, Erlang does not need an "if" statement because the Erlang runtime will examine the parameters being passed to a function, and call the first function having a signature that matches the current pattern of parameters. (Erlang syntax does provide an "if" statement, but it is considered syntactic sugar and, compared to its usage in imperative languages, plays only a minor role in application logic design).</p>

<p>In this case, it is unnecessary to test for a parameter value within the body of the function because such a test is implicitly performed by providing a set of function signatures that describe the different patterns of values that could be received by a function.</p>

<p>In the case above, the first version of do_fib/3 will only be called when the third parameter has the precise value of 1. In all other cases, the second version of do_fib/3 will be called.</p>

<p>This example demonstrates that functional programming languages often implement conditional logic <em>implicitly</em> by matching parameter patterns rather than <em>explicitly</em> by means of an "if" statement.</p>
<h4 id="lisp">Lisp</h4>

<p>The Fibonacci function can be written in <a href="Common_Lisp" title="wikilink">Common Lisp</a> as follows:</p>
<pre class="lisp"><code>(defun fib (n &amp;optional; (a 0) (b 1))
  (if (= n 0)
      a
      (fib (- n 1) b (+ a b))))</code></pre>

<p>The program can then be called as</p>
<pre class="lisp"><code>(fib 10)</code></pre>
<h4 id="d">D</h4>

<p><a href="D_(programming_language)" title="wikilink">D</a> has support for functional programming:</p>
<div class="sourceCode"><pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;
<span class="kw">import</span> std.range;

<span class="dt">void</span> main()
{
    <span class="co">/* 'f' is a range representing the first 10 Fibonacci numbers */</span>
    <span class="kw">auto</span> f = recurrence!((seq, i) =&gt; seq[<span class="dv">0</span>] + seq[<span class="dv">1</span>])(<span class="dv">0</span>, <span class="dv">1</span>)
             .take(<span class="dv">10</span>);

    writeln(f);
}</code></pre></div>
<h4 id="r">R</h4>

<p><a href="R_(programming_language)" title="wikilink">R (programming language)</a> is an environment for statistical computing and graphics. It is also a functional programming language.</p>

<p>The Fibonacci function can be written in <a href="R_(programming_language)" title="wikilink">R</a> as a recursive function as follows:</p>
<pre class="rsplus"><code>fib &lt;- function(n) {
 if (n == 1) 1
 else if (n == 2) 1
 else fib(n - 1) + fib(n - 2)
}</code></pre>

<p>Or it can be written as a singly recursive function:</p>
<pre class="rsplus"><code>fib &lt;- function(n,a=1,b=1){ 
 if (n == 1) a 
 else fib(n-1,b,a+b) 
} </code></pre>

<p>Or it can be written as an iterative function:</p>
<pre class="rsplus"><code>fib &lt;- function(n) {
 if (n == 1) 1
 else if (n == 2) 1
 else {
  fib&lt;-c(1,1)
  for (i in 3:n) fib&lt;-c(0,fib[1])+fib[2]
  fib[2]
 }
}</code></pre>

<p>The function can then be called as</p>
<pre class="rsplus"><code>fib(10)</code></pre>
<h2 id="use-in-industry">Use in industry</h2>

<p>Functional programming has long been popular in academia, but with few industrial applications.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> However, recently several prominent functional programming languages have been used in commercial or industrial systems. For example, the <a href="Erlang_(programming_language)" title="wikilink">Erlang</a> programming language, which was developed by the <a href="Sweden" title="wikilink">Swedish</a> company <a class="uri" href="Ericsson" title="wikilink">Ericsson</a> in the late 1980s, was originally used to implement fault-tolerant telecommunications systems.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> It has since become popular for building a range of applications at companies such as <a class="uri" href="T-Mobile" title="wikilink">T-Mobile</a>, <a class="uri" href="Nortel" title="wikilink">Nortel</a>, <a class="uri" href="Facebook" title="wikilink">Facebook</a>, <a href="Électricité_de_France" title="wikilink">Électricité de France</a> and <a class="uri" href="WhatsApp" title="wikilink">WhatsApp</a>.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a><a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a><a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a><a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a><a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> The <a href="Scheme_(programming_language)" title="wikilink">Scheme</a> dialect of <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> was used as the basis for several applications on early <a href="Apple_Macintosh" title="wikilink">Apple Macintosh</a> computers,<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a><a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> and has more recently been applied to problems such as training <a href="software_simulation" title="wikilink">simulation software</a><a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> and <a class="uri" href="telescope" title="wikilink">telescope</a> control.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> <a class="uri" href="OCaml" title="wikilink">OCaml</a>, which was introduced in the mid-1990s, has seen commercial use in areas such as financial analysis,<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a> <a href="software_driver" title="wikilink">driver</a> verification, industrial <a class="uri" href="robot" title="wikilink">robot</a> programming, and static analysis of <a href="embedded_software" title="wikilink">embedded software</a>.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a> <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, although initially intended as a research language,<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a> has also been applied by a range of companies, in areas such as aerospace systems, hardware design, and web programming.<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a><a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p>

<p>Other functional programming languages that have seen use in industry include <a href="Scala_(programming_language)" title="wikilink">Scala</a>,<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> <a href="F_Sharp_(programming_language)" title="wikilink">F#</a>,<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a><a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> (both being functional-OO hybrids with support for both <a href="purely_functional" title="wikilink">purely functional</a> and imperative programming) <a href="Wolfram_Language" title="wikilink">Wolfram Language</a>,<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a> <a href="Lisp_(programming_language)" title="wikilink">Lisp</a>,<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a> <a href="Standard_ML" title="wikilink">Standard ML</a>,<a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a><a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a> and <a class="uri" href="Clojure" title="wikilink">Clojure</a>.<a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a></p>
<h2 id="in-education">In education</h2>

<p>Functional programming is being used as a method to teach problem solving, algebra and geometric concepts.<a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Comparison_of_programming_paradigms" title="wikilink">Comparison of programming paradigms</a></li>
<li><a href="Eager_evaluation" title="wikilink">Eager evaluation</a></li>
<li><a href="List_of_functional_programming_topics" title="wikilink">List of functional programming topics</a></li>
<li><a href="Nested_function" title="wikilink">Nested function</a></li>
<li><a href="Inductive_functional_programming" title="wikilink">Inductive functional programming</a></li>
<li><a href="Functional_reactive_programming" title="wikilink">Functional reactive programming</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li>Cousineau, Guy and Michel Mauny. <em>The Functional Approach to Programming</em>. Cambridge, UK: <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>, 1998.</li>
<li>Curry, Haskell Brooks and Feys, Robert and Craig, William. <em>Combinatory Logic</em>. Volume I. North-Holland Publishing Company, Amsterdam, 1958.</li>
<li></li>
<li><a href="Mark_Jason_Dominus" title="wikilink">Dominus, Mark Jason</a>. <em><a href="http://hop.perl.plover.com/book/pdf/HigherOrderPerl.pdf">Higher-Order Perl</a></em>. <a href="Morgan_Kaufmann" title="wikilink">Morgan Kaufmann</a>. 2005.</li>
<li></li>
<li>Graham, Paul. <em>ANSI Common LISP</em>. Englewood Cliffs, New Jersey: <a href="Prentice_Hall" title="wikilink">Prentice Hall</a>, 1996.</li>
<li>MacLennan, Bruce J. <em>Functional Programming: Practice and Theory</em>. Addison-Wesley, 1990.</li>
<li></li>
<li>Pratt, Terrence, W. and Marvin V. Zelkowitz. <em>Programming Languages: Design and Implementation</em>. 3rd ed. Englewood Cliffs, New Jersey: <a href="Prentice_Hall" title="wikilink">Prentice Hall</a>, 1996.</li>
<li>Salus, Peter H. <em>Functional and Logic Programming Languages</em>. Vol. 4 of Handbook of Programming Languages. Indianapolis, Indiana: <a href="Macmillan_Technical_Publishing" title="wikilink">Macmillan Technical Publishing</a>, 1998.</li>
<li>Thompson, Simon. <em>Haskell: The Craft of Functional Programming</em>. Harlow, England: <a href="Addison-Wesley_Longman_Limited" title="wikilink">Addison-Wesley Longman Limited</a>, 1996.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li>

<p>An introduction</p></li>
<li><em>Functional programming in Python</em> (by David Mertz): <a href="http://gnosis.cx/publish/programming/charming_python_13.html">part 1</a>, <a href="http://gnosis.cx/publish/programming/charming_python_16.html">part 2</a>, <a href="http://gnosis.cx/publish/programming/charming_python_19.html">part 3</a></li>
</ul>

<p>"</p>

<p><a href="Category:Programming_paradigms" title="wikilink">Category:Programming paradigms</a> <a href="Category:Functional_programming" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29">The memoir of <a href="Herbert_A._Simon" title="wikilink">Herbert A. Simon</a> (1991), <em>Models of My Life</em> pp.189-190 ISBN 0-465-04640-1 claims that he, Al Newell, and Cliff Shaw are "commonly adjudged to be the parents of [the] artificial intelligence [field]", for writing <a href="Logic_Theorist" title="wikilink">Logic Theorist</a>, a program which proved theorems from <em><a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a></em> automatically. In order to accomplish this, they had to invent a language and a paradigm which, which viewed retrospectively, embeds functional programming.<a href="#fnref29">↩</a></li>
<li id="fn30"><a class="uri" href="http://www.stanford.edu/class/cs242/readings/backus.pdf">http://www.stanford.edu/class/cs242/readings/backus.pdf</a><a href="#fnref30">↩</a></li>
<li id="fn31">R.M. Burstall. Design considerations for a functional programming language. Invited paper, Proc. Infotech State of the Art Conf. "The Software Revolution", Copenhagen, 45–57 (1977)<a href="#fnref31">↩</a></li>
<li id="fn32">R.M. Burstall and J. Darlington. A transformation system for developing recursive programs. Journal of the Association for Computing Machinery 24(1):44–67 (1977)<a href="#fnref32">↩</a></li>
<li id="fn33">R.M. Burstall, D.B. MacQueen and D.T. Sannella. HOPE: an experimental applicative language. Proc. 1980 LISP Conference, Stanford, 136–143 (1980).<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm">The Implementation of Functional Programming Languages</a>. Simon Peyton Jones, published by Prentice Hall, 1987<a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"> <a href="http://lambda-the-ultimate.org/node/1134">source of citation</a><a href="#fnref42">↩</a></li>
<li id="fn43">; (<a href="http://www-128.ibm.com/developerworks/library/l-prog.html">Part 1</a>, <a href="http://www-128.ibm.com/developerworks/library/l-prog2.html">Part 2</a>)<a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"><a href="#fnref51">↩</a></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"></li>
<li id="fn60"></li>
<li id="fn61"></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"></li>
<li id="fn64"><a href="http://blog.whatsapp.com/index.php/2012/01/1-million-is-so-2011/">1 million is so 2011</a> // WhatsApp blog, 2012-01-06: "the last important piece of our infrastracture is Erlang"<a href="#fnref64">↩</a></li>
<li id="fn65"></li>
<li id="fn66"></li>
<li id="fn67"></li>
<li id="fn68"></li>
<li id="fn69"></li>
<li id="fn70"></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"><a href="#fnref74">↩</a></li>
<li id="fn75"></li>
<li id="fn76"></li>
<li id="fn77"><a href="#fnref77">↩</a></li>
<li id="fn78"><a href="#fnref78">↩</a></li>
<li id="fn79"><a href="#fnref79">↩</a></li>
<li id="fn80"><a href="#fnref80">↩</a></li>
<li id="fn81"><a href="#fnref81">↩</a></li>
<li id="fn82"><a href="#fnref82">↩</a></li>
</ol>
</section>
</body>

