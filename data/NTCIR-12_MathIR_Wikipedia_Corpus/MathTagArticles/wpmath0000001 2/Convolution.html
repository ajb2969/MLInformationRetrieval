<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="238">Convolution</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Convolution</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Visual comparison of convolution, <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a> and <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a>.</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and, in particular, <a href="functional_analysis" title="wikilink">functional analysis</a>, <strong>convolution</strong> is a <a href="operation_(mathematics)" title="wikilink">mathematical operation</a> on two <a href="function_(mathematics)" title="wikilink">functions</a> <em>f</em> and <em>g</em>, producing a third function that is typically viewed as a modified version of one of the original functions, giving the area overlap between the two functions as a function of the amount that one of the original functions is <a href="Translation_(geometry)" title="wikilink">translated</a>. Convolution is similar to <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a>. It has applications that include <a class="uri" href="probability" title="wikilink">probability</a>, <a class="uri" href="statistics" title="wikilink">statistics</a>, <a href="computer_vision" title="wikilink">computer vision</a>, <a href="natural_language_processing" title="wikilink">natural language processing</a>, <a href="image_processing" title="wikilink">image</a> and <a href="signal_processing" title="wikilink">signal processing</a>, <a href="electrical_engineering" title="wikilink">electrical engineering</a>, and <a href="differential_equations" title="wikilink">differential equations</a>.</p>

<p>The convolution can be defined for functions on <a href="group_(mathematics)" title="wikilink">groups</a> other than <a href="Euclidean_space" title="wikilink">Euclidean space</a>. For example, <a href="periodic_function" title="wikilink">periodic functions</a>, such as the <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a>, can be defined on a <a class="uri" href="circle" title="wikilink">circle</a> and convolved by <em>periodic convolution</em>. (See row 10 at <a class="uri" href="DTFT#Properties" title="wikilink">DTFT#Properties</a>.)  And <em>discrete convolution</em> can be defined for functions on the set of <a class="uri" href="integers" title="wikilink">integers</a>. Generalizations of convolution have applications in the field of <a href="numerical_analysis" title="wikilink">numerical analysis</a> and <a href="numerical_linear_algebra" title="wikilink">numerical linear algebra</a>, and in the design and implementation of <a href="finite_impulse_response" title="wikilink">finite impulse response</a> filters in signal processing.</p>

<p>Computing the inverse of the convolution operation is known as <a class="uri" href="deconvolution" title="wikilink">deconvolution</a>.</p>
<h2 id="definition">Definition</h2>

<p>The convolution of <em>f</em> and <em>g</em> is written <em>f</em>∗<em>g</em>, using an <a class="uri" href="asterisk" title="wikilink">asterisk</a> or star. It is defined as the integral of the product of the two functions after one is reversed and shifted. As such, it is a particular kind of <a href="integral_transform" title="wikilink">integral transform</a>:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Convolution:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>g</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g)(t)\ \ \,
  </annotation>
 </semantics>
</math>

  </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Convolution:1">
 <semantics>
  <mrow>
   <mi></mi>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>τ</ci>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{\mathrm{def}}{=}\ \int_{-\infty}^{\infty}f(\tau)\,g(t-\tau)\,d\tau
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Convolution:2">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mi>τ</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>τ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
      <ci>g</ci>
      <ci>τ</ci>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\int_{-\infty}^{\infty}f(t-\tau)\,g(\tau)\,d\tau.
  </annotation>
 </semantics>
</math>

       (<a href="#Properties" title="wikilink">commutativity</a>)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>While the symbol <em>t</em> is used above, it need not represent the time domain. But in that context, the convolution formula can be described as a weighted average of the function <em>f</em>(<em>τ</em>) at the moment <em>t</em> where the weighting is given by <em>g</em>(−<em>τ</em>) simply shifted by amount <em>t</em>. As <em>t</em> changes, the weighting function emphasizes different parts of the input function.</p>

<p>For functions <em>f</em>, <em>g</em> <a href="Support_(mathematics)" title="wikilink">supported</a> on only 

<math display="inline" id="Convolution:3">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi mathvariant="normal">∞</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed-open">
    <cn type="integer">0</cn>
    <infinity></infinity>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,\infty)
  </annotation>
 </semantics>
</math>

 (i.e., zero for negative arguments), the integration limits can be truncated, resulting in</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Convolution:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>t</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>τ</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>τ</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>τ</mi>
      </mrow>
     </mrow>
     <mi>for</mi>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>τ</ci>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>τ</ci>
        </apply>
        <ci>d</ci>
        <ci>τ</ci>
       </apply>
      </apply>
      <ci>for</ci>
      <ci>f</ci>
      <ci>g</ci>
     </list>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <interval closure="closed-open">
      <cn type="integer">0</cn>
      <infinity></infinity>
     </interval>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g)(t)=\int_{0}^{t}f(\tau)\,g(t-\tau)\,d\tau\ \ \ \mathrm{for}\ \ f,g:[0,%
\infty)\to\mathbb{R}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>In this case, the <a href="Laplace_transform" title="wikilink">Laplace transform</a> is more appropriate than the <a href="Fourier_transform" title="wikilink">Fourier transform</a> below and boundary terms become relevant.</p>

<p>For the multi-dimensional formulation of convolution, see <a href="#Domain_of_definition" title="wikilink">Domain of definition</a> (below).</p>
<h3 id="derivations">Derivations</h3>

<p>Convolution describes the output (in terms of the input) of an important class of operations known as <em>linear time-invariant</em> (LTI). See <a href="LTI_system_theory#Overview" title="wikilink">LTI system theory</a> for a derivation of convolution as the result of LTI constraints. In terms of the <a href="Fourier_transforms" title="wikilink">Fourier transforms</a> of the input and output of an LTI operation, no new frequency components are created. The existing ones are only modified (amplitude and/or phase). In other words, the output transform is the pointwise product of the input transform with a third transform (known as a <a href="transfer_function" title="wikilink">transfer function</a>). See <a href="Convolution_theorem" title="wikilink">Convolution theorem</a> for a derivation of that property of convolution. Conversely, convolution can be derived as the inverse Fourier transform of the pointwise product of two Fourier transforms.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><strong>Visual explanations of convolution</strong><br/>
</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><ol>
<li>Express each function in terms of a <a href="Free_variables_and_bound_variables" title="wikilink">dummy variable</a> 

<math display="inline" id="Convolution:5">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau.
  </annotation>
 </semantics>
</math>

</li>
<li>Reflect one of the functions

<math display="block" id="Convolution:6">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\tau)
  </annotation>
 </semantics>
</math>

→

<math display="inline" id="Convolution:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <minus></minus>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(-\tau).
  </annotation>
 </semantics>
</math>

</li>
<li>Add a time-offset, <em>t</em>, which allows 

<math display="inline" id="Convolution:8">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mi>τ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(t-\tau)
  </annotation>
 </semantics>
</math>

 to slide along the 

<math display="inline" id="Convolution:9">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

-axis.</li>
<li>Start <em>t</em> at −∞ and slide it all the way to +∞. Wherever the two functions intersect, find the integral of their product. In other words, compute a <u>sliding</u>, weighted-sum of function 

<math display="inline" id="Convolution:10">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\tau)
  </annotation>
 </semantics>
</math>

, where the weighting function is 

<math display="inline" id="Convolution:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <minus></minus>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(-\tau).
  </annotation>
 </semantics>
</math>

</li>
</ol>
<dl>
<dd>The resulting <a class="uri" href="waveform" title="wikilink">waveform</a> (not shown here) is the convolution of functions <em>f</em> and <em>g</em>.
</dd>
<dd>If <em>f</em>(<em>t</em>) is a <a href="unit_impulse" title="wikilink">unit impulse</a>, the result of this process is simply <em>g</em>(<em>t</em>), which is therefore called the <a href="impulse_response" title="wikilink">impulse response</a>. Formally<strong>:</strong>

<p>

<math display="block" id="Convolution:12">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>τ</ci>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-\infty}^{\infty}\delta(\tau)\,g(t-\tau)\,d\tau=g(t)
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl></td>
</tr>
<tr class="even">
<td style="text-align: left;"><dl>
<dd>In this example, the red-colored "pulse", 

<math display="inline" id="Convolution:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\tau),
  </annotation>
 </semantics>
</math>

 is a symmetrical function 

<math display="inline" id="Convolution:14">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt" stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mi>τ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ g(-\tau)=g(\tau)\ ),
  </annotation>
 </semantics>
</math>

 so convolution is equivalent to correlation. A snapshot of this "movie" shows functions 

<math display="inline" id="Convolution:15">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mi>τ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(t-\tau)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Convolution:16">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\tau)
  </annotation>
 </semantics>
</math>

 (in blue) for some value of parameter 

<math display="inline" id="Convolution:17">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t,
  </annotation>
 </semantics>
</math>

 which is arbitrarily defined as the distance from the 

<math display="inline" id="Convolution:18">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=0
  </annotation>
 </semantics>
</math>

 axis to the center of the red pulse. The amount of yellow is the area of the product 

<math display="inline" id="Convolution:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>τ</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\tau)\cdot g(t-\tau),
  </annotation>
 </semantics>
</math>

 computed by the convolution/correlation integral. The movie is created by continuously changing 

<math display="inline" id="Convolution:20">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and recomputing the integral. The result (shown in black) is a function of 

<math display="inline" id="Convolution:21">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t,
  </annotation>
 </semantics>
</math>

 but is plotted on the same axis as 

<math display="inline" id="Convolution:22">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau,
  </annotation>
 </semantics>
</math>

  for convenience and comparison.
</dd>
</dl></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><dl>
<dd>In this depiction, 

<math display="inline" id="Convolution:23">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\tau)
  </annotation>
 </semantics>
</math>

 could represent the response of an RC circuit to a narrow pulse that occurs at 

<math display="inline" id="Convolution:24">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=0.
  </annotation>
 </semantics>
</math>

 In other words, if 

<math display="inline" id="Convolution:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\tau)=\delta(\tau),
  </annotation>
 </semantics>
</math>

 the result of convolution is just 

<math display="inline" id="Convolution:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t).
  </annotation>
 </semantics>
</math>

 But when 

<math display="inline" id="Convolution:27">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\tau)
  </annotation>
 </semantics>
</math>

 is the wider pulse (in red), the response is a "smeared" version of 

<math display="inline" id="Convolution:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t).
  </annotation>
 </semantics>
</math>

 It begins at  

<math display="inline" id="Convolution:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mn>0.5</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <cn type="float">0.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=-0.5,
  </annotation>
 </semantics>
</math>

 because we defined 

<math display="inline" id="Convolution:30">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 as the distance from the 

<math display="inline" id="Convolution:31">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=0
  </annotation>
 </semantics>
</math>

 axis to the <u>center</u> of the wide pulse (instead of the leading edge).
</dd>
</dl></td>
</tr>
</tbody>
</table>
<h2 id="historical-developments">Historical developments</h2>

<p>One of the earliest uses of the convolution integral appeared in <a class="uri" href="D'Alembert" title="wikilink">D'Alembert</a>'s derivation of <a href="Taylor's_theorem" title="wikilink">Taylor's theorem</a> in <em>Recherches sur différents points importants du système du monde,</em> published in 1754.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Also, an expression of the type:</p>

<p>

<math display="block" id="Convolution:32">
 <semantics>
  <mrow>
   <mo largeop="true" symmetric="true">∫</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <int></int>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>u</ci>
      </apply>
      <ci>g</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>u</ci>
     </apply>
     <ci>d</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int f(u)\cdot g(x-u)du
  </annotation>
 </semantics>
</math>

</p>

<p>is used by <a href="Sylvestre_François_Lacroix" title="wikilink">Sylvestre François Lacroix</a> on page 505 of his book entitled <em>Treatise on differences and series</em>, which is the last of 3 volumes of the encyclopedic series: <em>Traité du calcul différentiel et du calcul intégral</em>, Chez Courcier, Paris, 1797-1800.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Soon thereafter, convolution operations appear in the works of <a href="Pierre_Simon_Laplace" title="wikilink">Pierre Simon Laplace</a>, <a href="Jean_Baptiste_Joseph_Fourier" title="wikilink">Jean Baptiste Joseph Fourier</a>, <a href="Siméon_Denis_Poisson" title="wikilink">Siméon Denis Poisson</a>, and others. The term itself did not come into wide use until the 1950s or 60s. Prior to that it was sometimes known as <em>faltung</em> (which means <em>folding</em> in <a href="German_language" title="wikilink">German</a>), <em>composition product</em>, <em>superposition integral</em>, and <em>Carson's integral</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Yet it appears as early as 1903, though the definition is rather unfamiliar in older uses.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The operation:</p>

<p>

<math display="block" id="Convolution:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>t</mi>
      </msubsup>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>ψ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>s</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>s</mi>
      </mrow>
     </mrow>
     <mo rspace="22.5pt">,</mo>
     <mn>0</mn>
    </mrow>
    <mo>≤</mo>
    <mi>t</mi>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>φ</ci>
        <ci>s</ci>
        <ci>ψ</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>s</ci>
        </apply>
        <ci>d</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </list>
     <ci>t</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{t}\varphi(s)\psi(t-s)\,ds,\qquad 0\leq t<\infty,
  </annotation>
 </semantics>
</math>

</p>

<p>is a particular case of composition products considered by the Italian mathematician <a href="Vito_Volterra" title="wikilink">Vito Volterra</a> in 1913.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="circular-convolution">Circular convolution</h2>

<p>When a function <em>g</em><sub><em>T</em></sub> is periodic, with period <em>T</em>, then for functions, <em>f</em>, such that <em>f</em>∗<em>g</em><sub><em>T</em></sub> exists, the convolution is also periodic and identical to:</p>

<p>

<math display="block" id="Convolution:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <msub>
        <mi>g</mi>
        <mi>T</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>T</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mrow>
           <mo>-</mo>
           <mi mathvariant="normal">∞</mi>
          </mrow>
         </mrow>
         <mi mathvariant="normal">∞</mi>
        </munderover>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>τ</mi>
           <mo>+</mo>
           <mrow>
            <mi>k</mi>
            <mi>T</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <msub>
       <mi>g</mi>
       <mi>T</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mi>τ</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>τ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>k</ci>
           <apply>
            <minus></minus>
            <infinity></infinity>
           </apply>
          </apply>
         </apply>
         <infinity></infinity>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <plus></plus>
          <ci>τ</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>T</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g_{T})(t)\equiv\int_{t_{0}}^{t_{0}+T}\left[\sum_{k=-\infty}^{\infty}f(\tau+%
kT)\right]g_{T}(t-\tau)\,d\tau,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>t</em><sub>o</sub> is an arbitrary choice. The summation is called a <a href="periodic_summation" title="wikilink">periodic summation</a> of the function <em>f</em>.</p>

<p>When <em>g</em><sub><em>T</em></sub> is a <a href="periodic_summation" title="wikilink">periodic summation</a> of another function, <em>g</em>, then <em>f</em>∗<em>g</em><sub><em>T</em></sub> is known as a <em>circular</em> or <em>cyclic</em> convolution of <em>f</em> and <em>g</em>.<br/>
And if the periodic summation above is replaced by <em>f</em><sub><em>T</em></sub>, the operation is called a <em>periodic</em> convolution of <em>f</em><sub><em>T</em></sub> and <em>g</em><sub><em>T</em></sub>.</p>
<h2 id="discrete-convolution">Discrete convolution</h2>

<p>For complex-valued functions <em>f</em>, <em>g</em> defined on the set <strong>Z</strong> of integers, the <strong>discrete convolution</strong> of <em>f</em> and <em>g</em> is given by:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>

<math display="block" id="Convolution:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo rspace="4.2pt" stretchy="false">]</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g)[n]\ \stackrel{\mathrm{def}}{=}\ \sum_{m=-\infty}^{\infty}f[m]\,g[n-m]
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Convolution:36">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">]</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>m</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{m=-\infty}^{\infty}f[n-m]\,g[m].
  </annotation>
 </semantics>
</math>

       (<a href="#Properties" title="wikilink">commutativity</a>)
</dd>
</dl>
</dd>
</dl>

<p>The convolution of two finite sequences is defined by extending the sequences to finitely supported functions on the set of integers. When the sequences are the coefficients of two <a href="polynomial" title="wikilink">polynomials</a>, then the coefficients of the ordinary product of the two polynomials are the convolution of the original two sequences. This is known as the <a href="Cauchy_product" title="wikilink">Cauchy product</a> of the coefficients of the sequences.</p>

<p>Thus when <em>g</em> has finite support in the set 

<math display="inline" id="Convolution:37">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo>-</mo>
    <mi>M</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mi>M</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mi>M</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <minus></minus>
     <ci>M</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>M</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{-M,-M+1,\dots,M-1,M\}
  </annotation>
 </semantics>
</math>

 (representing, for instance, a <a href="finite_impulse_response" title="wikilink">finite impulse response</a>), a finite summation may be used:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="block" id="Convolution:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi>M</mi>
       </mrow>
      </mrow>
      <mi>M</mi>
     </munderover>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>m</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <apply>
         <minus></minus>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g)[n]=\sum_{m=-M}^{M}f[n-m]g[m].
  </annotation>
 </semantics>
</math>

</p>
<h2 id="circular-discrete-convolution">Circular discrete convolution</h2>

<p>When a function <em>g<sub>N</sub></em> is periodic, with period <em>N</em>, then for functions, <em>f</em>, such that <em>f</em>∗<em>g<sub>N</sub></em> exists, the convolution is also periodic and identical to:</p>

<p>

<math display="block" id="Convolution:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <msub>
        <mi>g</mi>
        <mi>N</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mrow>
           <mo>-</mo>
           <mi mathvariant="normal">∞</mi>
          </mrow>
         </mrow>
         <mi mathvariant="normal">∞</mi>
        </munderover>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>m</mi>
           <mo>+</mo>
           <mrow>
            <mi>k</mi>
            <mi>N</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <msub>
       <mi>g</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <apply>
           <minus></minus>
           <infinity></infinity>
          </apply>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g_{N})[n]\equiv\sum_{m=0}^{N-1}\left(\sum_{k=-\infty}^{\infty}{f}[m+kN]%
\right)g_{N}[n-m].\,
  </annotation>
 </semantics>
</math>

</p>

<p>The summation on <em>k</em> is called a <a href="periodic_summation" title="wikilink">periodic summation</a> of the function <em>f</em>.</p>

<p>If <em>g<sub>N</sub></em> is a <a href="periodic_summation" title="wikilink">periodic summation</a> of another function, <em>g</em>, then <em>f</em>∗<em>g<sub>N</sub></em> is known as a <a href="circular_convolution" title="wikilink">circular convolution</a> of <em>f</em> and <em>g</em>.</p>

<p>When the non-zero durations of both <em>f</em> and <em>g</em> are limited to the interval [0, <em>N</em> − 1], <em>f</em>∗<em>g<sub>N</sub></em> reduces to these common forms:</p>

<p>] \equiv (f *_N g)[n] \end{align}|<mtpl><eqref>Eq.1<eqref></eqref></eqref></mtpl>}}</p>

<p>The notation (<em>f</em> ∗<sub><em>N</em></sub> <em>g</em>) for <em>cyclic convolution</em> denotes convolution over the <a href="cyclic_group" title="wikilink">cyclic group</a> of <a href="modular_arithmetic" title="wikilink">integers modulo <em>N</em></a>.</p>

<p>Circular convolution arises most often in the context of fast convolution with an <a href="Fast_Fourier_transform" title="wikilink">FFT</a> algorithm.</p>
<h3 id="fast-convolution-algorithms">Fast convolution algorithms</h3>

<p>In many situations, discrete convolutions can be converted to circular convolutions so that fast transforms with a convolution property can be used to implement the computation. For example, convolution of digit sequences is the kernel operation in <a class="uri" href="multiplication" title="wikilink">multiplication</a> of multi-digit numbers, which can therefore be efficiently implemented with transform techniques (; ).</p>

<p>requires <em>N</em> arithmetic operations per output value and <em>N</em><sup>2</sup> operations for <em>N</em> outputs. That can be significantly reduced with any of several fast algorithms. <a href="Digital_signal_processing" title="wikilink">Digital signal processing</a> and other applications typically use fast convolution algorithms to reduce the cost of the convolution to O(<em>N</em> log <em>N</em>) complexity.</p>

<p>The most common fast convolution algorithms use <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT) algorithms via the <a href="Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem" title="wikilink">circular convolution theorem</a>. Specifically, the <a href="circular_convolution" title="wikilink">circular convolution</a> of two finite-length sequences is found by taking an FFT of each sequence, multiplying pointwise, and then performing an inverse FFT. Convolutions of the type defined above are then efficiently implemented using that technique in conjunction with zero-extension and/or discarding portions of the output. Other fast convolution algorithms, such as the <a href="Schönhage–Strassen_algorithm" title="wikilink">Schönhage–Strassen algorithm</a> or the Mersenne transform,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> use fast Fourier transforms in other <a href="ring_(mathematics)" title="wikilink">rings</a>.</p>

<p>If one sequence is much longer than the other, zero-extension of the shorter sequence and fast circular convolution is not the most computationally efficient method available.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Instead, decomposing the longer sequence into blocks and convolving each block allows for faster algorithms such as the <a href="Overlap–save_method" title="wikilink">Overlap–save method</a> and <a href="Overlap–add_method" title="wikilink">Overlap–add method</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> A hybrid convolution method that combines block and FIR algorithms allows for a zero input-output latency that is useful for real-time convolution computations.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="domain-of-definition">Domain of definition</h2>

<p>The convolution of two complex-valued functions on <strong>R</strong><sup><em>d</em></sup> is itself a complex-valued function on <strong>R</strong><sup><em>d</em></sup>, defined by:</p>

<p>

<math display="block" id="Convolution:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>d</mi>
      </msup>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>d</mi>
      </msup>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>y</ci>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <ci>g</ci>
       <ci>y</ci>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f*g)(x)=\int_{\mathbf{R}^{d}}f(y)g(x-y)\,dy=\int_{\mathbf{R}^{d}}f(x-y)g(y)\,dy,
  </annotation>
 </semantics>
</math>

</p>

<p>is well-defined only if <em>f</em> and <em>g</em> decay sufficiently rapidly at infinity in order for the integral to exist. Conditions for the existence of the convolution may be tricky, since a blow-up in <em>g</em> at infinity can be easily offset by sufficiently rapid decay in <em>f</em>. The question of existence thus may involve different conditions on <em>f</em> and <em>g</em>:</p>
<h3 id="compactly-supported-functions">Compactly supported functions</h3>

<p>If <em>f</em> and <em>g</em> are <a href="compact_support" title="wikilink">compactly supported</a> <a href="continuous_function" title="wikilink">continuous functions</a>, then their convolution exists, and is also compactly supported and continuous . More generally, if either function (say <em>f</em>) is compactly supported and the other is <a href="locally_integrable_function" title="wikilink">locally integrable</a>, then the convolution <em>f</em>∗<em>g</em> is well-defined and continuous.</p>

<p>Convolution of <em>f</em> and <em>g</em> is also well defined when both functions are locally square integrable on <strong>R</strong> and supported on an interval of the form [a, +∞) (or both supported on [-∞, a]).</p>
<h3 id="integrable-functions">Integrable functions</h3>

<p>The convolution of <em>f</em> and <em>g</em> exists if <em>f</em> and <em>g</em> are both <a href="Lebesgue_integral" title="wikilink">Lebesgue integrable functions</a> in <a href="Lp_space" title="wikilink">L<sup>1</sup>(<strong>R</strong><sup><em>d</em></sup>)</a>, and in this case <em>f</em>∗<em>g</em> is also integrable . This is a consequence of <a href="Fubini's_theorem#Tonelli's_theorem" title="wikilink">Tonelli's theorem</a>. This is also true for functions in 

<math display="inline" id="Convolution:41">
 <semantics>
  <msup>
   <mi mathvariant="normal">ℓ</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-ℓ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell^{1}
  </annotation>
 </semantics>
</math>

, under the discrete convolution, or more generally for the <a href="#Convolutions_on_groups" title="wikilink">convolution on any group</a>.</p>

<p>Likewise, if <em>f</em> ∈ <em>L</em><sup>1</sup>(<strong>R</strong><sup><em>d</em></sup>) and <em>g</em> ∈ <em>L</em><sup><em>p</em></sup>(<strong>R</strong><sup><em>d</em></sup>) where 1 ≤ <em>p</em> ≤ ∞, then <em>f</em>∗<em>g</em> ∈ <em>L</em><sup><em>p</em></sup>(<strong>R</strong><sup><em>d</em></sup>) and</p>

<p>

<math display="block" id="Convolution:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>p</mi>
    </msub>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mi>f</mi>
       <mo>∥</mo>
      </mrow>
      <mn>1</mn>
     </msub>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mi>g</mi>
       <mo>∥</mo>
      </mrow>
      <mi>p</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>g</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|{f}*g\|_{p}\leq\|f\|_{1}\|g\|_{p}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>In the particular case <em>p</em> = 1, this shows that <em>L</em><sup>1</sup> is a <a href="Banach_algebra" title="wikilink">Banach algebra</a> under the convolution (and equality of the two sides holds if <em>f</em> and <em>g</em> are non-negative almost everywhere).</p>

<p>More generally, <a href="Young's_inequality#Young's_inequality_for_convolutions" title="wikilink">Young's inequality</a> implies that the convolution is a continuous bilinear map between suitable <em>L</em><sup><em>p</em></sup> spaces. Specifically, if 1 ≤ <em>p</em>,<em>q</em>,<em>r</em> ≤ ∞ satisfy</p>

<p>

<math display="block" id="Convolution:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>p</mi>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <mi>q</mi>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>r</mi>
     </mfrac>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>r</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{p}+\frac{1}{q}=\frac{1}{r}+1,
  </annotation>
 </semantics>
</math>

</p>

<p>then</p>

<p>

<math display="block" id="Convolution:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>f</mi>
        <mo>*</mo>
        <mi>g</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mi>r</mi>
     </msub>
     <mo>≤</mo>
     <mrow>
      <msub>
       <mrow>
        <mo>∥</mo>
        <mi>f</mi>
        <mo>∥</mo>
       </mrow>
       <mi>p</mi>
      </msub>
      <msub>
       <mrow>
        <mo>∥</mo>
        <mi>g</mi>
        <mo>∥</mo>
       </mrow>
       <mi>q</mi>
      </msub>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <msup>
       <mi class="ltx_font_mathcaligraphic">ℒ</mi>
       <mi>p</mi>
      </msup>
     </mrow>
     <mo rspace="7.5pt">,</mo>
     <mrow>
      <mi>g</mi>
      <mo>∈</mo>
      <msup>
       <mi class="ltx_font_mathcaligraphic">ℒ</mi>
       <mi>q</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>g</ci>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>f</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>g</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℒ</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℒ</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|f*g\right\|_{r}\leq\left\|f\right\|_{p}\left\|g\right\|_{q},\quad f\in%
\mathcal{L}^{p},\ g\in\mathcal{L}^{q},
  </annotation>
 </semantics>
</math>

</p>

<p>so that the convolution is a continuous bilinear mapping from <em>L</em><sup><em>p</em></sup>×<em>L</em><sup><em>q</em></sup> to <em>L</em><sup><em>r</em></sup>. The Young inequality for convolution is also true in other contexts (circle group, convolution on <strong>Z</strong>). The preceding inequality is not sharp on the real line: when , there exists a constant <mtpl></mtpl> such that:</p>

<p>

<math display="block" id="Convolution:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>f</mi>
        <mo>*</mo>
        <mi>g</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mi>r</mi>
     </msub>
     <mo>≤</mo>
     <mrow>
      <msub>
       <mi>B</mi>
       <mrow>
        <mi>p</mi>
        <mo>,</mo>
        <mi>q</mi>
       </mrow>
      </msub>
      <msub>
       <mrow>
        <mo>∥</mo>
        <mi>f</mi>
        <mo>∥</mo>
       </mrow>
       <mi>p</mi>
      </msub>
      <msub>
       <mrow>
        <mo>∥</mo>
        <mi>g</mi>
        <mo>∥</mo>
       </mrow>
       <mi>q</mi>
      </msub>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <msup>
       <mi class="ltx_font_mathcaligraphic">ℒ</mi>
       <mi>p</mi>
      </msup>
     </mrow>
     <mo rspace="7.5pt">,</mo>
     <mrow>
      <mi>g</mi>
      <mo>∈</mo>
      <msup>
       <mi class="ltx_font_mathcaligraphic">ℒ</mi>
       <mi>q</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>g</ci>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <list>
        <ci>p</ci>
        <ci>q</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>f</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>g</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℒ</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℒ</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|f*g\right\|_{r}\leq B_{p,q}\left\|f\right\|_{p}\left\|g\right\|_{q},%
\quad f\in\mathcal{L}^{p},\ g\in\mathcal{L}^{q}.
  </annotation>
 </semantics>
</math>

</p>

<p>The optimal value of <mtpl></mtpl> was discovered in 1975.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>A stronger estimate is true provided :</p>

<p>

<math display="block" id="Convolution:46">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mi>r</mi>
   </msub>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>p</mi>
      <mo>,</mo>
      <mi>q</mi>
     </mrow>
    </msub>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mi>f</mi>
      <mo>∥</mo>
     </mrow>
     <mi>p</mi>
    </msub>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mi>g</mi>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mi>q</mi>
      <mo>,</mo>
      <mi>w</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <list>
       <ci>p</ci>
       <ci>q</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>g</ci>
      </apply>
      <list>
       <ci>q</ci>
       <ci>w</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f*g\|_{r}\leq C_{p,q}\|f\|_{p}\|g\|_{q,w}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Convolution:47">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mi>g</mi>
    <mo>∥</mo>
   </mrow>
   <mrow>
    <mi>q</mi>
    <mo>,</mo>
    <mi>w</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>g</ci>
    </apply>
    <list>
     <ci>q</ci>
     <ci>w</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|g\|_{q,w}
  </annotation>
 </semantics>
</math>

 is the <a href="Lp_space#Weak_Lp" title="wikilink">weak <em>L<sup>q</sup></em></a> norm. Convolution also defines a bilinear continuous map 

<math display="inline" id="Convolution:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>L</mi>
     <mrow>
      <mi>p</mi>
      <mo>,</mo>
      <mi>w</mi>
     </mrow>
    </msup>
    <mo>×</mo>
    <msup>
     <mi>L</mi>
     <mrow>
      <mi>q</mi>
      <mo>.</mo>
      <mi>w</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>→</mo>
   <msup>
    <mi>L</mi>
    <mrow>
     <mi>r</mi>
     <mo>,</mo>
     <mi>w</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <list>
       <ci>p</ci>
       <ci>w</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>q</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <list>
      <ci>r</ci>
      <ci>w</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{p,w}\times L^{q.w}\to L^{r,w}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Convolution:49">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo><</mo>
    <mrow>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>r</mi>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <cn type="integer">1</cn>
     <list>
      <ci>p</ci>
      <ci>q</ci>
     </list>
    </apply>
    <apply>
     <lt></lt>
     <ci>r</ci>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1<p,q,r<\infty
  </annotation>
 </semantics>
</math>

, owing to the weak Young inequality:<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>

<math display="block" id="Convolution:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mi>r</mi>
      <mo>,</mo>
      <mi>w</mi>
     </mrow>
    </msub>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>p</mi>
       <mo>,</mo>
       <mi>q</mi>
      </mrow>
     </msub>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mi>f</mi>
       <mo>∥</mo>
      </mrow>
      <mrow>
       <mi>p</mi>
       <mo>,</mo>
       <mi>w</mi>
      </mrow>
     </msub>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mi>g</mi>
       <mo>∥</mo>
      </mrow>
      <mrow>
       <mi>r</mi>
       <mo>,</mo>
       <mi>w</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <list>
      <ci>r</ci>
      <ci>w</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <list>
       <ci>p</ci>
       <ci>q</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
      <list>
       <ci>p</ci>
       <ci>w</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>g</ci>
      </apply>
      <list>
       <ci>r</ci>
       <ci>w</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f*g\|_{r,w}\leq C_{p,q}\|f\|_{p,w}\|g\|_{r,w}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="functions-of-rapid-decay">Functions of rapid decay</h3>

<p>In addition to compactly supported functions and integrable functions, functions that have sufficiently rapid decay at infinity can also be convolved. An important feature of the convolution is that if <em>f</em> and <em>g</em> both decay rapidly, then <em>f</em>∗<em>g</em> also decays rapidly. In particular, if <em>f</em> and <em>g</em> are <a href="rapidly_decreasing_function" title="wikilink">rapidly decreasing functions</a>, then so is the convolution <em>f</em>∗<em>g</em>. Combined with the fact that convolution commutes with differentiation (see <strong>Properties</strong>), it follows that the class of <a href="Schwartz_function" title="wikilink">Schwartz functions</a> is closed under convolution .</p>
<h3 id="distributions">Distributions</h3>

<p>Under some circumstances, it is possible to define the convolution of a function with a distribution, or of two distributions. If <em>f</em> is a compactly supported function and <em>g</em> is a distribution, then <em>f</em>∗<em>g</em> is a smooth function defined by a distributional formula analogous to</p>

<p>

<math display="block" id="Convolution:51">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <msup>
      <mi>𝐑</mi>
      <mi>d</mi>
     </msup>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐑</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>y</ci>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>d</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\mathbf{R}^{d}}{f}(y)g(x-y)\,dy.
  </annotation>
 </semantics>
</math>

</p>

<p>More generally, it is possible to extend the definition of the convolution in a unique way so that the associative law</p>

<p>

<math display="block" id="Convolution:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>*</mo>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mpadded width="+1.7pt">
     <mi>φ</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>φ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f*(g*\varphi)=(f*g)*\varphi\,
  </annotation>
 </semantics>
</math>

</p>

<p>remains valid in the case where <em>f</em> is a distribution, and <em>g</em> a compactly supported distribution .</p>
<h3 id="measures">Measures</h3>

<p>The convolution of any two <a href="Borel_measure" title="wikilink">Borel measures</a> μ and ν of <a href="bounded_variation" title="wikilink">bounded variation</a> is the measure λ defined by </p>

<p>

<math display="block" id="Convolution:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>d</mi>
      </msup>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>d</mi>
      </msup>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <msup>
        <mi>𝐑</mi>
        <mi>d</mi>
       </msup>
      </msub>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mi>y</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>μ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>ν</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐑</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐑</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <plus></plus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <ci>d</ci>
       <ci>μ</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>ν</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\mathbf{R}^{d}}f(x)d\lambda(x)=\int_{\mathbf{R}^{d}}\int_{\mathbf{R}^{d}%
}f(x+y)\,d\mu(x)\,d\nu(y).
  </annotation>
 </semantics>
</math>

 This agrees with the convolution defined above when μ and ν are regarded as distributions, as well as the convolution of L<sup>1</sup> functions when μ and ν are absolutely continuous with respect to the Lebesgue measure.</p>

<p>The convolution of measures also satisfies the following version of Young's inequality</p>

<p>

<math display="block" id="Convolution:54">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>μ</mi>
     <mo>*</mo>
     <mi>ν</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>μ</mi>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mi>ν</mi>
     <mo rspace="4.2pt">∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>ν</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>ν</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mu*\nu\|\leq\|\mu\|\|\nu\|\,
  </annotation>
 </semantics>
</math>

 where the norm is the <a href="total_variation" title="wikilink">total variation</a> of a measure. Because the space of measures of bounded variation is a <a href="Banach_space" title="wikilink">Banach space</a>, convolution of measures can be treated with standard methods of <a href="functional_analysis" title="wikilink">functional analysis</a> that may not apply for the convolution of distributions.</p>
<h2 id="properties">Properties</h2>
<h3 id="algebraic-properties">Algebraic properties</h3>

<p>The convolution defines a product on the <a href="linear_space" title="wikilink">linear space</a> of integrable functions. This product satisfies the following algebraic properties, which formally mean that the space of integrable functions with the product given by convolution is a <a href="commutative_algebra" title="wikilink">commutative algebra</a> without <a href="identity_element" title="wikilink">identity</a> . Other linear spaces of functions, such as the space of continuous functions of compact support, are <a href="closure_(mathematics)" title="wikilink">closed</a> under the convolution, and so also form commutative algebras.</p>
<dl>
<dt><a class="uri" href="Commutativity" title="wikilink">Commutativity</a></dt>
<dd>

<math display="inline" id="Convolution:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mo>*</mo>
    <mpadded width="+1.7pt">
     <mi>f</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f*g=g*f\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dt><a class="uri" href="Associativity" title="wikilink">Associativity</a></dt>
<dd>

<math display="inline" id="Convolution:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>*</mo>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mpadded width="+1.7pt">
     <mi>h</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f*(g*h)=(f*g)*h\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dt><a class="uri" href="Distributivity" title="wikilink">Distributivity</a></dt>
<dd>

<math display="inline" id="Convolution:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>+</mo>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>h</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f*(g+h)=(f*g)+(f*h)\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dt>Associativity with scalar multiplication</dt>
<dd>

<math display="inline" id="Convolution:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mpadded width="+1.7pt">
     <mi>g</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(f*g)=(af)*g\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>for any real (or complex) number 

<math display="inline" id="Convolution:59">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>a</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {a}\,
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dt><a href="Multiplicative_identity" title="wikilink">Multiplicative identity</a></dt>
</dl>

<p>No algebra of functions possesses an identity for the convolution. The lack of identity is typically not a major inconvenience, since most collections of functions on which the convolution is performed can be convolved with a <a href="Dirac_delta" title="wikilink">delta distribution</a> or, at the very least (as is the case of <em>L</em><sup>1</sup>) admit <a href="Nascent_delta_function" title="wikilink">approximations to the identity</a>. The linear space of compactly supported distributions does, however, admit an identity under the convolution. Specifically,</p>

<p>

<math display="block" id="Convolution:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mi>δ</mi>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>δ</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f*\delta=f\,
  </annotation>
 </semantics>
</math>

 where δ is the delta distribution.</p>
<dl>
<dt>Inverse element</dt>
</dl>

<p>Some distributions have an <a href="inverse_element" title="wikilink">inverse element</a> for the convolution, <em>S</em><sup>(−1)</sup>, which is defined by</p>

<p>

<math display="block" id="Convolution:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>*</mo>
     <mi>S</mi>
    </mrow>
    <mo>=</mo>
    <mi>δ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>S</ci>
    </apply>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{(-1)}*S=\delta.\,
  </annotation>
 </semantics>
</math>

 The set of invertible distributions forms an <a href="abelian_group" title="wikilink">abelian group</a> under the convolution.</p>
<dl>
<dt>Complex conjugation</dt>
</dl>

<p>

<math display="block" id="Convolution:62">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <mi>f</mi>
     <mo>*</mo>
     <mi>g</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo>¯</mo>
    </mover>
    <mo>*</mo>
    <mpadded width="-1.7pt">
     <mover accent="true">
      <mi>g</mi>
      <mo>¯</mo>
     </mover>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{f*g}=\overline{f}*\overline{g}\!
  </annotation>
 </semantics>
</math>

</p>
<h3 id="integration">Integration</h3>

<p>If <em>f</em> and <em>g</em> are integrable functions, then the integral of their convolution on the whole space is simply obtained as the product of their integrals:</p>

<p>

<math display="block" id="Convolution:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>d</mi>
      </msup>
     </msub>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mo>*</mo>
        <mi>g</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∫</mo>
        <msup>
         <mi>𝐑</mi>
         <mi>d</mi>
        </msup>
       </msub>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∫</mo>
        <msup>
         <mi>𝐑</mi>
         <mi>d</mi>
        </msup>
       </msub>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐑</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\mathbf{R}^{d}}(f*g)(x)\,dx=\left(\int_{\mathbf{R}^{d}}f(x)\,dx\right)%
\left(\int_{\mathbf{R}^{d}}g(x)\,dx\right).
  </annotation>
 </semantics>
</math>

</p>

<p>This follows from <a href="Fubini's_theorem" title="wikilink">Fubini's theorem</a>. The same result holds if <em>f</em> and <em>g</em> are only assumed to be nonnegative measurable functions, by <a href="Fubini's_theorem#Tonelli's_theorem" title="wikilink">Tonelli's theorem</a>.</p>
<h3 id="differentiation">Differentiation</h3>

<p>In the one-variable case,</p>

<p>

<math display="block" id="Convolution:64">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>d</mi>
     <mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo>*</mo>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mpadded width="+1.7pt">
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mfrac>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>g</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{d}{dx}(f*g)=\frac{df}{dx}*g=f*\frac{dg}{dx}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>d</em>/<em>dx</em> is the <a class="uri" href="derivative" title="wikilink">derivative</a>. More generally, in the case of functions of several variables, an analogous formula holds with the <a href="partial_derivative" title="wikilink">partial derivative</a>:</p>

<p>

<math display="block" id="Convolution:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mo>∂</mo>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mfrac>
     <mo>*</mo>
     <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mo>*</mo>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>g</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial}{\partial x_{i}}(f*g)=\frac{\partial f}{\partial x_{i}}*g=f*%
\frac{\partial g}{\partial x_{i}}.
  </annotation>
 </semantics>
</math>

</p>

<p>A particular consequence of this is that the convolution can be viewed as a "smoothing" operation: the convolution of <em>f</em> and <em>g</em> is differentiable as many times as <em>f</em> and <em>g</em> are in total.</p>

<p>These identities hold under the precise condition that <em>f</em> and <em>g</em> are absolutely integrable and at least one of them has an absolutely integrable (L<sup>1</sup>) weak derivative, as a consequence of <a href="Young's_inequality" title="wikilink">Young's inequality</a>. For instance, when <em>f</em> is continuously differentiable with compact support, and <em>g</em> is an arbitrary locally integrable function,</p>

<p>

<math display="block" id="Convolution:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mi>d</mi>
      <mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mo>*</mo>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{d}{dx}({f}*g)=\frac{df}{dx}*g.
  </annotation>
 </semantics>
</math>

 These identities also hold much more broadly in the sense of tempered distributions if one of <em>f</em> or <em>g</em> is a compactly supported distribution or a Schwartz function and the other is a tempered distribution. On the other hand, two positive integrable and infinitely differentiable functions may have a nowhere continuous convolution.</p>

<p>In the discrete case, the <a href="difference_operator" title="wikilink">difference operator</a> <em>D</em> <em>f</em>(<em>n</em>) = <em>f</em>(<em>n</em> + 1) − <em>f</em>(<em>n</em>) satisfies an analogous relationship:</p>

<p>

<math display="block" id="Convolution:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>D</mi>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
     <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mo>*</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>D</mi>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>f</ci>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(f*g)=(Df)*g=f*(Dg).\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="convolution-theorem">Convolution theorem</h3>

<p>The <a href="convolution_theorem" title="wikilink">convolution theorem</a> states that</p>

<p>

<math display="block" id="Convolution:68">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mo>⋅</mo>
       <mi class="ltx_font_mathcaligraphic">ℱ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>f</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>g</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℱ</ci>
     <set>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>k</ci>
        <ci>ℱ</ci>
       </apply>
       <set>
        <ci>f</ci>
       </set>
      </apply>
      <ci>ℱ</ci>
     </apply>
     <set>
      <ci>g</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\{f*g\}=k\cdot\mathcal{F}\{f\}\cdot\mathcal{F}\{g\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Convolution:69">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>f</mi>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℱ</ci>
    <set>
     <ci>f</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\{f\}\,
  </annotation>
 </semantics>
</math>

 denotes the <a href="Fourier_transform" title="wikilink">Fourier transform</a> of 

<math display="inline" id="Convolution:70">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Convolution:71">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a constant that depends on the specific <a href="Normalizing_constant" title="wikilink">normalization</a> of the Fourier transform. Versions of this theorem also hold for the <a href="Laplace_transform" title="wikilink">Laplace transform</a>, <a href="two-sided_Laplace_transform" title="wikilink">two-sided Laplace transform</a>, <a class="uri" href="Z-transform" title="wikilink">Z-transform</a> and <a href="Mellin_transform" title="wikilink">Mellin transform</a>.</p>

<p>See also the less trivial <a href="Titchmarsh_convolution_theorem" title="wikilink">Titchmarsh convolution theorem</a>.</p>
<h3 id="translation-invariance">Translation invariance</h3>

<p>The convolution commutes with translations, meaning that</p>

<p>

<math display="block" id="Convolution:72">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>τ</mi>
       <mi>x</mi>
      </msub>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>τ</mi>
       <mi>x</mi>
      </msub>
      <mi>g</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>x</ci>
       </apply>
       <ci>f</ci>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>x</ci>
       </apply>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{x}({f}*g)=(\tau_{x}f)*g={f}*(\tau_{x}g)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where τ<sub><em>x</em></sub>f is the translation of the function <em>f</em> by <em>x</em> defined by</p>

<p>

<math display="block" id="Convolution:73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>τ</mi>
        <mi>x</mi>
       </msub>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>y</mi>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>x</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>y</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\tau_{x}f)(y)=f(y-x).\,
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>f</em> is a <a href="Schwartz_function" title="wikilink">Schwartz function</a>, then τ<sub><em>x</em></sub><em>f</em> is the convolution with a translated Dirac delta function τ<sub><em>x</em></sub><em>f</em> = <em>f</em>∗<em>τ</em><sub><em>x</em></sub> <em>δ</em>. So translation invariance of the convolution of Schwartz functions is a consequence of the associativity of convolution.</p>

<p>Furthermore, under certain conditions, convolution is the most general translation invariant operation. Informally speaking, the following holds</p>
<ul>
<li>Suppose that <em>S</em> is a <a href="linear_operator" title="wikilink">linear operator</a> acting on functions which commutes with translations: <em>S</em>(τ<sub><em>x</em></sub><em>f</em>) = τ<sub><em>x</em></sub>(<em>Sf</em>) for all <em>x</em>. Then <em>S</em> is given as convolution with a function (or distribution) <em>g</em><sub><em>S</em></sub>; that is <em>Sf</em> = <em>g</em><sub><em>S</em></sub>∗<em>f</em>.</li>
</ul>

<p>Thus any translation invariant operation can be represented as a convolution. Convolutions play an important role in the study of <a href="time-invariant_system" title="wikilink">time-invariant systems</a>, and especially <a href="LTI_system_theory" title="wikilink">LTI system theory</a>. The representing function <em>g</em><sub><em>S</em></sub> is the <a href="impulse_response" title="wikilink">impulse response</a> of the transformation <em>S</em>.</p>

<p>A more precise version of the theorem quoted above requires specifying the class of functions on which the convolution is defined, and also requires assuming in addition that <em>S</em> must be a <a href="continuous_linear_operator" title="wikilink">continuous linear operator</a> with respect to the appropriate <a class="uri" href="topology" title="wikilink">topology</a>. It is known, for instance, that every continuous translation invariant continuous linear operator on <em>L</em><sup>1</sup> is the convolution with a finite <a href="Borel_measure" title="wikilink">Borel measure</a>. More generally, every continuous translation invariant continuous linear operator on <em>L</em><sup><em>p</em></sup> for 1 ≤ <em>p</em> (f * g)(x) = \int_G f(y) g(y^{-1}x)\,d\lambda(y). \,</p>

<p>It is not commutative in general. In typical cases of interest <em>G</em> is a <a href="locally_compact" title="wikilink">locally compact</a> <a href="Hausdorff_space" title="wikilink">Hausdorff</a> <a href="topological_group" title="wikilink">topological group</a> and λ is a (left-) <a href="Haar_measure" title="wikilink">Haar measure</a>. In that case, unless <em>G</em> is <a href="unimodular_group" title="wikilink">unimodular</a>, the convolution defined in this way is not the same as 

<math display="inline" id="Convolution:74">
 <semantics>
  <mrow>
   <mo largeop="true" symmetric="true">∫</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <msup>
       <mi>y</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <int></int>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>g</ci>
     <ci>y</ci>
     <ci>d</ci>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\int f(xy^{-1})g(y)\,d\lambda(y)}
  </annotation>
 </semantics>
</math>

. The preference of one over the other is made so that convolution with a fixed function <em>g</em> commutes with left translation in the group:</p>

<p>

<math display="block" id="Convolution:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>h</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>*</mo>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>L</mi>
        <mi>h</mi>
       </msub>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>h</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>h</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{h}(f*g)=(L_{h}f)*g.
  </annotation>
 </semantics>
</math>

</p>

<p>Furthermore, the convention is also required for consistency with the definition of the convolution of measures given below. However, with a right instead of a left Haar measure, the latter integral is preferred over the former.</p>

<p>On locally compact <a href="abelian_group" title="wikilink">abelian groups</a>, a version of the <a href="convolution_theorem" title="wikilink">convolution theorem</a> holds: the Fourier transform of a convolution is the pointwise product of the Fourier transforms. The <a href="circle_group" title="wikilink">circle group</a> <strong>T</strong> with the Lebesgue measure is an immediate example. For a fixed <em>g</em> in <em>L</em><sup>1</sup>(<strong>T</strong>), we have the following familiar operator acting on the <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>L</em><sup>2</sup>(<strong>T</strong>):</p>

<p>

<math display="block" id="Convolution:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi>𝐓</mi>
      </msub>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>y</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>y</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>𝐓</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>y</ci>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T{f}(x)=\frac{1}{2\pi}\int_{\mathbf{T}}{f}(y)g(x-y)\,dy.
  </annotation>
 </semantics>
</math>

</p>

<p>The operator <em>T</em> is <a href="compact_operator_on_Hilbert_space" title="wikilink">compact</a>. A direct calculation shows that its adjoint <em>T*</em> is convolution with</p>

<p>

<math display="block" id="Convolution:77">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}(-y).\,
  </annotation>
 </semantics>
</math>

</p>

<p>By the commutativity property cited above, <em>T</em> is <a href="normal_operator" title="wikilink">normal</a>: <em>T</em>*<em>T</em> = <em>TT</em>*. Also, <em>T</em> commutes with the translation operators. Consider the family <em>S</em> of operators consisting of all such convolutions and the translation operators. Then <em>S</em> is a commuting family of normal operators. According to <a href="compact_operator_on_Hilbert_space" title="wikilink">spectral theory</a>, there exists an orthonormal basis {<em>h<sub>k</sub></em>} that simultaneously diagonalizes <em>S</em>. This characterizes convolutions on the circle. Specifically, we have</p>

<p>

<math display="block" id="Convolution:78">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>i</mi>
       <mi>k</mi>
       <mi>x</mi>
      </mrow>
     </msup>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>k</mi>
     <mo>∈</mo>
     <mi>ℤ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>k</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>k</ci>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{k}(x)=e^{ikx},\quad k\in\mathbb{Z},\;
  </annotation>
 </semantics>
</math>

</p>

<p>which are precisely the <a href="Character_(mathematics)" title="wikilink">characters</a> of <strong>T</strong>. Each convolution is a compact <a href="multiplication_operator" title="wikilink">multiplication operator</a> in this basis. This can be viewed as a version of the convolution theorem discussed above.</p>

<p>A discrete example is a finite <a href="cyclic_group" title="wikilink">cyclic group</a> of order <em>n</em>. Convolution operators are here represented by <a href="circulant_matrices" title="wikilink">circulant matrices</a>, and can be diagonalized by the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a>.</p>

<p>A similar result holds for compact groups (not necessarily abelian): the matrix coefficients of finite-dimensional <a href="unitary_representation" title="wikilink">unitary representations</a> form an orthonormal basis in <em>L</em><sup>2</sup> by the <a href="Peter–Weyl_theorem" title="wikilink">Peter–Weyl theorem</a>, and an analog of the convolution theorem continues to hold, along with many other aspects of <a href="harmonic_analysis" title="wikilink">harmonic analysis</a> that depend on the Fourier transform.</p>
<h2 id="convolution-of-measures">Convolution of measures</h2>

<p>Let <em>G</em> be a topological group. If μ and ν are finite <a href="Borel_measure" title="wikilink">Borel measures</a> on <em>G</em>, then their convolution μ∗ν is defined by</p>

<p>

<math display="block" id="Convolution:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>*</mo>
      <mi>ν</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" rspace="0pt" symmetric="true">∫</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <msub>
       <mn>1</mn>
       <mi>E</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mi>y</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ν</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>ν</ci>
     </apply>
     <ci>E</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <ci>E</ci>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <ci>d</ci>
       <ci>μ</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>ν</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu*\nu)(E)=\int\!\!\!\int 1_{E}(xy)\,d\mu(x)\,d\nu(y)
  </annotation>
 </semantics>
</math>

</p>

<p>for each measurable subset <em>E</em> of <em>G</em>. The convolution is also a finite measure, whose <a href="total_variation" title="wikilink">total variation</a> satisfies</p>

<p>

<math display="block" id="Convolution:80">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>μ</mi>
      <mo>*</mo>
      <mi>ν</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mi>μ</mi>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mi>ν</mi>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>ν</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>ν</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mu*\nu\|\leq\|\mu\|\|\nu\|.\,
  </annotation>
 </semantics>
</math>

</p>

<p>In the case when <em>G</em> is <a href="locally_compact" title="wikilink">locally compact</a> with (left-)<a href="Haar_measure" title="wikilink">Haar measure</a> λ, and μ and ν are <a href="absolute_continuity" title="wikilink">absolutely continuous</a> with respect to a λ, <a href="Radon–Nikodym_theorem" title="wikilink">so that each has a density function</a>, then the convolution μ∗ν is also absolutely continuous, and its density function is just the convolution of the two separate density functions.</p>

<p>If μ and ν are <a href="probability_measure" title="wikilink">probability measures</a> on the topological group  then the convolution μ∗ν is the <a href="probability_distribution" title="wikilink">probability distribution</a> of the sum <em>X</em> + <em>Y</em> of two <a href="statistical_independence" title="wikilink">independent</a> <a href="random_variable" title="wikilink">random variables</a> <em>X</em> and <em>Y</em> whose respective distributions are μ and ν.</p>
<h2 id="bialgebras">Bialgebras</h2>

<p>Let (<em>X</em>, Δ, ∇, <em>ε</em>, <em>η</em>) be a <a class="uri" href="bialgebra" title="wikilink">bialgebra</a> with comultiplication Δ, multiplication ∇, unit η, and counit ε. The convolution is a product defined on the <a href="endomorphism_algebra" title="wikilink">endomorphism algebra</a> End(<em>X</em>) as follows. Let φ, ψ ∈ End(<em>X</em>), that is, φ,ψ : <em>X</em> → <em>X</em> are functions that respect all algebraic structure of <em>X</em>, then the convolution φ∗ψ is defined as the composition</p>

<p>

<math display="block" id="Convolution:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mover accent="true">
     <mo>→</mo>
     <mo>Δ</mo>
    </mover>
    <mrow>
     <mi>X</mi>
     <mo>⊗</mo>
     <mi>X</mi>
    </mrow>
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mi>ϕ</mi>
      <mo>⊗</mo>
      <mi>ψ</mi>
     </mrow>
    </mover>
    <mrow>
     <mi>X</mi>
     <mo>⊗</mo>
     <mi>X</mi>
    </mrow>
    <mover accent="true">
     <mo>→</mo>
     <mo>∇</mo>
    </mover>
    <mi>X</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <ci>normal-Δ</ci>
      <ci>normal-→</ci>
     </apply>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ϕ</ci>
       <ci>ψ</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>normal-∇</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\xrightarrow{\Delta}X\otimes X\xrightarrow{\phi\otimes\psi}X\otimes X%
\xrightarrow{\nabla}X.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The convolution appears notably in the definition of <a href="Hopf_algebra" title="wikilink">Hopf algebras</a> . A bialgebra is a Hopf algebra if and only if it has an antipode: an endomorphism <em>S</em> such that</p>

<p>

<math display="block" id="Convolution:82">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>*</mo>
     <msub>
      <mo>id</mo>
      <mi>X</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>id</mo>
      <mi>X</mi>
     </msub>
     <mo>*</mo>
     <mi>S</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>η</mi>
     <mo>∘</mo>
     <mi>ε</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>X</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <compose></compose>
      <ci>η</ci>
      <ci>ε</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S*\operatorname{id}_{X}=\operatorname{id}_{X}*S=\eta\circ\varepsilon.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="applications">Applications</h2>

<p> Convolution and related operations are found in many applications in science, engineering and mathematics.</p>
<ul>
<li>In image processing</li>
</ul>
<dl>
<dd><dl>
<dd>In <a href="digital_image_processing" title="wikilink">digital image processing</a> convolutional filtering plays an important role in many important <a href="algorithm" title="wikilink">algorithms</a> in <a href="edge_detection" title="wikilink">edge detection</a> and related processes.
</dd>
<dd>In <a class="uri" href="optics" title="wikilink">optics</a>, an out-of-focus photograph is a convolution of the sharp image with a lens function. The photographic term for this is <a class="uri" href="bokeh" title="wikilink">bokeh</a>.
</dd>
<dd>In <a href="image_processing" title="wikilink">image processing</a> applications such as adding blurring.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>In digital data processing</li>
</ul>
<dl>
<dd><dl>
<dd>In <a href="analytical_chemistry" title="wikilink">analytical chemistry</a>, <a href="Savitzky–Golay_smoothing_filter" title="wikilink">Savitzky–Golay smoothing filters</a> are used for the analysis of spectroscopic data. They can improve <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> with minimal distortion of the spectra.
</dd>
<dd>In <a class="uri" href="statistics" title="wikilink">statistics</a>, a weighted <a href="moving_average_model" title="wikilink">moving average</a> is a convolution.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>In <a class="uri" href="acoustics" title="wikilink">acoustics</a>, <a class="uri" href="reverberation" title="wikilink">reverberation</a> is the convolution of the original sound with <a href="echo_(phenomenon)" title="wikilink">echoes</a> from objects surrounding the sound source.</li>
</ul>
<dl>
<dd><dl>
<dd>In <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, convolution is used to map the <a href="impulse_response" title="wikilink">impulse response</a> of a real room on a digital audio signal.
</dd>
<dd>In <a href="electronic_music" title="wikilink">electronic music</a> convolution is the imposition of a <a href="Spectrum" title="wikilink">spectral</a> or rhythmic structure on a sound. Often this envelope or structure is taken from another sound. The convolution of two signals is the filtering of one through the other.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>In <a href="electrical_engineering" title="wikilink">electrical engineering</a>, the convolution of one function (the <a href="Signal_(electrical_engineering)" title="wikilink">input signal</a>) with a second function (the <a href="impulse_response" title="wikilink">impulse response</a>) gives the output of a <a href="linear_time-invariant_system" title="wikilink">linear time-invariant system</a> (LTI). At any given moment, the output is an accumulated effect of all the prior values of the input function, with the most recent values typically having the most influence (expressed as a multiplicative factor). The impulse response function provides that factor as a function of the elapsed time since each input value occurred.</li>
<li>In <a class="uri" href="physics" title="wikilink">physics</a>, wherever there is a <a href="linear_system" title="wikilink">linear system</a> with a "<a href="superposition_principle" title="wikilink">superposition principle</a>", a convolution operation makes an appearance. For instance, in <a class="uri" href="spectroscopy" title="wikilink">spectroscopy</a> line broadening due to the Doppler effect on its own gives a <a href="Normal_distribution" title="wikilink">Gaussian</a> <a href="spectral_line_shape" title="wikilink">spectral line shape</a> and collision broadening alone gives a <a href="Cauchy_distribution" title="wikilink">Lorentzian</a> line shape. When both effects are operative, the line shape is a convolution of Gaussian and Lorentzian, a <a href="Voigt_function" title="wikilink">Voigt function</a>.</li>
</ul>
<dl>
<dd><dl>
<dd>In <a href="Time-resolved_spectroscopy" title="wikilink">Time-resolved fluorescence spectroscopy</a>, the excitation signal can be treated as a chain of delta pulses, and the measured fluorescence is a sum of exponential decays from each delta pulse.
</dd>
<dd>In <a href="computational_fluid_dynamics" title="wikilink">computational fluid dynamics</a>, the <a href="large_eddy_simulation" title="wikilink">large eddy simulation</a> (LES) <a href="turbulence_model" title="wikilink">turbulence model</a> uses the convolution operation to lower the range of length scales necessary in computation thereby reducing computational cost.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>In <a href="probability_theory" title="wikilink">probability theory</a>, the <a href="probability_distribution" title="wikilink">probability distribution</a> of the sum of two <a href="independent_(probability)" title="wikilink">independent</a> <a href="random_variable" title="wikilink">random variables</a> is the convolution of their individual distributions.</li>
</ul>
<dl>
<dd><dl>
<dd>In <a href="kernel_density_estimation" title="wikilink">kernel density estimation</a>, a distribution is estimated from sample points by convolution with a kernel, such as an isotropic Gaussian. .
</dd>
</dl>
</dd>
</dl>
<ul>
<li>In radiotherapy treatment planning systems, most part of all modern codes of calculation applies a <a href="convolution-superposition_algorithm" title="wikilink">convolution-superposition algorithm</a>.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Analog_signal_processing" title="wikilink">Analog signal processing</a></li>
<li><a href="Circulant_matrix" title="wikilink">Circulant matrix</a></li>
<li><a href="Convolution_for_optical_broad-beam_responses_in_scattering_media" title="wikilink">Convolution for optical broad-beam responses in scattering media</a></li>
<li><a href="Convolution_power" title="wikilink">Convolution power</a></li>
<li><a class="uri" href="Cross-correlation" title="wikilink">Cross-correlation</a></li>
<li><a class="uri" href="Deconvolution" title="wikilink">Deconvolution</a></li>
<li><a href="Dirichlet_convolution" title="wikilink">Dirichlet convolution</a></li>
<li><a href="Jan_Mikusinski" title="wikilink">Jan Mikusinski</a></li>
<li><a href="List_of_convolutions_of_probability_distributions" title="wikilink">List of convolutions of probability distributions</a></li>
<li><a href="LTI_system_theory#Impulse_response_and_convolution" title="wikilink">LTI system theory#Impulse response and convolution</a></li>
<li><a href="Scaled_correlation" title="wikilink">Scaled correlation</a></li>
<li><a href="Titchmarsh_convolution_theorem" title="wikilink">Titchmarsh convolution theorem</a></li>
<li><a href="Toeplitz_matrix" title="wikilink">Toeplitz matrix</a> (convolutions can be considered a Toeplitz matrix operation where each row is a shifted copy of the convolution kernel)</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li></li>
<li></li>
<li>Dominguez-Torres, Alejandro (Nov 2, 2010). "Origin and history of convolution". 41 pgs. <a class="uri" href="http://www.slideshare.net/Alexdfar/origin-adn-history-of-convolution">http://www.slideshare.net/Alexdfar/origin-adn-history-of-convolution</a>. Cranfield, Bedford MK43 OAL, UK. Retrieved Mar 13, 2013.</li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://jeff560.tripod.com/c.html">Earliest Uses: The entry on Convolution has some historical information.</a></li>
<li><a href="http://rkb.home.cern.ch/rkb/AN16pp/node38.html#SECTION000380000000000000000">Convolution</a>, on <a href="http://rkb.home.cern.ch/rkb/titleA.html">The Data Analysis BriefBook</a></li>
<li><a class="uri" href="http://www.jhu.edu/~signals/convolve/index.html">http://www.jhu.edu/~signals/convolve/index.html</a> Visual convolution Java Applet</li>
<li><a class="uri" href="http://www.jhu.edu/~signals/discreteconv2/index.html">http://www.jhu.edu/~signals/discreteconv2/index.html</a> Visual convolution Java Applet for discrete-time functions</li>
<li><a href="http://www.archive.org/details/Lectures_on_Image_Processing">Lectures on Image Processing: A collection of 18 lectures in pdf format from Vanderbilt University. Lecture 7 is on 2-D convolution.</a>, by Alan Peters
<ul>
<li><a class="uri" href="http://archive.org/details/Lectures_on_Image_Processing">http://archive.org/details/Lectures_on_Image_Processing</a></li>
</ul></li>
<li><a href="http://micro.magnet.fsu.edu/primer/java/digitalimaging/processing/kernelmaskoperation/">Convolution Kernel Mask Operation Interactive tutorial</a></li>
<li><a href="http://mathworld.wolfram.com/Convolution.html">Convolution</a> at <a class="uri" href="MathWorld" title="wikilink">MathWorld</a></li>
<li><a href="http://www.nongnu.org/freeverb3/">Freeverb3 Impulse Response Processor</a>: Opensource zero latency impulse response processor with VST plugins</li>
<li>Stanford University CS 178 <a href="http://graphics.stanford.edu/courses/cs178/applets/convolution.html">interactive Flash demo</a> showing how spatial convolution works.</li>
<li><a href="http://www.youtube.com/watch?v=IW4Reburjpc">A video lecture on the subject of convolution</a> given by <a href="Salman_Khan_(educator)" title="wikilink">Salman Khan</a></li>
<li><a href="http://www.onmyphd.com/?p=convolution">A Javascript interactive plot of the convolution with several functions</a></li>
</ul>

<p>"</p>

<p><a href="Category:Functional_analysis" title="wikilink">Category:Functional analysis</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Binary_operations" title="wikilink">Category:Binary operations</a> <a href="Category:Fourier_analysis" title="wikilink">Category:Fourier analysis</a> <a href="Category:Bilinear_operators" title="wikilink">Category:Bilinear operators</a> <a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Dominguez-Torres, p 2<a href="#fnref1">↩</a></li>
<li id="fn2">Dominguez-Torres, p 4<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">According to [Lothar von Wolfersdorf (2000), "Einige Klassen quadratischer Integralgleichungen", <em>Sitzungsberichte der Sächsischen Akademie der Wissenschaften zu Leipzig</em>, <em>Mathematisch-naturwissenschaftliche Klasse</em>, volume <strong>128</strong>, number 2, 6–7], the source is Volterra, Vito (1913), "Leçons sur les fonctions de linges". Gauthier-Villars, Paris 1913.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="William_Beckner_(mathematician)" title="wikilink">Beckner, William</a> (1975), "Inequalities in Fourier analysis", Ann. of Math. (2) <strong>102</strong>: 159–182. Independently, Brascamp, Herm J. and <a href="Elliott_H._Lieb" title="wikilink">Lieb, Elliott H.</a> (1976), "Best constants in Young's inequality, its converse, and its generalization to more than three functions", Advances in Math. <strong>20</strong>: 151–173. See <a href="Brascamp–Lieb_inequality" title="wikilink">Brascamp–Lieb inequality</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">Zölzer, Udo, ed. (2002). <em>DAFX:Digital Audio Effects</em>, p.48–49. ISBN 0471490784.<a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
