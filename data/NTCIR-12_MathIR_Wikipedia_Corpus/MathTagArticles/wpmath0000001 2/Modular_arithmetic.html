<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="673">Modular arithmetic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modular arithmetic</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Time-keeping on this clock uses arithmetic modulo 12.</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>modular arithmetic</strong> is a system of <a class="uri" href="arithmetic" title="wikilink">arithmetic</a> for <a href="integer" title="wikilink">integers</a>, where numbers "wrap around" upon reaching a certain value—the <strong>modulus</strong>. The modern approach to modular arithmetic was developed by <a href="Carl_Friedrich_Gauss" title="wikilink">Carl Friedrich Gauss</a> in his book <em><a href="Disquisitiones_Arithmeticae" title="wikilink">Disquisitiones Arithmeticae</a></em>, published in 1801.</p>

<p>A familiar use of modular arithmetic is in the <a href="12-hour_clock" title="wikilink">12-hour clock</a>, in which the day is divided into two 12-hour periods. If the time is 7:00 now, then 8 hours later it will be 3:00. Usual addition would suggest that the later time should be 7 + 8 = 15, but this is not the answer because clock time "wraps around" every 12 hours; in 12-hour time, there is no "15 o'clock". Likewise, if the clock starts at 12:00 (noon) and 21 hours elapse, then the time will be 9:00 the next day, rather than 33:00. Because the hour number starts over after it reaches 12, this is arithmetic <em>modulo</em> 12. According to the definition below, 12 is <a href="congruence_relation" title="wikilink">congruent</a> not only to 12 itself, but also to 0, so the time called "12:00" could also be called "0:00", since 12 is congruent to 0 modulo 12.</p>
<h2 id="history">History</h2>

<p>The foundations of modular arithmetic were introduced in the third century BCE, by <a class="uri" href="Euclid" title="wikilink">Euclid</a>, in the 7th book of his <a href="Euclid's_Elements" title="wikilink"><em>Elements</em></a>.</p>
<h2 id="congruence-relation">Congruence relation</h2>

<p>Modular arithmetic can be handled mathematically by introducing a <a href="congruence_relation" title="wikilink">congruence relation</a> on the <a href="integer" title="wikilink">integers</a> that is compatible with the operations on integers: <a class="uri" href="addition" title="wikilink">addition</a>, <a class="uri" href="subtraction" title="wikilink">subtraction</a>, and <a class="uri" href="multiplication" title="wikilink">multiplication</a>. For a positive integer <em>n</em>, two integers <em>a</em> and <em>b</em> are said to be <strong>congruent</strong> <strong>modulo</strong> <em>n</em>, written:</p>

<p>

<math display="block" id="Modular_arithmetic:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>≡</mo>
    <mrow>
     <mi>b</mi>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>a</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>b</ci>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\equiv b\;\;(\mathop{{\rm mod}}n),\,
  </annotation>
 </semantics>
</math>

</p>

<p>if their difference <em>a</em> − <em>b</em> is an integer <a href="multiple_(mathematics)" title="wikilink">multiple</a> of <em>n</em> (or <em>n</em> divides <em>a</em> − <em>b</em>). The number <em>n</em> is called the <strong>modulus</strong> of the congruence.</p>

<p>For example,</p>

<p>

<math display="block" id="Modular_arithmetic:1">
 <semantics>
  <mrow>
   <mn>38</mn>
   <mo>≡</mo>
   <mrow>
    <mn>14</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mpadded width="+1.7pt">
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>12</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <cn type="integer">38</cn>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">14</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">12</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   38\equiv 14\;\;(\mathop{{\rm mod}}12)\,
  </annotation>
 </semantics>
</math>

</p>

<p>because 38 − 14 = 24, which is a multiple of 12.</p>

<p>The same rule holds for negative values:</p>

<p>

<math display="inline" id="Modular_arithmetic:2">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle-8
  </annotation>
 </semantics>
</math>


</p>

<p>Equivalently, 

<math display="inline" id="Modular_arithmetic:3">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≡</mo>
   <mrow>
    <mi>b</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mpadded width="+1.7pt">
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>a</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>b</ci>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\equiv b\;\;(\mathop{{\rm mod}}n)\,
  </annotation>
 </semantics>
</math>

 can also be thought of as asserting that the <a href="remainder" title="wikilink">remainders</a> of the <a href="Euclidean_division" title="wikilink">division</a> of both 

<math display="inline" id="Modular_arithmetic:4">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modular_arithmetic:5">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Modular_arithmetic:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 are the same. For instance:</p>

<p>

<math display="block" id="Modular_arithmetic:7">
 <semantics>
  <mrow>
   <mn>38</mn>
   <mo>≡</mo>
   <mrow>
    <mn>14</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mpadded width="+1.7pt">
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>12</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <cn type="integer">38</cn>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">14</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">12</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   38\equiv 14\;\;(\mathop{{\rm mod}}12)\,
  </annotation>
 </semantics>
</math>

</p>

<p>because both 38 and 14 have the same remainder 2 when divided by 12. It is also the case that 

<math display="inline" id="Modular_arithmetic:8">
 <semantics>
  <mrow>
   <mrow>
    <mn>38</mn>
    <mo>-</mo>
    <mn>14</mn>
   </mrow>
   <mo>=</mo>
   <mn>24</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <cn type="integer">38</cn>
     <cn type="integer">14</cn>
    </apply>
    <cn type="integer">24</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   38-14=24
  </annotation>
 </semantics>
</math>

 is an integer multiple of 12, which agrees with the prior definition of the congruence relation.</p>

<p>A remark on the notation: Because it is common to consider several congruence relations for different moduli at the same time, the modulus is incorporated in the notation. In spite of the ternary notation, the congruence relation for a given modulus is <a href="binary_relation" title="wikilink">binary</a>. This would have been clearer if the notation <em>a</em> <sub><em>n</em></sub> <em>b</em> had been used, instead of the common traditional notation.</p>

<p>The properties that make this relation a congruence relation (respecting addition, subtraction, and multiplication) are the following.</p>

<p>If</p>

<p>

<math display="block" id="Modular_arithmetic:9">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>≡</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}\equiv b_{1}\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Modular_arithmetic:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>≡</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{2}\equiv b_{2}\;\;(\mathop{{\rm mod}}n),
  </annotation>
 </semantics>
</math>

</p>

<p>then:</p>
<ul>
<li>

<math display="inline" id="Modular_arithmetic:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mpadded width="+1.7pt">
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}+a_{2}\equiv b_{1}+b_{2}\;\;(\mathop{{\rm mod}}n)\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Modular_arithmetic:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mpadded width="+1.7pt">
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}-a_{2}\equiv b_{1}-b_{2}\;\;(\mathop{{\rm mod}}n)\,
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The above two properties would still hold if the theory were expanded to include all <a href="real_numbers" title="wikilink">real numbers</a>, that is if 

<math display="inline" id="Modular_arithmetic:13">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},a_{2},b_{1},b_{2},n\,
  </annotation>
 </semantics>
</math>

 were not necessarily all integers. The next property, however, would fail if these variables were not all integers:</p>
<ul>
<li>

<math display="inline" id="Modular_arithmetic:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}a_{2}\equiv b_{1}b_{2}\;\;(\mathop{{\rm mod}}n).\,
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="remainders">Remainders</h2>

<p>The notion of modular arithmetic is related to that of the <a class="uri" href="remainder" title="wikilink">remainder</a> in <a href="Euclidean_division" title="wikilink">Euclidean division</a>. The operation of finding the remainder is sometimes referred to as the <a href="modulo_operation" title="wikilink">modulo operation</a>, and denoted with "mod" used as an <a href="infix_notation" title="wikilink">infix operator</a>. For example, the remainder of the division of 14 by 12 is denoted by 

<math display="inline" id="Modular_arithmetic:15">
 <semantics>
  <mrow>
   <mn>14</mn>
   <mi>m</mi>
   <mi>o</mi>
   <mi>d</mi>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">14</cn>
    <ci>m</ci>
    <ci>o</ci>
    <ci>d</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   14mod12
  </annotation>
 </semantics>
</math>

; as this remainder is 2, we have 

<math display="inline" id="Modular_arithmetic:16">
 <semantics>
  <mrow>
   <mrow>
    <mn>14</mn>
    <mi>m</mi>
    <mi>o</mi>
    <mi>d</mi>
    <mn>12</mn>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">14</cn>
     <ci>m</ci>
     <ci>o</ci>
     <ci>d</ci>
     <cn type="integer">12</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   14mod12=2
  </annotation>
 </semantics>
</math>

.</p>

<p>The congruence, indicated by "≡" followed by "mod" between parentheses, means that the operator "mod", applied to both members, gives the same result. That is</p>

<p>

<math display="block" id="Modular_arithmetic:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≡</mo>
   <mrow>
    <mi>B</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>B</ci>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\equiv B\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

 is equivalent to</p>

<p>

<math display="block" id="Modular_arithmetic:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="-6.8pt">
      <mi>A</mi>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="-6.8pt">
      <mi>B</mi>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\!\!\!\!\mod n=B\!\!\!\!\mod n.
  </annotation>
 </semantics>
</math>

</p>

<p>The fundamental property of multiplication in modular arithmetic may thus be written</p>

<p>

<math display="block" id="Modular_arithmetic:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="-6.8pt">
        <mi>a</mi>
       </mpadded>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mi>n</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="-6.8pt">
        <mi>b</mi>
       </mpadded>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a\!\!\!\!\mod n)\,(b\!\!\!\!\mod n)\equiv ab\;\;(\mathop{{\rm mod}}n),
  </annotation>
 </semantics>
</math>

 or, equivalently,</p>

<p>

<math display="block" id="Modular_arithmetic:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mpadded width="-6.8pt">
          <mi>a</mi>
         </mpadded>
         <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
         <mi>n</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mpadded width="-6.8pt">
          <mi>b</mi>
         </mpadded>
         <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="0pt" stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo rspace="0pt" stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((a\!\!\!\!\mod n)\,(b\!\!\!\!\mod n))\!\!\!\!\mod n=(ab)\!\!\!\!\mod n.
  </annotation>
 </semantics>
</math>

</p>

<p>In <a href="computer_science" title="wikilink">computer science</a>, it is the remainder operator that is usually indicated by either "%" (e.g. in <a href="C_(programming_language)" title="wikilink">C</a>, <a href="C++_(programming_language)" title="wikilink">C++</a>, <a href="Java_(programming_language)" title="wikilink">Java</a>, <a class="uri" href="JavaScript" title="wikilink">JavaScript</a>, <a class="uri" href="Perl" title="wikilink">Perl</a> and <a href="Python_(programming_language)" title="wikilink">Python</a>) or "mod" (e.g. in <a href="Pascal_(programming_language)" title="wikilink">Pascal</a>, <a class="uri" href="BASIC" title="wikilink">BASIC</a>, <a class="uri" href="SQL" title="wikilink">SQL</a>, <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, <a class="uri" href="ABAP" title="wikilink">ABAP</a>), with exceptions (e.g. Excel). These operators are commonly pronounced as "mod", but it is specifically a remainder that is computed (since in C++ a negative number will be returned if the first argument is negative, and in Python a negative number will be returned if the second argument is negative). The function <em>modulo</em> instead of <em>mod</em>, like 38 ≡ 14 (modulo 12) is sometimes used to indicate the common residue rather than a remainder (e.g. in <a href="Ruby_(programming_language)" title="wikilink">Ruby</a>). For details of the specific operations defined in different languages, see the <a href="modulo_operation" title="wikilink">modulo operation</a> page.</p>
<h2 id="residue-systems">Residue systems</h2>

<p>Each residue class modulo <em>n</em> may be represented by any one of its members, although we usually represent each residue class by the smallest nonnegative integer which belongs to that class (since this is the proper remainder which results from division). Any two members of different residue classes modulo <em>n</em> are incongruent modulo <em>n</em>. Furthermore, every integer belongs to one and only one residue class modulo <em>n</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The set of integers {0, 1, 2, ..., <em>n</em>−1} is called the <strong>least residue system modulo</strong> <strong><em>n</em></strong>. Any set of <em>n</em> integers, no two of which are congruent modulo <em>n</em>, is called a <strong>complete residue system modulo</strong> <strong><em>n</em></strong>.</p>

<p>It is clear that the least residue system is a complete residue system, and that a complete residue system is simply a set containing precisely one representative of each residue class modulo <em>n</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The least residue system modulo 4 is {0, 1, 2, 3}. Some other complete residue systems modulo 4 are:</p>
<ul>
<li>{1, 2, 3, 4}</li>
<li>{13, 14, 15, 16}</li>
<li>{−2, −1 ,0, 1}</li>
<li>{−13, 4, 17, 18}</li>
<li>{−5, 0, 6, 21}</li>
<li>{27, 32, 37, 42}</li>
</ul>

<p>Some sets which are <em>not</em> complete residue systems modulo 4 are:</p>
<ul>
<li>{−5, 0, 6, 22} since 6 is congruent to 22 modulo 4.</li>
<li>{5, 15} since a complete residue system modulo 4 must have exactly 4 incongruent residue classes.</li>
</ul>
<h3 id="reduced-residue-systems">Reduced residue systems</h3>

<p>Any set of φ(<em>n</em>) integers that are relatively prime to <em>n</em> and that are mutually incongruent modulo <em>n</em>, where φ(<em>n</em>) denotes <a href="Euler's_totient_function" title="wikilink">Euler's totient function</a>, is called a <strong>reduced residue system modulo <em>n</em></strong>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The example above, {5,15} is an example of a reduced residue system modulo 4.</p>
<h2 id="congruence-classes">Congruence classes </h2>

<p>Like any congruence relation, congruence modulo <em>n</em> is an <a href="equivalence_relation" title="wikilink">equivalence relation</a>, and the <a href="equivalence_class" title="wikilink">equivalence class</a> of the integer <em>a</em>, denoted by 

<math display="inline" id="Modular_arithmetic:21">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>a</mi>
    <mo>¯</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}_{n}
  </annotation>
 </semantics>
</math>

, is the set 

<math display="inline" id="Modular_arithmetic:22">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>a</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\ldots,a-2n,a-n,a,a+n,a+2n,\ldots\right\}
  </annotation>
 </semantics>
</math>

. This set, consisting of the integers congruent to <em>a</em> modulo <em>n</em>, is called the <strong>congruence class</strong> or <strong>residue class</strong> or simply <strong>residue</strong> of the integer <em>a</em>, modulo <em>n</em>. When the modulus <em>n</em> is known from the context, that <strong>residue</strong> may also be denoted 

<math display="inline" id="Modular_arithmetic:23">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>a</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle[a]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="integers-modulo-n">Integers modulo <em>n</em></h2>

<p>The set of all <a href="Modular_arithmetic#Congruence_classes" title="wikilink">congruence classes</a> of the integers for a modulus <em>n</em> is called the set of <strong>integers modulo <em>n</em></strong>, and is denoted 

<math display="inline" id="Modular_arithmetic:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Modular_arithmetic:25">
 <semantics>
  <mrow>
   <mi>ℤ</mi>
   <mo>/</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>ℤ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Modular_arithmetic:26">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{n}
  </annotation>
 </semantics>
</math>

. The notation 

<math display="inline" id="Modular_arithmetic:27">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{n}
  </annotation>
 </semantics>
</math>

 is, however, not recommended because it can be confused with the set of <a href="P-adic#Algebraic_approach" title="wikilink"><em>n</em>-adic integers</a>. The set is defined as follows.</p>

<p>

<math display="block" id="Modular_arithmetic:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <msub>
      <mover accent="true">
       <mi>a</mi>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>ℤ</mi>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <in></in>
      <ci>a</ci>
      <ci>ℤ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}=\left\{\overline{a}_{n}|a\in\mathbb{Z}\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>When <em>n</em> ≠ 0, 

<math display="inline" id="Modular_arithmetic:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 has <em>n</em> elements, and can be written as:</p>

<p>

<math display="block" id="Modular_arithmetic:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <msub>
      <mover accent="true">
       <mn>0</mn>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mn>1</mn>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mn>2</mn>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}=\left\{\overline{0}_{n},\overline{1}_{n},\overline{2}_{%
n},\ldots,\overline{n-1}_{n}\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>When <em>n</em> = 0, 

<math display="inline" id="Modular_arithmetic:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 does not have zero elements; rather, it is <a href="isomorphism" title="wikilink">isomorphic</a> to 

<math display="inline" id="Modular_arithmetic:32">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Modular_arithmetic:33">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>a</mi>
     <mo>¯</mo>
    </mover>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>a</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <set>
     <ci>a</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}_{0}=\left\{a\right\}
  </annotation>
 </semantics>
</math>

.</p>

<p>We can define addition, subtraction, and multiplication on 

<math display="inline" id="Modular_arithmetic:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 by the following rules:</p>
<ul>
<li>

<math display="inline" id="Modular_arithmetic:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>a</mi>
      <mo>¯</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>b</mi>
      <mo>¯</mo>
     </mover>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>¯</mo>
    </mover>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}_{n}+\overline{b}_{n}=\overline{(a+b)}_{n}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Modular_arithmetic:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>a</mi>
      <mo>¯</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>b</mi>
      <mo>¯</mo>
     </mover>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>¯</mo>
    </mover>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <minus></minus>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}_{n}-\overline{b}_{n}=\overline{(a-b)}_{n}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Modular_arithmetic:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>a</mi>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <msub>
      <mover accent="true">
       <mi>b</mi>
       <mo>¯</mo>
      </mover>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mover accent="true">
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>¯</mo>
     </mover>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}_{n}\overline{b}_{n}=\overline{(ab)}_{n}.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The verification that this is a proper definition uses the properties given before.</p>

<p>In this way, 

<math display="inline" id="Modular_arithmetic:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 becomes a <a href="commutative_ring" title="wikilink">commutative ring</a>. For example, in the ring 

<math display="inline" id="Modular_arithmetic:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mn>24</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <cn type="integer">24</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/24\mathbb{Z}
  </annotation>
 </semantics>
</math>

, we have</p>

<p>

<math display="block" id="Modular_arithmetic:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mn>12</mn>
      <mo>¯</mo>
     </mover>
     <mn>24</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mn>21</mn>
      <mo>¯</mo>
     </mover>
     <mn>24</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mn>9</mn>
     <mo>¯</mo>
    </mover>
    <mn>24</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <cn type="integer">12</cn>
      </apply>
      <cn type="integer">24</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <cn type="integer">21</cn>
      </apply>
      <cn type="integer">24</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">9</cn>
     </apply>
     <cn type="integer">24</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{12}_{24}+\overline{21}_{24}=\overline{9}_{24}
  </annotation>
 </semantics>
</math>

 as in the arithmetic for the 24-hour clock.</p>

<p>The notation 

<math display="inline" id="Modular_arithmetic:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 is used, because it is the <a href="factor_ring" title="wikilink">factor ring</a> of 

<math display="inline" id="Modular_arithmetic:42">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 by the <a href="ring_ideal" title="wikilink">ideal</a> 

<math display="inline" id="Modular_arithmetic:43">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 containing all integers divisible by <em>n</em>, where 

<math display="inline" id="Modular_arithmetic:44">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">0</cn>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\mathbb{Z}
  </annotation>
 </semantics>
</math>

 is the <a href="singleton_set" title="wikilink">singleton set</a> 

<math display="inline" id="Modular_arithmetic:45">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mn>0</mn>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{0\right\}
  </annotation>
 </semantics>
</math>

. Thus 

<math display="inline" id="Modular_arithmetic:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 is a <a href="field_(mathematics)" title="wikilink">field</a> when 

<math display="inline" id="Modular_arithmetic:47">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 is a <a href="maximal_ideal" title="wikilink">maximal ideal</a>, that is, when 

<math display="inline" id="Modular_arithmetic:48">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is prime.</p>

<p>In terms of groups, the residue class 

<math display="inline" id="Modular_arithmetic:49">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>a</mi>
    <mo>¯</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}_{n}
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="coset" title="wikilink">coset</a> of <em>a</em> in the <a href="quotient_group" title="wikilink">quotient group</a> 

<math display="inline" id="Modular_arithmetic:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

, a <a href="cyclic_group" title="wikilink">cyclic group</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The set 

<math display="inline" id="Modular_arithmetic:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 has a number of important mathematical properties that are foundational to various branches of mathematics.</p>

<p>Rather than excluding the special case <em>n</em> = 0, it is more useful to include 

<math display="inline" id="Modular_arithmetic:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mn>0</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/0\mathbb{Z}
  </annotation>
 </semantics>
</math>

 (which, as mentioned before, is isomorphic to the ring 

<math display="inline" id="Modular_arithmetic:53">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 of integers), for example when discussing the <a href="characteristic_(algebra)" title="wikilink">characteristic</a> of a <a href="ring_(mathematics)" title="wikilink">ring</a>.</p>

<p>The ring of integers modulo <em>n</em> is a <a href="finite_field" title="wikilink">finite field</a> if and only if <em>n</em> is <a class="uri" href="prime" title="wikilink">prime</a>. If <em>n</em> is a non-prime <a href="prime_power" title="wikilink">prime power</a>, there exists a unique (up to isomorphism) finite field GF(<em>n</em>) with <em>n</em> elements, which must not be confused with the ring of integers modulo <em>n</em>, although they have the same number of elements.</p>
<h2 id="applications">Applications</h2>

<p>Modular arithmetic is referenced in <a href="number_theory" title="wikilink">number theory</a>, <a href="group_theory" title="wikilink">group theory</a>, <a href="ring_theory" title="wikilink">ring theory</a>, <a href="knot_theory" title="wikilink">knot theory</a>, <a href="abstract_algebra" title="wikilink">abstract algebra</a>, <a href="computer_algebra" title="wikilink">computer algebra</a>, <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <a href="computer_science" title="wikilink">computer science</a>, <a class="uri" href="chemistry" title="wikilink">chemistry</a> and the <a href="visual_arts" title="wikilink">visual</a> and <a href="music" title="wikilink">musical</a> arts.</p>

<p>It is one of the foundations of number theory, touching on almost every aspect of its study, and provides key examples for group theory, ring theory and abstract algebra.</p>

<p>Modular arithmetic is often used to calculate checksums that are used within identifiers. <a href="International_Bank_Account_Number" title="wikilink">International Bank Account Numbers</a> (IBANs), for example, make use of modulo 97 arithmetic to trap user input errors in bank account numbers.</p>

<p>In cryptography, modular arithmetic directly underpins <a href="public-key_cryptography" title="wikilink">public key</a> systems such as <a href="RSA_(algorithm)" title="wikilink">RSA</a> and <a href="Diffie-Hellman_key_exchange" title="wikilink">Diffie-Hellman</a>, as well as providing <a href="finite_field" title="wikilink">finite fields</a> which underlie <a href="elliptic_curve" title="wikilink">elliptic curves</a>, and is used in a variety of <a href="symmetric_key_algorithm" title="wikilink">symmetric key algorithms</a> including <a href="Advanced_Encryption_Standard" title="wikilink">AES</a>, <a href="International_Data_Encryption_Algorithm" title="wikilink">IDEA</a>, and <a class="uri" href="RC4" title="wikilink">RC4</a>.</p>

<p>In computer algebra, modular arithmetic is commonly used to limit the size of integer coefficients in intermediate calculations and data. It is used in <a href="polynomial_factorization" title="wikilink">polynomial factorization</a>, a problem for which all known efficient algorithms use modular arithmetic. It is used by the most efficient implementations of <a href="polynomial_greatest_common_divisor" title="wikilink">polynomial greatest common divisor</a>, exact <a href="linear_algebra" title="wikilink">linear algebra</a> and <a href="Gröbner_basis" title="wikilink">Gröbner basis</a> algorithms over the integers and the rational numbers.</p>

<p>In computer science, modular arithmetic is often applied in <a href="bitwise_operation" title="wikilink">bitwise operations</a> and other operations involving fixed-width, cyclic <a href="data_structure" title="wikilink">data structures</a>. The <a href="modulo_operation" title="wikilink">modulo operation</a>, as implemented in many <a href="programming_language" title="wikilink">programming languages</a> and <a href="calculator" title="wikilink">calculators</a>, is an application of modular arithmetic that is often used in this context. <a class="uri" href="XOR" title="wikilink">XOR</a> is the sum of 2 bits, modulo 2.</p>

<p>In chemistry, the last digit of the <a href="CAS_registry_number" title="wikilink">CAS registry number</a> (a number which is unique for each chemical compound) is a <a href="check_digit" title="wikilink">check digit</a>, which is calculated by taking the last digit of the first two parts of the <a href="CAS_registry_number" title="wikilink">CAS registry number</a> times 1, the previous digit times 2, the previous digit times 3 etc., adding all these up and computing the sum modulo 10.</p>

<p>In music, arithmetic modulo 12 is used in the consideration of the system of <a href="twelve-tone_equal_temperament" title="wikilink">twelve-tone equal temperament</a>, where <a class="uri" href="octave" title="wikilink">octave</a> and <a class="uri" href="enharmonic" title="wikilink">enharmonic</a> equivalency occurs (that is, pitches in a 1∶2 or 2∶1 ratio are equivalent, and C-<a href="Sharp_(music)" title="wikilink">sharp</a> is considered the same as D-<a href="Flat_(music)" title="wikilink">flat</a>).</p>

<p>The method of <a href="casting_out_nines" title="wikilink">casting out nines</a> offers a quick check of decimal arithmetic computations performed by hand. It is based on modular arithmetic modulo 9, and specifically on the crucial property that 10 ≡ 1 (mod 9).</p>

<p>Arithmetic modulo 7 is used in algorithms that determine the day of the week for a given date. In particular, <a href="Zeller's_congruence" title="wikilink">Zeller's congruence</a> and the <a href="doomsday_algorithm" title="wikilink">doomsday algorithm</a> make heavy use of modulo-7 arithmetic.</p>

<p>More generally, modular arithmetic also has application in disciplines such as <a class="uri" href="law" title="wikilink">law</a> (see e.g., <a class="uri" href="apportionment" title="wikilink">apportionment</a>), <a class="uri" href="economics" title="wikilink">economics</a>, (see e.g., <a href="game_theory" title="wikilink">game theory</a>) and other areas of the <a href="social_sciences" title="wikilink">social sciences</a>, where <a href="Proportional_(fair_division)" title="wikilink">proportional</a> division and allocation of resources plays a central part of the analysis.</p>
<h2 id="computational-complexity">Computational complexity</h2>

<p>Since modular arithmetic has such a wide range of applications, it is important to know how hard it is to solve a system of congruences. A linear system of congruences can be solved in <a href="polynomial_time" title="wikilink">polynomial time</a> with a form of <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, for details see <a href="linear_congruence_theorem" title="wikilink">linear congruence theorem</a>. Algorithms, such as <a href="Montgomery_reduction" title="wikilink">Montgomery reduction</a>, also exist to allow simple arithmetic operations, such as multiplication and <a href="Modular_exponentiation" title="wikilink">exponentiation modulo <em>n</em></a>, to be performed efficiently on large numbers.</p>

<p>Solving a system of non-linear modular arithmetic equations is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="example-implementations">Example implementations</h2>

<p>Below are two reasonably fast C functions for performing modular multiplication on unsigned integers not larger than 63 bits, without overflow of the transient operations. An algorithmic way to compute a * b (mod m):</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint64_t</span> mul_mod(<span class="dt">uint64_t</span> a, <span class="dt">uint64_t</span> b, <span class="dt">uint64_t</span> m)
{
   <span class="dt">uint64_t</span> d = <span class="dv">0</span>, mp2 = m &gt;&gt; <span class="dv">1</span>;
   <span class="dt">int</span> i;
   <span class="kw">if</span> (a &gt;= m) a %= m;
   <span class="kw">if</span> (b &gt;= m) b %= m;
   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">64</span>; ++i)
   {
       d = (d &gt;= mp2) ? (d &lt;&lt; <span class="dv">1</span>) - m : d &lt;&lt; <span class="dv">1</span>;
       <span class="kw">if</span> (a &amp; 0x8000000000000000ULL)
           d += b;
       <span class="kw">if</span> (d &gt; m) d -= m;
       a &lt;&lt;= <span class="dv">1</span>;
   }
   <span class="kw">return</span> d;
}</code></pre></div>

<p>On computer architectures where an <a href="Extended_precision#x86_Extended_Precision_Format" title="wikilink">extended precision</a> format with at least 64 bits of mantissa is available (such as the <a href="long_double" title="wikilink">long double</a> type of most x86 C compilers), the following routine is faster than any algorithmic solution, by employing the trick that, by hardware, <a class="uri" href="floating-point" title="wikilink">floating-point</a> multiplication results in the most significant bits of the product kept, while integer multiplication results in the least significant bits kept:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint64_t</span> mul_mod(<span class="dt">uint64_t</span> a, <span class="dt">uint64_t</span> b, <span class="dt">uint64_t</span> m)
{
   <span class="dt">long</span> <span class="dt">double</span> x;
   <span class="dt">uint64_t</span> c;
   <span class="dt">int64_t</span> r;
   <span class="kw">if</span> (a &gt;= m) a %= m;
   <span class="kw">if</span> (b &gt;= m) b %= m;
   x = a;
   c = x * b / m;
   r = (<span class="dt">int64_t</span>)(a * b - c * m) % (<span class="dt">int64_t</span>)m;
   <span class="kw">return</span> r &lt; <span class="dv">0</span> ? r + m : r;
}</code></pre></div>

<p>However, for both routines to work, m <strong>must not exceed</strong> 63 bits.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Boolean_ring" title="wikilink">Boolean ring</a></li>
<li><a href="Circular_buffer" title="wikilink">Circular buffer</a> circular math memory addressing</li>
<li><a href="Congruence_relation" title="wikilink">Congruence relation</a></li>
<li><a href="Division_(mathematics)" title="wikilink">Division</a></li>
<li><a href="Finite_field" title="wikilink">Finite field</a></li>
<li><a href="Legendre_symbol" title="wikilink">Legendre symbol</a></li>
<li><a href="Modular_exponentiation" title="wikilink">Modular exponentiation</a></li>
<li><a href="Modular_multiplicative_inverse" title="wikilink">Modular multiplicative inverse</a></li>
<li><a href="Modulo_operation" title="wikilink">Modulo operation</a></li>
<li><a href="Number_theory" title="wikilink">Number theory</a></li>
<li><a href="Pisano_period" title="wikilink">Pisano period</a> (Fibonacci sequences modulo <em>n</em>)</li>
<li><a href="Primitive_root_modulo_n" title="wikilink">Primitive root</a></li>
<li><a href="Quadratic_reciprocity" title="wikilink">Quadratic reciprocity</a></li>
<li><a href="Quadratic_residue" title="wikilink">Quadratic residue</a></li>
<li><a href="Rational_reconstruction_(mathematics)" title="wikilink">Rational reconstruction (mathematics)</a></li>
<li><a href="Reduced_residue_system" title="wikilink">Reduced residue system</a></li>
<li><a href="Serial_number_arithmetic" title="wikilink">Serial number arithmetic</a> (a special case of modular arithmetic)</li>
<li><a href="Two-element_Boolean_algebra" title="wikilink">Two-element Boolean algebra</a></li>
<li>Topics relating to the group theory behind modular arithmetic:
<ul>
<li><a href="Cyclic_group" title="wikilink">Cyclic group</a></li>
<li><a href="Multiplicative_group_of_integers_modulo_n" title="wikilink">Multiplicative group of integers modulo n</a></li>
</ul></li>
<li>Other important theorems relating to modular arithmetic:
<ul>
<li><a href="Carmichael_function" title="wikilink">Carmichael's theorem</a></li>
<li><a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a></li>
<li><a href="Euler's_theorem" title="wikilink">Euler's theorem</a></li>
<li><a href="Fermat's_little_theorem" title="wikilink">Fermat's little theorem</a> (a special case of Euler's theorem)</li>
<li><a href="Lagrange's_theorem_(group_theory)" title="wikilink">Lagrange's theorem</a></li>
</ul></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.britannica.com/EBchecked/topic/920687/modular-arithmetic">1</a> Encyclopædia Britannica. Modular Arithmetic.</li>
<li>

<p>. See in particular chapters 5 and 6 for a review of basic modular arithmetic.</p></li>
<li>Maarten Bullynck "<a href="http://www.kuttaka.org/Gauss_Modular.pdf">Modular Arithmetic before C.F. Gauss. Systematisations and discussions on remainder problems in 18th century Germany</a>"</li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 31.3: Modular arithmetic, pp. 862–868.</li>
<li><a href="http://genealogy.math.ndsu.nodak.edu/id.php?id=3545">Anthony Gioia</a>, <em>Number Theory, an Introduction</em> Reprint (2001) Dover. ISBN 0-486-41449-3</li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li>In this <a href="http://britton.disted.camosun.bc.ca/modart/jbmodart.htm">modular art</a> article, one can learn more about applications of modular arithmetic in art.</li>
<li></li>
<li>An <a href="http://mersennewiki.org/index.php/modular_arithmetic">article</a> on modular arithmetic on the GIMPS wiki</li>
<li><a href="http://www.cut-the-knot.org/blue/Modulo.shtml">Modular Arithmetic and patterns in addition and multiplication tables</a></li>
<li><a href="http://wheelof.com/whitney">Whitney Music Box</a>—an audio/video demonstration of integer modular math</li>
</ul>
<h3 id="automated-modular-arithmetic-theorem-provers">Automated modular arithmetic theorem provers</h3>
<ul>
<li><a href="http://www.domagoj-babic.com/index.php/ResearchProjects/Spear">Spear</a></li>
<li><a href="http://www.lenherr.name/~thomas/ma/aaprover.page">AAProver</a> - Simple C++ framework easy to use in applications, supporting (among others) all integer operators present in languages such as C/C++/Java and arbitrary bit-width.</li>
</ul>

<p>"</p>

<p><a href="Category:Modular_arithmetic" title="wikilink">*</a> <a href="Category:Finite_rings" title="wikilink">Category:Finite rings</a> <a href="Category:Group_theory" title="wikilink">Category:Group theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Sengadir T., <a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>

