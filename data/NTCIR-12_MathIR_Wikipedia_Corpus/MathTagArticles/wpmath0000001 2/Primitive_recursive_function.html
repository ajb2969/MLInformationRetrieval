<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="842">Primitive recursive function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Primitive recursive function</h1>
<hr/>

<p>In <a href="recursion_theory" title="wikilink">computability theory</a>, <strong>primitive recursive functions</strong> are a class of <a href="function_(mathematics)" title="wikilink">functions</a> that are defined using primitive <a href="Recursion_(computer_science)" title="wikilink">recursion</a> and <a href="function_composition" title="wikilink">composition</a> as central operations and are a strict <a class="uri" href="subset" title="wikilink">subset</a> of the <a href="total_function" title="wikilink">total</a> <a href="µ-recursive_function" title="wikilink">µ-recursive functions</a> (µ-recursive functions are also called <a href="computable_function" title="wikilink">partial recursive</a>). Primitive recursive functions form an important building block on the way to a full formalization of computability. These functions are also important in <a href="proof_theory" title="wikilink">proof theory</a>.</p>

<p>Most of the functions normally studied in <a href="number_theory" title="wikilink">number theory</a> are primitive recursive. For example: <a class="uri" href="addition" title="wikilink">addition</a>, <a href="division_(mathematics)" title="wikilink">division</a>, <a class="uri" href="factorial" title="wikilink">factorial</a>, <a href="exponential_function" title="wikilink">exponential</a> and the <em>n</em>th prime are all primitive recursive. So are many approximations to real-valued functions.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In fact, it is difficult to devise a total recursive function that is <em>not</em> primitive recursive, although some are known (see the section on <a href="Primitive_recursive_function#Limitations" title="wikilink">Limitations</a> below). The set of primitive recursive functions is known as <a href="PR_(complexity)" title="wikilink">PR</a> in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>.</p>
<h2 id="definition">Definition</h2>

<p>The primitive recursive functions are among the number-theoretic functions, which are functions from the <a href="natural_number" title="wikilink">natural numbers</a> (nonnegative integers) {0, 1, 2, ...} to the natural numbers. These functions take <em>n</em> arguments for some natural number <em>n</em> and are called <em>n</em>-<a href="arity" title="wikilink">ary</a>.</p>

<p>The basic primitive recursive functions are given by these <a href="axiom" title="wikilink">axioms</a>:</p>
<ol>
<li><strong>Constant function</strong>: The 0-ary <a href="constant_term" title="wikilink">constant function</a> 0 is primitive recursive.</li>
<li><strong>Successor function</strong>: The 1-ary successor function <em>S</em>, which returns the successor of its argument (see <a href="Peano_postulates" title="wikilink">Peano postulates</a>), is primitive recursive. That is, <em>S</em>(<em>k</em>) = <em>k</em> + 1.</li>
<li><strong>Projection function</strong>: For every <em>n</em>≥1 and each <em>i</em> with 1≤<em>i</em>≤<em>n</em>, the <em>n</em>-ary projection function <em>P</em><sub><em>i</em></sub><sup><em>n</em></sup>, which returns its <em>i</em>-th argument, is primitive recursive.</li>
</ol>

<p>More complex primitive recursive functions can be obtained by applying the <a href="operation_(mathematics)" title="wikilink">operations</a> given by these axioms:</p>
<ol>
<li><strong>Composition</strong>: Given <em>f</em>, a <em>k</em>-ary primitive recursive function, and <em>k</em> <em>m</em>-ary primitive recursive functions <em>g</em><sub>1</sub>,...,<em>g</em><sub><em>k</em></sub>, the <a href="Function_composition" title="wikilink">composition</a> of <em>f</em> with <em>g</em><sub>1</sub>,...,<em>g</em><sub><em>k</em></sub>, i.e. the <em>m</em>-ary function 

<math display="inline" id="Primitive_recursive_function:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>m</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>m</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>m</ci>
        </apply>
       </vector>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>m</ci>
        </apply>
       </vector>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{1},\ldots,x_{m})=f(g_{1}(x_{1},\ldots,x_{m}),\ldots,g_{k}(x_{1},\ldots,x_%
{m}))\,
  </annotation>
 </semantics>
</math>

 is primitive recursive.</li>
<li><strong>Primitive recursion</strong>: Given <em>f</em>, a <em>k</em>-ary primitive recursive function, and <em>g</em>, a (<em>k</em>+2)-ary primitive recursive function, the (<em>k</em>+1)-ary function <em>h</em> is defined as the primitive recursion of <em>f</em> and <em>g</em>, i.e. the function <em>h</em> is primitive recursive when

<p>

<math display="block" id="Primitive_recursive_function:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <vector>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(0,x_{1},\ldots,x_{k})=f(x_{1},\ldots,x_{k})\,
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Primitive_recursive_function:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <vector>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>h</ci>
       <vector>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(S(y),x_{1},\ldots,x_{k})=g(y,h(y,x_{1},\ldots,x_{k}),x_{1},\ldots,x_{k})\,.
  </annotation>
 </semantics>
</math>

</p></li>
</ol>

<p>The <strong>primitive recursive</strong> functions are the basic functions and those obtained from the basic functions by applying these operations a finite number of times.</p>
<h3 id="role-of-the-projection-functions">Role of the projection functions</h3>

<p>The projection functions can be used to avoid the apparent rigidity in terms of the <a class="uri" href="arity" title="wikilink">arity</a> of the functions above; by using compositions with various projection functions, it is possible to pass a subset of the arguments of one function to another function. For example, if <em>g</em> and <em>h</em> are 2-ary primitive recursive functions then</p>

<p>

<math display="block" id="Primitive_recursive_function:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>h</ci>
       <interval closure="open">
        <ci>c</ci>
        <ci>a</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>b</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b,c)=g(h(c,a),h(a,b))\!
  </annotation>
 </semantics>
</math>

 is also primitive recursive. One formal definition using projection functions is</p>

<p>

<math display="block" id="Primitive_recursive_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msubsup>
          <mi>P</mi>
          <mn>3</mn>
          <mn>3</mn>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo>,</mo>
          <mi>b</mi>
          <mo>,</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msubsup>
          <mi>P</mi>
          <mn>1</mn>
          <mn>3</mn>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo>,</mo>
          <mi>b</mi>
          <mo>,</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msubsup>
          <mi>P</mi>
          <mn>1</mn>
          <mn>3</mn>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo>,</mo>
          <mi>b</mi>
          <mo>,</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msubsup>
          <mi>P</mi>
          <mn>2</mn>
          <mn>3</mn>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo>,</mo>
          <mi>b</mi>
          <mo>,</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>h</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>P</ci>
           <cn type="integer">3</cn>
          </apply>
          <cn type="integer">3</cn>
         </apply>
         <vector>
          <ci>a</ci>
          <ci>b</ci>
          <ci>c</ci>
         </vector>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>P</ci>
           <cn type="integer">3</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <vector>
          <ci>a</ci>
          <ci>b</ci>
          <ci>c</ci>
         </vector>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>P</ci>
           <cn type="integer">3</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <vector>
          <ci>a</ci>
          <ci>b</ci>
          <ci>c</ci>
         </vector>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>P</ci>
           <cn type="integer">3</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <vector>
          <ci>a</ci>
          <ci>b</ci>
          <ci>c</ci>
         </vector>
        </apply>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b,c)=g(h(P^{3}_{3}(a,b,c),P^{3}_{1}(a,b,c)),h(P^{3}_{1}(a,b,c),P^{3}_{2}(a%
,b,c))).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="converting-predicates-to-numeric-functions">Converting predicates to numeric functions</h3>

<p>In some settings it is natural to consider primitive recursive functions that take as inputs tuples that mix numbers with <a href="truth_value" title="wikilink">truth values</a> { t= true, f=false }, or that produce truth values as outputs (see Kleene [1952 pp. 226–227]). This can be accomplished by identifying the truth values with numbers in any fixed manner. For example, it is common to identify the truth value <em>t</em> with the number <em>1</em> and the truth value <em>f</em> with the number <em>0</em>. Once this identification has been made, the <a href="indicator_function" title="wikilink">characteristic function</a> of a set <em>A</em>, which literally returns <em>1</em> or <em>0</em>, can be viewed as a predicate that tells whether a number is in the set <em>A</em>. Such an identification of predicates with numeric functions will be assumed for the remainder of this article.</p>
<h3 id="computer-language-definition">Computer language definition</h3>

<p>An example of a primitive recursive programming language is one that contains basic arithmetic operators (e.g. + and −, or ADD and SUBTRACT), conditionals and comparison (IF-THEN, EQUALS, LESS-THAN), and bounded loops, such as the basic <a href="for_loop" title="wikilink">for loop</a>, where there is a known or calculable upper bound to all loops (FOR i FROM 1 to n, with neither i nor n modifiable by the loop body). No control structures of greater generality, such as <a href="while_loop" title="wikilink">while loops</a> or IF-THEN plus <a class="uri" href="GOTO" title="wikilink">GOTO</a>, are admitted in a primitive recursive language. <a href="Douglas_Hofstadter" title="wikilink">Douglas Hofstadter's</a> <a href="BlooP_and_FlooP" title="wikilink">Bloop</a> in <a href="Gödel,_Escher,_Bach" title="wikilink">Gödel, Escher, Bach</a> is one such. Adding unbounded loops (WHILE, GOTO) makes the language partially recursive, or Turing-complete; Floop is such, as are almost all real-world computer languages.</p>

<p>Arbitrary computer programs, or <a href="Turing_machine" title="wikilink">Turing machines</a>, cannot in general be analyzed to see if they halt or not (the <a href="halting_problem" title="wikilink">halting problem</a>). However, all primitive recursive functions halt. This is not a contradiction; primitive recursive programs are a non-arbitrary subset of all possible programs, constructed specifically to be analyzable.</p>
<h2 id="examples">Examples</h2>

<p>Most number-theoretic functions definable using <a href="recursion_(computer_science)" title="wikilink">recursion</a> on a single variable are primitive recursive. Basic examples include the addition and "limited subtraction" functions.</p>
<h3 id="addition">Addition</h3>

<p>Intuitively, addition can be recursively defined with the rules:</p>
<dl>
<dd>add(0,<em>x</em>)=<em>x</em>,
</dd>
<dd>add(<em>n</em>+1,<em>x</em>)=add(<em>n</em>,<em>x</em>)+1.
</dd>
</dl>

<p>To fit this into a strict primitive recursive definition, define:</p>
<dl>
<dd>add(0,<em>x</em>)=<em>P</em><sub>1</sub><sup>1</sup>(<em>x</em>) ,
</dd>
<dd>add(S(<em>n</em>),<em>x</em>)=<em>S</em>(<em>P</em><sub>2</sub><sup>3</sup>(<em>n</em>, add(<em>n</em>,<em>x</em>), <em>x</em>)).
</dd>
</dl>

<p>Here S(<em>n</em>) is "the successor of <em>n</em>" (i.e., <em>n</em>+1), <em>P</em><sub>1</sub><sup>1</sup> is the <a href="identity_function" title="wikilink">identity function</a>, and <em>P</em><sub>2</sub><sup>3</sup> is the <a href="projection_function" title="wikilink">projection function</a> that takes 3 arguments and returns the second one. Functions <em>f</em> and <em>g</em> required by the above definition of the primitive recursion operation are respectively played by <em>P</em><sub>1</sub><sup>1</sup> and the composition of <em>S</em> and <em>P</em><sub>2</sub><sup>3</sup>.</p>
<h3 id="subtraction">Subtraction</h3>

<p>Because primitive recursive functions use natural numbers rather than integers, and the natural numbers are not closed under subtraction, a <strong>limited subtraction</strong> function (also called "proper subtraction") is studied in this context. This limited subtraction function sub(<em>a</em>,<em>b</em>) [or <em>b</em> ∸ <em>a</em>] returns <em>b</em> - <em>a</em> if this is nonnegative and returns <em>0</em> otherwise.</p>

<p>The <strong>predecessor function</strong> acts as the opposite of the successor function and is recursively defined by the rules:</p>
<dl>
<dd>pred(0)=0,
</dd>
<dd>pred(<em>n</em>+1)=<em>n</em>.
</dd>
</dl>

<p>These rules can be converted into a more formal definition by primitive recursion:</p>
<dl>
<dd>pred(0)=0,
</dd>
<dd>pred(S(<em>n</em>))=<em>P</em><sub>1</sub><sup>2</sup>(<em>n</em>, pred(<em>n</em>)).
</dd>
</dl>

<p>The limited subtraction function is definable from the predecessor function in a manner analogous to the way addition is defined from successor:</p>
<dl>
<dd>sub(0,<em>x</em>)=<em>P</em><sub>1</sub><sup>1</sup>(<em>x</em>),
</dd>
<dd>sub(S(<em>n</em>),<em>x</em>)=pred(<em>P</em><sub>2</sub><sup>3</sup>(<em>n</em>, sub(<em>n</em>,<em>x</em>), <em>x</em>)).
</dd>
</dl>

<p>Here sub(<em>a</em>,<em>b</em>) corresponds to <em>b</em>∸<em>a</em>; for the sake of simplicity, the order of the arguments has been switched from the "standard" definition to fit the requirements of primitive recursion. This could easily be rectified using composition with suitable projections.</p>
<h3 id="other-operations-on-natural-numbers">Other operations on natural numbers</h3>

<p><a class="uri" href="Exponentiation" title="wikilink">Exponentiation</a> and <a href="primality_test" title="wikilink">primality testing</a> are primitive recursive. Given primitive recursive functions <em>e</em>, <em>f</em>, <em>g</em>, and <em>h</em>, a function that returns the value of <em>g</em> when <em>e</em>≤<em>f</em> and the value of <em>h</em> otherwise is primitive recursive.</p>
<h3 id="operations-on-integers-and-rational-numbers">Operations on integers and rational numbers</h3>

<p>By using <a href="Gödel_numbering" title="wikilink">Gödel numberings</a>, the primitive recursive functions can be extended to operate on other objects such as integers and <a href="rational_number" title="wikilink">rational numbers</a>. If integers are encoded by Gödel numbers in a standard way, the arithmetic operations including addition, subtraction, and multiplication are all primitive recursive. Similarly, if the rationals are represented by Gödel numbers then the <a href="Field_(mathematics)" title="wikilink">field</a> operations are all primitive recursive.</p>
<h2 id="relationship-to-recursive-functions">Relationship to recursive functions</h2>

<p>The broader class of <a href="partial_recursive_function" title="wikilink">partial recursive functions</a> is defined by introducing an <a href="mu_operator" title="wikilink">unbounded search operator</a>. The use of this operator may result in a <a href="partial_function" title="wikilink">partial function</a>, that is, a relation with <em>at most</em> one value for each argument, but does not necessarily have <em>any</em> value for any argument (see <a href="Domain_of_a_function" title="wikilink">domain</a>). An equivalent definition states that a partial recursive function is one that can be computed by a <a href="Turing_machine" title="wikilink">Turing machine</a>. A total recursive function is a partial recursive function that is defined for every input.</p>

<p>Every primitive recursive function is total recursive, but not all total recursive functions are primitive recursive. The <a href="Ackermann_function" title="wikilink">Ackermann function</a> <em>A</em>(<em>m</em>,<em>n</em>) is a well-known example of a total recursive function that is not primitive recursive. There is a characterization of the primitive recursive functions as a subset of the total recursive functions using the Ackermann function. This characterization states that a function is primitive recursive <a href="if_and_only_if" title="wikilink">if and only if</a> there is a natural number <em>m</em> such that the function can be computed by a Turing machine that always halts within A(<em>m</em>,<em>n</em>) or fewer steps, where <em>n</em> is the sum of the arguments of the primitive recursive function.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>An important property of the primitive recursive functions is that they are a <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> subset of the set of all <a href="total_recursive_function" title="wikilink">total recursive functions</a> (which is not itself recursively enumerable). This means that there is a single computable function <em>f</em>(<em>e</em>,<em>n</em>) such that:</p>
<ul>
<li>For every primitive recursive function <em>g</em>, there is an <em>e</em> such that <em>g</em>(<em>n</em>) = <em>f</em>(<em>e</em>,<em>n</em>) for all <em>n</em>, and</li>
<li>For every <em>e</em>, the function <em>h</em>(<em>n</em>) = <em>f</em>(<em>e</em>,<em>n</em>) is primitive recursive.</li>
</ul>

<p>However, the primitive recursive functions are not the largest recursively enumerable set of total computable functions.</p>
<h2 id="limitations">Limitations</h2>

<p>Primitive recursive functions tend to correspond very closely with our intuition of what a computable function must be. Certainly the initial functions are intuitively computable (in their very simplicity), and the two operations by which one can create new primitive recursive functions are also very straightforward. However the set of primitive recursive functions does not include every possible total computable function — this can be seen with a variant of <a href="Cantor's_diagonal_argument" title="wikilink">Cantor's diagonal argument</a>. This argument provides a total computable function that is not primitive recursive. A sketch of the proof is as follows:</p>
<dl>
<dd>The primitive recursive functions of one argument (i.e., unary functions) can be <a href="Recursively_enumerable_set" title="wikilink">computably enumerated</a>. This enumeration uses the definitions of the primitive recursive functions (which are essentially just expressions with the composition and primitive recursion operations as operators and the basic primitive recursive functions as atoms), and can be assumed to contain every definition once, even though a same <em>function</em> will occur many times on the list (since many definitions define the same function; indeed simply composing by the <a href="identity_function" title="wikilink">identity function</a> generates infinitely many definitions of any one primitive recursive function). This means that the 

<math display="inline" id="Primitive_recursive_function:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-th definition of a primitive recursive function in this enumeration can be effectively determined from 

<math display="inline" id="Primitive_recursive_function:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Indeed if one uses some <a href="Gödel_numbering" title="wikilink">Gödel numbering</a> to encode definitions as numbers, then this 

<math display="inline" id="Primitive_recursive_function:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-th definition in the list is computed by a primitive recursive function of 

<math display="inline" id="Primitive_recursive_function:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Let <mtpl></mtpl> denote the unary primitive recursive function given by this definition.
</dd>
</dl>
<dl>
<dd>Now define the "evaluator function" 

<math display="inline" id="Primitive_recursive_function:9">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ev
  </annotation>
 </semantics>
</math>

 with two arguments, by <mtpl> <em>f</em><sub><em>i</em></sub>(<em>j</em>)}}</mtpl>. Clearly 

<math display="inline" id="Primitive_recursive_function:10">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ev
  </annotation>
 </semantics>
</math>

 is total and computable, since one can effectively determine the definition of <mtpl></mtpl>, and being a primitive recursive function <mtpl></mtpl> is itself total and computable, so <mtpl></mtpl> is always defined and effectively computable. However a diagonal argument will show that the function 

<math display="inline" id="Primitive_recursive_function:11">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ev
  </annotation>
 </semantics>
</math>

 of two arguments is not primitive recursive.
</dd>
</dl>
<dl>
<dd>Suppose 

<math display="inline" id="Primitive_recursive_function:12">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ev
  </annotation>
 </semantics>
</math>

 were primitive recursive, then the unary function 

<math display="inline" id="Primitive_recursive_function:13">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 defined by 

<math display="inline" id="Primitive_recursive_function:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>e</mi>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>v</ci>
      <interval closure="open">
       <ci>i</ci>
       <ci>i</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(i)=S(ev(i,i))
  </annotation>
 </semantics>
</math>

 would also be primitive recursive, as it is defined by composition from the successor function and 

<math display="inline" id="Primitive_recursive_function:15">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ev
  </annotation>
 </semantics>
</math>

. But then 

<math display="inline" id="Primitive_recursive_function:16">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 occurs in the enumeration, so there is some number 

<math display="inline" id="Primitive_recursive_function:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 such that <mtpl> <em>f</em><sub><em>n</em></sub>}}</mtpl>. But now <mtpl> S(<em>ev</em>(<em>n</em>,<em>n</em>)) {{=}} S(<em>f</em><sub><em>n</em></sub>(<em>n</em>)) {{=}} S(<em>g</em>(<em>n</em>))}}</mtpl> gives a contradiction.
</dd>
</dl>

<p>This argument can be applied to any class of computable (total) functions that can be enumerated in this way, as explained in the article <a href="Machines_that_always_halt" title="wikilink">Machines that always halt</a>. Note however that the <em>partial</em> computable functions (those that need not be defined for all arguments) can be explicitly enumerated, for instance by enumerating Turing machine encodings.</p>

<p>Other examples of total recursive but not primitive recursive functions are known:</p>
<ul>
<li>The function that takes <em>m</em> to <a href="Ackermann_function" title="wikilink">Ackermann</a>(<em>m</em>,<em>m</em>) is a unary total recursive function that is not primitive recursive.</li>
<li>The <a href="Paris–Harrington_theorem" title="wikilink">Paris–Harrington theorem</a> involves a total recursive function that is not primitive recursive. Because this function is motivated by <a href="Ramsey_theory" title="wikilink">Ramsey theory</a>, it is sometimes considered more "natural" than the Ackermann function.</li>
<li>The <a href="Sudan_function" title="wikilink">Sudan function</a></li>
<li>The <a href="Goodstein_function" title="wikilink">Goodstein function</a></li>
</ul>
<h2 id="some-common-primitive-recursive-functions">Some common primitive recursive functions</h2>
<dl>
<dd>The following examples and definitions are from Kleene (1952) pp. 223-231 — many appear with proofs. Most also appear with similar names, either as proofs or as examples, in Boolos-Burgess-Jeffrey 2002 pp. 63-70; they add #22 the logarithm lo(x, y) or lg(x, y) depending on the exact derivation.
</dd>
</dl>

<p>In the following we observe that primitive recursive functions can be of four types:</p>
<ol>
<li><em>functions</em> for short: "number-theoretic functions" from { 0, 1, 2, ...} to { 0, 1, 2, ...},</li>
<li><em>predicates</em>: from { 0, 1, 2, ...} to truth values { t =true, f =false },</li>
<li><em>propositional connectives</em>: from truth values { t, f } to truth values { t, f },</li>
<li><em>representing functions</em>: from truth values { t, f } to { 0, 1, 2, ... }. Many times a predicate requires a representing function to convert the predicate's output { t, f } to { 0, 1 } (note the order "t" to "0" and "f" to "1" matches with ~sg( ) defined below). By definition a function φ(<strong>x</strong>) is a "representing function" of the predicate P(<strong>x</strong>) if φ takes only values 0 and 1 and produces <em>0</em> when P is true".</li>
</ol>

<p>In the following the mark " ' ", e.g. a', is the primitive mark meaning "the successor of", usually thought of as " +1", e.g. a +1 =<sub>def</sub> a'. The functions 16-20 and #G are of particular interest with respect to converting primitive recursive predicates to, and extracting them from, their "arithmetical" form expressed as <a href="Gödel_number" title="wikilink">Gödel numbers</a>.</p>

<p>:# Addition: a+b</p>

<p>:# Multiplication: a×b</p>

<p>:# Exponentiation: a<sup>b</sup></p>

<p>:# Factorial a! : 0! = 1, a'! = a!×a'</p>

<p>:# pred(a): (Predecessor or decrement): If a &gt; 0 then a-1 else 0</p>

<p>:# Proper subtraction a ∸ b: If a ≥ b then a-b else 0</p>

<p>:# Minimum(a<sub>1</sub>, ... a<sub>n</sub>)</p>

<p>:# Maximum(a<sub>1</sub>, ... a<sub>n</sub>)</p>

<p>:# Absolute difference: | a-b | =<sub>def</sub> (a ∸ b) + (b ∸ a)</p>

<p>:# ~sg(a): NOT[signum(a)]: If a=0 then 1 else 0</p>

<p>:# sg(a): signum(a): If a=0 then 0 else 1</p>

<p>:# a | b: (a divides b): If b=k×a for some k then 0 else 1</p>

<p>:# Remainder(a, b): the leftover if b does not divide a "evenly". Also called MOD(a, b)</p>

<p>:# a = b: sg | a - b | (Kleene's convention was to represent <em>true</em> by 0 and <em>false</em> by 1; presently, especially in computers, the most common convention is the reverse, namely to represent <em>true</em> by 1 and <em>false</em> by 0, which amounts to changing sg into ~sg here and in the next item)</p>

<p>:# a def a&gt;1 &amp; NOT(Exists c)<sub>1<c sub=""> [ c|a ]</c></sub></p>

<p>:# p<sub>i</sub>: the i+1-st prime number</p>

<p>:# (a)<sub>i</sub>: exponent of p<sub>i</sub> in a: the unique x such that p<sub>i</sub><sup>x</sup>|a &amp; NOT(p<sub>i</sub><sup>x'</sup>|a)</p>

<p>:# lh(a): the "length" or number of non-vanishing exponents in a</p>

<p>:# lo(a, b): logarithm of a to the base b</p>
<dl>
<dd>''In the following, the abbreviation <strong>x</strong> =<sub>def</sub> x<sub>1</sub>, ... x<sub>n</sub>; subscripts may be applied if the meaning requires.
</dd>
</dl>
<ul>
<li><ol>
<li>A: A function φ definable explicitly from functions Ψ and constants q<sub>1</sub>, ... q<sub>n</sub> is primitive recursive in Ψ.</li>
</ol></li>
<li><ol>
<li>B: The finite sum Σ<sub>y<z sub=""> ψ(<strong>x</strong>, y) and product Π<sub>y<z sub="">ψ(<strong>x</strong>, y) are primitive recursive in ψ.</z></sub></z></sub></li>
</ol></li>
<li><ol>
<li>C: A <em>predicate</em> P obtained by substituting functions χ<sub>1</sub>,..., χ<sub>m</sub> for the respective variables of a predicate Q is primitive recursive in χ<sub>1</sub>,..., χ<sub>m</sub>, Q.</li>
</ol></li>
<li><ol>
<li>D: The following <em>predicates</em> are primitive recursive in Q and R:</li>
</ol></li>
</ul>

<p>::* NOT_Q(<strong>x</strong>) .</p>

<p>::* Q OR R: Q(<strong>x</strong>) V R(<strong>x</strong>),</p>

<p>::* Q AND R: Q(<strong>x</strong>) &amp; R(<strong>x</strong>),</p>

<p>::* Q IMPLIES R: Q(<strong>x</strong>) → R(<strong>x</strong>)</p>

<p>::* Q is equivalent to R: Q(<strong>x</strong>) ≡ R(<strong>x</strong>)</p>
<ul>
<li><ol>
<li>E: The following <em>predicates</em> are primitive recursive in the <em>predicate</em> R:</li>
</ol></li>
</ul>

<p>::* (Ey)<sub>y<z sub=""> R(<strong>x</strong>, y) where (Ey)<sub>y<z sub=""> denotes "there exists at least one y that is less than z such that"</z></sub></z></sub></p>

<p>::* (y)<sub>y<z sub=""> R(<strong>x</strong>, y) where (y)<sub>y<z sub=""> denotes "for all y less than z it is true that"</z></sub></z></sub></p>

<p>::* μy<sub>y<z sub=""> R(<strong>x</strong>, y). The operator μy<sub>y<z sub=""> R(<strong>x</strong>, y) is a <em>bounded</em> form of the so-called minimization- or <a class="uri" href="mu-operator" title="wikilink">mu-operator</a>: Defined as "the least value of y less than z such that R(<strong>x</strong>, y) is true; or z if there is no such value."</z></sub></z></sub></p>
<ul>
<li><ol>
<li>F: Definition by cases: The function defined thus, where Q<sub>1</sub>, ..., Q<sub>m</sub> are mutually exclusive <em>predicates</em> (or "ψ(<strong>x</strong>) shall have the value given by the first clause that applies), is primitive recursive in φ<sub>1</sub>, ..., Q<sub>1</sub>, ... Q<sub>m</sub>:</li>
</ol></li>
</ul>
<dl>
<dd><dl>
<dd>φ(<strong>x</strong>) =
<ul>
<li>φ<sub>1</sub>(<strong>x</strong>) if Q<sub>1</sub>(<strong>x</strong>) is true,</li>
<li>. . . . . . . . . . . . . . . . . . .</li>
<li>φ<sub>m</sub>(<strong>x</strong>) if Q<sub>m</sub>(<strong>x</strong>) is true</li>
<li>φ<sub>m+1</sub>(<strong>x</strong>) otherwise</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<ul>
<li><ol>
<li>G: If φ satisfies the equation:</li>
</ol></li>
</ul>
<dl>
<dd><dl>
<dd>φ(y,<strong>x</strong>) = χ(y, NOT-φ(y; x<sub>2</sub>, ... x<sub>n</sub> ), x<sub>2</sub>, ... x<sub>n</sub> then φ is primitive recursive in χ. 'So, in a sense the knowledge of the value NOT-φ(y; <strong>x</strong><sub>2 to n</sub> ) of the course-of-values function is equivalent to the knowledge of the sequence of values φ(0,<strong>x</strong><sub>2 to n</sub>), ..., φ(y-1,<strong>x</strong><sub>2 to n</sub>) of the original function."
</dd>
</dl>
</dd>
</dl>
<h2 id="additional-primitive-recursive-forms">Additional primitive recursive forms</h2>

<p>Some additional forms of recursion also define functions that are in fact primitive recursive. Definitions in these forms may be easier to find or more natural for reading or writing. <a href="Course-of-values_recursion" title="wikilink">Course-of-values recursion</a> defines primitive recursive functions. Some forms of mutual recursion also define primitive recursive functions.</p>

<p>The functions that can be programmed in the <a href="LOOP_(programming_language)" title="wikilink">LOOP programming language</a> are exactly the primitive recursive functions. This gives a different characterization of the power of these functions. The main limitation of the LOOP language, compared to a <a href="Turing-complete_language" title="wikilink">Turing-complete language</a>, is that in the LOOP language the number of times that each loop will run is specified before the loop begins to run.</p>
<h2 id="finitism-and-consistency-results">Finitism and consistency results</h2>

<p>The primitive recursive functions are closely related to mathematical <a class="uri" href="finitism" title="wikilink">finitism</a>, and are used in several contexts in mathematical logic where a particularly constructive system is desired. <a href="Primitive_recursive_arithmetic" title="wikilink">Primitive recursive arithmetic</a> (PRA), a formal axiom system for the natural numbers and the primitive recursive functions on them, is often used for this purpose.</p>

<p>PRA is much weaker than <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>, which is not a finitistic system. Nevertheless, many results in <a href="number_theory" title="wikilink">number theory</a> and in <a href="proof_theory" title="wikilink">proof theory</a> can be proved in PRA. For example, <a href="Gödel's_incompleteness_theorem" title="wikilink">Gödel's incompleteness theorem</a> can be formalized into PRA, giving the following theorem:</p>
<dl>
<dd>If <em>T</em> is a theory of arithmetic satisfying certain hypotheses, with Gödel sentence <em>G</em><sub><em>T</em></sub>, then PRA proves the implication Con(<em>T</em>)→<em>G</em><sub><em>T</em></sub>.
</dd>
</dl>

<p>Similarly, many of the syntactic results in proof theory can be proved in PRA, which implies that there are primitive recursive functions that carry out the corresponding syntactic transformations of proofs.</p>

<p>In proof theory and <a href="set_theory" title="wikilink">set theory</a>, there is an interest in finitistic <a href="consistency_proof" title="wikilink">consistency proofs</a>, that is, consistency proofs that themselves are finitistically acceptable. Such a proof establishes that the consistency of a theory <em>T</em> implies the consistency of a theory <em>S</em> by producing a primitive recursive function that can transform any proof of an inconsistency from <em>S</em> into a proof of an inconsistency from <em>T</em>. One sufficient condition for a consistency proof to be finitistic is the ability to formalize it in PRA. For example, many consistency results in set theory that are obtained by <a href="forcing_(mathematics)" title="wikilink">forcing</a> can be recast as syntactic proofs that can be formalized in PRA.</p>
<h2 id="history">History</h2>

<p><a href="Recursive_definition" title="wikilink">Recursive definitions</a> had been used more less formally in mathematics before, but the construction of primitive recursion is traced back to <a href="Richard_Dedekind" title="wikilink">Richard Dedekind</a>'s theorem 126 of his <em>Was sind und was sollen die Zahlen?</em> (1888). This work was the first to give a proof that a certain recursive construction defines a unique function.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The current terminology was coined by <a href="Rózsa_Péter" title="wikilink">Rózsa Péter</a> (1934) after Ackermann had proved in 1928 that the function which today is named after him was not primitive recursive, an event which prompted the need to rename what until then were simply called recursive functions.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Course-of-values_recursion" title="wikilink">Course-of-values recursion</a></li>
<li><a href="Grzegorczyk_hierarchy" title="wikilink">Grzegorczyk hierarchy</a></li>
<li><a href="Machine_that_always_halts" title="wikilink">Machine that always halts</a></li>
<li><a href="Recursion_(computer_science)" title="wikilink">Recursion (computer science)</a></li>
<li><a href="Primitive_recursive_functional" title="wikilink">Primitive recursive functional</a></li>
<li><a href="Double_recursion" title="wikilink">Double recursion</a></li>
<li><a href="Primitive_recursive_set_function" title="wikilink">Primitive recursive set function</a></li>
<li><a href="Primitive_recursive_ordinal_function" title="wikilink">Primitive recursive ordinal function</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Brainerd, W.S., Landweber, L.H. (1974), <em>Theory of Computation</em>, Wiley, ISBN 0-471-09585-0</li>
<li><a href="Robert_I._Soare" title="wikilink">Robert I. Soare</a>, <em>Recursively Enumerable Sets and Degrees</em>, Springer-Verlag, 1987. ISBN 0-387-15299-7</li>
<li><a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a> (1952) <em>Introduction to Metamathematics</em>, North-Holland Publishing Company, New York, 11th reprint 1971: (2nd edition notes added on 6th reprint). In Chapter XI. General Recursive Functions §57</li>
<li><a href="George_Boolos" title="wikilink">George Boolos</a>, <a href="John_P._Burgess" title="wikilink">John Burgess</a>, <a href="Richard_Jeffrey" title="wikilink">Richard Jeffrey</a> (2002), <em>Computability and Logic: Fourth Edition</em>, Cambridge University Press, Cambridge, UK. Cf pp. 70–71.</li>
<li>Robert I. Soare 1995 <em>Computability and Recursion</em> <a class="uri" href="http://www.people.cs.uchicago.edu/~soare/History/compute.pdf">http://www.people.cs.uchicago.edu/~soare/History/compute.pdf</a></li>
<li>Daniel Severin 2008, <em>Unary primitive recursive functions</em>, J. Symbolic Logic Volume 73, Issue 4, pp. 1122–1138 <a href="http://arxiv.org/abs/cs/0603063v3">arXiv</a> [<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.jsl/1230396909 projecteuclid]</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Functions_and_mappings" title="wikilink">Category:Functions and mappings</a> <a class="uri" href="Category:Recursion" title="wikilink">Category:Recursion</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Brainerd and Landweber, 1974<a href="#fnref1">↩</a></li>
<li id="fn2">This follows from the facts that the functions of this form are the most quickly growing primitive recursive functions, and that a function is primitive recursive if and only if its time complexity is bounded by a primitive recursive function. For the former, see . For the latter, see .<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
