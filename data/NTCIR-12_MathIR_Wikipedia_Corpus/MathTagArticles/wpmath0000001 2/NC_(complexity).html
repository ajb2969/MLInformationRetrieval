<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="731">NC (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>NC (complexity)</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">complexity theory</a>, the class <strong>NC</strong> (for "Nick's Class") is the set of <a href="decision_problem" title="wikilink">decision problems</a> decidable in <a href="polylogarithmic_time" title="wikilink">polylogarithmic time</a> on a <a href="parallel_computing" title="wikilink">parallel computer</a> with a polynomial number of processors. In other words, a problem is in <strong>NC</strong> if there exist constants <em>c</em> and <em>k</em> such that it can be solved in time <em><a href="Big_O_notation" title="wikilink">O</a></em>(log<sup><em>c</em></sup> <em>n</em>) using <em><a href="Big_O_notation" title="wikilink">O</a></em>(<em>n</em><sup><em>k</em></sup>) parallel processors. <a href="Stephen_Cook" title="wikilink">Stephen Cook</a> coined the name "Nick's class" after <a href="Nick_Pippenger" title="wikilink">Nick Pippenger</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> who had done extensive research on circuits with polylogarithmic depth and polynomial size.</p>

<p>Just as the class <strong><a href="P_(complexity)" title="wikilink">P</a></strong> can be thought of as the tractable problems (<a href="Cobham's_thesis" title="wikilink">Cobham's thesis</a>), so <strong>NC</strong> can be thought of as the problems that can be efficiently solved on a parallel computer.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <strong>NC</strong> is a subset of <strong>P</strong> because polylogarithmic parallel computations can be simulated by polynomial-time sequential ones. It is unknown whether <strong>NC</strong> = <strong>P</strong>, but most researchers suspect this to be false, meaning that there are probably some tractable problems that are "inherently sequential" and cannot significantly be sped up by using parallelism. Just as the class <strong><a class="uri" href="NP-complete" title="wikilink">NP-complete</a></strong> can be thought of as "probably intractable", so the class <strong><a class="uri" href="P-complete" title="wikilink">P-complete</a></strong>, when using <strong>NC</strong> reductions, can be thought of as "probably not parallelizable" or "probably inherently sequential".</p>

<p>The parallel computer in the definition can be assumed to be a <em>parallel, random-access machine</em> (<a href="parallel_random_access_machine" title="wikilink">PRAM</a>). That is a parallel computer with a central pool of memory, and any processor can access any bit of memory in constant time. The definition of <strong>NC</strong> is not affected by the choice of how the PRAM handles simultaneous access to a single bit by more than one processor. It can be CRCW, CREW, or EREW. See <a href="parallel_random_access_machine" title="wikilink">PRAM</a> for descriptions of those models.</p>

<p>Equivalently, <strong>NC</strong> can be defined as those decision problems decidable by a <a href="Boolean_circuit" title="wikilink">uniform Boolean circuit</a> (which can be calculated from the length of the input) with <a class="uri" href="polylogarithmic" title="wikilink">polylogarithmic</a> depth and a polynomial number of gates.</p>

<p><strong><a href="RNC_(complexity)" title="wikilink">RNC</a></strong> is a class extending <strong>NC</strong> with access to randomness.</p>
<h2 id="problems-in-nc">Problems in NC</h2>

<p>As with <strong>P</strong>, by a slight abuse of language, one might classify function problems and search problems as being in <strong>NC</strong>. <strong>NC</strong> is known to include many problems, including</p>
<ul>
<li>Integer addition, multiplication and division;</li>
<li>Matrix multiplication, determinant, inverse, rank;</li>
<li>Polynomial GCD, by a reduction to linear algebra using <a href="Sylvester_matrix" title="wikilink">Sylvester matrix</a></li>
<li>Finding a maximal matching.</li>
</ul>

<p>Often algorithms for those problems had to be separately invented and could not be naïvely adapted from well-known algorithms – Gaussian elimination and Euclidean algorithm rely on operations performed in sequence. One might contrast <a href="ripple_carry_adder" title="wikilink">ripple carry adder</a> with a <a href="carry-lookahead_adder" title="wikilink">carry-lookahead adder</a>.</p>
<h2 id="the-nc-hierarchy">The NC hierarchy</h2>

<p><strong>NC</strong><sup><em>i</em></sup> is the class of decision problems decidable by uniform boolean circuits with a polynomial number of gates of at most two inputs and depth <em>O</em>(log<sup><em>i</em></sup> <em>n</em>), or the class of decision problems solvable in time <em>O</em>(log<sup><em>i</em></sup> <em>n</em>) on a parallel computer with a polynomial number of processors. Clearly, we have</p>

<p>

<math display="block" id="NC_(complexity):0">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐍𝐂</mi>
    <mn>1</mn>
   </msup>
   <mo>⊆</mo>
   <msup>
    <mi>𝐍𝐂</mi>
    <mn>2</mn>
   </msup>
   <mo>⊆</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⊆</mo>
   <msup>
    <mi>𝐍𝐂</mi>
    <mi>i</mi>
   </msup>
   <mo>⊆</mo>
   <mrow>
    <mi mathvariant="normal">⋯</mi>
    <mi>𝐍𝐂</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-⋯</ci>
      <ci>𝐍𝐂</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{NC}^{1}\subseteq\mathbf{NC}^{2}\subseteq\cdots\subseteq\mathbf{NC}^{i}%
\subseteq\cdots\mathbf{NC}
  </annotation>
 </semantics>
</math>

</p>

<p>which forms the <strong>NC</strong>-hierarchy.</p>

<p>We can relate the <strong>NC</strong> classes to the space classes <strong><a href="L_(complexity)" title="wikilink">L</a></strong> and <strong><a href="NL_(complexity)" title="wikilink">NL</a></strong><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <strong><a href="AC_(complexity)" title="wikilink">AC</a></strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="block" id="NC_(complexity):1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐍𝐂</mi>
     <mn>1</mn>
    </msup>
    <mo>⊆</mo>
    <mi>𝐋</mi>
    <mo>⊆</mo>
    <mi>𝐍𝐋</mi>
    <mo>⊆</mo>
    <msup>
     <mi>𝐀𝐂</mi>
     <mn>1</mn>
    </msup>
    <mo>⊆</mo>
    <msup>
     <mi>𝐍𝐂</mi>
     <mn>2</mn>
    </msup>
    <mo>⊆</mo>
    <mi>𝐏</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>𝐋</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐍𝐋</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐀𝐂</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>𝐏</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{NC}^{1}\subseteq\mathbf{L}\subseteq\mathbf{NL}\subseteq\mathbf{AC}^{1}%
\subseteq\mathbf{NC}^{2}\subseteq\mathbf{P}.
  </annotation>
 </semantics>
</math>

</p>

<p>The NC classes are related to the AC classes, which are defined similarly, but with gates having unbounded fanin. For each <em>i</em>, we have<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>

<math display="block" id="NC_(complexity):2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐍𝐂</mi>
     <mi>i</mi>
    </msup>
    <mo>⊆</mo>
    <msup>
     <mi>𝐀𝐂</mi>
     <mi>i</mi>
    </msup>
    <mo>⊆</mo>
    <msup>
     <mi>𝐍𝐂</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐀𝐂</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐍𝐂</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{NC}^{i}\subseteq\mathbf{AC}^{i}\subseteq\mathbf{NC}^{i+1}.
  </annotation>
 </semantics>
</math>

</p>

<p>As an immediate consequence of this, we have that <strong>NC</strong> = <strong>AC</strong>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> It is known that both inclusions are strict for <em>i</em> = 0.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Similarly, we have that <strong>NC</strong> is equivalent to the problems solvable on an <a href="alternating_Turing_machine" title="wikilink">alternating Turing machine</a> restricted to at most two options at each step with <em>O</em>(log <em>n</em>) space and 

<math display="inline" id="NC_(complexity):3">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\log n)^{O(1)}
  </annotation>
 </semantics>
</math>

 alternations.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="open-problem-is-nc-proper">Open problem: Is NC proper?</h3>

<p>One major open question in <a href="computational_complexity_theory" title="wikilink">complexity theory</a> is whether or not every containment in the <strong>NC</strong> hierarchy is proper. It was observed by Papadimitriou that, if <strong>NC</strong><sup><em>i</em></sup> = <strong>NC</strong><sup><em>i</em>+1</sup> for some <em>i</em>, then <strong>NC</strong><sup><em>i</em></sup> = <strong>NC</strong><sup><em>j</em></sup> for all <em>j</em> ≥ <em>i</em>, and as a result, <strong>NC</strong><sup><em>i</em></sup> = <strong>NC</strong>. This observation is known as <strong>NC</strong>-hierarchy collapse because even a single equality in the chain of containments</p>

<p>

<math display="block" id="NC_(complexity):4">
 <semantics>
  <mrow>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mn>1</mn>
   </msup>
   <mo>⊆</mo>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mn>2</mn>
   </msup>
   <mo>⊆</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{NC}^{1}\subseteq\textbf{NC}^{2}\subseteq\cdots
  </annotation>
 </semantics>
</math>

 implies that the entire <strong>NC</strong> hierarchy "collapses" down to some level <em>i</em>. Thus, there are 2 possibilities:</p>
<ol>
<li>

<math display="inline" id="NC_(complexity):5">
 <semantics>
  <mrow>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mn>1</mn>
   </msup>
   <mo>⊂</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⊂</mo>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mi>i</mi>
   </msup>
   <mo>⊂</mo>
   <mi mathvariant="normal">…</mi>
   <mo>⊂</mo>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msup>
   <mo>⊂</mo>
   <mrow>
    <mi mathvariant="normal">⋯</mi>
    <mtext>𝐍𝐂</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-⋯</ci>
      <mtext>NC</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{NC}^{1}\subset\cdots\subset\textbf{NC}^{i}\subset...\subset\textbf{NC}%
^{i+j}\subset\cdots\textbf{NC}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="NC_(complexity):6">
 <semantics>
  <mrow>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mn>1</mn>
   </msup>
   <mo>⊂</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⊂</mo>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mi>i</mi>
   </msup>
   <mo>=</mo>
   <mi mathvariant="normal">…</mi>
   <mo>=</mo>
   <msup>
    <mtext>𝐍𝐂</mtext>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">⋯</mi>
    <mtext>𝐍𝐂</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>NC</mtext>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>normal-⋯</ci>
      <mtext>NC</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{NC}^{1}\subset\cdots\subset\textbf{NC}^{i}=...=\textbf{NC}^{i+j}=%
\cdots\textbf{NC}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>It is widely believed that (1) is the case, although no proof as to the truth of either statement has yet been discovered.</p>
<h2 id="barringtons-theorem">Barrington's theorem</h2>

<p>A <strong>branching program</strong> with <em>n</em> variables of width <em>k</em> and length <em>m</em> consists of a sequence of <em>m</em> instructions. Each of the instructions is a tuple (<em>i</em>, <em>p</em>, <em>q</em>) where <em>i</em> is the index of variable to check (1 ≤ <em>i</em> ≤ <em>n</em>), and <em>p</em> and <em>q</em> are functions from {1, 2, ..., <em>k</em>} to {1, 2, ..., <em>k</em>}. Numbers 1, 2, ..., <em>k</em> are called states of the branching program. The program initially starts in state 1, and each instruction (<em>i</em>, <em>p</em>, <em>q</em>) changes the state from <em>x</em> to <em>p</em>(<em>x</em>) or <em>q</em>(<em>x</em>), depending on whether the <em>i</em>th variable is 0 or 1.</p>

<p>A family of branching programs consists of a branching program with <em>n</em> variables for each <em>n</em>.</p>

<p>It is easy to show that every language <em>L</em> on {0,1} can be recognized by a family of branching programs of width 4 and exponential length, or by a family of exponential width and linear length.</p>

<p>Every regular language on {0,1} can be recognized by a family of branching programs of constant width and linear number of instructions (since a DFA can be converted to a branching program). <strong>BWBP</strong> denotes the class of languages recognizable by a family of branching programs of bounded width and polynomial length.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p><strong>Barrington's theorem</strong><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> says that is exactly <a href="uniformity_(circuit)" title="wikilink">nonuniform</a> <strong>NC</strong><sup>1</sup>. The proof uses the <a href="solvable_group" title="wikilink">nonsolvability</a> of the symmetric group S<sub>5</sub>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>The theorem is rather surprising. For instance, it implies that the <a href="majority_function" title="wikilink">majority function</a> can be computed by a family of branching programs of constant width and polynomial size, while intuition might suggest that to achieve polynomial size, one needs a linear number of states.</p>
<h3 id="proof-of-barringtons-theorem">Proof of Barrington's theorem</h3>

<p>A branching program of constant width and polynomial size can be easily converted (via divide-and-conquer) to a circuit in <strong>NC</strong><sup>1</sup>.</p>

<p>Conversely, suppose a circuit in <strong>NC</strong><sup>1</sup> is given. Without loss of generality, assume it uses only AND and NOT gates.</p>

<p>Lemma 1: If there exists a branching program that sometimes works as a permutation <em>P</em> and sometimes as <em>Q</em>, by right-multiplying permutations in the first instruction by α, and in the last instruction left-multiplying by β, we can make a circuit of the same length that behaves as β<em>P</em>α or β<em>Q</em>α, respectively.</p>

<p>Call a branching program α-computing a circuit <em>C</em> if it works as identity when C's output is 0, and as α when C's output is 1.</p>

<p>As a consequence of lemma 1 and the fact that all cycles of length 5 are <a href="Conjugacy_class" title="wikilink">conjugate</a>, for any two 5-cycles α, β, if there exists a branching program α-computing a circuit <em>C</em>, then there exists a branching program β-computing the circuit <em>C</em>, of the same length.</p>

<p>Lemma 2: There exist 5-cycles γ, δ such that their <a class="uri" href="commutator" title="wikilink">commutator</a> 

<math display="inline" id="NC_(complexity):7">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mi>δ</mi>
    <msup>
     <mi>γ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>δ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>γ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>δ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\delta\gamma^{-1}\delta^{-1}=\epsilon
  </annotation>
 </semantics>
</math>

 is a 5-cycle. For example, γ = (1 2 3 4 5), δ = (1 3 5 4 2).</p>

<p>We will now prove Barrington's theorem by induction.</p>

<p>Assume that for all subcircuits <em>D</em> of <em>C</em> and 5-cycles α, there exists a branching program α-computing <em>D</em>. We will show that for all 5-cycles α, there exists a branching program α-computing <em>C</em>.</p>
<ul>
<li>If the circuit outputs <em>x<sub>i</sub></em>, the branching program has one instruction checking <em>x<sub>i</sub></em> and outputting identity or α respectively.</li>
<li>If the circuit outputs 

<math display="inline" id="NC_(complexity):8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg C
  </annotation>
 </semantics>
</math>

, where <em>C</em> is a different circuit. Create a branching program 

<math display="inline" id="NC_(complexity):9">
 <semantics>
  <msup>
   <mi>α</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{-1}
  </annotation>
 </semantics>
</math>

-computing <em>C</em>, and multiply output of the program (using lemma 1) by α to get a branching program outputting 

<math display="inline" id="NC_(complexity):10">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   id
  </annotation>
 </semantics>
</math>

 or α, i.e. α-computing 

<math display="inline" id="NC_(complexity):11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg C
  </annotation>
 </semantics>
</math>

.</li>
<li>If the circuit outputs 

<math display="inline" id="NC_(complexity):12">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>∧</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>C</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\wedge D
  </annotation>
 </semantics>
</math>

, join the branching programs that 

<math display="inline" id="NC_(complexity):13">
 <semantics>
  <msup>
   <mi>δ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{-1}
  </annotation>
 </semantics>
</math>

-compute <em>D</em>, 

<math display="inline" id="NC_(complexity):14">
 <semantics>
  <msup>
   <mi>γ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>γ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma^{-1}
  </annotation>
 </semantics>
</math>

-compute C, δ-compute <em>D</em>, γ-compute C. If one of the circuits outputs 0, the resulting program will be identity; if both circuits output 1, the resulting program will work as ε. In other words, we get a program ε-computing 

<math display="inline" id="NC_(complexity):15">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>∧</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>C</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\wedge D
  </annotation>
 </semantics>
</math>

. Because ε and α are two 5-cycles, they are conjugate, and there exists a program α-computing 

<math display="inline" id="NC_(complexity):16">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>∧</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>C</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\wedge D
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The size of the branching program is at most 

<math display="inline" id="NC_(complexity):17">
 <semantics>
  <msup>
   <mn>4</mn>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">4</cn>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4^{d}
  </annotation>
 </semantics>
</math>

, where <em>d</em> is the depth of the circuit. If the circuit has logarithmic depth, the branching program has polynomial length.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://www.cs.armstrong.edu/greenlaw/research/PARALLEL/limits.pdf">Greenlaw, Raymond, James Hoover, and Walter Ruzzo. <em>Limits To Parallel computation; P-Completeness Theory</em>. ISBN 0-19-508591-4</a></li>
<li>

<p>Lectures 28 - 34 and 36</p></li>
<li>

<p>Lecture 12: Relation of <em>NC</em> to Time-Space Classes</p></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a> <a href="Category:Circuit_complexity" title="wikilink">Category:Circuit complexity</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Arora &amp; Barak (2009) p.120<a href="#fnref1">↩</a></li>
<li id="fn2">Arora &amp; Barak (2009) p.118<a href="#fnref2">↩</a></li>
<li id="fn3">Papadimitriou (1994) Theorem 16.1<a href="#fnref3">↩</a></li>
<li id="fn4">Clote &amp; Kranakis (2002) p.437<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7">Clote &amp; Kranakis (2002) p.12<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Clote &amp; Kranakis (2002) p.50<a href="#fnref10">↩</a></li>
<li id="fn11"><mtpl></mtpl><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
</ol>
</section>
</body>
</html>
