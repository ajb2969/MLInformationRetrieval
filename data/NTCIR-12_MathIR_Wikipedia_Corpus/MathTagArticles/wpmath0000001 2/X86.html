<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1117">X86</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>X86</h1>
<hr/>

<p> </p>

<p><strong>x86</strong> is a family of <a href="backward_compatible" title="wikilink">backward compatible</a> <a href="instruction_set_architecture" title="wikilink">instruction set architectures</a> based on the <a href="Intel_8086" title="wikilink">Intel 8086</a> <a href="Central_processing_unit" title="wikilink">CPU</a> and its <a href="Intel_8088" title="wikilink">Intel 8088</a> variant. The 8086 was introduced in 1978 as a fully <a class="uri" href="16-bit" title="wikilink">16-bit</a> extension of Intel's <a class="uri" href="8-bit" title="wikilink">8-bit</a> based <a href="Intel_8080" title="wikilink">8080</a> microprocessor, with <a href="x86_memory_segmentation" title="wikilink">memory segmentation</a> as a solution for addressing more memory than can be covered by a plain 16-bit address. The term "x86" came into being because the names of several successors to the Intel's 8086 processor ended in "86", including <a href="Intel_80186" title="wikilink">80186</a>, <a href="Intel_80286" title="wikilink">80286</a>, <a href="Intel_80386" title="wikilink">80386</a> and <a href="Intel_80486" title="wikilink">80486</a> processors.</p>

<p>Many additions and extensions have been added to the x86 instruction set over the years, almost consistently with full <a href="backward_compatibility" title="wikilink">backward compatibility</a>. The architecture has been implemented in processors from <a href="Intel_Corporation" title="wikilink">Intel</a>, <a class="uri" href="Cyrix" title="wikilink">Cyrix</a>, <a href="Advanced_Micro_Devices" title="wikilink">AMD</a>, <a href="VIA_Technologies" title="wikilink">VIA</a> and many other companies; there are also open implementations, such as the Zet <a href="System_on_a_chip" title="wikilink">SoC</a> platform.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The term is not synonymous with <a href="IBM_PC_compatible" title="wikilink">IBM PC compatibility</a> as this implies a multitude of other <a href="computer_hardware" title="wikilink">computer hardware</a>; <a href="embedded_system" title="wikilink">embedded systems</a> as well as general-purpose computers used x86 chips <a href="Influence_of_the_IBM_PC_on_the_personal_computer_market#Before_the_IBM_PC's_introduction" title="wikilink">before the PC-compatible market started</a>, some of them before the <a href="IBM_PC" title="wikilink">IBM PC</a> itself.</p>
<h2 id="overview">Overview</h2>

<p>In the 1980s and early 1990s when the <a class="uri" href="8088" title="wikilink">8088</a> and <a class="uri" href="80286" title="wikilink">80286</a> were still in common use, the term x86 usually represented any 8086 compatible CPU. Today, however, x86 usually implies a binary compatibility also with the <a class="uri" href="32-bit" title="wikilink">32-bit</a> <a href="instruction_set" title="wikilink">instruction set</a> of the 80386. This is due to the fact that this instruction set has become something of a lowest common denominator for many modern operating systems and probably also because the term became common <em>after</em> the introduction of the <a href="Intel_80386" title="wikilink">80386</a> in 1985.</p>

<p>A few years after the introduction of the 8086 and 8088, Intel added some complexity to its naming scheme and terminology as the "iAPX" of the ambitious but ill-fated <a href="Intel_iAPX_432" title="wikilink">Intel iAPX 432</a> processor was tried on the more successful 8086 family of chips, applied as a kind of system-level prefix. An 8086 <em>system</em>, including <a href="coprocessor" title="wikilink">coprocessors</a> such as <a class="uri" href="8087" title="wikilink">8087</a> and/or <a class="uri" href="8089" title="wikilink">8089</a>, as well as simpler Intel-specific system chips, was thereby described as an iAPX 86 <em>system</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> There were also terms <em>iRMX</em> (for operating systems), <em>iSBC</em> (for single-board computers), and <em>iSBX</em> (for multimodule boards based on the 8086-architecture) all together under the heading <em>Microsystem 80</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> However, this naming scheme was quite temporary, lasting for a few years during the early 1980s.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Although the 8086 was primarily developed for <a href="embedded_systems" title="wikilink">embedded systems</a> and small multi-user or single-user computers, largely as a response to the successful 8080-compatible <a href="Zilog_Z80" title="wikilink">Zilog Z80</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> the x86 line soon grew in features and processing power. Today, x86 is ubiquitous in both stationary and portable personal computers, and is also used in <a href="midrange_computer" title="wikilink">midrange computers</a>, <a href="workstation" title="wikilink">workstations</a>, servers and most new <a class="uri" href="supercomputer" title="wikilink">supercomputer</a> <a href="computer_cluster" title="wikilink">clusters</a> of <a class="uri" href="TOP500" title="wikilink">TOP500</a> list. A large amount of <a href="computer_software" title="wikilink">software</a>, including <a href="operating_system" title="wikilink">operating systems</a> (OSs) such as <a class="uri" href="DOS" title="wikilink">DOS</a>, <a href="Microsoft_Windows" title="wikilink">Windows</a>, <a class="uri" href="Linux" title="wikilink">Linux</a>, <a class="uri" href="BSD" title="wikilink">BSD</a>, <a href="Solaris_(operating_system)" title="wikilink">Solaris</a> and <a href="Mac_OS_X" title="wikilink">Mac OS X</a>, functions with x86-based hardware.</p>

<p>Modern x86 is relatively uncommon in <a href="embedded_systems" title="wikilink">embedded systems</a>, however, and small <a href="Low-power_electronics" title="wikilink">low power</a> applications (using tiny batteries) as well as low-cost microprocessor markets, such as <a href="home_appliance" title="wikilink">home appliances</a> and toys, lack any significant x86 presence. Simple 8-bit and 16-bit based architectures are common here, although the x86-compatible <a href="VIA_C7" title="wikilink">VIA C7</a>, <a href="VIA_Nano" title="wikilink">VIA Nano</a>, <a href="Advanced_Micro_Devices" title="wikilink">AMD</a>'s <a href="Geode_(processor)" title="wikilink">Geode</a>, <a href="Athlon_Neo" title="wikilink">Athlon Neo</a> and <a href="Intel_Atom" title="wikilink">Intel Atom</a> are examples of 32- and <a href="64-bit_computing" title="wikilink">64-bit</a> designs used in some <em>relatively</em> low power and low cost segments.</p>

<p>There have been several attempts, including by Intel itself, to end the market dominance of the "inelegant" x86 architecture designed directly from the first simple 8-bit microprocessors. Examples of this are the <a href="iAPX_432" title="wikilink">iAPX 432</a> (a project originally named the "Intel 8800"<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>), the <a href="Intel_960" title="wikilink">Intel 960</a>, <a href="Intel_860" title="wikilink">Intel 860</a> and the Intel/Hewlett-Packard <a class="uri" href="Itanium" title="wikilink">Itanium</a> architecture. However, the continuous refinement of x86 <a href="microarchitecture" title="wikilink">microarchitectures</a>, <a href="electronic_circuit" title="wikilink">circuitry</a> and <a href="semiconductor_manufacturing" title="wikilink">semiconductor manufacturing</a> would make it hard to replace x86 in many segments. AMD's 64-bit extension of x86 (which Intel eventually responded to with a compatible design)<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and the scalability of x86 chips such as the <a href="multi-core_processor" title="wikilink">eight-core</a> Intel Xeon and 12-core AMD Opteron is underlining x86 as an example of how continuous refinement of established industry standards can resist the competition from completely new architectures.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="chronology">Chronology</h2>

<p>The table below lists brands of common<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> consumer targeted processors implementing the x86 <a href="instruction_set" title="wikilink">instruction set</a>, grouped by generations that emphasize important events of x86 history. Note: CPU generations are not strict - each generation is characterized by significantly improved or commercially successful processor <a class="uri" href="microarchitecture" title="wikilink">microarchitecture</a> designs.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Generation</p></th>
<th style="text-align: left;">
<p>First introduced</p></th>
<th style="text-align: left;">
<p>Prominent consumer CPU brands</p></th>
<th style="text-align: left;">
<p>Linear/physical address space</p></th>
<th style="text-align: left;">
<p>Notable (new) features</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1st</p></td>
<td style="text-align: left;">
<p>1978</p></td>
<td style="text-align: left;">
<p><a href="Intel_8086" title="wikilink">Intel 8086</a>, <a href="Intel_8088" title="wikilink">Intel 8088</a> and clones</p></td>
<td style="text-align: left;">
<p>16-bit / 20-bit</p></td>
<td style="text-align: left;">
<p>First x86 microprocessors</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1982</p></td>
<td style="text-align: left;">
<p><a href="Intel_80186" title="wikilink">Intel 80186</a>, <a href="Intel_80188" title="wikilink">Intel 80188</a> and clones, <a href="NEC_V20" title="wikilink">NEC V20</a>/V30</p></td>
<td style="text-align: left;">
<p>Hardware for fast <a href="Memory_address" title="wikilink">address</a> calculations, fast multiplication and division</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2nd</p></td>
<td style="text-align: left;">
<p><a href="Intel_80286" title="wikilink">Intel 80286</a> and clones</p></td>
<td style="text-align: left;">
<p>16-bit ((14+16)-bit segmented) / 24-bit</p></td>
<td style="text-align: left;">
<p><a href="memory_management_unit" title="wikilink">MMU</a>, for <a href="protected_mode" title="wikilink">protected mode</a> and a larger <a href="address_space" title="wikilink">address space</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3rd (<a class="uri" href="IA-32" title="wikilink">IA-32</a>)</p></td>
<td style="text-align: left;">
<p>1985</p></td>
<td style="text-align: left;">
<p><a href="Intel_80386" title="wikilink">Intel 80386</a> and clones, <a href="AMD_Am386" title="wikilink">AMD Am386</a></p></td>
<td style="text-align: left;">
<p>32-bit ((14+32)-bit segmented) / 32-bit</p></td>
<td style="text-align: left;">
<p><a class="uri" href="32-bit" title="wikilink">32-bit</a> <a href="instruction_set" title="wikilink">instruction set</a>, MMU with paging</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3rd/4th</p></td>
<td style="text-align: left;">
<p>1992</p></td>
<td style="text-align: left;">
<p><a href="Cyrix_Cx486SLC" title="wikilink">Cyrix Cx486SLC</a>, <a href="Cyrix_Cx486DLC" title="wikilink">Cyrix Cx486DLC</a></p></td>
<td style="text-align: left;">
<p>L1 cache and pipelining introduced into the 386 platform</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4th (<a href="Floating_point_unit" title="wikilink">FPU</a>)</p></td>
<td style="text-align: left;">
<p>1989</p></td>
<td style="text-align: left;">
<p><a href="Intel_80486" title="wikilink">Intel 80486</a> and clones, <a href="AMD_Am486" title="wikilink">AMD Am486</a></p></td>
<td style="text-align: left;">
<p>RISC-like <a class="uri" href="pipelining" title="wikilink">pipelining</a>, integrated <a class="uri" href="x87" title="wikilink">x87</a> <a href="Floating_point_unit" title="wikilink">FPU</a> (80-bit), on-chip <a href="CPU_cache" title="wikilink">cache</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4th/5th</p></td>
<td style="text-align: left;">
<p>1997</p></td>
<td style="text-align: left;">
<p><a class="uri" href="Am5x86" title="wikilink">Am5x86</a>, <a href="Cyrix_5x86" title="wikilink">Cyrix 5x86</a>, <a href="Pentium_OverDrive" title="wikilink">Pentium OverDrive</a></p></td>
<td style="text-align: left;">
<p>Partial Pentium's specification brought into the 486 platform</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5th</p></td>
<td style="text-align: left;">
<p>1993</p></td>
<td style="text-align: left;">
<p><a href="P5_(microarchitecture)" title="wikilink">Pentium</a>, <a href="Pentium_MMX" title="wikilink">Pentium MMX</a>, <a href="Rise_Technology" title="wikilink">Rise</a> <a class="uri" href="mP6" title="wikilink">mP6</a></p></td>
<td style="text-align: left;">
<p><a class="uri" href="Superscalar" title="wikilink">Superscalar</a> <a class="uri" href="64-bit" title="wikilink">64-bit</a> <a href="Bus_(computing)" title="wikilink">databus</a>, faster FPU, <a href="MMX_(instruction_set)" title="wikilink">MMX</a> (2× 32-bit)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5th/6th</p></td>
<td style="text-align: left;">
<p>1996</p></td>
<td style="text-align: left;">
<p><a href="AMD_K5" title="wikilink">AMD K5</a>, <a href="Cyrix_6x86" title="wikilink">Cyrix 6x86</a>, <a href="Cyrix_MII" title="wikilink">Cyrix MII</a>, <a href="Nx586" title="wikilink">Nx586 (1994)</a>, <a href="Integrated_Device_Technology" title="wikilink">IDT</a>/<a href="Centaur_Technology" title="wikilink">Centaur</a>-<a href="WinChip" title="wikilink">C6</a>, <a href="Cyrix_III" title="wikilink">Cyrix III</a>-Samuel, <a href="VIA_C3" title="wikilink">VIA C3</a>-Samuel2 / VIA C3-Ezra (2001)</p></td>
<td style="text-align: left;">
<p>discrete microarchitecture (μ-op translation)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6th</p></td>
<td style="text-align: left;">
<p>1997</p></td>
<td style="text-align: left;">
<p>AMD <a href="AMD_K6" title="wikilink">K6</a>/<a href="AMD_K6-2" title="wikilink">2</a>/<a href="AMD_K6-III" title="wikilink">III</a></p></td>
<td style="text-align: left;">
<p>L3-cache support, <a class="uri" href="3DNow!" title="wikilink">3DNow!</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1995</p></td>
<td style="text-align: left;">
<p><a href="Pentium_Pro" title="wikilink">Pentium Pro</a>, <a href="Cyrix_III" title="wikilink">Cyrix III</a>-Joshua (2000)</p></td>
<td style="text-align: left;">
<p>As above / 36-bit physical (<a href="Physical_Address_Extension" title="wikilink">PAE</a>)</p></td>
<td style="text-align: left;">
<p>μ-op translation, conditional move instructions, <a href="Out-of-order_execution" title="wikilink">Out-of-order</a> <a href="register_renaming" title="wikilink">register renaming</a>, <a href="speculative_execution" title="wikilink">speculative execution</a>, <a href="Physical_Address_Extension" title="wikilink">PAE</a> (Pentium Pro), in-package <a href="L2_cache" title="wikilink">L2 cache</a> (Pentium Pro)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1997</p></td>
<td style="text-align: left;">
<p><a href="Pentium_II" title="wikilink">Pentium II</a>/<a href="Pentium_III" title="wikilink">III</a></p></td>
<td style="text-align: left;">
<p><a href="Streaming_SIMD_Extensions" title="wikilink">SSE</a> (2× 64-bit)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6th/7th</p></td>
<td style="text-align: left;">
<p>2003</p></td>
<td style="text-align: left;">
<p><a href="Pentium_M" title="wikilink">Pentium M</a>, <a href="VIA_C7" title="wikilink">VIA C7</a> (2005), <a href="Intel_Core" title="wikilink">Intel Core</a> (2006)</p></td>
<td style="text-align: left;">
<p>Optimized for low <a href="thermal_design_power" title="wikilink">thermal design power</a>, four pumped FSB</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>7th</p></td>
<td style="text-align: left;">
<p>1999</p></td>
<td style="text-align: left;">
<p><a class="uri" href="Athlon" title="wikilink">Athlon</a>, <a href="Athlon_XP" title="wikilink">Athlon XP</a></p></td>
<td style="text-align: left;">
<p>Superscalar FPU, wide design (up to three x86 instr./clock)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2000</p></td>
<td style="text-align: left;">
<p><a href="Pentium_4" title="wikilink">Pentium 4</a></p></td>
<td style="text-align: left;">
<p>Deeply <a href="pipelining" title="wikilink">pipelined</a>, high frequency, <a class="uri" href="SSE2" title="wikilink">SSE2</a>, <a class="uri" href="hyper-threading" title="wikilink">hyper-threading</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>7/8th</p></td>
<td style="text-align: left;">
<p>2004</p></td>
<td style="text-align: left;">
<p>Pentium 4 <a href="Pentium4#Prescott" title="wikilink">Prescott</a>, <a href="Pentium_D" title="wikilink">Pentium D</a></p></td>
<td style="text-align: left;">
<p>64-bit / 40-bit physical</p></td>
<td style="text-align: left;">
<p>Very deeply <a href="pipelining" title="wikilink">pipelined</a>, very high frequency, <a class="uri" href="SSE3" title="wikilink">SSE3</a>, 64-bit capability (integer CPU) in LGA 775 sockets, CMT</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>8th</p></td>
<td style="text-align: left;">
<p>2006</p></td>
<td style="text-align: left;">
<p><a href="Intel_Core_2" title="wikilink">Intel Core 2</a></p></td>
<td style="text-align: left;">
<p>64-bit (integer CPU), low power, <a class="uri" href="multi-core" title="wikilink">multi-core</a>, lower clock frequency, <a class="uri" href="SSE4" title="wikilink">SSE4</a> (Penryn), wide dynamic execution, micro-op fusion, macro-uop fusion.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2008</p></td>
<td style="text-align: left;">
<p><a href="VIA_Nano" title="wikilink">VIA Nano</a></p></td>
<td style="text-align: left;">
<p><a href="Out-of-order_execution" title="wikilink">Out-of-order</a>, superscalar, 64-bit (integer CPU), <a href="hardware-based_encryption" title="wikilink">hardware-based encryption</a>; very low power; adaptive <a href="power_management" title="wikilink">power management</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2003</p></td>
<td style="text-align: left;">
<p><a href="Athlon_64" title="wikilink">Athlon 64</a>, <a class="uri" href="Opteron" title="wikilink">Opteron</a></p></td>
<td style="text-align: left;">
<p>As above / 40-bit physical</p></td>
<td style="text-align: left;">
<p><a href="x86-64" title="wikilink">x86-64 instruction set</a> (<a href="Central_processing_unit" title="wikilink">CPU</a> main integer core), on-die memory controller, <a class="uri" href="HyperTransport" title="wikilink">HyperTransport</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2007</p></td>
<td style="text-align: left;">
<p>AMD <a href="Phenom_(processor)" title="wikilink">Phenom</a>, <a href="AMD_Phenom_II" title="wikilink">AMD Phenom II</a> (2008)</p></td>
<td style="text-align: left;">
<p>As above / 48-bit physical</p></td>
<td style="text-align: left;">
<p>Monolithic quad-core, <a class="uri" href="SSE4a" title="wikilink">SSE4a</a>, HyperTransport 3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>8th/9th</p></td>
<td style="text-align: left;">
<p>2008</p></td>
<td style="text-align: left;">
<p><a href="Intel_Core_i3" title="wikilink">Intel Core i3</a>, <a href="Core_i5" title="wikilink">Core i5</a> and <a href="Core_i7" title="wikilink">Core i7</a></p></td>
<td style="text-align: left;">
<p>As above / 40-bit physical</p></td>
<td style="text-align: left;">
<p>QuickPath, native memory controller, on-die L3 cache, modular, GPGPU introduced onto CPU chip</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Intel_Atom" title="wikilink">Intel Atom</a></p></td>
<td style="text-align: left;">
<p>In-order but highly pipelined, very-low-power, some models with 32-bit (integer CPU), on-die GPU</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2011</p></td>
<td style="text-align: left;">
<p>AMD <a href="Bobcat_(processor)" title="wikilink">Bobcat</a></p></td>
<td style="text-align: left;">
<p><a href="Out-of-order_execution" title="wikilink">Out-of-order</a>, 64-bit (integer CPU), on-die GPU; low power (Bobcat)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AMD <a href="AMD_Fusion" title="wikilink">Llano</a></p></td>
<td style="text-align: left;">
<p>As above / 48-bit physical</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>9th (<a href="Graphics_processing_unit" title="wikilink">GPU</a>)</p></td>
<td style="text-align: left;">
<p>2011</p></td>
<td style="text-align: left;">
<p>AMD <a href="Bulldozer_(processor)" title="wikilink">Bulldozer and Trinity</a></p></td>
<td style="text-align: left;">
<p><a class="uri" href="SSE5" title="wikilink">SSE5</a>/<a href="Advanced_Vector_Extensions" title="wikilink">AVX</a> (4× 64-bit), highly modular design, integrated on-die <a href="Graphics_processing_unit" title="wikilink">GPU</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Intel <a href="Sandy_Bridge_(microarchitecture)" title="wikilink">Sandy Bridge</a> and <a href="Ivy_Bridge_(microarchitecture)" title="wikilink">Ivy Bridge</a></p></td>
<td style="text-align: left;">
<p>As above / 40-bit physical</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2013</p></td>
<td style="text-align: left;">
<p>Intel <a href="Haswell_(microarchitecture)" title="wikilink">Haswell</a></p></td>
<td style="text-align: left;">
<p>As above / 44-bit physical</p></td>
<td style="text-align: left;">
<p><a href="Advanced_Vector_Extensions_2" title="wikilink">AVX2</a>, <a href="FMA_instruction_set" title="wikilink">FMA3</a>, <a href="Transactional_Synchronization_Extensions" title="wikilink">TSX</a>, <a href="Bit_Manipulation_Instruction_Sets" title="wikilink">BMI1, and BMI2</a> instructions</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Others</p></td>
<td style="text-align: left;">
<p>2012</p></td>
<td style="text-align: left;">
<p>Intel <a href="Xeon_Phi" title="wikilink">Xeon Phi</a> (<a href="Larrabee_(microarchitecture)" title="wikilink">Larrabee</a>)</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>(<a href="Many_Integrated_Core" title="wikilink">MIC</a> pilot) Many Integrated Cores (62), In-order <a href="P5_(microarchitecture)" title="wikilink">P54C</a> with x86-64, very wide <a href="vector_processing" title="wikilink">vector unit</a>, LRBni instructions (8× 64-bit)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2000</p></td>
<td style="text-align: left;">
<p><a href="Transmeta_Crusoe" title="wikilink">Transmeta Crusoe</a>, <a href="Transmeta_Efficeon" title="wikilink">Transmeta Efficeon</a></p></td>
<td style="text-align: left;">
<p>32-bit ((14+32)-bit segmented) / 32-bit</p></td>
<td style="text-align: left;">
<p><a href="Very_long_instruction_word" title="wikilink">VLIW</a> design with x86 <a class="uri" href="emulator" title="wikilink">emulator</a>, on-die memory controller</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2001</p></td>
<td style="text-align: left;">
<p>Intel <a class="uri" href="Itanium" title="wikilink">Itanium</a> IA-32 compatibility mode</p></td>
<td style="text-align: left;">
<p>32-bit ((14+32)-bit segmented) / N/A</p></td>
<td style="text-align: left;">
<p><a href="Explicitly_parallel_instruction_computing" title="wikilink">EPIC</a> architecture with an on-package engine (pre-2006 chips, later using <a href="IA-32_Execution_Layer" title="wikilink">IA-32 Execution Layer</a>) that provides backward support for most IA-32 applications</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
<h2 id="history">History</h2>
<h3 id="background">Background</h3>

<p>The x86 architecture was first used for the <a href="Intel_8086" title="wikilink">Intel 8086</a> central processing unit (<a href="Central_processing_unit" title="wikilink">CPU</a>) released during 1978, a fully 16-bit design based on the earlier 8-bit based <a href="Intel_8008" title="wikilink">8008</a> and <a href="Intel_8080" title="wikilink">8080</a>. Although not <a href="binary_code_compatibility" title="wikilink">binary compatible</a>, it was designed to allow <a href="assembly_language" title="wikilink">assembly language</a> programs written for these processors (as well as the contemporary <a class="uri" href="8085" title="wikilink">8085</a>) to be mechanically translated into equivalent <a href="x86_assembly_language" title="wikilink">8086 assembly</a>. This made the new processor a tempting software migration route for many customers.</p>

<p>However, the 16-bit external data bus of the 8086 implied fairly significant hardware redesign, as well as other complications and expenses. To address this obstacle, Intel introduced the almost identical <a href="Intel_8088" title="wikilink">8088</a>, basically an 8086 with an 8-bit external databus that permitted simpler <a href="printed_circuit_board" title="wikilink">printed circuit boards</a> and demanded fewer (1-bit wide) <a class="uri" href="DRAM" title="wikilink">DRAM</a> chips; it was also more easily interfaced to already established (i.e. low-cost) 8-bit system and peripheral chips. Among other, non-technical factors, this contributed to IBM's decision to design a <a href="personal_computer" title="wikilink">personal computer</a> based on the 8088, despite the presence of 16-bit microprocessors from Motorola, Zilog, National Semiconductor and others, as well as several established 8-bit processors that were also considered. Largely as a result of IBM's position and historical reputation as a strong and dominant computer company, the resulting <a href="IBM_PC" title="wikilink">IBM PC</a> subsequently became preferred to <a class="uri" href="Z80" title="wikilink">Z80</a>-based <a class="uri" href="CP/M" title="wikilink">CP/M</a> systems, <a href="Apple_II" title="wikilink">Apple IIs</a>, and other popular computers as the <a href="de_facto_standard" title="wikilink">de facto standard</a> for personal computers, thus enabling the 8088 and its successors to dominate this large part of the microprocessor market.</p>
<h4 id="iapx-432-and-the-80286">iAPX 432 and the 80286</h4>

<p>Another factor was that the advanced but non-compatible 32-bit <a href="IAPX_432" title="wikilink">Intel 8800</a> (alias iAPX 432) failed in the market around the time the original IBM-PC was initiated; the new and fast <a href="Intel_80286" title="wikilink">80286</a> actually contributed to the disappointment in the performance of the semi-contemporary 8800 during early 1982. (The <a href="Intel_80186" title="wikilink">80186</a>, initiated simultaneously with the 80286, was intended for <a href="embedded_systems" title="wikilink">embedded systems</a>, and would therefore have had a large market anyway.) The market failure of the 32-bit 8800 was a significant impetus for Intel to continue to develop more advanced 8086-compatible processors instead, such as the <a href="Intel_80386" title="wikilink">80386</a> (a 32-bit extension of the well performing 80286).</p>
<h3 id="other-manufacturers">Other manufacturers</h3>

<p> </p>

<p>At various times, companies such as <a class="uri" href="IBM" title="wikilink">IBM</a>, <a class="uri" href="NEC" title="wikilink">NEC</a>, <a class="uri" href="AMD" title="wikilink">AMD</a>, <a href="Texas_Instruments" title="wikilink">TI</a>, <a href="STMicroelectronics" title="wikilink">STM</a>, <a class="uri" href="Fujitsu" title="wikilink">Fujitsu</a>, <a href="Oki_Electric_Industry" title="wikilink">OKI</a>, <a href="Siemens_AG" title="wikilink">Siemens</a>, <a class="uri" href="Cyrix" title="wikilink">Cyrix</a>, <a class="uri" href="Intersil" title="wikilink">Intersil</a>, <a href="Chips_and_Technologies" title="wikilink">C&amp;T;</a>, <a class="uri" href="NexGen" title="wikilink">NexGen</a>, <a href="United_Microelectronics_Corporation" title="wikilink">UMC</a>, and <a class="uri" href="DM&amp;P;" title="wikilink">DM&amp;P;</a> started to design or manufacture x86 <a href="central_processing_unit" title="wikilink">processors</a> (CPUs) intended for personal computers as well as embedded systems. Such x86 implementations are seldom simple copies but often employ different internal <a href="microarchitecture" title="wikilink">microarchitectures</a> as well as different solutions at the electronic and physical levels. Quite naturally, early compatible microprocessors were 16-bit, while 32-bit designs were developed much later. For the <a href="personal_computer" title="wikilink">personal computer</a> market, real quantities started to appear around 1990 with <a class="uri" href="i386" title="wikilink">i386</a> and <a class="uri" href="i486" title="wikilink">i486</a> compatible processors, often named similarly to Intel's original chips. Other companies, which designed or manufactured x86 or <a class="uri" href="x87" title="wikilink">x87</a> processors, include <a href="ITT_Corporation" title="wikilink">ITT Corporation</a>, <a href="National_Semiconductor" title="wikilink">National Semiconductor</a>, <a href="ULSI_System_Technology" title="wikilink">ULSI System Technology</a>, and <a class="uri" href="Weitek" title="wikilink">Weitek</a>.</p>

<p>Following the fully <a href="pipelining" title="wikilink">pipelined</a> <a class="uri" href="i486" title="wikilink">i486</a>, <a href="Intel_Corporation" title="wikilink">Intel</a> introduced the <a href="Pentium_(brand)" title="wikilink">Pentium</a> brand name (which, unlike numbers, could be <a href="trademark" title="wikilink">trademarked</a>) for their new set of <a class="uri" href="superscalar" title="wikilink">superscalar</a> x86 designs; with the x86 naming scheme now legally cleared, other x86 vendors had to choose different names for their x86-compatible products, and initially some chose to continue with variations of the numbering scheme: <a class="uri" href="IBM" title="wikilink">IBM</a> partnered with <a class="uri" href="Cyrix" title="wikilink">Cyrix</a> to produce the <a href="Cyrix_Cx5x86" title="wikilink">5x86</a> and then the very efficient <a class="uri" href="6x86" title="wikilink">6x86</a> (M1) and <a href="6x86" title="wikilink">6x86MX</a> (<a href="Cyrix_6x86" title="wikilink">MII</a>) lines of Cyrix designs, which were the first x86 microprocessors implementing <a href="register_renaming" title="wikilink">register renaming</a> to enable <a href="speculative_execution" title="wikilink">speculative execution</a>. AMD meanwhile designed and manufactured the advanced but delayed <a class="uri" href="5k86" title="wikilink">5k86</a> (<a href="AMD_K5" title="wikilink">K5</a>), which, <em>internally</em>, was closely based on AMD's earlier <a class="uri" href="29K" title="wikilink">29K</a> <a class="uri" href="RISC" title="wikilink">RISC</a> design; similar to <a class="uri" href="NexGen" title="wikilink">NexGen</a>'s <a class="uri" href="Nx586" title="wikilink">Nx586</a>, it used a strategy such that dedicated pipeline stages decode x86 instructions into uniform and easily handled <a href="micro-operation" title="wikilink">micro-operations</a>, a method that has remained the basis for most x86 designs to this day.</p>

<p>Some early versions of these microprocessors had heat dissipation problems. The 6x86 was also affected by a few minor compatibility problems, the <a class="uri" href="Nx586" title="wikilink">Nx586</a> lacked a <a href="floating_point_unit" title="wikilink">floating point unit</a> (FPU) and (the then crucial) pin-compatibility, while the <a href="AMD_K5" title="wikilink">K5</a> had somewhat disappointing performance when it was (eventually) introduced. Customer ignorance of alternatives to the Pentium series further contributed to these designs being comparatively unsuccessful, despite the fact that the <a href="AMD_K5" title="wikilink">K5</a> had very good Pentium compatibility and the <a class="uri" href="6x86" title="wikilink">6x86</a> was significantly faster than the Pentium on integer code. <a class="uri" href="AMD" title="wikilink">AMD</a> later managed to establish itself as a serious contender with the <a href="AMD_K6" title="wikilink">K6</a> set of processors, which gave way to the very successful <a class="uri" href="Athlon" title="wikilink">Athlon</a> and <a class="uri" href="Opteron" title="wikilink">Opteron</a>. There were also other contenders, such as <a href="Centaur_Technology" title="wikilink">Centaur Technology</a> (formerly <a href="Integrated_Device_Technology" title="wikilink">IDT</a>), <a href="Rise_Technology" title="wikilink">Rise Technology</a>, and <a class="uri" href="Transmeta" title="wikilink">Transmeta</a>. <a href="VIA_Technologies" title="wikilink">VIA Technologies</a>' energy efficient <a href="VIA_C3" title="wikilink">C3</a> and <a href="VIA_C7" title="wikilink">C7</a> processors, which were designed by the <a href="Centaur_Technology" title="wikilink">Centaur</a> company, have been sold for many years. Centaur's newest design, the <a href="VIA_Nano" title="wikilink">VIA Nano</a>, is their first processor with <a class="uri" href="superscalar" title="wikilink">superscalar</a> and <a href="speculative_execution" title="wikilink">speculative execution</a>. It was, perhaps interestingly, introduced at about the same time as Intel's first "in-order" processor since the <a href="P5_(microarchitecture)" title="wikilink">P5</a> <a href="Pentium_(brand)" title="wikilink">Pentium</a>, the <a href="Intel_Atom" title="wikilink">Intel Atom</a>.</p>
<h3 id="extensions-of-word-size">Extensions of word size</h3>

<p>The <a href="instruction_set_architecture" title="wikilink">instruction set architecture</a> has twice been extended to a larger <a href="Word_(data_type)" title="wikilink">word size</a>. In 1985, Intel released the 32-bit 80386 (later known as i386) which gradually replaced the earlier 16-bit chips in computers (although typically not in <a href="embedded_system" title="wikilink">embedded systems</a>) during the following years; this extended programming model was originally referred to as <em>the i386 architecture</em> (like its first implementation) but Intel later dubbed it <a class="uri" href="IA-32" title="wikilink">IA-32</a> when introducing its (unrelated) <a class="uri" href="IA-64" title="wikilink">IA-64</a> architecture.</p>

<p>In 1999-2003, <a href="Advanced_Micro_Devices" title="wikilink">AMD</a> extended this 32-bit architecture to 64 bits and referred to it as <a class="uri" href="x86-64" title="wikilink">x86-64</a> in early documents and later as <a class="uri" href="AMD64" title="wikilink">AMD64</a>. Intel soon adopted AMD's architectural extensions under the name IA-32e, later using the name EM64T and finally using Intel 64. <a class="uri" href="Microsoft" title="wikilink">Microsoft</a> and <a href="Sun_Microsystems" title="wikilink">Sun Microsystems</a> also use term "x64", while many <a href="Linux_distribution" title="wikilink">Linux distributions</a> also use the "amd64" term. Microsoft Windows, for example, designates its 32-bit versions as "x86" and 64-bit versions as "x64", while installation files of 64-bit Windows versions are required to be placed into a directory called "AMD64".<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="overview-1">Overview</h2>
<h3 id="basic-properties-of-the-architecture">Basic properties of the architecture</h3>

<p>The x86 architecture is a variable instruction length, primarily "<a href="Complex_instruction_set_computer" title="wikilink">CISC</a>" design with emphasis on <a href="backward_compatibility" title="wikilink">backward compatibility</a>. The instruction set is not typical CISC, however, but basically an extended version of the simple eight-bit <a href="Intel_8008" title="wikilink">8008</a> and <a href="Intel_8080" title="wikilink">8080</a> architectures. Byte-addressing is enabled and words are stored in memory with <a href="endianness" title="wikilink">little-endian</a> byte order. Memory access to unaligned addresses is allowed for all valid word sizes. The largest native size for <a href="integer_(computing)" title="wikilink">integer</a> <em>arithmetic</em> and memory addresses (or <a href="offset_(computer_science)" title="wikilink">offsets</a>) is 16, 32 or 64 bits depending on architecture generation (newer processors include direct support for smaller integers as well). Multiple scalar values can be handled simultaneously via the SIMD unit present in later generations, as described below. Immediate addressing offsets and immediate data may be expressed as 8-bit quantities for the frequently occurring cases or contexts where a -128..127 range is enough. Typical instructions are therefore 2 or 3 bytes in length (although some are much longer, and some are single-byte).</p>

<p>To further conserve encoding space, most registers are expressed in opcodes using three or four bits, the latter via an opcode prefix in 64-bit mode, while at most one operand to an instruction can be a memory location. However, this memory operand may also be the <em>destination</em> (or a combined source <em>and</em> destination), while the other operand, the <em>source</em>, can be either <em>register</em> or <em>immediate</em>. Among other factors, this contributes to a code size that rivals eight-bit machines and enables efficient use of instruction cache memory. The relatively small number of general registers (also inherited from its 8-bit ancestors) has made register-relative addressing (using small immediate offsets) an important method of accessing operands, especially on the stack. Much work has therefore been invested in making such accesses as fast as register accesses, i.e. a one cycle instruction throughput, in most circumstances where the accessed data is available in the top-level cache.</p>
<h4 id="floating-point-and-simd">Floating point and SIMD</h4>

<p>A dedicated <a href="floating_point_processor" title="wikilink">floating point processor</a> with 80-bit internal registers, the <a href="Intel_8087" title="wikilink">8087</a>, was developed for the original <a class="uri" href="8086" title="wikilink">8086</a>. This microprocessor subsequently developed into the extended <a class="uri" href="80387" title="wikilink">80387</a>, and later processors incorporated a <a href="backward_compatible" title="wikilink">backward compatible</a> version of this functionality on the same microprocessor as the main processor. In addition to this, modern x86 designs also contain a <a class="uri" href="SIMD" title="wikilink">SIMD</a>-unit (see <a href="Streaming_SIMD_Extensions" title="wikilink">SSE</a> below) where instructions can work in parallel on (one or two) 128-bit words, each containing 2 or 4 <a href="floating_point_number" title="wikilink">floating point numbers</a> (each 64 or 32 bits wide respectively), or alternatively, 2, 4, 8 or 16 integers (each 64, 32, 16 or 8 bits wide respectively).</p>

<p>The presence of wide SIMD registers means that existing x86 processors can load or store up to 128 bits of memory data in a single instruction and also perform bitwise operations (although not integer arithmetic) on full 128-bits quantities in parallel. Intel's <a href="Sandy_Bridge" title="wikilink">Sandy Bridge</a> processors added the AVX (Advanced Vector Extensions) instructions. widening the SIMD registers to 256 bits. Knights Corner, the architecture used by Intel on their Xeon Phi co-processors, uses 512-bit wide SIMD registers.</p>
<h3 id="current-implementations">Current implementations</h3>

<p>During <a href="Execution_(computers)" title="wikilink">execution</a>, current x86 processors employ a few extra decoding steps to split most instructions into smaller pieces called micro-operations. These are then handed to a <a href="control_unit" title="wikilink">control unit</a> that buffers and schedules them in compliance with x86-semantics so that they can be executed, partly in parallel, by one of several (more or less specialized) <a href="execution_units" title="wikilink">execution units</a>. These modern x86 designs are thus <a class="uri" href="superscalar" title="wikilink">superscalar</a>, and also capable of <a href="out_of_order_execution" title="wikilink">out of order</a> and <a href="speculative_execution" title="wikilink">speculative execution</a> (via <a href="register_renaming" title="wikilink">register renaming</a>), which means they may execute multiple (partial or complete) x86 instructions simultaneously, and not necessarily in the same order as given in the instruction stream.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>When introduced, in the mid-1990s, this method was sometimes referred to as a "RISC core" or as "RISC translation", partly for marketing reasons, but also because these micro-operations share some properties with certain types of RISC instructions. However, <em>traditional</em> <a class="uri" href="microcode" title="wikilink">microcode</a> (used since the 1950s) also inherently shares many of the same properties; the new method differs mainly in that the translation to micro-operations now occurs asynchronously. Not having to synchronize the execution units with the decode steps opens up possibilities for more analysis of the (buffered) code stream, and therefore permits detection of operations that can be performed in parallel, simultaneously feeding more than one execution unit.</p>

<p>The latest processors also do the opposite when appropriate; they combine certain x86 sequences (such as a compare followed by a conditional jump) into a more complex micro-op which fits the execution model better and thus can be executed faster or with less machine resources involved.</p>

<p>Another way to try to improve performance is to cache the decoded micro-operations, so the processor can directly access the decoded micro-operations from a special cache, instead of decoding them again. Intel followed this approach with the Execution Trace Cache feature in their NetBurst Microarchitecture (for Pentium 4 processors) and later in the Decoded Stream Buffer (for Core-branded processors since Sandy Bridge).<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p><a class="uri" href="Transmeta" title="wikilink">Transmeta</a> used a completely different method in their x86 compatible CPUs. They used <a href="Just-in-time_compilation" title="wikilink">just-in-time</a> translation to convert x86 instructions to the CPU's native <a class="uri" href="VLIW" title="wikilink">VLIW</a> instruction set. Transmeta argued that their approach allows for more power efficient designs since the CPU can forgo the complicated decode step of more traditional x86 implementations.</p>
<h2 id="segmentation">Segmentation</h2>

<p>Minicomputers during the late 1970s were running up against the 16-bit 64-<a href="kilobyte" title="wikilink">KB</a> address limit, as memory had become cheaper. Some minicomputers like the <a class="uri" href="PDP-11" title="wikilink">PDP-11</a> used complex bank-switching schemes, or, in the case of Digital's <a class="uri" href="VAX" title="wikilink">VAX</a>, redesigned much more expensive processors which could directly handle 32-bit addressing and data. The original 8086, developed from the simple <a href="Intel_8080" title="wikilink">8080</a> microprocessor and primarily aiming at very small and inexpensive computers and other specialized devices, instead adopted simple segment registers which increased the memory address width by only 4 bits. By multiplying a 64-KB address by 16, the 20-bit address could address a total of one <a class="uri" href="megabyte" title="wikilink">megabyte</a> (1,048,576 bytes) which was quite a large amount for a small computer at the time. The concept of segment registers was not new to many mainframes which used segment registers to swap quickly to different tasks. In practice, on the x86 it was (is) a much-criticized implementation which greatly complicated many common programming tasks and compilers. However, the architecture soon allowed <a href="Linear_addressing" title="wikilink">linear</a> 32-bit addressing (starting with the 80386 in late 1985) but major actors (such as <a class="uri" href="Microsoft" title="wikilink">Microsoft</a>) took several years to convert their 16-bit based systems. The 80386 (and 80486) was therefore largely used as a fast (but still 16-bit based) 8086 for many years.</p>

<p>Data and code could be managed within "near" 16-bit segments within 64 KB portions of the total 1 <a href="megabyte" title="wikilink">MB</a> address space, or a compiler could operate in a "far" mode using 32-bit <code>segment:offset</code> pairs reaching (only) 1 MB. While that would also prove to be quite limiting by the mid-1980s, it was working for the emerging PC market, and made it very simple to translate software from the older <a href="Intel_8008" title="wikilink">8008</a>, <a href="Intel_8080" title="wikilink">8080</a>, <a href="Intel_8085" title="wikilink">8085</a>, and <a class="uri" href="Z80" title="wikilink">Z80</a> to the newer processor. During 1985, the 16-bit segment addressing model was effectively factored out by the introduction of 32-bit offset registers, in the <a href="Intel_80386" title="wikilink">386</a> design.</p>

<p>In <a href="real_mode" title="wikilink">real mode</a>, segmentation is achieved by <a href="Bit_shift" title="wikilink">shifting</a> the segment address left by 4 bits and adding an offset in order to receive a final 20-bit address. For example, if DS is A000h and SI is 5677h, DS:SI will point at the absolute address DS × 10h + SI = A5677h. Thus the total address space in real mode is 2<sup>20</sup> bytes, or 1 <a href="megabyte" title="wikilink">MB</a>, quite an impressive figure for 1978. All memory addresses consist of both a segment and offset; every type of access (code, data, or stack) has a default segment register associated with it (for data the register is usually DS, for code it is CS, and for stack it is SS). For data accesses, the segment register can be explicitly specified (using a segment override prefix) to use any of the four segment registers.</p>

<p>In this scheme, two different segment/offset pairs can point at a single absolute location. Thus, if DS is A111h and SI is 4567h, DS:SI will point at the same A5677h as above. This scheme makes it impossible to use more than four segments at once. CS and SS are vital for the correct functioning of the program, so that only DS and ES can be used to point to data segments outside the program (or, more precisely, outside the currently executing segment of the program) or the stack.</p>

<p>In <a href="protected_mode" title="wikilink">protected mode</a>, a segment register no longer contains the physical address of the beginning of a segment, but contain a "selector" that points to a system-level structure called a <em>segment descriptor</em>. A segment descriptor contains the physical address of the beginning of the segment, the length of the segment, and access permissions to that segment. The offset is checked against the length of the segment, with offsets referring to locations outside the segment causing an exception. Offsets referring to locations inside the segment are combined with the physical address of the beginning of the segment to get the physical address corresponding to that offset.</p>

<p>The segmented nature can make programming and compiler design difficult because the use of near and far pointers affects performance.</p>
<h2 id="addressing-modes">Addressing modes</h2>

<p><a href="Addressing_mode" title="wikilink">Addressing modes</a> for 16-bit x86 processors can be summarized by this formula:</p>

<p>

<math display="block" id="X86:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>C</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>D</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>S</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>E</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>B</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>B</mi>
             <mi>P</mi>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>}</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>{</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mi>S</mi>
            <mi>I</mi>
           </mrow>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mi>D</mi>
            <mi>I</mi>
           </mrow>
          </mtd>
         </mtr>
        </mtable>
        <mo>}</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>displacement</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>C</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <matrix>
        <matrixrow>
         <apply>
          <times></times>
          <ci>B</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>B</ci>
          <ci>P</ci>
         </apply>
        </matrixrow>
       </matrix>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <matrix>
       <matrixrow>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>I</ci>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>I</ci>
        </apply>
       </matrixrow>
      </matrix>
     </matrixrow>
    </matrix>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>displacement</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{Bmatrix}CS:\\
DS:\\
SS:\\
ES:\end{Bmatrix}\begin{bmatrix}\begin{Bmatrix}BX\\
BP\end{Bmatrix}\end{bmatrix}+\begin{bmatrix}\begin{Bmatrix}SI\\
DI\end{Bmatrix}\end{bmatrix}+\rm[displacement]
  </annotation>
 </semantics>
</math>

</p>

<p>Addressing modes for 32-bit address size on 32-bit or 64-bit x86 processors can be summarized by this formula:<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>

<math display="block" id="X86:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>C</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>D</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>S</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>E</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>F</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>G</mi>
          <mi>S</mi>
         </mrow>
         <mo>:</mo>
         <mi></mi>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>A</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>B</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>C</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>D</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>S</mi>
             <mi>P</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>B</mi>
             <mi>P</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>S</mi>
             <mi>I</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>D</mi>
             <mi>I</mi>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>}</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>A</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>B</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>C</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>D</mi>
             <mi>X</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>B</mi>
             <mi>P</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>S</mi>
             <mi>I</mi>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mi>E</mi>
             <mi>D</mi>
             <mi>I</mi>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>}</mo>
        </mrow>
        <mo>*</mo>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>2</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>4</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>8</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>}</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>displacement</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>C</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <times></times>
         <ci>G</ci>
         <ci>S</ci>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <matrix>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>A</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>B</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>C</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>D</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>S</ci>
          <ci>P</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>B</ci>
          <ci>P</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>S</ci>
          <ci>I</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>D</ci>
          <ci>I</ci>
         </apply>
        </matrixrow>
       </matrix>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>A</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>B</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>C</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>D</ci>
          <ci>X</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>B</ci>
          <ci>P</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>S</ci>
          <ci>I</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>D</ci>
          <ci>I</ci>
         </apply>
        </matrixrow>
       </matrix>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">2</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">4</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">8</cn>
        </matrixrow>
       </matrix>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>displacement</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{Bmatrix}CS:\\
DS:\\
SS:\\
ES:\\
FS:\\
GS:\end{Bmatrix}\begin{bmatrix}\begin{Bmatrix}EAX\\
EBX\\
ECX\\
EDX\\
ESP\\
EBP\\
ESI\\
EDI\end{Bmatrix}\end{bmatrix}+\begin{bmatrix}\begin{Bmatrix}EAX\\
EBX\\
ECX\\
EDX\\
EBP\\
ESI\\
EDI\end{Bmatrix}*\begin{Bmatrix}1\\
2\\
4\\
8\end{Bmatrix}\end{bmatrix}+\rm[displacement]
  </annotation>
 </semantics>
</math>

</p>

<p>Addressing modes for 64-bit code on 64-bit x86 processors can be summarized by this formula:</p>

<p>

<math display="block" id="X86:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mrow>
          <mo>{</mo>
          <mtable displaystyle="true">
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <mrow>
               <mi>F</mi>
               <mi>S</mi>
              </mrow>
              <mo>:</mo>
              <mi></mi>
             </mrow>
            </mtd>
           </mtr>
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <mrow>
               <mi>G</mi>
               <mi>S</mi>
              </mrow>
              <mo>:</mo>
              <mi></mi>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>}</mo>
         </mrow>
         <mrow>
          <mo>[</mo>
          <mtable displaystyle="true">
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <mpadded width="+2.8pt">
               <mi>general</mi>
              </mpadded>
              <mi>register</mi>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>]</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mrow>
              <mpadded width="+2.8pt">
               <mi>general</mi>
              </mpadded>
              <mi>register</mi>
             </mrow>
             <mo>*</mo>
             <mrow>
              <mo>{</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="center">
                 <mn>1</mn>
                </mtd>
               </mtr>
               <mtr>
                <mtd columnalign="center">
                 <mn>2</mn>
                </mtd>
               </mtr>
               <mtr>
                <mtd columnalign="center">
                 <mn>4</mn>
                </mtd>
               </mtr>
               <mtr>
                <mtd columnalign="center">
                 <mn>8</mn>
                </mtd>
               </mtr>
              </mtable>
              <mo>}</mo>
             </mrow>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>R</mi>
        <mi>I</mi>
        <mi>P</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>}</mo>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>displacement</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <matrix>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <matrix>
         <matrixrow>
          <apply>
           <ci>normal-:</ci>
           <apply>
            <times></times>
            <ci>F</ci>
            <ci>S</ci>
           </apply>
           <csymbol cd="latexml">absent</csymbol>
          </apply>
         </matrixrow>
         <matrixrow>
          <apply>
           <ci>normal-:</ci>
           <apply>
            <times></times>
            <ci>G</ci>
            <ci>S</ci>
           </apply>
           <csymbol cd="latexml">absent</csymbol>
          </apply>
         </matrixrow>
        </matrix>
        <matrix>
         <matrixrow>
          <apply>
           <times></times>
           <ci>general</ci>
           <ci>register</ci>
          </apply>
         </matrixrow>
        </matrix>
       </apply>
       <matrix>
        <matrixrow>
         <apply>
          <times></times>
          <apply>
           <times></times>
           <ci>general</ci>
           <ci>register</ci>
          </apply>
          <matrix>
           <matrixrow>
            <cn type="integer">1</cn>
           </matrixrow>
           <matrixrow>
            <cn type="integer">2</cn>
           </matrixrow>
           <matrixrow>
            <cn type="integer">4</cn>
           </matrixrow>
           <matrixrow>
            <cn type="integer">8</cn>
           </matrixrow>
          </matrix>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>I</ci>
       <ci>P</ci>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>displacement</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{Bmatrix}\begin{Bmatrix}FS:\\
GS:\end{Bmatrix}\begin{bmatrix}{\rm general\;register}\end{bmatrix}+\begin{%
bmatrix}{\rm general\;register}*\begin{Bmatrix}1\\
2\\
4\\
8\end{Bmatrix}\end{bmatrix}\\
\\
RIP\end{Bmatrix}+\rm[displacement]
  </annotation>
 </semantics>
</math>

</p>

<p>Instruction relative addressing in 64-bit code (RIP + displacement, where RIP is the instruction pointer register) simplifies the implementation of <a href="position-independent_code" title="wikilink">position-independent code</a> (as used in <a href="shared_libraries" title="wikilink">shared libraries</a> in some operating systems).</p>

<p>The 8086 had 64 KB of 8-bit (or alternatively 32 K-word of 16-bit) <a class="uri" href="I/O" title="wikilink">I/O</a> space, and a 64 KB (one segment) <a href="Stack_(data_structure)" title="wikilink">stack</a> in memory supported by <a href="computer_hardware" title="wikilink">computer hardware</a>. Only words (2 bytes) can be pushed to the stack. The stack grows downwards (toward numerically lower addresses), its bottom being pointed by SS:SP. There are 256 <a href="interrupt" title="wikilink">interrupts</a>, which can be invoked by both hardware and software. The interrupts can cascade, using the stack to store the <a href="Return_statement" title="wikilink">return address</a>.</p>
<h2 id="x86-registers">x86 registers</h2>

<p><em>For a description of the general notion of a CPU register, see <a href="Processor_register" title="wikilink">Processor register</a>.</em></p>
<h3 id="bit">16-bit</h3>

<p>The original <a href="Intel_8086" title="wikilink">Intel 8086</a> and <a href="Intel_8088" title="wikilink">8088</a> have fourteen 16-<a class="uri" href="bit" title="wikilink">bit</a> registers. Four of them (AX, BX, CX, DX) are general-purpose registers (GPRs), although each may have an additional purpose; for example, only CX can be used as a counter with the <em>loop</em> instruction. Each can be accessed as two separate bytes (thus BX's high byte can be accessed as BH and low byte as BL). Two pointer registers have special roles: SP (stack pointer) points to the "top" of the <a href="stack_(data_structure)" title="wikilink">stack</a>, and BP (base pointer) is often used to point at some other place in the stack, typically above the local variables (see <a href="frame_pointer" title="wikilink">frame pointer</a>). The registers SI, DI, BX and BP are <a href="address_register" title="wikilink">address registers</a>, and may also be used for array indexing.</p>

<p>Four segment registers (CS, DS, SS and ES) are used to form a memory address. The <a href="FLAGS_register_(computing)" title="wikilink">FLAGS register</a> contains <a href="Flag_(computing)" title="wikilink">flags</a> such as <a href="carry_flag" title="wikilink">carry flag</a>, <a href="overflow_flag" title="wikilink">overflow flag</a> and <a href="zero_flag" title="wikilink">zero flag</a>. Finally, the instruction pointer (IP) points to the next instruction that will be fetched from memory and then executed; this register cannot be directly accessed (read or written) by a program.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The <a href="Intel_80186" title="wikilink">Intel 80186</a> and <a href="Intel_80188" title="wikilink">80188</a> are essentially an upgraded 8086 or 8088 CPU, respectively, with on-chip peripherals added, and they have the same CPU registers as the 8086 and 8088 (in addition to interface registers for the peripherals).</p>

<p>The 8086, 8088, 80186, and 80188 can use an optional floating-point coprocessor, the <a href="Intel_8087" title="wikilink">8087</a>. The 8087 appears to the programmer as part of the CPU and adds eight 80-bit wide registers, st(0) to st(7), each of which can hold numeric data in one of seven formats: 32-, 64-, or 80-bit floating point, 16-, 32-, or 64-bit (binary) integer, and 80-bit packed decimal integer.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>In the <a href="Intel_80286" title="wikilink">Intel 80286</a>, to support <a href="protected_mode" title="wikilink">protected mode</a>, three special registers hold descriptor table addresses (GDTR, LDTR, <a href="Interrupt_descriptor_table" title="wikilink">IDTR</a>), and a fourth task register (TR) is used for task switching. The <a href="Intel_80287" title="wikilink">80287</a> is the floating-point coprocessor for the 80286 and has the same registers as the 8087 with the same data formats.</p>
<h3 id="bit-1">32-bit</h3>

<p><a href="File:Table_of_x86_Registers_svg.svg" title="wikilink">thumb|right|upright=2.1|Registers available in the x86 instruction set</a></p>

<p>With the advent of the 32-bit <a href="Intel_80386" title="wikilink">80386</a> processor, the 16-bit general-purpose registers, base registers, index registers, instruction pointer, and <a href="FLAGS_register" title="wikilink">FLAGS register</a>, but not the segment registers, were expanded to 32 bits. This is represented by prefixing an "E" (for "extended") to the register names in <a href="x86_assembly_language" title="wikilink">x86 assembly language</a>. Thus, the AX register corresponds to the lowest 16 bits of the new 32-bit EAX register, SI corresponds to the lowest 16 bits of ESI, and so on. The general-purpose registers, base registers, and index registers can all be used as the base in addressing modes, and all of those registers except for the stack pointer can be used as the index in addressing modes.</p>

<p>Two new segment registers (FS and GS) were added. With a greater number of registers, instructions and operands, the <a href="machine_code" title="wikilink">machine code</a> format was expanded. To provide backward compatibility, segments with executable code can be marked as containing either 16-bit or 32-bit instructions. Special prefixes allow inclusion of 32-bit instructions in a 16-bit segment or vice versa.</p>

<p>The 80386 had an optional floating-point coprocessor, the <a class="uri" href="80387" title="wikilink">80387</a>; it had eight 80-bit wide registers: st(0) to st(7),<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> like the 8087 and 80287. (The 80386 could also use an 80287 coprocessor.) With the <a class="uri" href="80486" title="wikilink">80486</a> and all subsequent x86 models, the floating-point processing unit (FPU) was integrated on-chip.</p>

<p>With the <a href="Pentium_MMX" title="wikilink">Pentium MMX</a>, eight 64-bit MMX integer registers were added (MMX0 to MMX7, which share lower bits with the 80-bit-wide FPU stack).<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> With the <a href="Pentium_III" title="wikilink">Pentium III</a>, a 32-bit <a href="Streaming_SIMD_Extensions" title="wikilink">Streaming SIMD Extensions</a> (SSE) control/status register (MXCSR) and eight 128-bit SSE floating point registers (XMM0 to XMM7) were added.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="bit-2">64-bit</h3>

<p>Starting with the <a href="AMD_Opteron" title="wikilink">AMD Opteron</a> processor, the x86 architecture extended the 32-bit registers into 64-bit registers in a way similar to how the 16 to 32-bit extension took place. An <strong>R</strong>-prefix identifies the 64-bit registers (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, RFLAGS, RIP), and eight additional 64-bit general registers (R8-R15) were also introduced in the creation of <a class="uri" href="x86-64" title="wikilink">x86-64</a>. However, these extensions are only usable in 64-bit mode, which is one of the two modes only available in <a href="long_mode" title="wikilink">long mode</a>. The addressing modes were not dramatically changed from 32-bit mode, except that addressing was extended to 64 bits, virtual addresses are now sign extended to 64 bits (in order to disallow mode bits in virtual addresses), and other selector details were dramatically reduced. In addition, an addressing mode was added to allow memory references relative to RIP (the <a href="instruction_pointer" title="wikilink">instruction pointer</a>), to ease the implementation of <a href="position-independent_code" title="wikilink">position-independent code</a>, used in shared libraries in some operating systems.</p>
<h3 id="bit-3">128-bit</h3>

<p>SIMD registers XMM0–XMM15.</p>
<h3 id="bit-4">256-bit</h3>

<p>SIMD registers YMM0–YMM15.</p>
<h3 id="bit-5">512-bit</h3>

<p>SIMD registers ZMM0–ZMM31.</p>
<h3 id="miscellaneousspecial-purpose">Miscellaneous/special purpose</h3>

<p>x86 processors that have a <a href="protected_mode" title="wikilink">protected mode</a>, i.e. the 80286 and later processors, also have three descriptor registers (GDTR, LDTR, <a href="Interrupt_descriptor_table" title="wikilink">IDTR</a>) and a task register (TR).</p>

<p>32-bit x86 processors (starting with the 80386) also include various special/miscellaneous registers such as <a href="control_register" title="wikilink">control registers</a> (CR0 through 4, CR8 for 64-bit only), <a href="debug_register" title="wikilink">debug registers</a> (DR0 through 3, plus 6 and 7), <a href="test_register" title="wikilink">test registers</a> (TR3 through 7; 80486 only), and model-specific registers (MSRs, appearing with the Pentium).</p>
<h3 id="purpose">Purpose</h3>

<p>Although the main registers (with the exception of the instruction pointer) are "general-purpose" in the 32-bit and 64-bit versions of the instruction set and can be used for anything, it was originally envisioned that they be used for the following purposes:</p>
<ul>
<li>AL/AH/AX/EAX/RAX: Accumulator</li>
<li>BL/BH/BX/EBX/RBX: Base index (for use with arrays)</li>
<li>CL/CH/CX/ECX/RCX: Counter (for use with loops and strings)</li>
<li>DL/DH/DX/EDX/RDX: Extend the precision of the accumulator (e.g. combine 32-bit EAX and EDX for 64-bit integer operations in 32-bit code)</li>
<li>SI/ESI/RSI: <em>Source index</em> for <a href="string_(computer_science)" title="wikilink">string</a> operations.</li>
<li>DI/EDI/RDI: <em>Destination index</em> for string operations.</li>
<li>SP/ESP/RSP: Stack pointer for top address of the stack.</li>
<li>BP/EBP/RBP: Stack base pointer for holding the address of the current <a href="stack_frame" title="wikilink">stack frame</a>.</li>
<li>IP/EIP/RIP: Instruction pointer. Holds the <a href="program_counter" title="wikilink">program counter</a>, the current instruction address.</li>
</ul>

<p>Segment registers:</p>
<ul>
<li>CS: Code</li>
<li>DS: Data</li>
<li>SS: Stack</li>
<li>ES: Extra data</li>
<li>FS: Extra data #2</li>
<li>GS: Extra data #3</li>
</ul>

<p>No particular purposes were envisioned for the other 8 registers available only in 64-bit mode.</p>

<p>Some instructions compile and execute more efficiently when using these registers for their designed purpose. For example, using AL as an <a href="Accumulator_(computing)" title="wikilink">accumulator</a> and adding an immediate byte value to it produces the efficient <em>add to AL</em> <a class="uri" href="opcode" title="wikilink">opcode</a> of 04h, whilst using the BL register produces the generic and longer <em>add to register</em> opcode of 80C3h. Another example is double precision division and multiplication that works specifically with the AX and DX registers.</p>

<p>Modern compilers benefited from the introduction of the <em>sib</em> byte (<em>scale-index-base byte</em>) that allows registers to be treated uniformly (<a class="uri" href="minicomputer" title="wikilink">minicomputer</a>-like). However, using the sib byte universally is inoptimal, as it produces longer encodings than only using it selectively when necessary. (The main benefit of the sib byte is the orthogonality and more powerful addressing modes it provides, which make it possible to save instructions and the use of registers for address calculations such as scaling an index.) Some special instructions lost priority in the hardware design and became slower than equivalent small code sequences. A notable example is the LODSW instruction.</p>
<h3 id="structure">Structure</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>General Purpose Registers (A, B, C and D)</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>56</p></td>
<td style="text-align: left;">
<p>48</p></td>
<td style="text-align: left;">
<p>40</p></td>
<td style="text-align: left;">
<p>32</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>R?X</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>E?X</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?X</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?H</p></td>
<td style="text-align: left;">
<p>?L</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>64-bit mode-only General Purpose Registers (R8, R9, R10, R11, R12, R13, R14, R15)</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>56</p></td>
<td style="text-align: left;">
<p>48</p></td>
<td style="text-align: left;">
<p>40</p></td>
<td style="text-align: left;">
<p>32</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>?</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?D</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?W</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?B</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Segment Registers (C, D, S, E, F and G)</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>?S</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Pointer Registers (S and B)</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>56</p></td>
<td style="text-align: left;">
<p>48</p></td>
<td style="text-align: left;">
<p>40</p></td>
<td style="text-align: left;">
<p>32</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>R?P</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>E?P</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?P</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?PL</p></td>
</tr>
</tbody>
</table>

<p>Note: The ?PL registers are only available in 64-bit mode.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Index Registers (S and D)</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>56</p></td>
<td style="text-align: left;">
<p>48</p></td>
<td style="text-align: left;">
<p>40</p></td>
<td style="text-align: left;">
<p>32</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>R?I</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>E?I</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?I</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>?IL</p></td>
</tr>
</tbody>
</table>

<p>Note: The ?IL registers are only available in 64-bit mode.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Instruction Pointer Register (I)</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>56</p></td>
<td style="text-align: left;">
<p>48</p></td>
<td style="text-align: left;">
<p>40</p></td>
<td style="text-align: left;">
<p>32</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>RIP</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>EIP</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>IP</p></td>
</tr>
</tbody>
</table>
<h2 id="operating-modes">Operating modes</h2>
<h3 id="real-mode">Real mode</h3>

<p>Real Address mode,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> commonly called Real mode, is an operating mode of <a class="uri" href="8086" title="wikilink">8086</a> and later x86-compatible <a href="Central_processing_unit" title="wikilink">CPUs</a>. Real mode is characterized by a 20-bit segmented memory address space (meaning that only 1 <a href="Mebibyte" title="wikilink">MiB</a> of memory can be addressed—actually, slightly more), direct software access to peripheral hardware, and no concept of <a href="memory_protection" title="wikilink">memory protection</a> or <a href="computer_multitasking" title="wikilink">multitasking</a> at the hardware level. All x86 CPUs in the <a href="Intel_80286" title="wikilink">80286</a> series and later start up in real mode at power-on; <a href="Intel_80186" title="wikilink">80186</a> CPUs and earlier had only one operational mode, which is equivalent to real mode in later chips. (On the IBM PC platform, direct software access to the IBM <a class="uri" href="BIOS" title="wikilink">BIOS</a> routines is available only in real mode, since BIOS is written for real mode. However, this is not a characteristic of the x86 CPU but of the IBM BIOS design.)</p>

<p>In order to use more than 64 KB of memory, the segment registers must be used. This created great complications for compiler implementors who introduced odd pointer modes such as "near", "far" and "huge" to leverage the implicit nature of segmented architecture to different degrees, with some pointers containing 16-bit offsets within implied segments and other pointers containing segment addresses and offsets within segments. It is technically possible to use up to 256 KB of memory for code and data, with up to 64 KB for code, by setting all four segment registers once and then only using 16-bit offsets (optionally with default-segment override prefixes) to address memory, but this puts substantial restrictions on the way data can be addressed and memory operands can be combined, and it violates the architectural intent of the Intel designers, which is for separate data items (e.g. arrays, structures, code units) to be contained in separate segments and addressed by their own segment addresses, in new programs that are not ported from earlier 8-bit processors with 16-bit address spaces.</p>
<h3 id="protected-mode">Protected mode</h3>

<p>In addition to real mode, the Intel 80286 supports protected mode, expanding addressable <a href="physical_memory" title="wikilink">physical memory</a> to 16 <a href="megabyte" title="wikilink">MB</a> and addressable <a href="virtual_memory" title="wikilink">virtual memory</a> to 1 <a href="gigabyte" title="wikilink">GB</a>, and providing <a href="protected_memory" title="wikilink">protected memory</a>, which prevents programs from corrupting one another. This is done by using the segment registers only for storing an index into a descriptor table that is stored in memory. There are two such tables, the <a href="Global_Descriptor_Table" title="wikilink">Global Descriptor Table</a> (GDT) and the <a href="Local_Descriptor_Table" title="wikilink">Local Descriptor Table</a> (LDT), each holding up to 8192 segment descriptors, each segment giving access to 64 KB of memory. In the 80286, a segment descriptor provides a 24-bit <a href="base_address" title="wikilink">base address</a>, and this base address is added to a 16-bit offset to create an absolute address. The base address from the table fulfills the same role that the literal value of the segment register fulfills in real mode; the segment registers have been converted from direct registers to indirect registers. Each segment can be assigned one of four <a href="ring_(computer_security)" title="wikilink">ring</a> levels used for hardware-based <a href="computer_security" title="wikilink">computer security</a>. Each segment descriptor also contains a segment limit field which specifies the maximum offset that may be used with the segment. Because offsets are 16 bits, segments are still limited to 64 KB each in 80286 protected mode.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>Each time a segment register is loaded in protected mode, the 80286 must read a 6-byte segment descriptor from memory into an a set of hidden internal registers. Therefore, loading segment registers is much slower in protected mode than in real mode, and changing segments very frequently is to be avoided. Actual memory operations using protected mode segments are not slowed much because the 80286 and later have hardware to check the offset against the segment limit in parallel with instruction execution.</p>

<p>The <a href="Intel_80386" title="wikilink">Intel 80386</a> extended offsets and also the segment limit field in each segment descriptor to 32 bits, enabling a segment to span the entire memory space. It also introduced support in protected mode for <a class="uri" href="paging" title="wikilink">paging</a>, a mechanism making it possible to use paged <a href="virtual_memory" title="wikilink">virtual memory</a> (with 4 KB page size). Paging allows the CPU to map any page of the virtual memory space to any page of the physical memory space. To do this, it uses additional mapping tables in memory called page tables. Protected mode on the 80386 can operate with paging either enabled or disabled; the segmentation mechanism is always active and generates virtual addresses that are then mapped by the paging mechanism if it is enabled. The segmentation mechanism can also be effectively disabled by setting all segments to have a base address of 0 and size limit equal to the whole address space; this also requires a minimally-sized segment descriptor table of only four descriptors (since the FS and GS segments need not be used).</p>

<p>Paging is used extensively by modern multitasking operating systems. <a class="uri" href="Linux" title="wikilink">Linux</a>, <a class="uri" href="386BSD" title="wikilink">386BSD</a> and <a href="Windows_NT" title="wikilink">Windows NT</a> were developed for the 386 because it was the first Intel architecture CPU to support paging and 32-bit segment offsets. The 386 architecture became the basis of all further development in the x86 series.</p>

<p>x86 processors that support protected mode boot into <a href="real_mode" title="wikilink">real mode</a> for backward compatibility with the older 8086 class of processors. Upon power-on (a.k.a. <a class="uri" href="booting" title="wikilink">booting</a>), the processor initializes in real mode, and then begins executing instructions. Operating system boot code, which might be stored in <a href="Read-only_memory" title="wikilink">ROM</a>, may place the processor into the <a href="protected_mode" title="wikilink">protected mode</a> to enable paging and other features. The instruction set in protected mode is backward compatible with the one used in real mode.</p>
<h4 id="virtual-8086-mode">Virtual 8086 mode</h4>

<p>There is also a sub-mode of operation in 32-bit protected mode (a.k.a. 80386 protected mode) called <em><a href="virtual_8086_mode" title="wikilink">virtual 8086 mode</a></em>, also known as <em>V86 mode</em>. This is basically a special hybrid operating mode that allows real mode programs and operating systems to run while under the control of a protected mode supervisor operating system. This allows for a great deal of flexibility in running both protected mode programs and real mode programs simultaneously. This mode is exclusively available for the 32-bit version of protected mode; it does not exist in the 16-bit version of protected mode, or in long mode.</p>
<h3 id="long-mode">Long mode</h3>

<p>In the mid 1990s, it was obvious that the 32-bit address space of the x86 architecture was limiting its performance in applications requiring large data sets. A 32-bit address space would allow the processor to directly address only 4 GB of data, a size surpassed by applications such as <a href="Video_editing_software" title="wikilink">video processing</a> and <a href="database_engine" title="wikilink">database engines</a>. Using 64-bit addresses, it is possible to directly address 16 <a href="Exbibyte" title="wikilink">EiB</a> of data, although most 64-bit architectures do not support access to the full 64-bit address space; for example, AMD64 supports only 48 bits from a 64-bit address, split into four paging levels.</p>

<p>In 1999, <a class="uri" href="AMD" title="wikilink">AMD</a> published a (nearly) complete specification for a <a class="uri" href="64-bit" title="wikilink">64-bit</a> extension of the x86 architecture which they called <em>x86-64</em> with claimed intentions to produce. That design is currently used in almost all x86 processors, with some exceptions intended for <a href="embedded_system" title="wikilink">embedded systems</a>.</p>

<p>Mass-produced <em>x86-64</em> chips for the general market were available four years later, in 2003, after the time was spent for working prototypes to be tested and refined; about the same time, the initial name <em>x86-64</em> was changed to <em>AMD64</em>. The success of the AMD64 line of processors coupled with lukewarm reception of the IA-64 architecture forced Intel to release its own implementation of the AMD64 instruction set. Intel had previously implemented support for AMD64<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> but opted not to enable it in hopes that AMD would not bring AMD64 to market before Itanium's new IA-64 instruction set was widely adopted. It branded its implementation of AMD64 as <em>EM64T</em>, and later re-branded it <em>Intel 64</em>.</p>

<p>In its literature and product version names, Microsoft and Sun refer to AMD64/Intel 64 collectively as <em>x64</em> in the Windows and <a href="Solaris_(operating_system)" title="wikilink">Solaris</a> operating systems respectively. <a href="Linux_distribution" title="wikilink">Linux distributions</a> refer to it either as "x86-64", its variant "x86_64", or "amd64". <a href="Berkeley_Software_Distribution" title="wikilink">BSD</a> systems use "amd64" while <a href="Mac_OS_X" title="wikilink">Mac OS X</a> uses "x86_64".</p>

<p>Long mode is mostly an extension of the 32-bit instruction set, but unlike the 16–to–32-bit transition, many instructions were dropped in the 64-bit mode. This does not affect actual binary backward compatibility (which would execute legacy code in other modes that retain support for those instructions), but it changes the way assembler and compilers for new code have to work.</p>

<p>This was the first time that a <em>major</em> extension of the x86 architecture was initiated and originated by a manufacturer other than Intel. It was also the first time that Intel accepted technology of this nature from an outside source.</p>
<h2 id="extensions">Extensions</h2>
<h3 id="floating-point-unit">Floating point unit</h3>

<p>Early x86 processors could be extended with <a class="uri" href="floating-point" title="wikilink">floating-point</a> hardware in the form of a series of floating point <a href="numerical_analysis" title="wikilink">numerical</a> <a href="co-processor" title="wikilink">co-processors</a> with names like <a href="Intel_8087" title="wikilink">8087</a>, 80287 and 80387, abbreviated x87. This was also known as the NPX (<em>Numeric Processor eXtension</em>), an apt name since the coprocessors, while used mainly for floating-point calculations, also performed integer operations on both binary and decimal formats. With very few exceptions, the 80486 and subsequent x86 processors then integrated this x87 functionality on chip which made the x87 instructions a <a href="de_facto" title="wikilink">de facto</a> integral part of the x86 instruction set.</p>

<p>Each x87 register, known as ST(0) through ST(7), is 80 bits wide and stores numbers in the <a href="IEEE_floating-point_standard" title="wikilink">IEEE floating-point standard</a> double extended precision format. These registers are organized as a stack with ST(0) as the top. This was done in order to conserve opcode space, and the registers are therefore randomly accessible only for either operand in a register-to-register instruction; ST0 must always be one of the two operands, either the source or the destination, regardless of whether the other operand is ST(x) or a memory operand. However, random access to the stack registers can be obtained through an instruction which exchanges any specified ST(x) with ST(0).</p>

<p>The operations include arithmetic and transcendental functions, including trigonometric and exponential functions, as well as instructions that load common constants (such as 0; 1; e, the base of the natural logarithm; log2(10); and log10(2)) into one of the stack registers. While the integer capability is often overlooked, the x87 can operate on larger integers with a single instruction than the 8086, 80286, 80386, or any x86 CPU without to 64-bit extensions can, and repeated integer calculations even on small values (e.g. 16-bit) can be accelerated by executing integer instructions on the x86 CPU and the x87 in parallel. (The x86 CPU keeps running while the x87 coprocessor calculates, and the x87 sets a signal to the x86 when it is finished or interrupts the x86 if it needs attention because of an error.)</p>
<h3 id="mmx">MMX</h3>

<p>MMX is a <a class="uri" href="SIMD" title="wikilink">SIMD</a> instruction set designed by Intel and introduced in 1997 for the <a href="Pentium_(brand)" title="wikilink">Pentium MMX</a> microprocessor. The MMX instruction set was developed from a similar concept first used on the <a href="Intel_i860" title="wikilink">Intel i860</a>. It is supported on most subsequent IA-32 processors by Intel and other vendors. MMX is typically used for video processing (in multimedia applications, for instance).</p>

<p>MMX added 8 new "registers" to the architecture, known as MM0 through MM7 (henceforth referred to as <em>MMn</em>). In reality, these new "registers" were just aliases for the existing x87 FPU stack registers. Hence, anything that was done to the floating point stack would also affect the MMX registers. Unlike the FP stack, these MMn registers were fixed, not relative, and therefore they were randomly accessible. The instruction set did not adopt the stack-like semantics so that existing operating systems could still correctly save and restore the register state when multitasking without modifications.</p>

<p>Each of the MMn registers are 64-bit integers. However, one of the main concepts of the MMX instruction set is the concept of <em>packed data types</em>, which means instead of using the whole register for a single 64-bit integer (<a class="uri" href="quadword" title="wikilink">quadword</a>), one may use it to contain two 32-bit integers (<a href="Integer_(computer_science)" title="wikilink">doubleword</a>), four 16-bit integers (<a href="Integer_(computer_science)" title="wikilink">word</a>) or eight 8-bit integers (<a href="Integer_(computer_science)" title="wikilink">byte</a>). Given that the MMX's 64-bit MMn registers are aliased to the FPU stack and each of the floating point registers are 80 bits wide, the upper 16 bits of the floating point registers are unused in MMX. These bits are set to all ones by any MMX instruction, which correspond to the floating point representation of <a href="NaN" title="wikilink">NaNs</a> or infinities.</p>
<h3 id="dnow">3DNow!</h3>

<p>In 1997 AMD introduced 3DNow!. The introduction of this technology coincided with the rise of <a href="3D_computer_graphics" title="wikilink">3D</a> entertainment applications and was designed to improve the CPU's <a href="vector_processing" title="wikilink">vector processing</a> performance of graphic-intensive applications. 3D video game developers and 3D graphics hardware vendors use 3DNow! to enhance their performance on AMD's <a href="AMD_K6" title="wikilink">K6</a> and <a class="uri" href="Athlon" title="wikilink">Athlon</a> series of processors.</p>

<p>3DNow! was designed to be the natural evolution of MMX from integers to floating point. As such, it uses exactly the same register naming convention as MMX, that is MM0 through MM7. The only difference is that instead of packing integers into these registers, two <a href="single_precision" title="wikilink">single precision</a> floating point numbers are packed into each register. The advantage of aliasing the FPU registers is that the same instruction and data structures used to save the state of the FPU registers can also be used to save 3DNow! register states. Thus no special modifications are required to be made to operating systems which would otherwise not know about them.</p>
<h3 id="sse">SSE</h3>

<p>In 1999, Intel introduced the Streaming SIMD Extensions (SSE) <a href="instruction_set" title="wikilink">instruction set</a>, following in 2000 with SSE2. The first addition allowed offloading of basic floating-point operations from the x87 stack and the second made MMX almost obsolete and allowed the instructions to be realistically targeted by conventional compilers. Introduced in 2004 along with the <a href="Intel_Prescott" title="wikilink"><em>Prescott</em></a> revision of the <a href="Pentium_4" title="wikilink">Pentium 4</a> processor, SSE3 added specific memory and <a href="Thread_(computing)" title="wikilink">thread</a>-handling instructions to boost the performance of Intel's <a class="uri" href="HyperThreading" title="wikilink">HyperThreading</a> technology. AMD licensed the SSE3 instruction set and implemented most of the SSE3 instructions for its revision E and later Athlon 64 processors. The Athlon 64 does not support HyperThreading and lacks those SSE3 instructions used only for HyperThreading.</p>

<p>SSE discarded all legacy connections to the FPU stack. This also meant that this instruction set discarded all legacy connections to previous generations of SIMD instruction sets like MMX. But it freed the designers up, allowing them to use larger registers, not limited by the size of the FPU registers. The designers created eight 128-bit registers, named XMM0 through XMM7. (<em>Note</em>: in <a href="x86-64" title="wikilink">AMD64</a>, the number of SSE XMM registers has been increased from 8 to 16.) However, the downside was that operating systems had to have an awareness of this new set of instructions in order to be able to save their register states. So Intel created a slightly modified version of Protected mode, called Enhanced mode which enables the usage of SSE instructions, whereas they stay disabled in regular Protected mode. An OS that is aware of SSE will activate Enhanced mode, whereas an unaware OS will only enter into traditional Protected mode.</p>

<p>SSE is a SIMD instruction set that works only on floating point values, like 3DNow!. However, unlike 3DNow! it severs all legacy connection to the FPU stack. Because it has larger registers than 3DNow!, SSE can pack twice the number of <a href="single_precision" title="wikilink">single precision</a> floats into its registers. The original SSE was limited to only single-precision numbers, like 3DNow!. The SSE2 introduced the capability to pack <a href="double_precision" title="wikilink">double precision</a> numbers too, which 3DNow! had no possibility of doing since a double precision number is 64-bit in size which would be the full size of a single 3DNow! MMn register. At 128 bits, the SSE XMMn registers could pack two double precision floats into one register. Thus SSE2 is much more suitable for scientific calculations than either SSE1 or 3DNow!, which were limited to only single precision. SSE3 does not introduce any additional registers.</p>
<h3 id="physical-address-extension-pae">Physical Address Extension (PAE)</h3>

<p><a href="Physical_Address_Extension" title="wikilink">Physical Address Extension</a> or PAE was first added in the Intel <a href="Pentium_Pro" title="wikilink">Pentium Pro</a>, to allow an additional 4 bits of physical addressing in 32-bit protected mode. The size of memory in Protected mode is usually limited to 4 <a href="gigabyte" title="wikilink">GB</a>. Through tricks in the processor's page and segment memory management systems, x86 operating systems may be able to access more than 32-bits of address space, even without the switchover to the 64-bit paradigm. This mode does not change the length of segment offsets or linear addresses; those are still only 32 bits.</p>
<h3 id="x86-64">x86-64</h3>
<figure><b>(Figure)</b>
<figcaption>In <a class="uri" href="supercomputer" title="wikilink">supercomputer</a> <a href="computer_cluster" title="wikilink">clusters</a> (as tracked by <a href="TOP_500" title="wikilink">TOP 500</a> data and visualized on the diagram above, last updated 2013), the appearance of 64-bit extensions for the x86 architecture enabled 64-bit x86 processors by AMD and Intel (orange and blue on the diagram, respectively) to replace most RISC processor architectures previously used in such systems (including <a class="uri" href="PA-RISC" title="wikilink">PA-RISC</a>, <a class="uri" href="SPARC" title="wikilink">SPARC</a>, <a href="DEC_Alpha" title="wikilink">Alpha</a> and others), as well as 32-bit x86 (green on the diagram), even though Intel itself initially tried unsuccessfully to replace x86 with a new incompatible 64-bit architecture in the <a class="uri" href="Itanium" title="wikilink">Itanium</a> processor. The main non-x86 architecture which is still used, as of 2014, in supercomputing clusters is the <a href="Power_Architecture" title="wikilink">Power Architecture</a> used by <a href="IBM_POWER_microprocessors" title="wikilink">IBM POWER microprocessors</a> (red on the diagram), with SPARC as a distant second.</figcaption>
</figure>

<p>By the 2000s it had become obvious that 32-bit x86 processors' limitations in memory addressing were an obstacle to their utilization in high-performance computing clusters and powerful desktop workstations. The aged 32-bit x86 was competing with much more advanced 64-bit RISC architectures which could address much more memory. Intel and the whole x86 ecosystem needed 64-bit memory addressing if x86 was to survive the 64-bit computing era, as workstation and desktop software applications were soon to start hitting the limitations present in 32-bit memory addressing. However, Intel felt that it was the right time to make a bold step and use the transition to 64-bit desktop computers for a transition away from the x86 architecture in general, an experiment which ultimately failed.</p>

<p>In 2001, Intel attempted to introduce a non-x86 64-bit architecture named <a class="uri" href="IA-64" title="wikilink">IA-64</a> in its <a class="uri" href="Itanium" title="wikilink">Itanium</a> processor, initially aiming for the <a href="high-performance_computing" title="wikilink">high-performance computing</a> market, hoping that it would eventually replace the 32-bit x86.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> While IA-64 was incompatible with x86, the Itanium processor did provide <a href="emulator" title="wikilink">emulation</a> capabilities for translating x86 instructions into IA-64, but this affected the performance of x86 programs so badly that it was rarely, if ever, actually useful to the users: programmers should rewrite x86 programs for the IA-64 architecture or their performance on Itanium would be orders of magnitude worse than on a true x86 processor. The market rejected the Itanium processor since it broke <a href="backward_compatibility" title="wikilink">backward compatibility</a> and preferred to continue using x86 chips, and very few programs were rewritten for IA-64.</p>

<p>AMD decided to take another path toward 64-bit memory addressing, making sure backward compatibility would not suffer. In April 2003, AMD released the first x86 processor with 64-bit general-purpose registers, the <a class="uri" href="Opteron" title="wikilink">Opteron</a>, capable of addressing much more than 4 <a href="Gigabyte" title="wikilink">GB</a> of virtual memory using the new <a class="uri" href="x86-64" title="wikilink">x86-64</a> extension (also known as AMD64 or x64). The 64-bit extensions to the x86 architecture were enabled only in the newly introduced <a href="long_mode" title="wikilink">long mode</a>, therefore 32-bit and 16-bit applications and operating systems could simply continue using an AMD64 processor in protected or other modes, without even the slightest sacrifice of performance<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and with full compatibility back to the original instructions of the 16-bit Intel 8086.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The market responded positively, adopting the 64-bit AMD processors for both high-performance applications and business or home computers.</p>

<p>Seeing the market rejecting the incompatible Itanium processor and Microsoft supporting AMD64, Intel had to respond and introduced its own x86-64 processor, the "<a href="Pentium_4#Prescott" title="wikilink">Prescott</a>" Pentium 4, in July 2004.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> As a result, the Itanium processor with its IA-64 instruction set is rarely used and x86, through its x86-64 incarnation, is still the dominant CPU architecture in non-embedded computers.</p>

<p>x86-64 also introduced the <a href="NX_bit" title="wikilink">NX bit</a>, which offers some protection against security bugs caused by <a href="buffer_overrun" title="wikilink">buffer overruns</a>.</p>

<p>As a result of AMD's 64-bit contribution to the x86 lineage and its subsequent acceptance by Intel, the 64-bit RISC architectures ceased to be a threat to the x86 ecosystem and almost disappeared from the workstation market. x86-64 began to be utilized in powerful <a href="supercomputer" title="wikilink">supercomputers</a> (in its <a href="AMD_Opteron" title="wikilink">AMD Opteron</a> and <a href="Intel_Xeon" title="wikilink">Intel Xeon</a> incarnations), a market which was previously the natural habitat for 64-bit RISC designs (such as the <a href="IBM_POWER_microprocessors" title="wikilink">IBM POWER microprocessors</a> or <a class="uri" href="SPARC" title="wikilink">SPARC</a> processors). The great leap toward 64-bit computing and the maintenance of backward compatibility with 32-bit and 16-bit software enabled the x86 architecture to become an extremely flexible platform today, with x86 chips being utilized from small low-power systems (for example, <a href="Intel_Quark" title="wikilink">Intel Quark</a> and <a href="Intel_Atom" title="wikilink">Intel Atom</a>) to fast gaming desktop computers (for example, <a href="Intel_Core_i7" title="wikilink">Intel Core i7</a> and <a href="AMD_FX" title="wikilink">AMD FX</a>), and even dominate large supercomputing <a href="computer_cluster" title="wikilink">clusters</a>, effectively leaving only the <a href="ARM_architecture" title="wikilink">ARM</a> 32-bit and 64-bit RISC architecture as a competitor in the <a class="uri" href="smartphone" title="wikilink">smartphone</a> and <a href="tablet_computer" title="wikilink">tablet</a> market.</p>
<h3 id="virtualization">Virtualization</h3>

<p>Prior to 2005 x86 architecture processors were unable to meet the <a href="Popek_and_Goldberg_virtualization_requirements" title="wikilink">Popek and Goldberg requirements</a> - a specification for virtualization created in 1974 by <a href="Gerald_J._Popek" title="wikilink">Gerald J. Popek</a> and <a href="Robert_P._Goldberg" title="wikilink">Robert P. Goldberg</a>. However both commercial and open source <a href="x86_virtualization" title="wikilink">x86 virtualization</a> hypervisor products were developed using <a href="Shadow_page_tables" title="wikilink">software-based virtualization</a>. Commercial systems included <a href="VMware_ESX" title="wikilink">VMware ESX</a>, <a href="VMware_Workstation" title="wikilink">VMware Workstation</a>, <a href="Parallels_Workstation" title="wikilink">Parallels</a>, <a class="uri" href="Microsoft" title="wikilink">Microsoft</a> <a class="uri" href="Hyper-V" title="wikilink">Hyper-V</a> Server, and <a href="Virtual_PC" title="wikilink">Microsoft Virtual PC</a>; while open source systems included <a class="uri" href="QEMU" title="wikilink">QEMU</a>/<a class="uri" href="KQEMU" title="wikilink">KQEMU</a>, <a class="uri" href="VirtualBox" title="wikilink">VirtualBox</a>, and <a class="uri" href="Xen" title="wikilink">Xen</a>.</p>

<p>The introduction of the AMD-V and Intel VT-x instruction sets in 2005 allowed x86 processors to meet the Popek and Goldberg virtualization requirements.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Itanium" title="wikilink">Itanium</a></li>
<li><a class="uri" href="PowerPC" title="wikilink">PowerPC</a></li>
<li><a href="Input/Output_Base_Address" title="wikilink">Input/Output Base Address</a></li>
<li><a href="Interrupt_request" title="wikilink">Interrupt request</a></li>
<li><a href="x86_assembly_language" title="wikilink">x86 assembly language</a></li>
<li><a href="x86_instruction_listings" title="wikilink">x86 instruction listings</a></li>
<li><a href="List_of_AMD_microprocessors" title="wikilink">List of AMD microprocessors</a></li>
<li><a href="List_of_Intel_microprocessors" title="wikilink">List of Intel microprocessors</a></li>
<li><a href="List_of_VIA_microprocessors" title="wikilink">List of VIA microprocessors</a></li>
<li><a href="List_of_x86_manufacturers" title="wikilink">List of x86 manufacturers</a></li>
<li><a class="uri" href="CPUID" title="wikilink">CPUID</a></li>
<li><a class="uri" href="Microarchitecture" title="wikilink">Microarchitecture</a></li>
<li><a class="uri" href="iAPX" title="wikilink">iAPX</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.intel.com/museum/corporatetimeline/index.htm?iid=about+ln_history">25 Years of Intel Architecture</a></li>
<li><a href="http://www.x86-guide.com/">x86 CPUs guide</a></li>
<li><a href="http://www.itworld.com/it-management/346559/why-intel-cant-seem-retire-x86">Why Intel can't seem to retire the x86</a></li>
<li><a href="http://www.felixcloutier.com/x86/">32/64-bit x86 Instruction Reference</a></li>
<li><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">Intel Intrinsics Guide</a>, an interactive reference tool for Intel intrinsic instructions</li>
</ul>

<p>"</p>

<p><a href="Category:1978_introductions" title="wikilink">Category:1978 introductions</a> <a href="Category:Intel_products" title="wikilink">Category:Intel products</a> <a href="Category:Instruction_set_architectures" title="wikilink">Category:Instruction set architectures</a> <a href="Category:IBM_PC_compatibles" title="wikilink">Category:IBM PC compatibles</a> <a href="Category:X86_architecture" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://bitsavers.trailing-edge.com/pdf/intel/80286/210498-001_1983_iAPX_286_Programmers_Reference_1983.pdf">Official Intel iAPX 286 programmers' manual</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://bitsavers.informatik.uni-stuttgart.de/pdf/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf">iAPX 86, iAPX 88 user's manual</a><a href="#fnref4">↩</a></li>
<li id="fn5">late 1981 to early 1984, approximately<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://bwrc.eecs.berkeley.edu/CIC/announce/1999/k8.annc.html">"Time and again, processor architects have looked at the inelegant x86 architecture and declared it cannot be stretched to accommodate the latest innovations," said Nathan Brookwood, principal analyst, Insight 64.</a><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">Intel iAPX 86,88 User's Manual, August 1981, p. S-6, S-13..S-15 (Order No. 210201-001)<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="http://www.geek.com/intels-yamhill-technology-x86-64-compatible/">Intel's Yamhill Technology: x86-64 compatible | Geek.com</a><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
</ol>
</section>
</body>
</html>
