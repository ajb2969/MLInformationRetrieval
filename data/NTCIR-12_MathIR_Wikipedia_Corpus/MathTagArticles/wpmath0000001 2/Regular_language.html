<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="891">Regular language</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Regular language</h1>
<hr/>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a> and <a href="formal_language_theory" title="wikilink">formal language theory</a>, a <strong>regular language</strong> (also called a <strong>rational language</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>) is a <a href="formal_language" title="wikilink">formal language</a> that can be expressed using a <a href="regular_expression" title="wikilink">regular expression</a>, in the strict sense of the latter notion used in theoretical computer science. (Many regular expressions engines provided by modern programming languages are <a href="Regular_expression#Patterns_for_non-regular_languages" title="wikilink">augmented with features</a> that allow recognition of languages that cannot be expressed by a classic regular expression.)</p>

<p>Alternatively, a regular language can be defined as a language recognized by a <a href="finite_automaton" title="wikilink">finite automaton</a>. The equivalence of regular expressions and finite automata is known as <strong><a href="Stephen_Cole_Kleene" title="wikilink">Kleene</a>'s theorem</strong>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a>, regular languages are defined to be the languages that are generated by Type-3 grammars (<a href="regular_grammar" title="wikilink">regular grammars</a>).</p>

<p>Regular languages are very useful in input <a class="uri" href="parsing" title="wikilink">parsing</a> and <a href="programming_language" title="wikilink">programming language</a> design.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>The collection of regular languages over an alphabet Σ is defined recursively as follows:</p>
<ul>
<li>The empty language Ø is a regular language.</li>
<li>For each <em>a</em> ∈ Σ (<em>a</em> belongs to Σ), the <a href="Singleton_(mathematics)" title="wikilink">singleton</a> language {<em>a</em>} is a regular language.</li>
<li>If <em>A</em> and <em>B</em> are regular languages, then <em>A</em> ∪ <em>B</em> (union), <em>A</em> • <em>B</em> (concatenation), and <em>A</em>* (<a href="Kleene_star" title="wikilink">Kleene star</a>) are regular languages.</li>
<li>No other languages over Σ are regular.</li>
</ul>

<p>See <a href="Regular_expression#Formal_language_theory" title="wikilink">regular expression</a> for its syntax and semantics. Note that the above cases are in effect the defining rules of regular expression.</p>
<h2 id="examples">Examples</h2>

<p>All finite languages are regular; in particular the <a href="empty_string" title="wikilink">empty string</a> language {ε} = Ø* is regular. Other typical examples include the language consisting of all strings over the alphabet {<em>a</em>, <em>b</em>} which contain an even number of <em>a</em>s, or the language consisting of all strings of the form: several <em>a</em>s followed by several <em>b</em>s.</p>

<p>A simple example of a language that is not regular is the set of strings 

<math display="inline" id="Regular_language:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <mpadded width="+1.7pt">
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
    </mpadded>
   </mrow>
   <mo rspace="5.3pt" stretchy="false">|</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a^{n}b^{n}\,|\;n\geq 0\}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Intuitively, it cannot be recognized with a finite automaton, since a finite automaton has finite memory and it cannot remember the exact number of a's. Techniques to prove this fact rigorously are given below.</p>
<h2 id="equivalent-formalisms">Equivalent formalisms</h2>

<p>A regular language satisfies the following equivalent properties:</p>
<ol>
<li>it is the language of a regular expression (by the above definition)</li>
<li>it is the language accepted by a <a href="nondeterministic_finite_automaton" title="wikilink">nondeterministic finite automaton</a> (NFA)<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>it is the language accepted by a <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a> (DFA)<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
<li>it can be generated by a <a href="regular_grammar" title="wikilink">regular grammar</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>it is the language accepted by an <a href="alternating_finite_automaton" title="wikilink">alternating finite automaton</a></li>
<li>it can be generated by a <a href="prefix_grammar" title="wikilink">prefix grammar</a></li>
<li>it can be accepted by a read-only <a href="Turing_machine" title="wikilink">Turing machine</a></li>
<li>it can be defined in <a href="monadic_predicate_calculus" title="wikilink">monadic</a> <a href="second-order_logic" title="wikilink">second-order logic</a> (<a href="Büchi-Elgot-Trakhtenbrot_theorem" title="wikilink">Büchi-Elgot-Trakhtenbrot theorem</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a>)</li>
<li>it is recognized by some finite <a class="uri" href="monoid" title="wikilink">monoid</a>, meaning it is the <a class="uri" href="preimage" title="wikilink">preimage</a> of a subset of a finite monoid under a homomorphism from the free monoid on its alphabet<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ol>

<p>Some authors use one of the above properties different from "1." as alternative definition of regular languages.</p>

<p>Some of the equivalences above, particularly those among the first four formalisms, are called <em>Kleene's theorem</em> in textbooks. Precisely which one (or which subset) is called such varies between authors. One textbook calls the equivalence of regular expressions and NFAs ("1." and "2." above) "Kleene's theorem".<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Another textbook calls the equivalence of regular expressions and DFAs ("1." and "3." above) "Kleene's theorem".<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Two other textbooks first prove the expressive equivalence of NFAs and DFAs ("2." and "3.") and then state "Kleene's theorem" as the equivalence between regular expressions and finite automata (the latter said to describe "recognizable languages").<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> A linguistically oriented text first equates regular grammars ("4." above) with DFAs and NFAs, calls the languages generated by (any of) these "regular", after which it introduces regular expressions which it terms to describe "rational languages", and finally states "Kleene's theorem" as the coincidence of regular and rational languages.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Other authors simply <em>define</em> "rational expression" and "regular expressions" as synonymous and do the same with "rational languages" and "regular languages".<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="closure-properties">Closure properties</h2>

<p>The regular languages are <a href="closure_(mathematics)" title="wikilink">closed</a> under the various operations, that is, if the languages <em>K</em> and <em>L</em> are regular, so is the result of the following operations:</p>
<ul>
<li>the set theoretic Boolean operations: <a href="union_(set_theory)" title="wikilink">union</a> 

<math display="inline" id="Regular_language:1">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∪</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cup L
  </annotation>
 </semantics>
</math>

, <a href="intersection_(set_theory)" title="wikilink">intersection</a> 

<math display="inline" id="Regular_language:2">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∩</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cap L
  </annotation>
 </semantics>
</math>

, and <a href="complement_(set_theory)" title="wikilink">complement</a> 

<math display="inline" id="Regular_language:3">
 <semantics>
  <mover accent="true">
   <mi>L</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{L}
  </annotation>
 </semantics>
</math>


. From this also <a href="relative_complement" title="wikilink">relative complement</a> 

<math display="inline" id="Regular_language:4">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>-</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K-L
  </annotation>
 </semantics>
</math>

 follows.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>the regular operations: <a href="union_(set_theory)" title="wikilink">union</a> 

<math display="inline" id="Regular_language:5">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∪</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cup L
  </annotation>
 </semantics>
</math>

, <a class="uri" href="concatenation" title="wikilink">concatenation</a> 

<math display="inline" id="Regular_language:6">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∘</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\circ L
  </annotation>
 </semantics>
</math>

, and <a href="Kleene_star" title="wikilink">Kleene star</a> 

<math display="inline" id="Regular_language:7">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>the <a href="abstract_family_of_languages" title="wikilink">trio</a> operations: <a href="string_homomorphism" title="wikilink">string homomorphism</a>, inverse string homomorphism, and intersection with regular languages. As a consequence they are closed under arbitrary <a href="finite_state_transducer" title="wikilink">finite state transductions</a>, like <a href="right_quotient" title="wikilink">quotient</a> 

<math display="inline" id="Regular_language:8">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>/</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K/L
  </annotation>
 </semantics>
</math>


 with a regular language. Even more, regular languages are closed under quotients with <em>arbitrary</em> languages: If L is regular then L/K is regular for any K.</li>
<li>the reverse (or mirror image) 

<math display="inline" id="Regular_language:9">
 <semantics>
  <msup>
   <mi>L</mi>
   <mi>R</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{R}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="deciding-whether-a-language-is-regular">Deciding whether a language is regular</h2>
<figure><b>(Figure)</b>
<figcaption>Regular language in classes of Chomsky hierarchy.</figcaption>
</figure>

<p>To locate the regular languages in the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a>, one notices that every regular language is <a href="Context_free_language" title="wikilink">context-free</a>. The converse is not true: for example the language consisting of all strings having the same number of <em>a</em>'s as <em>b</em>'s is context-free but not regular. To prove that a language such as this is not regular, one often uses the <a href="Myhill–Nerode_theorem" title="wikilink">Myhill–Nerode theorem</a> or the <a href="pumping_lemma" title="wikilink">pumping lemma</a> among other methods.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>There are two purely algebraic approaches to define regular languages. If:</p>
<ul>
<li>Σ is a finite alphabet,</li>
<li>Σ* denotes the <a href="free_monoid" title="wikilink">free monoid</a> over Σ consisting of all strings over Σ,</li>
<li><em>f</em> : Σ* → <em>M</em> is a <a href="monoid_homomorphism" title="wikilink">monoid homomorphism</a> where <em>M</em> is a <em>finite</em> monoid,</li>
<li><em>S</em> is a subset of <em>M</em></li>
</ul>

<p>then the set 

<math display="inline" id="Regular_language:10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>w</mi>
    <mo>∈</mo>
    <mpadded width="+1.7pt">
     <msup>
      <mi mathvariant="normal">Σ</mi>
      <mo>*</mo>
     </msup>
    </mpadded>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">|</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>w</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{w\in\Sigma^{*}\,|\,f(w)\in S\}
  </annotation>
 </semantics>
</math>

 is regular. Every regular language arises in this fashion.</p>

<p>If <em>L</em> is any subset of Σ*, one defines an <a href="equivalence_relation" title="wikilink">equivalence relation</a> ~ (called the <a href="syntactic_relation" title="wikilink">syntactic relation</a>) on Σ* as follows: <em>u</em> ~ <em>v</em> is defined to mean</p>
<dl>
<dd><em>uw</em> ∈ <em>L</em> if and only if <em>vw</em> ∈ <em>L</em> for all <em>w</em> ∈ Σ*
</dd>
</dl>

<p>The language <em>L</em> is regular if and only if the number of equivalence classes of ~ is finite (A proof of this is provided in the article on the <a href="syntactic_monoid" title="wikilink">syntactic monoid</a>). When a language is regular, then the number of equivalence classes is equal to the number of states of the <a href="DFA_minimization" title="wikilink">minimal deterministic finite automaton</a> accepting <em>L</em>.</p>

<p>A similar set of statements can be formulated for a monoid 

<math display="inline" id="Regular_language:11">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⊂</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\subset\Sigma^{*}
  </annotation>
 </semantics>
</math>

. In this case, equivalence over <em>M</em> leads to the concept of a recognizable language.</p>
<h2 id="complexity-results">Complexity results</h2>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <a href="complexity_class" title="wikilink">complexity class</a> of all regular languages is sometimes referred to as <strong>REGULAR</strong> or <strong>REG</strong> and equals <a class="uri" href="DSPACE" title="wikilink">DSPACE</a>(O(1)), the <a href="decision_problem" title="wikilink">decision problems</a> that can be solved in constant space (the space used is independent of the input size). <strong>REGULAR</strong> ≠ <a href="AC0" title="wikilink"><strong>AC</strong><sup>0</sup></a>, since it (trivially) contains the parity problem of determining whether the number of 1 bits in the input is even or odd and this problem is not in <strong>AC</strong><sup>0</sup>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> On the other hand, <strong>REGULAR</strong> does not contain <strong>AC</strong><sup>0</sup>, because the nonregular language of <a href="palindrome" title="wikilink">palindromes</a>, or the nonregular language 

<math display="inline" id="Regular_language:12">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mn>0</mn>
     <mi>n</mi>
    </msup>
    <msup>
     <mn>1</mn>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">0</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0^{n}1^{n}:n\in\mathbb{N}\}
  </annotation>
 </semantics>
</math>

 can both be recognized in <strong>AC</strong><sup>0</sup>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>If a language is <em>not</em> regular, it requires a machine with at least <a href="Big_O_notation" title="wikilink">Ω</a>(log log <em>n</em>) space to recognize (where <em>n</em> is the input size).<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> In other words, DSPACE(<a href="Big_O_notation" title="wikilink">o</a>(log log <em>n</em>)) equals the class of regular languages. In practice, most nonregular problems are solved by machines taking at least <a href="logarithmic_space" title="wikilink">logarithmic space</a>.</p>
<h2 id="subclasses">Subclasses</h2>

<p>Important subclasses of regular languages include</p>
<ul>
<li>Finite languages - those containing only a finite number of words.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> These are regular languages, as one can create a <a href="regular_expression" title="wikilink">regular expression</a> that is the <a href="Union_(set_theory)" title="wikilink">union</a> of every word in the language.</li>
<li><a href="Star-free_language" title="wikilink">Star-free languages</a>, those that can be described by a regular expression constructed from the empty symbol, letters, concatenation and all <a href="boolean_operators" title="wikilink">boolean operators</a> including <a href="Complement_(set_theory)" title="wikilink">complementation</a> but not the <a href="Kleene_star" title="wikilink">Kleene star</a>: this class includes all finite languages.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></li>
<li><strong>Cyclic languages</strong>, satisfying the conditions 

<math display="inline" id="Regular_language:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>v</mi>
     <mi>u</mi>
    </mrow>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>u</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   uv\in L\Leftrightarrow vu\in L
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Regular_language:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <msup>
     <mi>w</mi>
     <mi>n</mi>
    </msup>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <in></in>
     <ci>w</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in L\Leftrightarrow w^{n}\in L
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></li>
</ul>
<h2 id="the-number-of-words-in-a-regular-language">The number of words in a regular language</h2>

<p>Let 

<math display="inline" id="Regular_language:15">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>L</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>L</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{L}(n)
  </annotation>
 </semantics>
</math>

 denote the number of words of length 

<math display="inline" id="Regular_language:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Regular_language:17">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. The <a href="ordinary_generating_function" title="wikilink">ordinary generating function</a> for <em>L</em> is the <a href="formal_power_series" title="wikilink">formal power series</a></p>

<p>

<math display="block" id="Regular_language:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>S</mi>
      <mi>L</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>L</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <msup>
        <mi>z</mi>
        <mi>n</mi>
       </msup>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>L</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>L</ci>
      </apply>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{L}(z)=\sum_{n\geq 0}s_{L}(n)z^{n}\ .
  </annotation>
 </semantics>
</math>

</p>

<p>The generating function of a language <em>L</em> is a <a href="rational_function" title="wikilink">rational function</a> if <em>L</em> is regular.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> Hence for any regular language 

<math display="inline" id="Regular_language:19">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 there exist an integer constant 

<math display="inline" id="Regular_language:20">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{0}
  </annotation>
 </semantics>
</math>

, complex constants 

<math display="inline" id="Regular_language:21">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>λ</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1},\,\ldots,\,\lambda_{k}
  </annotation>
 </semantics>
</math>

 and complex polynomials 

<math display="inline" id="Regular_language:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}(x),\,\ldots,\,p_{k}(x)
  </annotation>
 </semantics>
</math>

 such that for every 

<math display="inline" id="Regular_language:23">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <msub>
    <mi>n</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq n_{0}
  </annotation>
 </semantics>
</math>


 the number 

<math display="inline" id="Regular_language:24">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>L</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>L</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{L}(n)
  </annotation>
 </semantics>
</math>

 of words of length 

<math display="inline" id="Regular_language:25">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Regular_language:26">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Regular_language:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>L</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msubsup>
      <mi>λ</mi>
      <mn>1</mn>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msubsup>
      <mi>λ</mi>
      <mi>k</mi>
      <mi>n</mi>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>L</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>k</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{L}(n)=p_{1}(n)\lambda_{1}^{n}+\cdots+p_{k}(n)\lambda_{k}^{n}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>Thus, non-regularity of certain languages 

<math display="inline" id="Regular_language:28">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
 </semantics>
</math>


 can be proved by counting the words of a given length in 

<math display="inline" id="Regular_language:29">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
 </semantics>
</math>

. Consider, for example, the <a href="Dyck_language" title="wikilink">Dyck language</a> of strings of balanced parentheses. The number of words of length 

<math display="inline" id="Regular_language:30">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n
  </annotation>
 </semantics>
</math>

 in the Dyck language is equal to the <a href="Catalan_number" title="wikilink">Catalan number</a> 

<math display="inline" id="Regular_language:31">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>∼</mo>
   <mfrac>
    <msup>
     <mn>4</mn>
     <mi>n</mi>
    </msup>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mn>3</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msqrt>
      <mi>π</mi>
     </msqrt>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">4</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <root></root>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}\sim\frac{4^{n}}{n^{3/2}\sqrt{\pi}}
  </annotation>
 </semantics>
</math>

, which is not of the form 

<math display="inline" id="Regular_language:32">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>λ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(n)\lambda^{n}
  </annotation>
 </semantics>
</math>

, witnessing the non-regularity of the Dyck language. Care must be taken since some of the eigenvalues 

<math display="inline" id="Regular_language:33">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>


 could have the same magnitude. For example, the number of words of length 

<math display="inline" id="Regular_language:34">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in the language of all even binary words is not of the form 

<math display="inline" id="Regular_language:35">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>λ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(n)\lambda^{n}
  </annotation>
 </semantics>
</math>

, but the number of words of even or odd length are of this form; the corresponding eigenvalues are 

<math display="inline" id="Regular_language:36">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2,-2
  </annotation>
 </semantics>
</math>

. In general, for every regular language there exists a constant 

<math display="inline" id="Regular_language:37">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 such that for all 

<math display="inline" id="Regular_language:38">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


, the number of words of length 

<math display="inline" id="Regular_language:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>m</mi>
   </mrow>
   <mo>+</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>m</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dm+a
  </annotation>
 </semantics>
</math>

 is asymptotically 

<math display="inline" id="Regular_language:40">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>a</mi>
   </msub>
   <msup>
    <mi>m</mi>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
   </msup>
   <msubsup>
    <mi>λ</mi>
    <mi>a</mi>
    <mi>m</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>a</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{a}m^{p_{a}}\lambda_{a}^{m}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>The <em>zeta function</em> of a language <em>L</em> is<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>

<math display="block" id="Regular_language:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>ζ</mi>
      <mi>L</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>n</mi>
         <mo>≥</mo>
         <mn>0</mn>
        </mrow>
       </munder>
       <mrow>
        <msub>
         <mi>s</mi>
         <mi>L</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mfrac>
         <msup>
          <mi>z</mi>
          <mi>n</mi>
         </msup>
         <mi>n</mi>
        </mfrac>
       </mrow>
      </mrow>
      <mo rspace="7.5pt">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ζ</ci>
      <ci>L</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>L</ci>
       </apply>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{L}(z)=\exp\left({\sum_{n\geq 0}s_{L}(n)\frac{z^{n}}{n}}\right)\ .
  </annotation>
 </semantics>
</math>

</p>

<p>The zeta function of a regular language is not in general rational, but that of a cyclic language is.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="generalizations">Generalizations</h2>

<p>The notion of a regular language has been generalized to infinite words (see <a href="ω-automaton" title="wikilink">ω-automata</a>) and to trees (see <a href="tree_automaton" title="wikilink">tree automaton</a>).</p>

<p><a href="Rational_set" title="wikilink">Rational set</a> generalizes the notion (of regular/rational language) to monoids that are not necessarily <a href="free_monoid" title="wikilink">free</a>. Likewise, the notion of a recognizable language (by a finite automaton) has namesake as <a href="recognizable_set" title="wikilink">recognizable set</a> over a monoid that is not necessarily free. Howard Straubing notes in relation to these facts that “The term "regular language" is a bit unfortunate. Papers influenced by <a href="Samuel_Eilenberg" title="wikilink">Eilenberg</a>'s monograph<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> often use either the term "recognizable language", which refers to the behavior of automata, or "rational language", which refers to important analogies between regular expressions and rational power series. (In fact, Eilenberg defines rational and recognizable subsets of arbitrary monoids; the two notions do not, in general, coincide.) This terminology, while better motivated, never really caught on, and "regular language" is used almost universally.”<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>

<p><a href="Rational_series" title="wikilink">Rational series</a> is another generalization, this time in the context of a <a href="formal_power_series_over_a_semiring" title="wikilink">formal power series over a semiring</a>. This approach gives rise to <a href="weighted_rational_expression" title="wikilink">weighted rational expressions</a> and <a href="weighted_automata" title="wikilink">weighted automata</a>. In this algebraic context, the regular languages (corresponding to <a href="Boolean_semiring" title="wikilink">Boolean</a>-weighted rational expressions) are usually called <em>rational languages</em>.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> Also in this context, Kleene's theorem finds a generalization called the <a href="Kleene-Schützenberger_theorem" title="wikilink">Kleene-Schützenberger theorem</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pumping_lemma_for_regular_languages" title="wikilink">Pumping lemma for regular languages</a></li>
<li><a href="Union_of_two_regular_languages" title="wikilink">Union of two regular languages</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p>Chapter 1: Regular Languages, pp. 31–90. Subsection "Decidable Problems Concerning Regular Languages" of section 4.1: Decidable Languages, pp. 152–155.</p></li>
<li>Philippe Flajolet and Robert Sedgewick, <em><a href="http://algo.inria.fr/flajolet/Publications/FlSe02.ps.gz">Analytic Combinatorics: Symbolic Combinatorics.</a></em> Online book, 2002.</li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="Stephen_Cole_Kleene" title="wikilink">Kleene, S.C.</a>: Representation of events in nerve nets and finite automata. In: Shannon, C.E., McCarthy, J. (eds.) Automata Studies, pp. 3–41. Princeton University Press, Princeton (1956); it is a slightly modified version of his 1951 <a href="RAND_Corporation" title="wikilink">RAND Corporation</a> report of the same title, <a href="http://www.rand.org/content/dam/rand/pubs/research_memoranda/2008/RM704.pdf">RM704</a>.</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Eilenberg (1974), p. 16 (Example II, 2.8) and p. 25 (Example II, 5.2).<a href="#fnref4">↩</a></li>
<li id="fn5">1. ⇒ 2. by <a href="Thompson's_construction_algorithm" title="wikilink">Thompson's construction algorithm</a><a href="#fnref5">↩</a></li>
<li id="fn6">2. ⇒ 1. by <a href="Kleene's_algorithm" title="wikilink">Kleene's algorithm</a><a href="#fnref6">↩</a></li>
<li id="fn7">2. ⇒ 3. by the <a href="powerset_construction" title="wikilink">powerset construction</a><a href="#fnref7">↩</a></li>
<li id="fn8">3. ⇒ 2. since the former <a href="deterministic_finite_automaton#Formal_definition" title="wikilink">definition</a> is stronger than the <a href="nondeterministic_finite_automaton#Formal_definition" title="wikilink">latter</a><a href="#fnref8">↩</a></li>
<li id="fn9">2. ⇒ 4. see Hopcroft, Ullman (1979), Theorem 9.2, p.219<a href="#fnref9">↩</a></li>
<li id="fn10">4. ⇒ 2. see Hopcroft, Ullman (1979), Theorem 9.1, p.218<a href="#fnref10">↩</a></li>
<li id="fn11">M. Weyer: Chapter 12 - Decidability of S1S and S2S, p. 219, Theorem 12.26. In: Erich Grädel, Wolfgang Thomas, Thomas Wilke (Eds.): Automata, Logics, and Infinite Games: A Guide to Current Research. Lecture Notes in Computer Science 2500, Springer 2002.<a href="#fnref11">↩</a></li>
<li id="fn12">3. ⇔ 9. by the <a href="Myhill–Nerode_theorem" title="wikilink">Myhill–Nerode theorem</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20">Salomaa (1981) p.28<a href="#fnref20">↩</a></li>
<li id="fn21">Salomaa (1981) p.27<a href="#fnref21">↩</a></li>
<li id="fn22"><a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">J. Hartmanis, P. L. Lewis II, and R. E. Stearns. Hierarchies of memory-limited computations. <em>Proceedings of the 6th Annual IEEE Symposium on Switching Circuit Theory and Logic Design</em>, pp. 179–190. 1965.<a href="#fnref25">↩</a></li>
<li id="fn26">A finite language shouldn't be confused with a (usually infinite) language generated by a finite automaton.<a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29">Berstel &amp; Reutenauer (2011) p.220<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31">Flajolet &amp; Sedgweick, section V.3.1, equation (13).<a href="#fnref31">↩</a></li>
<li id="fn32"><a href="http://cs.stackexchange.com/a/1048/55">Proof of theorem for irreducible DFAs</a><a href="#fnref32">↩</a></li>
<li id="fn33"><a class="uri" href="http://cs.stackexchange.com/a/11333/683">http://cs.stackexchange.com/a/11333/683</a> Proof of theorem for arbitrary DFAs<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="http://cs.stackexchange.com/q/1045/55">Number of words of a given length in a regular language</a><a href="#fnref34">↩</a></li>
<li id="fn35">Flajolet &amp; Sedgewick (2002) Theorem V.3<a href="#fnref35">↩</a></li>
<li id="fn36"></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38">Berstel &amp; Reutenauer (2011) p.222<a href="#fnref38">↩</a></li>
<li id="fn39"> in two volumes "A" (1974, ISBN 9780080873749) and "B" (1976, ISBN 9780080873756), the latter with two chapters by Bret Tilson.<a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41">Berstel &amp; Reutenauer (2011) p.47<a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
</ol>
</section>
</body>
</html>
