<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1062">Travelling salesman problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Travelling salesman problem</h1>
<hr/>

<p>The '''travelling salesman problem ''' (<strong>TSP</strong>) asks the following question: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? It is an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problem in <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a>, important in <a href="operations_research" title="wikilink">operations research</a> and <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>.</p>

<p> TSP is a special case of the <a href="Traveling_purchaser_problem" title="wikilink">travelling purchaser problem</a> and the <a href="Vehicle_routing_problem" title="wikilink">Vehicle routing problem</a>.</p>

<p>In the <a href="Computational_complexity_theory" title="wikilink">theory of computational complexity</a>, the decision version of the TSP (where, given a length <em>L</em>, the task is to decide whether the graph has any tour shorter than <em>L</em>) belongs to the class of <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems. Thus, it is possible that the <a href="Best,_worst_and_average_case" title="wikilink">worst-case</a> <a href="running_time" title="wikilink">running time</a> for any algorithm for the TSP increases <a href="Time_complexity#Superpolynomial_time" title="wikilink">superpolynomially</a> (perhaps, specifically, <a href="Exponential_time_hypothesis" title="wikilink">exponentially</a>) with the number of cities.</p>

<p>The problem was first formulated in 1930 and is one of the most intensively studied problems in optimization. It is used as a benchmark for many optimization methods. Even though the problem is computationally difficult, a large number of <a href="heuristic" title="wikilink">heuristics</a> and exact methods are known, so that some instances with tens of thousands of cities can be solved completely and even problems with millions of cities can be approximated within a small fraction of 1%.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The TSP has several applications even in its purest formulation, such as <a class="uri" href="planning" title="wikilink">planning</a>, <a class="uri" href="logistics" title="wikilink">logistics</a>, and the manufacture of <a href="Integrated_circuit" title="wikilink">microchips</a>. Slightly modified, it appears as a sub-problem in many areas, such as <a href="DNA_sequencing" title="wikilink">DNA sequencing</a>. In these applications, the concept <em>city</em> represents, for example, customers, soldering points, or DNA fragments, and the concept <em>distance</em> represents travelling times or cost, or a similarity measure between DNA fragments. The TSP also appears in astronomy, as astronomers observing many sources will want to minimise the time spent slewing the telescope between the sources. In many applications, additional constraints such as limited resources or time windows may be imposed.</p>
<h2 id="history">History</h2>

<p>The origins of the travelling salesman problem are unclear. A handbook for travelling salesmen from 1832 mentions the problem and includes example tours through Germany and Switzerland, but contains no mathematical treatment.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>William Rowan Hamilton</figcaption>
</figure>

<p>The travelling salesman problem was mathematically formulated in the 1800s by the Irish mathematician <a href="William_Rowan_Hamilton" title="wikilink">W.R. Hamilton</a> and by the British mathematician <a href="Thomas_Kirkman" title="wikilink">Thomas Kirkman</a>. Hamilton’s <a href="Icosian_Game" title="wikilink">Icosian Game</a> was a recreational puzzle based on finding a <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The general form of the TSP appears to have been first studied by mathematicians during the 1930s in Vienna and at Harvard, notably by <a href="Karl_Menger" title="wikilink">Karl Menger</a>, who defines the problem, considers the obvious brute-force algorithm, and observes the non-optimality of the nearest neighbour heuristic: </p>

<p>It was first considered mathematically in the 1930s by Merrill Flood who was looking to solve a school bus routing problem.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="Hassler_Whitney" title="wikilink">Hassler Whitney</a> at <a href="Princeton_University" title="wikilink">Princeton University</a> introduced the name <em>travelling salesman problem</em> soon after.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>In the 1950s and 1960s, the problem became increasingly popular in scientific circles in Europe and the USA after the <a href="RAND_Corporation" title="wikilink">RAND Corporation</a> in <a href="Santa_Monica" title="wikilink">Santa Monica</a>, offered prizes for steps in solving the problem.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Notable contributions were made by <a href="George_Dantzig" title="wikilink">George Dantzig</a>, <a href="Delbert_Ray_Fulkerson" title="wikilink">Delbert Ray Fulkerson</a> and <a href="Selmer_M._Johnson" title="wikilink">Selmer M. Johnson</a> from the RAND Corporation, who expressed the problem as an <a href="integer_linear_program" title="wikilink">integer linear program</a> and developed the <a href="cutting_plane" title="wikilink">cutting plane</a> method for its solution. They wrote what is considered the seminal paper on the subject in which with these new methods they solved an instance with 49 cities to optimality by constructing a tour and proving that no other tour could be shorter. Dantzig, Fulkerson and Johnson, however, speculated that given a near optimal solution we may be able to find optimality or prove optimality by adding a small amount of extra inequalities (cuts). They used this idea to solve their initial 49 city problem using a string model. They found they only needed 26 cuts to come to a solution for their 49 city problem. While this paper did not give an algorithmic approach to TSP problems, the ideas that lay within it were indispensable to later creating exact solution methods for the TSP, though it would take 15 years to find an algorithmic approach in creating these cuts.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> As well as cutting plane methods, Dantzig, Fulkerson and Johnson used <a href="branch_and_bound" title="wikilink">branch and bound</a> algorithms perhaps for the first time.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>In the following decades, the problem was studied by many researchers from <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="computer_science" title="wikilink">computer science</a>, <a class="uri" href="chemistry" title="wikilink">chemistry</a>, <a class="uri" href="physics" title="wikilink">physics</a>, and other sciences. In the 1960s however a new approach was created, instead of finding optimal solutions, people tried to instead find the worst solutions and in doing so, created lower bounds for the problem. These may then be used with branch and bound approaches. One method of doing this was to create the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> of the graph and then multiply the cost of this by 2.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Christofides made a big advance in this approach of giving an approach for which we know the worst case scenario. His algorithm given in 1976, at worst is 1.5 times longer than the optimal solution. As the algorithm was so simple and quick, many hoped it would give way to a near optimal solution method. However, until 2011 when it was beaten by less than a billionth of a percent, this remained the method with the best worst case scenario.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p><a href="Richard_M._Karp" title="wikilink">Richard M. Karp</a> showed in 1972 that the <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a> problem was <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, which implies the <a href="NP-hard" title="wikilink">NP-hardness</a> of TSP. This supplied a mathematical explanation for the apparent computational difficulty of finding optimal tours.</p>

<p>Great progress was made in the late 1970s and 1980, when Grötschel, Padberg, Rinaldi and others managed to exactly solve instances with up to 2392 cities, using cutting planes and <a class="uri" href="branch-and-bound" title="wikilink">branch-and-bound</a>.</p>

<p>In the 1990s, Applegate, Bixby, <a href="Vašek_Chvátal" title="wikilink">Chvátal</a>, and <a href="William_J._Cook" title="wikilink">Cook</a> developed the program <em>Concorde</em> that has been used in many recent record solutions. Gerhard Reinelt published the TSPLIB in 1991, a collection of benchmark instances of varying difficulty, which has been used by many research groups for comparing results. In 2006, Cook and others computed an optimal tour through an 85,900-city instance given by a microchip layout problem, currently the largest solved TSPLIB instance. For many other instances with millions of cities, solutions can be found that are guaranteed to be within 2-3% of an optimal tour.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>The problem is sometimes, especially in newer publications, referred to as <em>Travelling Salesperson Problem</em>.</p>
<h2 id="description">Description</h2>
<h3 id="as-a-graph-problem">As a graph problem</h3>

<p> TSP can be modelled as an <a href="graph_(mathematics)" title="wikilink">undirected weighted graph</a>, such that cities are the graph's <a href="vertex_(graph_theory)" title="wikilink">vertices</a>, paths are the graph's <a href="Glossary_of_graph_theory#Basics" title="wikilink">edges</a>, and a path's distance is the edge's length. It is a minimization problem starting and finishing at a specified <a href="vertex_(graph_theory)" title="wikilink">vertex</a> after having visited each other <a href="vertex_(graph_theory)" title="wikilink">vertex</a> exactly once. Often, the model is a <a href="complete_graph" title="wikilink">complete graph</a> (<em>i.e.</em> each pair of vertices is connected by an edge). If no path exists between two cities, adding an arbitrarily long edge will complete the graph without affecting the optimal tour.</p>
<h3 id="asymmetric-and-symmetric">Asymmetric and symmetric</h3>

<p>In the <em>symmetric TSP</em>, the distance between two cities is the same in each opposite direction, forming an <a href="undirected_graph" title="wikilink">undirected graph</a>. This symmetry halves the number of possible solutions. In the <em>asymmetric TSP</em>, paths may not exist in both directions or the distances might be different, forming a <a href="directed_graph" title="wikilink">directed graph</a>. <a href="Traffic_collision" title="wikilink">Traffic collisions</a>, <a href="one-way_street" title="wikilink">one-way streets</a>, and airfares for cities with different departure and arrival fees are examples of how this symmetry could break down.</p>
<h3 id="related-problems">Related problems</h3>
<ul>
<li>An equivalent formulation in terms of <a href="graph_theory" title="wikilink">graph theory</a> is: Given a <a href="Glossary_of_graph_theory" title="wikilink">complete weighted graph</a> (where the vertices would represent the cities, the edges would represent the roads, and the weights would be the cost or distance of that road), find a <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a> with the least weight.</li>
</ul>
<ul>
<li>The requirement of returning to the starting city does not change the <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> of the problem, see <a href="Hamiltonian_path_problem" title="wikilink">Hamiltonian path problem</a>.</li>
</ul>
<ul>
<li>Another related problem is the <a href="bottleneck_traveling_salesman_problem" title="wikilink">bottleneck travelling salesman problem</a> (bottleneck TSP): Find a Hamiltonian cycle in a <a href="glossary_of_graph_theory" title="wikilink">weighted graph</a> with the minimal weight of the weightiest <a href="edge_(graph_theory)" title="wikilink">edge</a>. The problem is of considerable practical importance, apart from evident transportation and logistics areas. A classic example is in <a href="Printed_circuit_board" title="wikilink">printed circuit</a> manufacturing: scheduling of a route of the <a class="uri" href="drill" title="wikilink">drill</a> machine to drill holes in a PCB. In robotic machining or drilling applications, the "cities" are parts to machine or holes (of different sizes) to drill, and the "cost of travel" includes time for retooling the robot (single machine job sequencing problem).<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ul>
<ul>
<li>The <a href="Set_TSP_problem" title="wikilink">generalized travelling salesman problem</a>, also known as the "travelling politician problem", deals with "states" that have (one or more) "cities" and the salesman has to visit exactly one "city" from each "state". One application is encountered in ordering a solution to the <a href="cutting_stock_problem" title="wikilink">cutting stock problem</a> in order to minimise knife changes. Another is concerned with drilling in <a class="uri" href="semiconductor" title="wikilink">semiconductor</a> manufacturing, see e.g., . Surprisingly, Behzad and Modarres demonstrated that the generalised travelling salesman problem can be transformed into a standard travelling salesman problem with the same number of cities, but a modified <a href="distance_matrix" title="wikilink">distance matrix</a>.</li>
</ul>
<ul>
<li>The sequential ordering problem deals with the problem of visiting a set of cities where precedence relations between the cities exist.</li>
</ul>
<ul>
<li>The travelling purchaser problem deals with a purchaser who is charged with purchasing a set of products. He can purchase these products in several cities, but at different prices and not all cities offer the same products. The objective is to find a route between a subset of the cities, which minimizes total cost (travel cost + purchasing cost) and which enables the purchase of all required products.</li>
</ul>
<h2 id="integer-linear-programming-formulation">Integer linear programming formulation</h2>

<p>TSP can be formulated as an <a href="integer_programming" title="wikilink">integer linear program</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Label the cities with the numbers 0, ..., <em>n</em> and define:</p>

<p>

<math display="block" id="Travelling_salesman_problem:0">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>the path goes from city</mtext>
        <mi>i</mi>
        <mtext>to city</mtext>
        <mi>j</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <mtext>the path goes from city</mtext>
      <ci>i</ci>
      <mtext>to city</mtext>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}=\begin{cases}1&\text{the path goes from city }i\text{ to city }j\\
0&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>For <em>i</em> = 0, ..., <em>n</em>, let 

<math display="inline" id="Travelling_salesman_problem:1">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 be an artificial variable, and finally take 

<math display="inline" id="Travelling_salesman_problem:2">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ij}
  </annotation>
 </semantics>
</math>

 to be the distance from city <em>i</em> to city <em>j</em>. Then TSP can be written as the following integer linear programming problem:</p>

<p>

<math display="inline" id="Travelling_salesman_problem:3">
 <semantics>
  <mi>min</mi>
  <annotation-xml encoding="MathML-Content">
   <min></min>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\min
  </annotation>
 </semantics>
</math>


</p>

<p>The first set of equalities requires that each city be arrived at from exactly one other city, and the second set of equalities requires that from each city there is a departure to exactly one other city. The last constraints enforce that there is only a single tour covering all cities, and not two or more disjointed tours that only collectively cover all cities. To prove this, it is shown below (1) that every feasible solution contains only one closed sequence of cities, and (2) that for every single tour covering all cities, there are values for the dummy variables 

<math display="inline" id="Travelling_salesman_problem:4">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 that satisfy the constraints.</p>

<p>To prove that every feasible solution contains only one closed sequence of cities, it suffices to show that every subtour in a feasible solution passes through city 0 (noting that the equalities ensure there can only be one such tour). For if we sum all the inequalities corresponding to 

<math display="inline" id="Travelling_salesman_problem:5">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}=1
  </annotation>
 </semantics>
</math>

 for any subtour of <em>k</em> steps not passing through city 0, we obtain:</p>

<p>

<math display="block" id="Travelling_salesman_problem:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mi>k</mi>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nk\leq(n-1)k,
  </annotation>
 </semantics>
</math>

</p>

<p>which is a contradiction.</p>

<p>It now must be shown that for every single tour covering all cities, there are values for the dummy variables 

<math display="inline" id="Travelling_salesman_problem:7">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 that satisfy the constraints.</p>

<p>Without loss of generality, define the tour as originating (and ending) at city 0. Choose 

<math display="inline" id="Travelling_salesman_problem:8">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}=t
  </annotation>
 </semantics>
</math>

 if city <em>i</em> is visited in step <em>t</em> (<em>i</em>, <em>t</em> = 1, 2, ..., n). Then</p>

<p>

<math display="block" id="Travelling_salesman_problem:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>u</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>u</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}-u_{j}\leq n-1,
  </annotation>
 </semantics>
</math>

</p>

<p>since 

<math display="inline" id="Travelling_salesman_problem:10">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 can be no greater than <em>n</em> and 

<math display="inline" id="Travelling_salesman_problem:11">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{j}
  </annotation>
 </semantics>
</math>

 can be no less than 1; hence the constraints are satisfied whenever 

<math display="inline" id="Travelling_salesman_problem:12">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}=0.
  </annotation>
 </semantics>
</math>

 For 

<math display="inline" id="Travelling_salesman_problem:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}=1
  </annotation>
 </semantics>
</math>

, we have:</p>

<p>

<math display="block" id="Travelling_salesman_problem:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>u</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}-u_{j}+nx_{ij}=(t)-(t+1)+n=n-1,
  </annotation>
 </semantics>
</math>

</p>

<p>satisfying the constraint.</p>
<h2 id="computing-a-solution">Computing a solution</h2>

<p>The traditional lines of attack for the NP-hard problems are the following:</p>
<ul>
<li>Devising algorithms for finding exact solutions (they will work reasonably fast only for small problem sizes).</li>
<li>Devising "suboptimal" or <a href="heuristic_algorithm" title="wikilink">heuristic algorithms</a>, i.e., algorithms that deliver either seemingly or probably good solutions, but which could not be proved to be optimal.</li>
<li>Finding special cases for the problem ("subproblems") for which either better or exact heuristics are possible.</li>
</ul>
<h3 id="exact-algorithms">Exact algorithms</h3>

<p>The most direct solution would be to try all <a href="permutation" title="wikilink">permutations</a> (ordered combinations) and see which one is cheapest (using <a href="brute_force_search" title="wikilink">brute force search</a>). The running time for this approach lies within a polynomial factor of 

<math display="inline" id="Travelling_salesman_problem:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n!)
  </annotation>
 </semantics>
</math>

, the <a class="uri" href="factorial" title="wikilink">factorial</a> of the number of cities, so this solution becomes impractical even for only 20 cities.</p>

<p><code>One of the earliest applications of </code><a href="dynamic_programming" title="wikilink"><code>dynamic</code> <code>programming</code></a><code> is the </code><a href="Held–Karp_algorithm" title="wikilink"><code>Held–Karp</code> <code>algorithm</code></a><code> that solves the problem in time </code>

<math display="inline" id="Travelling_salesman_problem:16">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}2^{n})
  </annotation>
 </semantics>
</math>

<code>.</code><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p><a href="File:Bruteforce.gif" title="wikilink">framed|right|Solution to a symmetric TSP with 7 cities using brute force search. Note: Number of permutations: (7-1)!/2 = 360</a></p>

<p>Improving these time bounds seems to be difficult. For example, it has not been determined whether an exact algorithm for TSP that runs in time 

<math display="inline" id="Travelling_salesman_problem:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>1.9999</mn>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="float">1.9999</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1.9999^{n})
  </annotation>
 </semantics>
</math>

 exists.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Other approaches include:</p>
<ul>
<li>Various <a href="Branch_and_bound" title="wikilink">branch-and-bound</a> algorithms, which can be used to process TSPs containing 40–60 cities.</li>
</ul>

<p><a href="File:Branchbound.gif" title="wikilink">framed|right|Solution of a TSP with 7 cities using a simple Branch and bound algorithm. Note: The number of permutations is much less than Brute force search</a></p>
<ul>
<li>Progressive improvement algorithms which use techniques reminiscent of <a href="linear_programming" title="wikilink">linear programming</a>. Works well for up to 200 cities.</li>
<li>Implementations of <a href="Branch_and_bound" title="wikilink">branch-and-bound</a> and problem-specific cut generation (<a href="Branch_and_cut" title="wikilink">branch-and-cut</a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a>); this is the method of choice for solving large instances. This approach holds the current record, solving an instance with 85,900 cities, see .</li>
</ul>

<p>An exact solution for 15,112 German towns from TSPLIB was found in 2001 using the <a href="cutting-plane_method" title="wikilink">cutting-plane method</a> proposed by <a href="George_Dantzig" title="wikilink">George Dantzig</a>, <a href="D._R._Fulkerson" title="wikilink">Ray Fulkerson</a>, and <a href="Selmer_M._Johnson" title="wikilink">Selmer M. Johnson</a> in 1954, based on <a href="linear_programming" title="wikilink">linear programming</a>. The computations were performed on a network of 110 processors located at <a href="Rice_University" title="wikilink">Rice University</a> and <a href="Princeton_University" title="wikilink">Princeton University</a> (see the Princeton external link). The total computation time was equivalent to 22.6 years on a single 500 MHz <a href="Alpha_processor" title="wikilink">Alpha processor</a>. In May 2004, the travelling salesman problem of visiting all 24,978 towns in Sweden was solved: a tour of length approximately 72,500 kilometers was found and it was proven that no shorter tour exists.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In March 2005, the travelling salesman problem of visiting all 33,810 points in a circuit board was solved using <em><a href="Concorde_TSP_Solver" title="wikilink">Concorde TSP Solver</a></em>: a tour of length 66,048,945 units was found and it was proven that no shorter tour exists. The computation took approximately 15.7 CPU-years (Cook et al. 2006). In April 2006 an instance with 85,900 points was solved using <em>Concorde TSP Solver</em>, taking over 136 CPU-years, see .</p>
<h3 id="heuristic-and-approximation-algorithms">Heuristic and approximation algorithms</h3>

<p>Various <a href="Heuristic_(computer_science)" title="wikilink">heuristics</a> and <a href="approximation_algorithm" title="wikilink">approximation algorithms</a>, which quickly yield good solutions have been devised. Modern methods can find solutions for extremely large problems (millions of cities) within a reasonable time which are with a high probability just 2–3% away from the optimal solution.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>Several categories of heuristics are recognized.</p>
<h4 id="constructive-heuristics">Constructive heuristics</h4>

<p> The <a href="nearest_neighbour_algorithm" title="wikilink">nearest neighbor (NN) algorithm</a> (or so-called <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>) lets the salesman choose the nearest unvisited city as his next move. This algorithm quickly yields an effectively short route. For N cities randomly distributed on a plane, the algorithm on average yields a path 25% longer than the shortest possible path.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> However, there exist many specially arranged city distributions which make the NN algorithm give the worst route (Gutin, Yeo, and Zverovich, 2002). This is true for both asymmetric and symmetric TSPs (Gutin and Yeo, 2007). Rosenkrantz et al. [1977] showed that the NN algorithm has the approximation factor 

<math display="inline" id="Travelling_salesman_problem:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\log|V|)
  </annotation>
 </semantics>
</math>

 for instances satisfying the triangle inequality. A variation of NN algorithm, called Nearest Fragment (NF) operator, which connects a group (fragment) of nearest unvisited cities, can find shorter route with successive iterations.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> The NF operator can also be applied on an initial solution obtained by NN algorithm for further improvement in an elitist model, where only better solutions are accepted.</p>

<p>The <a href="bitonic_tour" title="wikilink">bitonic tour</a> of a set of points is the minimum-perimeter <a href="monotone_polygon" title="wikilink">monotone polygon</a> that has the points as its vertices; it can be computed efficiently by <a href="dynamic_programming" title="wikilink">dynamic programming</a>.</p>

<p>Another constructive heuristic, Match Twice and Stitch (MTS) (Kahng, Reda 2004 <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a>), performs two sequential <a href="Matching_(graph_theory)" title="wikilink">matchings</a>, where the second matching is executed after deleting all the edges of the first matching, to yield a set of cycles. The cycles are then stitched to produce the final tour.</p>
<h5 id="christofides-algorithm-for-the-tsp">Christofides' algorithm for the TSP</h5>

<p>The <a href="Christofides_algorithm" title="wikilink">Christofides algorithm</a> follows a similar outline but combines the minimum spanning tree with a solution of another problem, minimum-weight <a href="perfect_matching" title="wikilink">perfect matching</a>. This gives a TSP tour which is at most 1.5 times the optimal. The Christofides algorithm was one of the first <a href="approximation_algorithm" title="wikilink">approximation algorithms</a>, and was in part responsible for drawing attention to approximation algorithms as a practical approach to intractable problems. As a matter of fact, the term "algorithm" was not commonly extended to approximation algorithms until later; the Christofides algorithm was initially referred to as the Christofides heuristic.</p>

<p>This algorithm looks at things differently by using a result from graph theory which helps improve on the LB of the TSP which originated from doubling the cost of the minimum spanning tree. Given an <a href="Eulerian_graph" title="wikilink">Eulerian graph</a> we can find an <a href="Eulerian_tour" title="wikilink">Eulerian tour</a> in <em>O(n)</em> time.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> So if we had an Eulerian graph with cities from a TSP as vertices then we can easily see that we could use such a method for finding an Eulerian tour to find a TSP solution. By <a href="triangular_inequality" title="wikilink">triangular inequality</a> we know that the TSP tour can be no longer than the Eulerian tour and as such we have a LB for the TSP. Such a method is described below. </p>
<ol>
<li>Find a minimum spanning tree for the problem</li>
<li>Create duplicates for every edge to create an Eulerian graph</li>
<li>Find an Eulerian tour for this graph</li>
<li>Convert to TSP: if a city if visited twice, create a shortcut from the city before this in the tour to the one after this.</li>
</ol>

<p>To improve our lower bound, we therefore need a better way of creating an Eulerian graph. But by triangular inequality, the best Eulerian graph must have the same cost as the best travelling salesman tour, hence finding optimal Eulerian graphs is at least as hard as TSP. One way of doing this that has been proposed is by the concept of minimum weight <a href="Matching_(graph_theory)" title="wikilink">matching</a> for the creation of which there exist algorithms of O($n^3$).<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> </p>

<p>To make a graph into an Eulerian graph, one starts with the minimum spanning tree. Then all the vertices of odd order must be made even. So a matching for the odd degree vertices must be added which increases the order of every odd degree vertex by one.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> This leaves us with a graph where every vertex is of even order which is thus Eulerian. Now we can adapt the above method to give Christofides' algorithm,</p>
<ol>
<li>Find a minimum spanning tree for the problem</li>
<li>Create a matching for the problem with the set of cities of odd order.</li>
<li>Find an Eulerian tour for this graph</li>
<li>Convert to TSP using shortcuts.</li>
</ol>
<h4 id="iterative-improvement">Iterative improvement</h4>
<figure><b>(Figure)</b>
<figcaption>An example of a 2-opt iteration</figcaption>
</figure>
<dl>
<dt>Pairwise exchange: The pairwise exchange or <em><a class="uri" href="2-opt" title="wikilink">2-opt</a></em> technique involves iteratively removing two edges and replacing these with two different edges that reconnect the fragments created by edge removal into a new and shorter tour. This is a special case of the <em>k</em>-opt method. Note that the label <em>Lin–Kernighan</em> is an often heard misnomer for 2-opt. Lin–Kernighan is actually the more general k-opt method.</dt>
</dl>

<p>For Euclidean instances, 2-opt heuristics give on average solutions that are about 5% better than Christofides' algorithm. If we start with an initial solution made with a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>, the average number of moves greatly decreases again and is <em>O(n)</em>. For random starts however, the average number of moves is <em>O(n</em> log<em>(n))</em>. However whilst in order this is a small increase in size, the initial number of moves for small problems is 10 times as big for a random start compared to one made from a greedy heuristic. This is because such 2-opt heuristics exploit `bad' parts of a solution such as crossings. These types of heuristics are often used within <a href="Vehicle_routing_problem" title="wikilink">Vehicle routing problem</a> heuristics to reoptimise route solutions.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<dl>
<dt><em>k</em>-opt heuristic, or <a class="uri" href="Lin–Kernighan" title="wikilink">Lin–Kernighan</a> heuristics: Take a given tour and delete <em>k</em> mutually disjoint edges. Reassemble the remaining fragments into a tour, leaving no disjoint subtours (that is, don't connect a fragment's endpoints together). This in effect simplifies the TSP under consideration into a much simpler problem. Each fragment endpoint can be connected to 2<em>k</em> − 2 other possibilities: of 2<em>k</em> total fragment endpoints available, the two endpoints of the fragment under consideration are disallowed. Such a constrained 2<em>k</em>-city TSP can then be solved with brute force methods to find the least-cost recombination of the original fragments. The <em>k</em>-opt technique is a special case of the <em>V</em>-opt or variable-opt technique. The most popular of the <em>k</em>-opt methods are 3-opt, and these were introduced by Shen Lin of Bell Labs in 1965. There is a special case of 3-opt where the edges are not disjoint (two of the edges are adjacent to one another). In practice, it is often possible to achieve substantial improvement over 2-opt without the combinatorial cost of the general 3-opt by restricting the 3-changes to this special subset where two of the removed edges are adjacent. This so-called two-and-a-half-opt typically falls roughly midway between 2-opt and 3-opt, both in terms of the quality of tours achieved and the time required to achieve those tours.<br/>
<em>V</em>-opt heuristic: The variable-opt method is related to, and a generalization of the <em>k</em>-opt method. Whereas the <em>k</em>-opt methods remove a fixed number (<em>k</em>) of edges from the original tour, the variable-opt methods do not fix the size of the edge set to remove. Instead they grow the set as the search process continues. The best known method in this family is the Lin–Kernighan method (mentioned above as a misnomer for 2-opt). <a href="Shen_Lin" title="wikilink">Shen Lin</a> and <a href="Brian_Kernighan" title="wikilink">Brian Kernighan</a> first published their method in 1972, and it was the most reliable heuristic for solving travelling salesman problems for nearly two decades. More advanced variable-opt methods were developed at Bell Labs in the late 1980s by David Johnson and his research team. These methods (sometimes called <a class="uri" href="Lin–Kernighan–Johnson" title="wikilink">Lin–Kernighan–Johnson</a>) build on the Lin–Kernighan method, adding ideas from <a href="tabu_search" title="wikilink">tabu search</a> and <a href="evolutionary_computing" title="wikilink">evolutionary computing</a>. The basic Lin–Kernighan technique gives results that are guaranteed to be at least 3-opt. The Lin–Kernighan–Johnson methods compute a Lin–Kernighan tour, and then perturb the tour by what has been described as a mutation that removes at least four edges and reconnecting the tour in a different way, then <em>V</em>-opting the new tour. The mutation is often enough to move the tour from the <a href="local_minimum" title="wikilink">local minimum</a> identified by Lin–Kernighan. <em>V</em>-opt methods are widely considered the most powerful heuristics for the problem, and are able to address special cases, such as the Hamilton Cycle Problem and other non-metric TSPs that other heuristics fail on. For many years Lin–Kernighan–Johnson had identified optimal solutions for all TSPs where an optimal solution was known and had identified the best known solutions for all other TSPs on which the method had been tried.</dt>
</dl>
<h4 id="randomised-improvement">Randomised improvement</h4>

<p>Optimized <a href="Markov_chain" title="wikilink">Markov chain</a> algorithms which use local searching heuristic sub-algorithms can find a route extremely close to the optimal route for 700 to 800 cities.</p>

<p>TSP is a touchstone for many general heuristics devised for combinatorial optimization such as <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>, <a href="simulated_annealing" title="wikilink">simulated annealing</a>, <a href="Tabu_search" title="wikilink">Tabu search</a>, <a href="ant_colony_optimization" title="wikilink">ant colony optimization</a>, <a href="river_formation_dynamics" title="wikilink">river formation dynamics</a> (see <a href="swarm_intelligence" title="wikilink">swarm intelligence</a>) and the <a href="cross_entropy_method" title="wikilink">cross entropy method</a>.</p>
<h5 id="ant-colony-optimization">Ant colony optimization</h5>

<p><a href="Artificial_intelligence" title="wikilink">Artificial intelligence</a> researcher <a href="Marco_Dorigo" title="wikilink">Marco Dorigo</a> described in 1997 a method of heuristically generating "good solutions" to the TSP using a <a href="Ant_colony_optimization" title="wikilink">simulation of an ant colony</a> called <em>ACS</em> (Ant Colony System).<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> It models behavior observed in real ants to find short paths between food sources and their nest, an <a href="emergence" title="wikilink">emergent</a> behaviour resulting from each ant's preference to follow <a href="Pheromone#Trail" title="wikilink">trail pheromones</a> deposited by other ants.</p>

<p>ACS sends out a large number of virtual ant agents to explore many possible routes on the map. Each ant probabilistically chooses the next city to visit based on a heuristic combining the distance to the city and the amount of virtual pheromone deposited on the edge to the city. The ants explore, depositing pheromone on each edge that they cross, until they have all completed a tour. At this point the ant which completed the shortest tour deposits virtual pheromone along its complete tour route (<em>global trail updating</em>). The amount of pheromone deposited is inversely proportional to the tour length: the shorter the tour, the more it deposits.</p>

<p> <a href="File:AntColony.gif" title="wikilink">framed|center|Ant Colony Optimization Algorithm for a TSP with 7 cities: Red and thick lines in the pheromone map indicate presence of more pheromone</a></p>
<h2 id="special-cases-of-the-tsp">Special cases of the TSP</h2>
<h3 id="metric-tsp">Metric TSP</h3>

<p>In the <em>metric TSP</em>, also known as <em>delta-TSP</em> or Δ-TSP, the intercity distances satisfy the <a href="triangle_inequality" title="wikilink">triangle inequality</a>.</p>

<p>A very natural restriction of the TSP is to require that the distances between cities form a <a href="metric_(mathematics)" title="wikilink">metric</a> to satisfy the <a href="triangle_inequality" title="wikilink">triangle inequality</a>; that is the direct connection from <em>A</em> to <em>B</em> is never farther than the route via intermediate <em>C</em>:</p>

<p>

<math display="block" id="Travelling_salesman_problem:19">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>A</mi>
      <mi>C</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>C</mi>
      <mi>B</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{AB}\leq d_{AC}+d_{CB}
  </annotation>
 </semantics>
</math>

.</p>

<p>The edge spans then build a <a href="metric_space" title="wikilink">metric</a> on the set of vertices. When the cities are viewed as points in the plane, many natural <a href="distance_function" title="wikilink">distance functions</a> are metrics, and so many natural instances of TSP satisfy this constraint.</p>

<p>The following are some examples of metric TSPs for various metrics.</p>
<ul>
<li>In the Euclidean TSP (see below) the distance between two cities is the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> between the corresponding points.</li>
<li>In the rectilinear TSP the distance between two cities is the sum of the differences of their <em>x</em>- and <em>y</em>-coordinates. This metric is often called the <a href="Manhattan_distance" title="wikilink">Manhattan distance</a> or city-block metric.</li>
<li>In the <a href="maximum_metric" title="wikilink">maximum metric</a>, the distance between two points is the maximum of the absolute values of differences of their <em>x</em>- and <em>y</em>-coordinates.</li>
</ul>

<p>The last two metrics appear for example in routing a machine that drills a given set of holes in a <a href="printed_circuit_board" title="wikilink">printed circuit board</a>. The Manhattan metric corresponds to a machine that adjusts first one co-ordinate, and then the other, so the time to move to a new point is the sum of both movements. The maximum metric corresponds to a machine that adjusts both co-ordinates simultaneously, so the time to move to a new point is the slower of the two movements.</p>

<p>In its definition, the TSP does not allow cities to be visited twice, but many applications do not need this constraint. In such cases, a symmetric, non-metric instance can be reduced to a metric one. This replaces the original graph with a complete graph in which the inter-city distance 

<math display="inline" id="Travelling_salesman_problem:20">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{AB}
  </annotation>
 </semantics>
</math>

 is replaced by the <a href="shortest_path" title="wikilink">shortest path</a> between <em>A</em> and <em>B</em> in the original graph.</p>
<h3 id="euclidean-tsp">Euclidean TSP</h3>

<p>The <strong>Euclidean TSP</strong>, or <strong>planar TSP</strong>, is the TSP with the distance being the ordinary <a href="Euclidean_distance" title="wikilink">Euclidean distance</a>.</p>

<p>The Euclidean TSP is a particular case of the metric TSP, since distances in a plane obey the triangle inequality.</p>

<p>Like the general TSP, the Euclidean TSP is NP-hard. With discretized metric (distances rounded up to an integer), the problem is NP-complete. However, in some respects it seems to be easier than the general metric TSP. For example, the minimum spanning tree of the graph associated with an instance of the Euclidean TSP is a <a href="Euclidean_minimum_spanning_tree" title="wikilink">Euclidean minimum spanning tree</a>, and so can be computed in expected O (<em>n</em> log <em>n</em>) time for <em>n</em> points (considerably less than the number of edges). This enables the simple 2-approximation algorithm for TSP with triangle inequality above to operate more quickly.</p>

<p>In general, for any <em>c</em> &gt; 0, where <em>d</em> is the number of dimensions in the Euclidean space, there is a polynomial-time algorithm that finds a tour of length at most (1 + 1/<em>c</em>) times the optimal for geometric instances of TSP in</p>

<p>

<math display="block" id="Travelling_salesman_problem:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>O</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>c</mi>
            <msqrt>
             <mi>d</mi>
            </msqrt>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>d</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </msup>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>O</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <apply>
          <root></root>
          <ci>d</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(n(\log n)^{(O(c\sqrt{d}))^{d-1}}\right),
  </annotation>
 </semantics>
</math>

</p>

<p>time; this is called a <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme</a> (PTAS). <a href="Sanjeev_Arora" title="wikilink">Sanjeev Arora</a> and <a href="Joseph_S._B._Mitchell" title="wikilink">Joseph S. B. Mitchell</a> were awarded the <a href="Gödel_Prize" title="wikilink">Gödel Prize</a> in 2010 for their concurrent discovery of a PTAS for the Euclidean TSP.</p>

<p>In practice, simpler heuristics with weaker guarantees continue to be used.</p>
<h3 id="asymmetric-tsp">Asymmetric TSP</h3>

<p>In most cases, the distance between two nodes in the TSP network is the same in both directions. The case where the distance from <em>A</em> to <em>B</em> is not equal to the distance from <em>B</em> to <em>A</em> is called asymmetric TSP. A practical application of an asymmetric TSP is route optimisation using street-level routing (which is made asymmetric by one-way streets, slip-roads, motorways, etc.).</p>
<h4 id="solving-by-conversion-to-symmetric-tsp">Solving by conversion to symmetric TSP</h4>

<p>Solving an asymmetric TSP graph can be somewhat complex. The following is a 3×3 matrix containing all possible path weights between the nodes <em>A</em>, <em>B</em> and <em>C</em>. One option is to turn an asymmetric matrix of size <em>N</em> into a symmetric matrix of size 2<em>N</em>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
</dd>
</dl>

<p>To double the size, each of the nodes in the graph is duplicated, creating a second <em>ghost node</em>. Using duplicate points with very low weights, such as −∞, provides a cheap route "linking" back to the real node and allowing symmetric evaluation to continue. The original 3×3 matrix shown above is visible in the bottom left and the inverse of the original in the top-right. Both copies of the matrix have had their diagonals replaced by the low-cost hop paths, represented by −∞.</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The original 3×3 matrix would produce two Hamiltonian cycles (a path that visits every node once), namely <em>A</em>-<em>B</em>-<em>C</em>-<em>A</em> [score 9] and <em>A</em>-<em>C</em>-<em>B</em>-<em>A</em> [score 12]. Evaluating the 6×6 symmetric version of the same problem now produces many paths, including <em>A</em>-<em>A′</em>-<em>B</em>-<em>B′</em>-<em>C</em>-<em>C′</em>-<em>A</em>, <em>A</em>-<em>B′</em>-<em>C</em>-<em>A′</em>-<em>A</em>, <em>A</em>-<em>A′</em>-<em>B</em>-<em>C′</em>-<em>A</em> [all score 9 – ∞].</p>

<p>The important thing about each new sequence is that there will be an alternation between dashed (<em>A′</em>,<em>B′</em>,<em>C′</em>) and un-dashed nodes (<em>A</em>, <em>B</em>, <em>C</em>) and that the link to "jump" between any related pair (<em>A</em>-<em>A′</em>) is effectively free. A version of the algorithm could use any weight for the <em>A</em>-<em>A′</em> path, as long as that weight is <em>lower</em> than all other path weights present in the graph. As the path weight to "jump" must effectively be "free", the value zero (0) could be used to represent this cost—if zero is not being used for another purpose already (such as designating invalid paths). In the two examples above, non-existent paths between nodes are shown as a blank square.</p>
<h3 id="analysts-travelling-salesman-problem">Analyst's travelling salesman problem</h3>

<p>There is an analogous problem in <a href="geometric_measure_theory" title="wikilink">geometric measure theory</a> which asks the following: under what conditions may a subset <em>E</em> of <a href="Euclidean_space" title="wikilink">Euclidean space</a> be contained in a <a href="rectifiable_curve" title="wikilink">rectifiable curve</a> (that is, when is there a curve with finite length that visits every point in <em>E</em>)? This problem is known as the <a href="analyst's_traveling_salesman_theorem" title="wikilink">analyst's travelling salesman problem</a></p>
<h3 id="tsp-path-length-for-random-sets-of-points-in-a-square">TSP path length for random sets of points in a square</h3>

<p>Suppose 

<math display="inline" id="Travelling_salesman_problem:22">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},\ldots,X_{n}
  </annotation>
 </semantics>
</math>

 are 

<math display="inline" id="Travelling_salesman_problem:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 independent random variables with uniform distribution in the square 

<math display="inline" id="Travelling_salesman_problem:24">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]^{2}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Travelling_salesman_problem:25">
 <semantics>
  <msubsup>
   <mi>L</mi>
   <mi>n</mi>
   <mo>∗</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>normal-∗</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\ast}_{n}
  </annotation>
 </semantics>
</math>

 be the shortest path length (i.e. TSP solution) for this set of points, according to the usual <a href="Euclidean_distance" title="wikilink">Euclidean distance</a>. It is known<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> that, almost surely,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Travelling_salesman_problem:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <msubsup>
       <mi>L</mi>
       <mi>n</mi>
       <mo>*</mo>
      </msubsup>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mfrac>
     <mo>→</mo>
     <mi>β</mi>
    </mrow>
    <mrow>
     <mrow>
      <mtext>when</mtext>
      <mi>n</mi>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <mtext>when</mtext>
      <ci>n</ci>
     </apply>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{L^{*}_{n}}{\sqrt{n}}\rightarrow\beta\qquad\text{when }n\to\infty,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Travelling_salesman_problem:27">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is a positive constant that is not known explicitly. Since 

<math display="inline" id="Travelling_salesman_problem:28">
 <semantics>
  <mrow>
   <msubsup>
    <mi>L</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}_{n}\leq 2\sqrt{n}+2
  </annotation>
 </semantics>
</math>

 (see below), it follows from <a href="bounded_convergence_theorem" title="wikilink">bounded convergence theorem</a> that 

<math display="inline" id="Travelling_salesman_problem:29">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <mrow>
      <mi>𝔼</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msubsup>
        <mi>L</mi>
        <mi>n</mi>
        <mo>*</mo>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>𝔼</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>L</ci>
          <times></times>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\lim_{n\to\infty}\mathbb{E}[L^{*}_{n}]/\sqrt{n}
  </annotation>
 </semantics>
</math>

, hence lower and upper bounds on 

<math display="inline" id="Travelling_salesman_problem:30">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 follow from bounds on 

<math display="inline" id="Travelling_salesman_problem:31">
 <semantics>
  <mrow>
   <mi>𝔼</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mi>L</mi>
     <mi>n</mi>
     <mo>*</mo>
    </msubsup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔼</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[L^{*}_{n}]
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="upper-bound">Upper bound</h4>
<ul>
<li>One has 

<math display="inline" id="Travelling_salesman_problem:32">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mo>*</mo>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <times></times>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}\leq 2\sqrt{n}+2
  </annotation>
 </semantics>
</math>

, and therefore 

<math display="inline" id="Travelling_salesman_problem:33">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>≤</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>β</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\leq 2
  </annotation>
 </semantics>
</math>

, by using a naive path which visits monotonically the points inside each of 

<math display="inline" id="Travelling_salesman_problem:34">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

 slices of width 

<math display="inline" id="Travelling_salesman_problem:35">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\sqrt{n}
  </annotation>
 </semantics>
</math>

 in the square.</li>
</ul>
<ul>
<li>Few <a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> proved 

<math display="inline" id="Travelling_salesman_problem:36">
 <semantics>
  <mrow>
   <msubsup>
    <mi>L</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mo>≤</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
    </msqrt>
    <mo>+</mo>
    <mn>1.75</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="float">1.75</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}_{n}\leq\sqrt{2n}+1.75
  </annotation>
 </semantics>
</math>

, hence 

<math display="inline" id="Travelling_salesman_problem:37">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>≤</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>β</ci>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\leq\sqrt{2}
  </annotation>
 </semantics>
</math>

, later improved by Karloff (1987)

<math display="block" id="Travelling_salesman_problem:38">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>≤</mo>
   <mrow>
    <mn>0.984</mn>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>β</ci>
    <apply>
     <times></times>
     <cn type="float">0.984</cn>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\leq 0.984\sqrt{2}
  </annotation>
 </semantics>
</math>

.</li>
<li>The currently <a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> best upper bound is 

<math display="inline" id="Travelling_salesman_problem:39">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>≤</mo>
   <mrow>
    <mn>0.92</mn>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>β</ci>
    <apply>
     <times></times>
     <cn type="float">0.92</cn>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\leq 0.92\dots
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h4 id="lower-bound">Lower bound</h4>
<ul>
<li>By observing that 

<math display="inline" id="Travelling_salesman_problem:40">
 <semantics>
  <mrow>
   <mi>𝔼</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mi>L</mi>
     <mi>n</mi>
     <mo>*</mo>
    </msubsup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔼</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[L^{*}_{n}]
  </annotation>
 </semantics>
</math>

 is greater than 

<math display="inline" id="Travelling_salesman_problem:41">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 times the distance between 

<math display="inline" id="Travelling_salesman_problem:42">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 and the closest point 

<math display="inline" id="Travelling_salesman_problem:43">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}\neq X_{0}
  </annotation>
 </semantics>
</math>

, one gets (after a short computation)</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Travelling_salesman_problem:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔼</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msubsup>
       <mi>L</mi>
       <mi>n</mi>
       <mo>*</mo>
      </msubsup>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>𝔼</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[L^{*}_{n}]\geq\tfrac{1}{2}\sqrt{n}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>A better lower bound is obtained<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> by observing that 

<math display="inline" id="Travelling_salesman_problem:45">
 <semantics>
  <mrow>
   <mi>𝔼</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mi>L</mi>
     <mi>n</mi>
     <mo>*</mo>
    </msubsup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔼</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[L^{*}_{n}]
  </annotation>
 </semantics>
</math>

 is greater than 

<math display="inline" id="Travelling_salesman_problem:46">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{2}n
  </annotation>
 </semantics>
</math>

 times the sum of the distances between 

<math display="inline" id="Travelling_salesman_problem:47">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 and the closest and second closest points 

<math display="inline" id="Travelling_salesman_problem:48">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>≠</mo>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>j</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i},X_{j}\neq X_{0}
  </annotation>
 </semantics>
</math>

, which gives</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Travelling_salesman_problem:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔼</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msubsup>
       <mi>L</mi>
       <mi>n</mi>
       <mo>*</mo>
      </msubsup>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <mo>+</mo>
       <mfrac>
        <mn>3</mn>
        <mn>8</mn>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>5</mn>
      <mn>8</mn>
     </mfrac>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>𝔼</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>L</ci>
         <times></times>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">8</cn>
       </apply>
      </apply>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">5</cn>
       <cn type="integer">8</cn>
      </apply>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[L^{*}_{n}]\geq\left(\tfrac{1}{4}+\tfrac{3}{8}\right)\sqrt{n}=\tfrac%
{5}{8}\sqrt{n},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>The currently <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> best lower bound is</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Travelling_salesman_problem:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔼</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msubsup>
       <mi>L</mi>
       <mi>n</mi>
       <mo>*</mo>
      </msubsup>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mfrac>
        <mn>5</mn>
        <mn>8</mn>
       </mfrac>
       <mo>+</mo>
       <mfrac>
        <mn>19</mn>
        <mn>5184</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>𝔼</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">5</cn>
       <cn type="integer">8</cn>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">19</cn>
       <cn type="integer">5184</cn>
      </apply>
     </apply>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[L^{*}_{n}]\geq(\tfrac{5}{8}+\tfrac{19}{5184})\sqrt{n},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>Held and Karp<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> gave a polynomial-time algorithm that provides numerical lower bounds for 

<math display="inline" id="Travelling_salesman_problem:51">
 <semantics>
  <msubsup>
   <mi>L</mi>
   <mi>n</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <times></times>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}_{n}
  </annotation>
 </semantics>
</math>

, and thus for 

<math display="inline" id="Travelling_salesman_problem:52">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mspace width="veryverythickmathspace">
   </mspace>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi></mi>
     <mo>≃</mo>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mi>n</mi>
       <mo>*</mo>
      </msubsup>
      <mo>/</mo>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">annotated</csymbol>
    <ci>β</ci>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(\simeq L^{*}_{n}/{\sqrt{n}})
  </annotation>
 </semantics>
</math>

 which seem to be good up to more or less 1%.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> In particular, David S. Johnson<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> obtained a lower bound by computer experiment:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Travelling_salesman_problem:53">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>L</mi>
     <mi>n</mi>
     <mo>*</mo>
    </msubsup>
    <mo>≳</mo>
    <mrow>
     <mrow>
      <mn>0.7080</mn>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mrow>
     <mo>+</mo>
     <mn>0.522</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">greater-than-or-equivalent-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="float">0.7080</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="float">0.522</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}_{n}\gtrsim 0.7080\sqrt{n}+0.522,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 0.522 comes from the points near square boundary which have fewer neighbors, and Christine L. Valenzuela and Antonia J. Jones <a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> obtained the following other numerical lower bound:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Travelling_salesman_problem:54">
 <semantics>
  <mrow>
   <msubsup>
    <mi>L</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mo>≳</mo>
   <mrow>
    <mrow>
     <mn>0.7078</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo>+</mo>
    <mn>0.551</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">greater-than-or-equivalent-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="float">0.7078</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="float">0.551</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}_{n}\gtrsim 0.7078\sqrt{n}+0.551
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>
<h2 id="computational-complexity">Computational complexity</h2>

<p>The problem has been shown to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> (more precisely, it is complete for the <a href="complexity_class" title="wikilink">complexity class</a> FP<sup>NP</sup>; see <a href="function_problem" title="wikilink">function problem</a>), and the <a href="decision_problem" title="wikilink">decision problem</a> version ("given the costs and a number <em>x</em>, decide whether there is a round-trip route cheaper than <em>x</em>") is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. The <a href="bottleneck_traveling_salesman_problem" title="wikilink">bottleneck travelling salesman problem</a> is also NP-hard. The problem remains NP-hard even for the case when the cities are in the plane with <a href="Euclidean_distance" title="wikilink">Euclidean distances</a>, as well as in a number of other restrictive cases. Removing the condition of visiting each city "only once" does not remove the NP-hardness, since it is easily seen that in the planar case there is an optimal tour that visits each city only once (otherwise, by the <a href="triangle_inequality" title="wikilink">triangle inequality</a>, a shortcut that skips a repeated visit would not increase the tour length).</p>
<h3 id="complexity-of-approximation">Complexity of approximation</h3>

<p>In the general case, finding a shortest travelling salesman tour is NPO-complete.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> If the distance measure is a metric and symmetric, the problem becomes <a class="uri" href="APX" title="wikilink">APX</a>-complete<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> and <a href="Christofides_algorithm" title="wikilink">Christofides’s algorithm</a> approximates it within 1.5.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>

<p>If the distances are restricted to 1 and 2 (but still are a metric) the approximation ratio becomes 8/7. In the asymmetric, metric case, only logarithmic performance guarantees are known, the best current algorithm achieves performance ratio 0.814 log(<em>n</em>);<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> it is an open question if a constant factor approximation exists.</p>

<p>The corresponding maximization problem of finding the <em>longest</em> travelling salesman tour is approximable within 63/38.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> If the distance function is symmetric, the longest tour can be approximated within 4/3 by a deterministic algorithm<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> and within 

<math display="inline" id="Travelling_salesman_problem:55">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>25</mn>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>33</mn>
     <mo>+</mo>
     <mi>ε</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">25</cn>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">33</cn>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{25}(33+\varepsilon)
  </annotation>
 </semantics>
</math>

 by a randomised algorithm.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></p>
<h2 id="human-performance-on-tsp">Human performance on TSP</h2>

<p>The TSP, in particular the <a href="Euclidean_distance" title="wikilink">Euclidean</a> variant of the problem, has attracted the attention of researchers in <a href="cognitive_psychology" title="wikilink">cognitive psychology</a>. It has been observed that humans are able to produce good quality solutions quickly.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> These results suggest that computer performance on the TSP may be improved by understanding and emulating the methods used by humans for these problems, and have also led to new insights into the mechanisms of human thought.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> The first issue of the <em>Journal of Problem Solving</em> was devoted to the topic of human performance on TSP,<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> and a 2011 review listed dozens of papers on the subject.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>
<h2 id="benchmarks">Benchmarks</h2>

<p>For benchmarking of TSP algorithms, <a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/"><strong>TSPLIB</strong></a> is a library of sample instances of the TSP and related problems is maintained, see the TSPLIB external reference. Many of them are lists of actual cities and layouts of actual <a href="Printed_circuit_board" title="wikilink">printed circuits</a>.</p>

<p>.</p>
<h2 id="popular-culture">Popular culture</h2>

<p><em><a href="Travelling_Salesman_(2012_film)" title="wikilink">Travelling Salesman</a></em>, by director Timothy Lanzone, is the story of four mathematicians hired by the U.S. government to solve the most elusive problem in computer-science history: <a href="P_vs._NP" title="wikilink">P vs. NP</a>.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Canadian_traveller_problem" title="wikilink">Canadian traveller problem</a></li>
<li><a href="Route_inspection_problem" title="wikilink">Route inspection problem</a> (also known as "Chinese postman problem")</li>
<li><a href="Set_TSP_problem" title="wikilink">Set TSP problem</a></li>
<li><a href="Seven_Bridges_of_Königsberg" title="wikilink">Seven Bridges of Königsberg</a></li>
<li><a href="Tube_Challenge" title="wikilink">Tube Challenge</a></li>
<li><a href="Vehicle_routing_problem" title="wikilink">Vehicle routing problem</a></li>
<li><a href="Graph_traversal#Graph_Exploration" title="wikilink">Graph Exploration</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.math.uwaterloo.ca/tsp/index.html">Traveling Salesman Problem</a> at <a href="University_of_Waterloo" title="wikilink">University of Waterloo</a></li>
<li><a href="http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/">TSPLIB</a> at the <a href="University_of_Heidelberg" title="wikilink">University of Heidelberg</a></li>
<li><em><a href="http://demonstrations.wolfram.com/TravelingSalesmanProblem/">Traveling Salesman Problem</a></em> by Jon McLoone at the Wolfram Demonstrations Project</li>
<li><a href="http://www.imdb.com/title/tt1801123/">Traveling Salesman movie (on IMDB)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Travelling_salesman_problem" title="wikilink"> </a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a> <a href="Category:NP-hard_problems" title="wikilink">Category:NP-hard problems</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a> <a href="Category:Hamiltonian_paths_and_cycles" title="wikilink">Category:Hamiltonian paths and cycles</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See the TSP world tour problem which has already been solved to within 0.05% of the optimal solution. <a href="http://www.math.uwaterloo.ca/tsp/world/">1</a><a href="#fnref1">↩</a></li>
<li id="fn2">"Der Handlungsreisende – wie er sein soll und was er zu tun hat, um Aufträge zu erhalten und eines glücklichen Erfolgs in seinen Geschäften gewiß zu sein – von einem alten Commis-Voyageur" (The travelling salesman — how he must be and what he should do in order to get commissions and be sure of the happy success in his business — by an old <em>commis-voyageur</em>)<a href="#fnref2">↩</a></li>
<li id="fn3">A discussion of the early work of Hamilton and Kirkman can be found in Graph Theory 1736–1936<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">A detailed treatment of the connection between Menger and Whitney as well as the growth in the study of TSP can be found in <a href="Alexander_Schrijver" title="wikilink">Alexander Schrijver</a>'s 2005 paper "On the history of combinatorial optimization (till 1960). Handbook of Discrete Optimization (K. Aardal, <a href="George_Nemhauser" title="wikilink">G.L. Nemhauser</a>, R. Weismantel, eds.), Elsevier, Amsterdam, 2005, pp. 1–68.<a href="http://homepages.cwi.nl/~lex/files/histco.ps">PS</a>,<a href="http://homepages.cwi.nl/~lex/files/histco.pdf">PDF</a><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">, pp.308-309.<a href="#fnref13">↩</a></li>
<li id="fn14">Tucker, A. W. (1960), "On Directed Graphs and Integer Programs", IBM Mathematical research Project (Princeton University)<a href="#fnref14">↩</a></li>
<li id="fn15">Dantzig, George B. (1963), <em>Linear Programming and Extensions</em>, Princeton, NJ: PrincetonUP, pp. 545–7, ISBN 0-691-08000-3, sixth printing, 1974.<a href="#fnref15">↩</a></li>
<li id="fn16"><code>,</code> <code>,</code> <a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">Work by David Applegate, AT&amp;T; Labs – Research, Robert Bixby, <a class="uri" href="ILOG" title="wikilink">ILOG</a> and Rice University, Vašek Chvátal, Concordia University, William Cook, University of Waterloo, and Keld Helsgaun, Roskilde University is discussed on their project web page hosted by the University of Waterloo and last updated in June 2004, here <a href="http://www.math.uwaterloo.ca/tsp/sweden/">2</a><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21">Johnson, D.S. and McGeoch, L.A.. "The traveling salesman problem: A case study in local optimization", Local search in combinatorial optimization, 1997, 215-310<a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28">Marco Dorigo. "Ant Colonies for the Traveling Salesman Problem. IRIDIA, Université Libre de Bruxelles. <em>IEEE Transactions on Evolutionary Computation</em>, 1(1):53–66. 1997. <a class="uri" href="http://citeseer.ist.psu.edu/86357.html">http://citeseer.ist.psu.edu/86357.html</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="http://www.research.att.com/~dsj/papers/HKsoda.pdf">David S. Johnson</a><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="http://users.cs.cf.ac.uk/Antonia.J.Jones/Papers/EJORHeldKarp/HeldKarp.pdf">Christine L. Valenzuela and Antonia J. Jones</a><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46">.<a href="#fnref46">↩</a></li>
<li id="fn47">.<a href="#fnref47">↩</a></li>
<li id="fn48"><a href="http://docs.lib.purdue.edu/jps/vol1/iss1/"><em>Journal of Problem Solving</em> 1(1)</a>, 2006, retrieved 2014-06-06.<a href="#fnref48">↩</a></li>
<li id="fn49"></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
</ol>
</section>
</body>
</html>
